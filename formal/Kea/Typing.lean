/-
  Kea.Typing — Minimal core expression typing model.

  This module introduces a small expression language and a syntax-directed
  inference function plus declarative typing judgment. It is intentionally
  narrow: literals, variables, closed anonymous records, and field projection.

  Purpose: provide a first M4 anchor for algorithmic-vs-declarative soundness
  over the current row-polymorphic core, without requiring full parser/runtime
  expression coverage.
-/

import Kea.Ty
import Kea.Properties.UnifyReflexive
import Kea.Properties.UnifyConsistent
import Kea.Properties.SubstCompose
import Kea.Unify
import Kea.Substitution

/-- Term environment for the core typing model. -/
abbrev TermEnv := List (String × Ty)

namespace TermEnv

/-- Lookup a variable in the term environment (first binding wins). -/
def lookup (env : TermEnv) (name : String) : Option Ty :=
  match env with
  | [] => none
  | (n, ty) :: rest => if n == name then some ty else lookup rest name

end TermEnv

mutual
  /-- Minimal core expressions for M4 typing-soundness kickoff. -/
  inductive CoreExpr : Type where
    | intLit : Int → CoreExpr
    | boolLit : Bool → CoreExpr
    | stringLit : String → CoreExpr
    | var : String → CoreExpr
    | lam : String → Ty → CoreExpr → CoreExpr
    | app : CoreExpr → CoreExpr → CoreExpr
    | letE : String → CoreExpr → CoreExpr → CoreExpr
    | record : CoreFields → CoreExpr
    | proj : CoreExpr → Label → CoreExpr

  /-- Field syntax for core anonymous records. -/
  inductive CoreFields : Type where
    | nil : CoreFields
    | cons : Label → CoreExpr → CoreFields → CoreFields
end

mutual
  /-- Algorithmic inference for core expressions. -/
  def inferExpr (env : TermEnv) : CoreExpr → Option Ty
    | .intLit _ => some .int
    | .boolLit _ => some .bool
    | .stringLit _ => some .string
    | .var name => TermEnv.lookup env name
    | .lam param paramTy body =>
      match inferExpr ((param, paramTy) :: env) body with
      | some bodyTy => some (.function (.cons paramTy .nil) bodyTy)
      | none => none
    | .app fn arg =>
      match inferExpr env fn, inferExpr env arg with
      | some (.function (.cons paramTy .nil) retTy), some argTy =>
        if beqTy paramTy argTy then some retTy else none
      | _, _ => none
    | .letE name value body =>
      match inferExpr env value with
      | some valueTy => inferExpr ((name, valueTy) :: env) body
      | none => none
    | .record fields =>
      match inferFields env fields with
      | some rowFields => some (.anonRecord (.mk rowFields none))
      | none => none
    | .proj e label =>
      match inferExpr env e with
      | some (.anonRecord (.mk rowFields none)) => RowFields.get rowFields label
      | _ => none

  /-- Algorithmic inference for core record fields. -/
  def inferFields (env : TermEnv) : CoreFields → Option RowFields
    | .nil => some .nil
    | .cons label e rest =>
      match inferExpr env e, inferFields env rest with
      | some ty, some restFields => some (.cons label ty restFields)
      | _, _ => none
end

mutual
  /-- Declarative typing judgment for core expressions. -/
  inductive HasType : TermEnv → CoreExpr → Ty → Prop where
    | int (env : TermEnv) (n : Int) :
        HasType env (.intLit n) .int
    | bool (env : TermEnv) (b : Bool) :
        HasType env (.boolLit b) .bool
    | string (env : TermEnv) (s : String) :
        HasType env (.stringLit s) .string
    | var (env : TermEnv) (name : String) (ty : Ty)
        (h_lookup : TermEnv.lookup env name = some ty) :
        HasType env (.var name) ty
    | lam (env : TermEnv) (param : String) (paramTy bodyTy : Ty) (body : CoreExpr)
        (h_body : HasType ((param, paramTy) :: env) body bodyTy) :
        HasType env (.lam param paramTy body) (.function (.cons paramTy .nil) bodyTy)
    | app (env : TermEnv) (fn arg : CoreExpr) (paramTy retTy : Ty)
        (h_fn : HasType env fn (.function (.cons paramTy .nil) retTy))
        (h_arg : HasType env arg paramTy) :
        HasType env (.app fn arg) retTy
    | letE (env : TermEnv) (name : String) (value body : CoreExpr) (valueTy bodyTy : Ty)
        (h_value : HasType env value valueTy)
        (h_body : HasType ((name, valueTy) :: env) body bodyTy) :
        HasType env (.letE name value body) bodyTy
    | record (env : TermEnv) (fields : CoreFields) (rowFields : RowFields)
        (h_fields : HasFieldsType env fields rowFields) :
        HasType env (.record fields) (.anonRecord (.mk rowFields none))
    | proj (env : TermEnv) (e : CoreExpr) (rowFields : RowFields) (label : Label) (ty : Ty)
        (h_e : HasType env e (.anonRecord (.mk rowFields none)))
        (h_get : RowFields.get rowFields label = some ty) :
        HasType env (.proj e label) ty

  /-- Declarative typing judgment for core record field syntax. -/
  inductive HasFieldsType : TermEnv → CoreFields → RowFields → Prop where
    | nil (env : TermEnv) :
        HasFieldsType env .nil .nil
    | cons (env : TermEnv) (label : Label) (e : CoreExpr) (rest : CoreFields)
        (ty : Ty) (restFields : RowFields)
        (h_head : HasType env e ty)
        (h_rest : HasFieldsType env rest restFields) :
        HasFieldsType env (.cons label e rest) (.cons label ty restFields)
end

mutual
  /--
  Unification-aware declarative typing: same core rules as `HasType`, plus an
  explicit substitution admissibility rule.
  -/
  inductive HasTypeU : TermEnv → CoreExpr → Ty → Prop where
    | int (env : TermEnv) (n : Int) :
        HasTypeU env (.intLit n) .int
    | bool (env : TermEnv) (b : Bool) :
        HasTypeU env (.boolLit b) .bool
    | string (env : TermEnv) (s : String) :
        HasTypeU env (.stringLit s) .string
    | var (env : TermEnv) (name : String) (ty : Ty)
        (h_lookup : TermEnv.lookup env name = some ty) :
        HasTypeU env (.var name) ty
    | lam (env : TermEnv) (param : String) (paramTy bodyTy : Ty) (body : CoreExpr)
        (h_body : HasTypeU ((param, paramTy) :: env) body bodyTy) :
        HasTypeU env (.lam param paramTy body) (.function (.cons paramTy .nil) bodyTy)
    | app (env : TermEnv) (fn arg : CoreExpr) (paramTy retTy : Ty)
        (h_fn : HasTypeU env fn (.function (.cons paramTy .nil) retTy))
        (h_arg : HasTypeU env arg paramTy) :
        HasTypeU env (.app fn arg) retTy
    | letE (env : TermEnv) (name : String) (value body : CoreExpr) (valueTy bodyTy : Ty)
        (h_value : HasTypeU env value valueTy)
        (h_body : HasTypeU ((name, valueTy) :: env) body bodyTy) :
        HasTypeU env (.letE name value body) bodyTy
    | record (env : TermEnv) (fields : CoreFields) (rowFields : RowFields)
        (h_fields : HasFieldsTypeU env fields rowFields) :
        HasTypeU env (.record fields) (.anonRecord (.mk rowFields none))
    | proj (env : TermEnv) (e : CoreExpr) (rowFields : RowFields) (label : Label) (ty : Ty)
        (h_e : HasTypeU env e (.anonRecord (.mk rowFields none)))
        (h_get : RowFields.get rowFields label = some ty) :
        HasTypeU env (.proj e label) ty
    | subst (env : TermEnv) (e : CoreExpr) (ty : Ty) (s : Subst) (fuel : Nat)
        (h_ty : HasTypeU env e ty) :
        HasTypeU env e (applySubstCompat s fuel ty)

  /-- Field typing for `HasTypeU`. -/
  inductive HasFieldsTypeU : TermEnv → CoreFields → RowFields → Prop where
    | nil (env : TermEnv) :
        HasFieldsTypeU env .nil .nil
    | cons (env : TermEnv) (label : Label) (e : CoreExpr) (rest : CoreFields)
        (ty : Ty) (restFields : RowFields)
        (h_head : HasTypeU env e ty)
        (h_rest : HasFieldsTypeU env rest restFields) :
        HasFieldsTypeU env (.cons label e rest) (.cons label ty restFields)
end

mutual
  /-- Lift monomorphic declarative typing derivations into `HasTypeU`. -/
  theorem hasType_to_hasTypeU
      {env : TermEnv} {e : CoreExpr} {ty : Ty}
      (h_ty : HasType env e ty) :
      HasTypeU env e ty := by
    cases h_ty with
    | int env n => exact HasTypeU.int env n
    | bool env b => exact HasTypeU.bool env b
    | string env s => exact HasTypeU.string env s
    | var env name ty h_lookup => exact HasTypeU.var env name ty h_lookup
    | lam env param paramTy bodyTy body h_body =>
      exact HasTypeU.lam env param paramTy bodyTy body (hasType_to_hasTypeU h_body)
    | app env fn arg paramTy _ h_fn h_arg =>
      exact HasTypeU.app env fn arg paramTy ty
        (hasType_to_hasTypeU h_fn) (hasType_to_hasTypeU h_arg)
    | letE env name value body valueTy _ h_value h_body =>
      exact HasTypeU.letE env name value body valueTy ty
        (hasType_to_hasTypeU h_value) (hasType_to_hasTypeU h_body)
    | record env fields rowFields h_fields =>
      exact HasTypeU.record env fields rowFields (hasFieldsType_to_hasFieldsTypeU h_fields)
    | proj env e rowFields label ty h_e h_get =>
      exact HasTypeU.proj env e rowFields label ty (hasType_to_hasTypeU h_e) h_get

  /-- Lift monomorphic field typing derivations into `HasFieldsTypeU`. -/
  theorem hasFieldsType_to_hasFieldsTypeU
      {env : TermEnv} {fs : CoreFields} {rowFields : RowFields}
      (h_fs : HasFieldsType env fs rowFields) :
      HasFieldsTypeU env fs rowFields := by
    cases h_fs with
    | nil env => exact HasFieldsTypeU.nil env
    | cons env label e rest ty restFields h_head h_rest =>
      exact HasFieldsTypeU.cons env label e rest ty restFields
        (hasType_to_hasTypeU h_head) (hasFieldsType_to_hasFieldsTypeU h_rest)
end

mutual
  /-- Algorithmic inference is sound with respect to declarative typing. -/
  theorem inferExpr_sound (env : TermEnv) (e : CoreExpr) :
      ∀ ty, inferExpr env e = some ty → HasType env e ty := by
    cases e with
    | intLit n =>
      intro ty h
      simp [inferExpr] at h
      cases h
      exact HasType.int env n
    | boolLit b =>
      intro ty h
      simp [inferExpr] at h
      cases h
      exact HasType.bool env b
    | stringLit s =>
      intro ty h
      simp [inferExpr] at h
      cases h
      exact HasType.string env s
    | var name =>
      intro ty h
      simp [inferExpr] at h
      exact HasType.var env name ty h
    | lam param paramTy body =>
      intro ty h
      simp [inferExpr] at h
      cases h_body : inferExpr ((param, paramTy) :: env) body with
      | none =>
        simp [h_body] at h
      | some bodyTy =>
        simp [h_body] at h
        cases h
        exact HasType.lam env param paramTy bodyTy body
          (inferExpr_sound ((param, paramTy) :: env) body bodyTy h_body)
    | app fn arg =>
      intro ty h
      simp [inferExpr] at h
      cases h_fn : inferExpr env fn with
      | none =>
        simp [h_fn] at h
      | some fnTy =>
        cases h_arg : inferExpr env arg with
        | none =>
          simp [h_fn, h_arg] at h
        | some argTy =>
          cases fnTy with
          | function params retTy =>
            cases params with
            | nil =>
              simp [h_fn, h_arg] at h
            | cons paramTy rest =>
              cases rest with
              | nil =>
                cases h_eq : beqTy paramTy argTy with
                | false =>
                  simp [h_fn, h_arg, h_eq] at h
                | true =>
                  simp [h_fn, h_arg, h_eq] at h
                  cases h
                  have h_param_eq : paramTy = argTy := beqTy_sound paramTy argTy h_eq
                  have h_fn_eq : inferExpr env fn = some (.function (.cons paramTy .nil) ty) := by
                    simpa using h_fn
                  have h_fn_ty : HasType env fn (.function (.cons paramTy .nil) ty) :=
                    inferExpr_sound env fn (.function (.cons paramTy .nil) ty) h_fn_eq
                  have h_arg_ty : HasType env arg argTy :=
                    inferExpr_sound env arg argTy h_arg
                  rw [← h_param_eq] at h_arg_ty
                  exact HasType.app env fn arg paramTy ty h_fn_ty h_arg_ty
              | cons _ _ =>
                simp [h_fn, h_arg] at h
          | int | intN _ _ | float | floatN _ | decimal _ _ | bool | string | html | markdown | atom | date | dateTime | unit =>
            simp [h_fn, h_arg] at h
          | list _ | map _ _ | set _ | option _ | result _ _ | existential _ _ | fixedSizeList _ _ | tensor _ _ | sum _ _ | «opaque» _ _ | functionEff _ _ _
            | record _ _ | anonRecord _ | dataframe _ | groupedFrame _ _ | tagged _ _ | dynamic | column _ | stream _ | task _ | actor _ | arc _
            | «forall» _ _ | app _ _ | constructor _ _ _ | var _ | row _ | tuple _ =>
            simp [h_fn, h_arg] at h
    | letE name value body =>
      intro ty h
      simp [inferExpr] at h
      cases h_value : inferExpr env value with
      | none =>
        simp [h_value] at h
      | some valueTy =>
        have h_value_ty : HasType env value valueTy :=
          inferExpr_sound env value valueTy h_value
        have h_body_ty : HasType ((name, valueTy) :: env) body ty := by
          exact inferExpr_sound ((name, valueTy) :: env) body ty (by simpa [h_value] using h)
        exact HasType.letE env name value body valueTy ty h_value_ty h_body_ty
    | record fields =>
      intro ty h
      simp [inferExpr] at h
      cases h_fields : inferFields env fields with
      | none =>
        simp [h_fields] at h
      | some rowFields =>
        simp [h_fields] at h
        cases h
        exact HasType.record env fields rowFields
          (inferFields_sound env fields rowFields h_fields)
    | proj e label =>
      intro ty h
      simp [inferExpr] at h
      cases h_e : inferExpr env e with
      | none =>
        simp [h_e] at h
      | some tySub =>
        cases tySub with
        | int | intN _ _ | float | floatN _ | decimal _ _ | bool | string | html | markdown | atom | date | dateTime | unit =>
          simp [h_e] at h
        | list _ | map _ _ | set _ | option _ | result _ _ | existential _ _ | fixedSizeList _ _ | tensor _ _ | sum _ _ | «opaque» _ _
          | record _ _ | dataframe _ | groupedFrame _ _ | tagged _ _ | dynamic | column _ | stream _ | task _ | actor _ | arc _
          | function _ _ | functionEff _ _ _ | «forall» _ _ | app _ _ | constructor _ _ _ | var _ | row _ | tuple _ =>
          simp [h_e] at h
        | anonRecord row =>
          cases row with
          | mk rowFields rest =>
            cases rest with
            | some rv =>
              simp [h_e] at h
            | none =>
              cases h_get : RowFields.get rowFields label with
              | none =>
                simp [h_e, h_get] at h
              | some foundTy =>
                simp [h_e, h_get] at h
                cases h
                have h_sub : HasType env e (.anonRecord (.mk rowFields none)) :=
                  inferExpr_sound env e (.anonRecord (.mk rowFields none)) h_e
                exact HasType.proj env e rowFields label ty h_sub h_get

  /-- Field inference is sound with respect to declarative field typing. -/
  theorem inferFields_sound (env : TermEnv) (fs : CoreFields) :
      ∀ rowFields, inferFields env fs = some rowFields → HasFieldsType env fs rowFields := by
    cases fs with
    | nil =>
      intro rowFields h
      simp [inferFields] at h
      cases h
      exact HasFieldsType.nil env
    | cons label e rest =>
      intro rowFields h
      simp [inferFields] at h
      cases h_e : inferExpr env e <;> simp [h_e] at h
      case _ tyHead =>
        cases h_rest : inferFields env rest <;> simp [h_rest] at h
        case _ restFields =>
          cases h
          exact HasFieldsType.cons env label e rest tyHead restFields
            (inferExpr_sound env e tyHead h_e)
            (inferFields_sound env rest restFields h_rest)
end

mutual
  /-- Declarative typing is complete with respect to algorithmic inference. -/
  theorem inferExpr_complete
      (env : TermEnv) (e : CoreExpr) (ty : Ty)
      (h_ty : HasType env e ty) :
      inferExpr env e = some ty := by
    cases h_ty with
    | int env n =>
      simp [inferExpr]
    | bool env b =>
      simp [inferExpr]
    | string env s =>
      simp [inferExpr]
    | var env name ty h_lookup =>
      simpa [inferExpr] using h_lookup
    | lam env param paramTy bodyTy body h_body =>
      simp [inferExpr, inferExpr_complete ((param, paramTy) :: env) body bodyTy h_body]
    | app env fn arg paramTy retTy h_fn h_arg =>
      simp [inferExpr,
        inferExpr_complete env fn (.function (.cons paramTy .nil) ty) h_fn,
        inferExpr_complete env arg paramTy h_arg,
        beqTy_refl paramTy]
    | letE env name value body valueTy bodyTy h_value h_body =>
      simp [inferExpr,
        inferExpr_complete env value valueTy h_value,
        inferExpr_complete ((name, valueTy) :: env) body ty h_body]
    | record env fields rowFields h_fields =>
      simp [inferExpr, inferFields_complete env fields rowFields h_fields]
    | proj env e rowFields label ty h_e h_get =>
      simp [inferExpr, inferExpr_complete env e (.anonRecord (.mk rowFields none)) h_e, h_get]

  /-- Declarative field typing is complete wrt algorithmic field inference. -/
  theorem inferFields_complete
      (env : TermEnv) (fs : CoreFields) (rowFields : RowFields)
      (h_fs : HasFieldsType env fs rowFields) :
      inferFields env fs = some rowFields := by
    cases h_fs with
    | nil env =>
      simp [inferFields]
    | cons env label e rest ty restFields h_head h_rest =>
      simp [inferFields, inferExpr_complete env e ty h_head, inferFields_complete env rest restFields h_rest]
end

/-- Algorithmic and declarative typing coincide on the current core slice. -/
theorem inferExpr_iff_hasType (env : TermEnv) (e : CoreExpr) (ty : Ty) :
    inferExpr env e = some ty ↔ HasType env e ty := by
  constructor
  · intro h
    exact inferExpr_sound env e ty h
  · intro h
    exact inferExpr_complete env e ty h

/-- Declarative field typing is functional on the core slice. -/
theorem hasFieldsType_unique
    {env : TermEnv} {fs : CoreFields} {row₁ row₂ : RowFields}
    (h₁ : HasFieldsType env fs row₁)
    (h₂ : HasFieldsType env fs row₂) :
    row₁ = row₂ := by
  have h_inf₁ : inferFields env fs = some row₁ := inferFields_complete env fs row₁ h₁
  have h_inf₂ : inferFields env fs = some row₂ := inferFields_complete env fs row₂ h₂
  rw [h_inf₁] at h_inf₂
  exact Option.some.inj h_inf₂

/-- Principal-field-typing corollary from one successful `inferFields` run. -/
theorem inferFields_principal
    {env : TermEnv} {fs : CoreFields} {row : RowFields}
    (h_inf : inferFields env fs = some row) :
    ∀ {row' : RowFields}, HasFieldsType env fs row' → row' = row := by
  intro row' h_row'
  have h_row : HasFieldsType env fs row := inferFields_sound env fs row h_inf
  exact hasFieldsType_unique h_row' h_row

/-- Declarative typing is functional on the core slice. -/
theorem hasType_unique
    {env : TermEnv} {e : CoreExpr} {ty₁ ty₂ : Ty}
    (h₁ : HasType env e ty₁)
    (h₂ : HasType env e ty₂) :
    ty₁ = ty₂ := by
  have h_inf₁ : inferExpr env e = some ty₁ := inferExpr_complete env e ty₁ h₁
  have h_inf₂ : inferExpr env e = some ty₂ := inferExpr_complete env e ty₂ h₂
  rw [h_inf₁] at h_inf₂
  exact Option.some.inj h_inf₂

/-- Principal-typing corollary from one successful `inferExpr` run. -/
theorem inferExpr_principal
    {env : TermEnv} {e : CoreExpr} {ty : Ty}
    (h_inf : inferExpr env e = some ty) :
    ∀ {ty' : Ty}, HasType env e ty' → ty' = ty := by
  intro ty' h_ty'
  have h_ty : HasType env e ty := inferExpr_sound env e ty h_inf
  exact hasType_unique h_ty' h_ty

/-- Packaged principal-typing surface for core `inferExpr`. -/
structure PrincipalTypingSliceCore
    (env : TermEnv) (e : CoreExpr) (ty : Ty) : Prop where
  sound : HasType env e ty
  unique : ∀ {ty' : Ty}, HasType env e ty' → ty' = ty

/-- Packaged principal-field-typing surface for core `inferFields`. -/
structure PrincipalFieldTypingSliceCore
    (env : TermEnv) (fs : CoreFields) (row : RowFields) : Prop where
  sound : HasFieldsType env fs row
  unique : ∀ {row' : RowFields}, HasFieldsType env fs row' → row' = row

/-- Build the core principal-typing bundle from `inferExpr` success. -/
theorem principalTypingSliceCore_of_infer
    {env : TermEnv} {e : CoreExpr} {ty : Ty}
    (h_inf : inferExpr env e = some ty) :
    PrincipalTypingSliceCore env e ty := by
  refine {
    sound := inferExpr_sound env e ty h_inf
    unique := ?_
  }
  intro ty' h_ty'
  exact inferExpr_principal h_inf h_ty'

/-- Build the core principal-field-typing bundle from `inferFields` success. -/
theorem principalFieldTypingSliceCore_of_infer
    {env : TermEnv} {fs : CoreFields} {row : RowFields}
    (h_inf : inferFields env fs = some row) :
    PrincipalFieldTypingSliceCore env fs row := by
  refine {
    sound := inferFields_sound env fs row h_inf
    unique := ?_
  }
  intro row' h_row'
  exact inferFields_principal h_inf h_row'

/-- Generic boundary assignability judgment for core expressions. -/
def HasTypeAtCoreBoundary
    (allows : Ty → Ty → Prop)
    (env : TermEnv) (e : CoreExpr) (expected : Ty) : Prop :=
  ∃ actual, HasType env e actual ∧ allows expected actual

/-- Core expressions with an explicit ascription form. -/
inductive CoreExprWithAscription : Type where
  | base : CoreExpr → CoreExprWithAscription
  | ascribe : CoreExpr → Ty → CoreExprWithAscription

/-- Declarative typing for `CoreExprWithAscription` under a boundary relation. -/
inductive HasTypeWithAscription
    (allows : Ty → Ty → Prop)
    : TermEnv → CoreExprWithAscription → Ty → Prop where
  | base (env : TermEnv) (e : CoreExpr) (ty : Ty)
      (h_ty : HasType env e ty) :
      HasTypeWithAscription allows env (.base e) ty
  | ascribe (env : TermEnv) (e : CoreExpr) (expected : Ty)
      (h_boundary : HasTypeAtCoreBoundary allows env e expected) :
      HasTypeWithAscription allows env (.ascribe e expected) expected

/-- `base` nodes in `HasTypeWithAscription` coincide with `HasType`. -/
theorem hasTypeWithAscription_base_iff
    (allows : Ty → Ty → Prop)
    (env : TermEnv) (e : CoreExpr) (ty : Ty) :
    HasTypeWithAscription allows env (.base e) ty
      ↔ HasType env e ty := by
  constructor
  · intro h
    cases h with
    | base _ _ h_ty => exact h_ty
  · intro h_ty
    exact HasTypeWithAscription.base env e ty h_ty

/-- `ascribe` nodes in `HasTypeWithAscription` coincide with core boundary
    assignability at the annotated type. -/
theorem hasTypeWithAscription_ascribe_iff
    (allows : Ty → Ty → Prop)
    (env : TermEnv) (e : CoreExpr) (expected : Ty) :
    HasTypeWithAscription allows env (.ascribe e expected) expected
      ↔ HasTypeAtCoreBoundary allows env e expected := by
  constructor
  · intro h
    cases h with
    | ascribe _ _ h_boundary => exact h_boundary
  · intro h_boundary
    exact HasTypeWithAscription.ascribe env e expected h_boundary

/-- Algorithmic typing for explicit ascription expressions under a boundary
    predicate. -/
def inferExprWithAscription
    (allows : Ty → Ty → Bool)
    (env : TermEnv) : CoreExprWithAscription → Option Ty
  | .base e => inferExpr env e
  | .ascribe e expected =>
    match inferExpr env e with
    | some actual =>
      if allows expected actual then some expected else none
    | none => none

/-- `inferExprWithAscription` is definitionally conservative on `.base`
    expressions. -/
theorem inferExprWithAscription_base_eq
    (allows : Ty → Ty → Bool)
    (env : TermEnv) (e : CoreExpr) :
    inferExprWithAscription allows env (.base e) = inferExpr env e := by
  rfl

/-- On `.base` expressions, `inferExprWithAscription` has exactly the same
    success/failure behavior as `inferExpr`. -/
theorem inferExprWithAscription_base_iff
    (allows : Ty → Ty → Bool)
    (env : TermEnv) (e : CoreExpr) (ty : Ty) :
    inferExprWithAscription allows env (.base e) = some ty
      ↔ inferExpr env e = some ty := by
  simp [inferExprWithAscription_base_eq allows env e]

/-- Soundness of `inferExprWithAscription` with respect to
    `HasTypeWithAscription` instantiated with the boolean boundary relation. -/
theorem inferExprWithAscription_sound
    (allows : Ty → Ty → Bool)
    (env : TermEnv) (e : CoreExprWithAscription) :
    ∀ ty,
      inferExprWithAscription allows env e = some ty →
      HasTypeWithAscription (fun expected actual => allows expected actual = true) env e ty := by
  intro ty h_infer
  cases e with
  | base e =>
    exact HasTypeWithAscription.base env e ty
      (inferExpr_sound env e ty h_infer)
  | ascribe e expected =>
    unfold inferExprWithAscription at h_infer
    cases h_expr : inferExpr env e with
    | none =>
      simp [h_expr] at h_infer
    | some actual =>
      cases h_allow : allows expected actual with
      | false =>
        simp [h_expr, h_allow] at h_infer
      | true =>
        have h_ty_eq : expected = ty := by
          simpa [inferExprWithAscription, h_expr, h_allow] using h_infer
        have h_expected :
            HasTypeWithAscription
              (fun expected actual => allows expected actual = true)
              env
              (.ascribe e expected)
              expected :=
          HasTypeWithAscription.ascribe env e expected
            ⟨actual, inferExpr_sound env e actual h_expr, h_allow⟩
        exact h_ty_eq ▸ h_expected

/-- Completeness of `inferExprWithAscription` with respect to
    `HasTypeWithAscription` instantiated with the boolean boundary relation. -/
theorem inferExprWithAscription_complete
    (allows : Ty → Ty → Bool)
    (env : TermEnv) (e : CoreExprWithAscription) (ty : Ty)
    (h_ty : HasTypeWithAscription (fun expected actual => allows expected actual = true) env e ty) :
    inferExprWithAscription allows env e = some ty := by
  cases h_ty with
  | base _ _ h_base =>
    have h_infer_base : inferExpr env _ = some ty :=
      inferExpr_complete env _ ty h_base
    simpa [inferExprWithAscription] using h_infer_base
  | ascribe _ _ h_boundary =>
    rcases h_boundary with ⟨actual, h_actual, h_allow⟩
    have h_infer_actual : inferExpr env _ = some actual :=
      inferExpr_complete env _ actual h_actual
    simp [inferExprWithAscription, h_infer_actual, h_allow]

/-- Algorithmic and declarative ascription typing coincide for
    `inferExprWithAscription`. -/
theorem inferExprWithAscription_iff_hasTypeWithAscription
    (allows : Ty → Ty → Bool)
    (env : TermEnv) (e : CoreExprWithAscription) (ty : Ty) :
    inferExprWithAscription allows env e = some ty
      ↔ HasTypeWithAscription (fun expected actual => allows expected actual = true) env e ty := by
  constructor
  · intro h
    exact inferExprWithAscription_sound allows env e ty h
  · intro h
    exact inferExprWithAscription_complete allows env e ty h

/-- On explicit `ascribe` nodes, algorithmic ascription inference at the
    annotated type is equivalent to core boundary assignability. -/
theorem inferExprWithAscription_ascribe_iff_boundary
    (allows : Ty → Ty → Bool)
    (env : TermEnv) (e : CoreExpr) (expected : Ty) :
    inferExprWithAscription allows env (.ascribe e expected) = some expected
      ↔
      HasTypeAtCoreBoundary
        (fun exp act => allows exp act = true)
        env e expected := by
  constructor
  · intro h_infer
    have h_ty :
        HasTypeWithAscription
          (fun exp act => allows exp act = true)
          env
          (.ascribe e expected)
          expected :=
      (inferExprWithAscription_iff_hasTypeWithAscription
        allows env (.ascribe e expected) expected).1 h_infer
    exact (hasTypeWithAscription_ascribe_iff
      (fun exp act => allows exp act = true) env e expected).1 h_ty
  · intro h_boundary
    have h_ty :
        HasTypeWithAscription
          (fun exp act => allows exp act = true)
          env
          (.ascribe e expected)
          expected :=
      (hasTypeWithAscription_ascribe_iff
        (fun exp act => allows exp act = true) env e expected).2 h_boundary
    exact (inferExprWithAscription_iff_hasTypeWithAscription
      allows env (.ascribe e expected) expected).2 h_ty

private theorem lookup_eq_cons
    {env env' : TermEnv}
    (h_lookup_eq : ∀ n, TermEnv.lookup env n = TermEnv.lookup env' n)
    (x : String) (xTy : Ty) :
    ∀ n, TermEnv.lookup ((x, xTy) :: env) n = TermEnv.lookup ((x, xTy) :: env') n := by
  intro n
  by_cases h : n = x
  · subst h
    simp [TermEnv.lookup]
  · simp [TermEnv.lookup, h_lookup_eq n]

mutual
  /--
  Declarative typing is invariant under lookup-equivalent environments.
  This is a generalized weakening-style transport lemma for the core model.
  -/
  theorem hasType_lookup_congr
      {env env' : TermEnv} {e : CoreExpr} {ty : Ty}
      (h_lookup_eq : ∀ n, TermEnv.lookup env n = TermEnv.lookup env' n) :
      HasType env e ty → HasType env' e ty := by
    intro h_ty
    cases h_ty with
    | int _ n =>
      exact HasType.int env' n
    | bool _ b =>
      exact HasType.bool env' b
    | string _ s =>
      exact HasType.string env' s
    | var _ name ty h_lookup =>
      exact HasType.var env' name ty (by simpa [h_lookup_eq name] using h_lookup)
    | lam _ param paramTy bodyTy body h_body =>
      exact HasType.lam env' param paramTy bodyTy body
        (hasType_lookup_congr (lookup_eq_cons h_lookup_eq param paramTy) h_body)
    | app _ fn arg paramTy _ h_fn h_arg =>
      exact HasType.app env' fn arg paramTy ty
        (hasType_lookup_congr h_lookup_eq h_fn)
        (hasType_lookup_congr h_lookup_eq h_arg)
    | letE _ name value body valueTy _ h_value h_body =>
      exact HasType.letE env' name value body valueTy ty
        (hasType_lookup_congr h_lookup_eq h_value)
        (hasType_lookup_congr (lookup_eq_cons h_lookup_eq name valueTy) h_body)
    | record _ fields rowFields h_fields =>
      exact HasType.record env' fields rowFields
        (hasFieldsType_lookup_congr h_lookup_eq h_fields)
    | proj _ e rowFields label ty h_e h_get =>
      exact HasType.proj env' e rowFields label ty
        (hasType_lookup_congr h_lookup_eq h_e) h_get

  /-- Field typing transport under lookup-equivalent environments. -/
  theorem hasFieldsType_lookup_congr
      {env env' : TermEnv} {fs : CoreFields} {rowFields : RowFields}
      (h_lookup_eq : ∀ n, TermEnv.lookup env n = TermEnv.lookup env' n) :
      HasFieldsType env fs rowFields → HasFieldsType env' fs rowFields := by
    intro h_fs
    cases h_fs with
    | nil _ =>
      exact HasFieldsType.nil env'
    | cons _ label e rest ty restFields h_head h_rest =>
      exact HasFieldsType.cons env' label e rest ty restFields
        (hasType_lookup_congr h_lookup_eq h_head)
        (hasFieldsType_lookup_congr h_lookup_eq h_rest)
end

/-- Algorithmic inference is preserved across lookup-equivalent environments. -/
theorem inferExpr_lookup_congr
    {env env' : TermEnv} {e : CoreExpr} {ty : Ty}
    (h_lookup_eq : ∀ n, TermEnv.lookup env n = TermEnv.lookup env' n) :
    inferExpr env e = some ty ↔ inferExpr env' e = some ty := by
  constructor
  · intro h
    have h_ty : HasType env e ty := (inferExpr_iff_hasType env e ty).1 h
    have h_ty' : HasType env' e ty := hasType_lookup_congr h_lookup_eq h_ty
    exact (inferExpr_iff_hasType env' e ty).2 h_ty'
  · intro h
    have h_lookup_eq_symm : ∀ n, TermEnv.lookup env' n = TermEnv.lookup env n := by
      intro n; symm; exact h_lookup_eq n
    have h_ty : HasType env' e ty := (inferExpr_iff_hasType env' e ty).1 h
    have h_ty' : HasType env e ty := hasType_lookup_congr h_lookup_eq_symm h_ty
    exact (inferExpr_iff_hasType env e ty).2 h_ty'

-- =========================================================================
-- Vertical slice: inference with threaded unification state
-- =========================================================================

/-- Result type for unification-backed expression inference. -/
inductive InferUnifyResult : Type where
  | ok  : UnifyState → Ty → InferUnifyResult
  | err : String → InferUnifyResult

mutual
  /--
  Algorithmic inference that threads `UnifyState` and delegates constraints to
  `unify` (fuel-bounded).
  -/
  def inferExprUnify (st : UnifyState) (fuel : Nat) (env : TermEnv) : CoreExpr → InferUnifyResult
    | .intLit _ => .ok st .int
    | .boolLit _ => .ok st .bool
    | .stringLit _ => .ok st .string
    | .var name =>
      match TermEnv.lookup env name with
      | some ty => .ok st ty
      | none => .err s!"unbound variable: {name}"
    | .lam param paramTy body =>
      match inferExprUnify st fuel ((param, paramTy) :: env) body with
      | .ok st' bodyTy => .ok st' (.function (.cons paramTy .nil) bodyTy)
      | .err e => .err e
    | .app fn arg =>
      match inferExprUnify st fuel env fn with
      | .err e => .err e
      | .ok stFn fnTy =>
        match inferExprUnify stFn fuel env arg with
        | .err e => .err e
        | .ok stArg argTy =>
          let (resVar, stRes) := stArg.freshTypeVar
          let expected := .function (.cons argTy .nil) (.var resVar)
          match unify stRes fuel fnTy expected with
          | .err e => .err e
          | .ok stU =>
            .ok stU (applySubstCompat stU.subst fuel (.var resVar))
    | .letE name value body =>
      match inferExprUnify st fuel env value with
      | .err e => .err e
      | .ok st' valueTy => inferExprUnify st' fuel ((name, valueTy) :: env) body
    | .record fields =>
      match inferFieldsUnify st fuel env fields with
      | .ok st' (.row (.mk rowFields none)) => .ok st' (.anonRecord (.mk rowFields none))
      | .ok _ _ => .err "internal error: expected row type from inferFieldsUnify"
      | .err e => .err e
    | .proj recv label =>
      match inferExprUnify st fuel env recv with
      | .err e => .err e
      | .ok stRecv recvTy =>
        let (fieldVar, stField) := stRecv.freshTypeVar
        let (restVar, stRest) := stField.freshRowVar
        let expected := .anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))
        match unify stRest fuel recvTy expected with
        | .err e => .err e
        | .ok stU =>
          .ok stU (applySubstCompat stU.subst fuel (.var fieldVar))

  /-- Unification-backed field inference (threads state through fields). -/
  def inferFieldsUnify (st : UnifyState) (fuel : Nat) (env : TermEnv) : CoreFields → InferUnifyResult
    | .nil => .ok st (.row (.mk .nil none))
    | .cons label e rest =>
      match inferExprUnify st fuel env e with
      | .err err => .err err
      | .ok stHead tyHead =>
        match inferFieldsUnify stHead fuel env rest with
        | .err err => .err err
        | .ok stRest (.row (.mk restFields none)) =>
          .ok stRest (.row (.mk (.cons label tyHead restFields) none))
        | .ok _ _ => .err "internal error: expected row type from inferFieldsUnify"
end

/-- Project a row-fields payload out of `inferFieldsUnify` results. -/
def inferFieldsUnifyRowFields
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields) :
    Option (UnifyState × RowFields) :=
  match inferFieldsUnify st fuel env fs with
  | .ok st' (.row (.mk fields none)) => some (st', fields)
  | _ => none

/-- Soundness hook shape for app branches in `inferExprUnify`. -/
def AppUnifySoundHook : Prop :=
  ∀ env fn arg fnTy argTy stBefore stAfter fuel resVar,
    HasType env fn fnTy →
    HasType env arg argTy →
    unify stBefore fuel fnTy (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter →
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar))

/--
Empty-substitution specialization of `AppUnifySoundHook`.
Used to test whether hook closure is possible in the simplest starting state.
-/
def AppUnifySoundHookEmptySubst : Prop :=
  ∀ env fn arg fnTy argTy stBefore stAfter fuel resVar,
    stBefore.subst = Subst.empty →
    HasType env fn fnTy →
    HasType env arg argTy →
    unify stBefore fuel fnTy (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter →
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar))

/-- Soundness hook shape for projection branches in `inferExprUnify`. -/
def ProjUnifySoundHook : Prop :=
  ∀ env recv label recvTy stBefore stAfter fuel fieldVar restVar,
    HasType env recv recvTy →
    unify stBefore fuel recvTy (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter →
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar))

/-- `HasTypeU`-targeted app hook shape for `inferExprUnify`. -/
def AppUnifySoundHookU : Prop :=
  ∀ env fn arg fnTy argTy stBefore stAfter fuel resVar,
    HasTypeU env fn fnTy →
    HasTypeU env arg argTy →
    unify stBefore fuel fnTy (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter →
    HasTypeU env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar))

/-- `HasTypeU`-targeted projection hook shape for `inferExprUnify`. -/
def ProjUnifySoundHookU : Prop :=
  ∀ env recv label recvTy stBefore stAfter fuel fieldVar restVar,
    HasTypeU env recv recvTy →
    unify stBefore fuel recvTy (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter →
    HasTypeU env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar))

/--
Global app-branch resolved-shape premise: successful app unification determines
the resolved function shape at the same fuel.
-/
def AppResolvedShapeFromUnify : Prop :=
  ∀ env fn arg fnTy argTy stBefore stAfter fuel resVar,
    HasTypeU env fn fnTy →
    HasTypeU env arg argTy →
    unify stBefore fuel fnTy (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter →
    applySubstCompat stAfter.subst fuel fnTy =
      .function
        (.cons (applySubstCompat stAfter.subst fuel argTy) .nil)
        (applySubstCompat stAfter.subst fuel (.var resVar))

/--
Global projection-branch resolved-shape premise: successful projection
unification determines a closed resolved receiver row and selected field type.
-/
def ProjResolvedShapeFromUnify : Prop :=
  ∀ env recv label recvTy stBefore stAfter fuel fieldVar restVar,
    HasTypeU env recv recvTy →
    unify stBefore fuel recvTy (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter →
    ∃ rowFields,
      applySubstCompat stAfter.subst fuel recvTy = .anonRecord (.mk rowFields none)
      ∧ RowFields.get rowFields label = some (applySubstCompat stAfter.subst fuel (.var fieldVar))

/-- Packaged global resolved-shape premises for app and projection branches. -/
def UnifyResolvedShapePremises : Prop :=
  AppResolvedShapeFromUnify ∧ ProjResolvedShapeFromUnify

/-- Packaged `HasType` hook assumptions for recursive soundness. -/
def UnifyHookPremises : Prop :=
  AppUnifySoundHook ∧ ProjUnifySoundHook

/-- Packaged `HasTypeU` hook assumptions for recursive soundness. -/
def UnifyHookPremisesU : Prop :=
  AppUnifySoundHookU ∧ ProjUnifySoundHookU

/--
Empty-substitution specialization of `ProjUnifySoundHook`.
Used to test whether hook closure is possible in the simplest starting state.
-/
def ProjUnifySoundHookEmptySubst : Prop :=
  ∀ env recv label recvTy stBefore stAfter fuel fieldVar restVar,
    stBefore.subst = Subst.empty →
    HasType env recv recvTy →
    unify stBefore fuel recvTy (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter →
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar))

/--
`AppUnifySoundHook` is not derivable from the current declarative judgment:
unification can succeed by binding a variable-typed function position, while
`HasType.app` requires the function side to already have a function type.
-/
theorem not_AppUnifySoundHook : ¬ AppUnifySoundHook := by
  intro h_app
  let env : TermEnv := [("f", .var 0)]
  let fn : CoreExpr := .var "f"
  let arg : CoreExpr := .intLit 1
  let stBefore : UnifyState := { UnifyState.empty with nextTypeVar := 2 }
  let expected : Ty := .function (.cons .int .nil) (.var 1)
  let stAfter : UnifyState := { stBefore with subst := stBefore.subst.bindType 0 expected }
  have h_fn : HasType env fn (.var 0) := by
    exact HasType.var env "f" (.var 0) (by simp [env, TermEnv.lookup])
  have h_arg : HasType env arg .int := HasType.int env 1
  have h_unify : unify stBefore 1 (.var 0) expected = .ok stAfter := by
    have h_occ : occursInTyList 0 (TyList.cons Ty.int TyList.nil) = false := by
      simp [occursInTyList, occursIn]
    have h_neq1 : (Ty.var 0 == expected) = false := by
      native_decide
    have h_neq2 : (expected == Ty.var 0) = false := by
      native_decide
    simp [unify, bindTypeVar, stBefore, stAfter, expected, UnifyState.empty,
      applySubst, occursIn, h_occ, h_neq1, h_neq2]
  have h_typed :
      HasType env (.app fn arg) (applySubstCompat stAfter.subst 1 (.var 1)) :=
    h_app env fn arg (.var 0) .int stBefore stAfter 1 1 h_fn h_arg h_unify
  have h_alg :
      inferExpr env (.app fn arg) = some (applySubstCompat stAfter.subst 1 (.var 1)) :=
    inferExpr_complete env (.app fn arg) (applySubstCompat stAfter.subst 1 (.var 1)) h_typed
  simp [inferExpr, env, fn, arg, TermEnv.lookup] at h_alg

/--
Even requiring an empty starting substitution is not enough to derive the app
hook against the monomorphic declarative judgment.
-/
theorem not_AppUnifySoundHookEmptySubst : ¬ AppUnifySoundHookEmptySubst := by
  intro h_app
  let env : TermEnv := [("f", .var 0)]
  let fn : CoreExpr := .var "f"
  let arg : CoreExpr := .intLit 1
  let stBefore : UnifyState := { UnifyState.empty with nextTypeVar := 2 }
  let expected : Ty := .function (.cons .int .nil) (.var 1)
  let stAfter : UnifyState := { stBefore with subst := stBefore.subst.bindType 0 expected }
  have h_fn : HasType env fn (.var 0) := by
    exact HasType.var env "f" (.var 0) (by simp [env, TermEnv.lookup])
  have h_arg : HasType env arg .int := HasType.int env 1
  have h_unify : unify stBefore 1 (.var 0) expected = .ok stAfter := by
    have h_occ : occursInTyList 0 (TyList.cons Ty.int TyList.nil) = false := by
      simp [occursInTyList, occursIn]
    have h_neq1 : (Ty.var 0 == expected) = false := by
      native_decide
    have h_neq2 : (expected == Ty.var 0) = false := by
      native_decide
    simp [unify, bindTypeVar, stBefore, stAfter, expected, UnifyState.empty,
      applySubst, occursIn, h_occ, h_neq1, h_neq2]
  have h_empty : stBefore.subst = Subst.empty := by
    simp [stBefore, UnifyState.empty]
  have h_typed :
      HasType env (.app fn arg) (applySubstCompat stAfter.subst 1 (.var 1)) :=
    h_app env fn arg (.var 0) .int stBefore stAfter 1 1 h_empty h_fn h_arg h_unify
  have h_alg :
      inferExpr env (.app fn arg) = some (applySubstCompat stAfter.subst 1 (.var 1)) :=
    inferExpr_complete env (.app fn arg) (applySubstCompat stAfter.subst 1 (.var 1)) h_typed
  simp [inferExpr, env, fn, arg, TermEnv.lookup] at h_alg

/--
`ProjUnifySoundHook` is not derivable from the current declarative judgment:
unification can succeed by binding a variable-typed receiver position, while
`HasType.proj` requires the receiver to already have a closed anon-record type.
-/
theorem not_ProjUnifySoundHook : ¬ ProjUnifySoundHook := by
  intro h_proj
  let env : TermEnv := [("r", .var 0)]
  let recv : CoreExpr := .var "r"
  let label : Label := "a"
  let stBefore : UnifyState := { UnifyState.empty with nextTypeVar := 2 }
  let expected : Ty := .anonRecord (.mk (.cons label (.var 1) .nil) (some 0))
  let stAfter : UnifyState := { stBefore with subst := stBefore.subst.bindType 0 expected }
  have h_recv : HasType env recv (.var 0) := by
    exact HasType.var env "r" (.var 0) (by simp [env, TermEnv.lookup])
  have h_unify : unify stBefore 1 (.var 0) expected = .ok stAfter := by
    have h_occ : occursInRow 0 (.mk (.cons label (.var 1) .nil) (some 0)) = false := by
      simp [occursInRow, occursInRowFields, occursIn]
    have h_neq1 : (Ty.var 0 == expected) = false := by
      native_decide
    have h_neq2 : (expected == Ty.var 0) = false := by
      native_decide
    simp [unify, bindTypeVar, stBefore, stAfter, expected, UnifyState.empty,
      applySubst, occursIn, h_occ, h_neq1, h_neq2]
  have h_typed :
      HasType env (.proj recv label) (applySubstCompat stAfter.subst 1 (.var 1)) :=
    h_proj env recv label (.var 0) stBefore stAfter 1 1 0 h_recv h_unify
  have h_alg :
      inferExpr env (.proj recv label) = some (applySubstCompat stAfter.subst 1 (.var 1)) :=
    inferExpr_complete env (.proj recv label) (applySubstCompat stAfter.subst 1 (.var 1)) h_typed
  simp [inferExpr, env, recv, TermEnv.lookup] at h_alg

/--
Even requiring an empty starting substitution is not enough to derive the
projection hook against the monomorphic declarative judgment.
-/
theorem not_ProjUnifySoundHookEmptySubst : ¬ ProjUnifySoundHookEmptySubst := by
  intro h_proj
  let env : TermEnv := [("r", .var 0)]
  let recv : CoreExpr := .var "r"
  let label : Label := "a"
  let stBefore : UnifyState := { UnifyState.empty with nextTypeVar := 2 }
  let expected : Ty := .anonRecord (.mk (.cons label (.var 1) .nil) (some 0))
  let stAfter : UnifyState := { stBefore with subst := stBefore.subst.bindType 0 expected }
  have h_recv : HasType env recv (.var 0) := by
    exact HasType.var env "r" (.var 0) (by simp [env, TermEnv.lookup])
  have h_unify : unify stBefore 1 (.var 0) expected = .ok stAfter := by
    have h_occ : occursInRow 0 (.mk (.cons label (.var 1) .nil) (some 0)) = false := by
      simp [occursInRow, occursInRowFields, occursIn]
    have h_neq1 : (Ty.var 0 == expected) = false := by
      native_decide
    have h_neq2 : (expected == Ty.var 0) = false := by
      native_decide
    simp [unify, bindTypeVar, stBefore, stAfter, expected, UnifyState.empty,
      applySubst, occursIn, h_occ, h_neq1, h_neq2]
  have h_empty : stBefore.subst = Subst.empty := by
    simp [stBefore, UnifyState.empty]
  have h_typed :
      HasType env (.proj recv label) (applySubstCompat stAfter.subst 1 (.var 1)) :=
    h_proj env recv label (.var 0) stBefore stAfter 1 1 0 h_empty h_recv h_unify
  have h_alg :
      inferExpr env (.proj recv label) = some (applySubstCompat stAfter.subst 1 (.var 1)) :=
    inferExpr_complete env (.proj recv label) (applySubstCompat stAfter.subst 1 (.var 1)) h_typed
  simp [inferExpr, env, recv, TermEnv.lookup] at h_alg

/--
The global app resolved-shape premise is false in the fuel model: successful
app unification can produce a substitution where the resolved function side and
the "resolved argument + resolved result" shape diverge at the same fuel.
-/
theorem not_AppResolvedShapeFromUnify : ¬ AppResolvedShapeFromUnify := by
  intro h_app_resolved
  let env : TermEnv := [("f", .var 0), ("x", .var 0)]
  let fn : CoreExpr := .var "f"
  let arg : CoreExpr := .var "x"
  let fnTy : Ty := .var 0
  let argTy : Ty := .var 0
  let resVar : TypeVarId := 2
  let target : Ty := .function (.cons argTy .nil) (.var resVar)
  let s0 : Subst :=
    { typeMap := fun v => if v == 0 then some (.var 1) else none
      rowMap := fun _ => none }
  let stBefore : UnifyState :=
    { subst := s0, lacks := Lacks.empty, traitBounds := [], nextTypeVar := 3, nextRowVar := 0 }
  let stAfter : UnifyState := { stBefore with subst := stBefore.subst.bindType 1 target }
  have h_fn : HasTypeU env fn fnTy := by
    exact HasTypeU.var env "f" fnTy (by simp [env, fnTy, TermEnv.lookup])
  have h_arg : HasTypeU env arg argTy := by
    exact HasTypeU.var env "x" argTy (by simp [env, argTy, TermEnv.lookup])
  have h_unify : unify stBefore 2 fnTy target = .ok stAfter := by
    have h_left_ne :
        (Ty.var 1 == Ty.function (.cons argTy .nil) (.var resVar)) = false := by
      native_decide
    have h_right_ne :
        (Ty.function (.cons argTy .nil) (.var resVar) == Ty.var 1) = false := by
      native_decide
    have h_occ :
        occursInTyList 1 (.cons argTy .nil) = false := by
      native_decide
    have h_ne : (1 : Nat) ≠ resVar := by
      native_decide
    simp [unify, bindTypeVar, stBefore, stAfter, fnTy, target, s0, applySubst,
      applySubstTyList, occursIn, h_left_ne, h_right_ne, h_occ, h_ne]
  have h_resolved :
      applySubstCompat stAfter.subst 2 fnTy =
        .function
          (.cons (applySubstCompat stAfter.subst 2 argTy) .nil)
          (applySubstCompat stAfter.subst 2 (.var resVar)) :=
    h_app_resolved env fn arg fnTy argTy stBefore stAfter 2 resVar h_fn h_arg h_unify
  let lhs : Ty := applySubstCompat stAfter.subst 2 fnTy
  let rhs : Ty :=
    .function
      (.cons (applySubstCompat stAfter.subst 2 argTy) .nil)
      (applySubstCompat stAfter.subst 2 (.var resVar))
  have h_false :
      (lhs == rhs) = false := by
    native_decide
  have h_true :
      (lhs == rhs) = true := by
    have h_resolved' : lhs = rhs := by
      simpa [lhs, rhs] using h_resolved
    rw [h_resolved']
    exact beqTy_refl rhs
  rw [h_true] at h_false
  cases h_false

/--
The global projection resolved-shape premise is false in the fuel model:
successful projection unification can leave the receiver resolved to an open
row at the same fuel, so no closed-row witness exists.
-/
theorem not_ProjResolvedShapeFromUnify : ¬ ProjResolvedShapeFromUnify := by
  intro h_proj_resolved
  let env : TermEnv := [("r", .var 0)]
  let recv : CoreExpr := .var "r"
  let label : Label := "a"
  let recvTy : Ty := .var 0
  let fieldVar : TypeVarId := 2
  let restVar : RowVarId := 1
  let stBefore : UnifyState := { UnifyState.empty with nextTypeVar := 3, nextRowVar := 2 }
  let expected : Ty := .anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))
  let stAfter : UnifyState := { stBefore with subst := stBefore.subst.bindType 0 expected }
  have h_recv : HasTypeU env recv recvTy := by
    exact HasTypeU.var env "r" recvTy (by simp [env, recvTy, TermEnv.lookup])
  have h_unify : unify stBefore 1 recvTy expected = .ok stAfter := by
    have h_occ :
        occursInRow 0 (.mk (.cons label (.var fieldVar) .nil) (some restVar)) = false := by
      simp [occursInRow, occursInRowFields, occursIn, fieldVar]
    have h_neq1 : (recvTy == expected) = false := by
      native_decide
    have h_neq2 : (expected == recvTy) = false := by
      native_decide
    simp [unify, bindTypeVar, stBefore, stAfter, recvTy, expected, UnifyState.empty,
      applySubst, occursIn, h_occ, h_neq1, h_neq2]
  rcases h_proj_resolved env recv label recvTy stBefore stAfter 1 fieldVar restVar h_recv h_unify with
    ⟨rowFields, h_resolved, _h_get⟩
  have h_open :
      applySubstCompat stAfter.subst 1 recvTy =
        .anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar)) := by
    simp [applySubstCompat, applySubst, stAfter, recvTy, expected, Subst.bindType]
  rw [h_open] at h_resolved
  cases rowFields <;> cases h_resolved

/-- Consequently, the bundled resolved-shape premise pair is also false. -/
theorem not_UnifyResolvedShapePremises : ¬ UnifyResolvedShapePremises := by
  intro h
  exact not_AppResolvedShapeFromUnify h.1

/--
Weaker app hook: derivable when the function side is already declaratively typed
as a single-argument function, and the unify result variable is known to resolve
to that return type.
-/
def AppUnifySoundHookWeak : Prop :=
  ∀ env fn arg argTy retTy stBefore stAfter fuel resVar,
    HasType env fn (.function (.cons argTy .nil) retTy) →
    HasType env arg argTy →
    unify stBefore fuel (.function (.cons argTy .nil) retTy) (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter →
    applySubstCompat stAfter.subst fuel (.var resVar) = retTy →
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar))

/-- `AppUnifySoundHookWeak` is derivable from declarative typing + result equality. -/
theorem appUnifySoundHookWeak_proved : AppUnifySoundHookWeak := by
  intro env fn arg argTy retTy stBefore stAfter fuel resVar h_fn h_arg _ h_res_eq
  rw [h_res_eq]
  exact HasType.app env fn arg argTy retTy h_fn h_arg

/--
Weaker projection hook: derivable when the receiver side is already
declaratively typed as a closed anonymous record carrying the selected field
at the substitution-resolved projection type.
-/
def ProjUnifySoundHookWeak : Prop :=
  ∀ env recv label recvTy stBefore stAfter fuel fieldVar restVar rowFields,
    HasType env recv recvTy →
    recvTy = .anonRecord (.mk rowFields none) →
    unify stBefore fuel recvTy (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter →
    RowFields.get rowFields label = some (applySubstCompat stAfter.subst fuel (.var fieldVar)) →
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar))

/-- `ProjUnifySoundHookWeak` is derivable from declarative projection typing. -/
theorem projUnifySoundHookWeak_proved : ProjUnifySoundHookWeak := by
  intro env recv label recvTy stBefore stAfter fuel fieldVar restVar rowFields
    h_recv h_shape _ h_get
  rw [h_shape] at h_recv
  exact HasType.proj env recv rowFields label
    (applySubstCompat stAfter.subst fuel (.var fieldVar)) h_recv h_get

/-- Any strong app hook witness implies the app weak-hook surface. -/
theorem appUnifySoundHookWeak_of_appUnifySoundHook
    (h_app : AppUnifySoundHook) :
    AppUnifySoundHookWeak := by
  intro env fn arg argTy retTy stBefore stAfter fuel resVar h_fn h_arg h_unify h_res_eq
  have h_app_step : HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)) :=
    h_app env fn arg (.function (.cons argTy .nil) retTy) argTy stBefore stAfter fuel resVar
      h_fn h_arg h_unify
  simpa [h_res_eq] using h_app_step

/-- Any strong projection hook witness implies the projection weak-hook surface. -/
theorem projUnifySoundHookWeak_of_projUnifySoundHook
    (h_proj : ProjUnifySoundHook) :
    ProjUnifySoundHookWeak := by
  intro env recv label recvTy stBefore stAfter fuel fieldVar restVar rowFields
    h_recv _ h_unify _
  exact h_proj env recv label recvTy stBefore stAfter fuel fieldVar restVar h_recv h_unify

/-- Packaged weak hook assumptions for app/projection branch reasoning. -/
def UnifyHookPremisesWeak : Prop :=
  AppUnifySoundHookWeak ∧ ProjUnifySoundHookWeak

/-- The weak hook package is derivable on both app and projection branches. -/
theorem unifyHookPremisesWeak_proved : UnifyHookPremisesWeak := by
  exact ⟨appUnifySoundHookWeak_proved, projUnifySoundHookWeak_proved⟩

/-- Any strong hook package implies the weak hook package. -/
theorem unifyHookPremisesWeak_of_unifyHookPremises
    (h_hooks : UnifyHookPremises) :
    UnifyHookPremisesWeak := by
  exact ⟨appUnifySoundHookWeak_of_appUnifySoundHook h_hooks.1,
    projUnifySoundHookWeak_of_projUnifySoundHook h_hooks.2⟩

/--
Canonical weak-boundary local-step bundle for `HasType`: packages app/proj
one-step soundness under resolved equality/row-shape premises.
-/
def UnifyStepSoundWeak : Prop :=
  (∀ env fn arg argTy retTy stBefore stAfter fuel resVar,
    HasType env fn (.function (.cons argTy .nil) retTy) →
    HasType env arg argTy →
    unify stBefore fuel (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter →
    applySubstCompat stAfter.subst fuel (.var resVar) = retTy →
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)))
  ∧
  (∀ env recv label recvTy stBefore stAfter fuel fieldVar restVar rowFields,
    HasType env recv recvTy →
    recvTy = .anonRecord (.mk rowFields none) →
    unify stBefore fuel recvTy
      (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter →
    RowFields.get rowFields label = some (applySubstCompat stAfter.subst fuel (.var fieldVar)) →
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar)))

/-- Build the weak local-step bundle from weak hook premises. -/
theorem unifyStepSoundWeak_of_hookPremisesWeak
    (h_hooks : UnifyHookPremisesWeak) :
    UnifyStepSoundWeak := by
  exact ⟨h_hooks.1, h_hooks.2⟩

/-- Canonical witness for the weak local-step bundle. -/
theorem unifyStepSoundWeak_proved : UnifyStepSoundWeak := by
  exact unifyStepSoundWeak_of_hookPremisesWeak unifyHookPremisesWeak_proved

/-- Build the weak local-step bundle directly from strong hook premises. -/
theorem unifyStepSoundWeak_of_unifyHookPremises
    (h_hooks : UnifyHookPremises) :
    UnifyStepSoundWeak := by
  exact unifyStepSoundWeak_of_hookPremisesWeak
    (unifyHookPremisesWeak_of_unifyHookPremises h_hooks)

/--
Unification-aware app hook: if substitution-resolving `fnTy` yields a
single-argument function shape over the resolved argument type, app typing is
derivable directly in `HasTypeU`.
-/
def AppUnifySoundHookUResolved : Prop :=
  ∀ env fn arg fnTy argTy stBefore stAfter fuel resVar,
    HasTypeU env fn fnTy →
    HasTypeU env arg argTy →
    unify stBefore fuel fnTy (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter →
    applySubstCompat stAfter.subst fuel fnTy =
      .function
        (.cons (applySubstCompat stAfter.subst fuel argTy) .nil)
        (applySubstCompat stAfter.subst fuel (.var resVar)) →
    HasTypeU env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar))

/--
`AppUnifySoundHookUResolved` is derivable from `HasTypeU.subst`: once the
resolved function-shape equation is available, no additional hook is needed.
-/
theorem appUnifySoundHookUResolved_proved : AppUnifySoundHookUResolved := by
  intro env fn arg fnTy argTy stBefore stAfter fuel resVar h_fn h_arg _ h_resolved
  have h_fn_resolved : HasTypeU env fn (applySubstCompat stAfter.subst fuel fnTy) :=
    HasTypeU.subst env fn fnTy stAfter.subst fuel h_fn
  have h_arg_resolved : HasTypeU env arg (applySubstCompat stAfter.subst fuel argTy) :=
    HasTypeU.subst env arg argTy stAfter.subst fuel h_arg
  rw [h_resolved] at h_fn_resolved
  exact HasTypeU.app env fn arg
    (applySubstCompat stAfter.subst fuel argTy)
    (applySubstCompat stAfter.subst fuel (.var resVar))
    h_fn_resolved h_arg_resolved

/--
Successor-fuel variant of `AppUnifySoundHookUResolved` matching the app-branch
shape exposed by `bindTypeVarConsistentIdempotent`-style lemmas.
-/
def AppUnifySoundHookUResolvedSucc : Prop :=
  ∀ env fn arg fnTy argTy stBefore stAfter fuel resVar,
    HasTypeU env fn fnTy →
    HasTypeU env arg argTy →
    unify stBefore fuel fnTy (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter →
    applySubstCompat stAfter.subst (fuel + 1) fnTy =
      .function
        (.cons (applySubstCompat stAfter.subst fuel argTy) .nil)
        (applySubstCompat stAfter.subst (fuel + 1) (.var resVar)) →
    HasTypeU env (.app fn arg) (applySubstCompat stAfter.subst (fuel + 1) (.var resVar))

/-- `AppUnifySoundHookUResolvedSucc` is derivable from `HasTypeU.subst`. -/
theorem appUnifySoundHookUResolvedSucc_proved : AppUnifySoundHookUResolvedSucc := by
  intro env fn arg fnTy argTy stBefore stAfter fuel resVar h_fn h_arg _ h_resolved
  have h_fn_resolved : HasTypeU env fn (applySubstCompat stAfter.subst (fuel + 1) fnTy) :=
    HasTypeU.subst env fn fnTy stAfter.subst (fuel + 1) h_fn
  have h_arg_resolved : HasTypeU env arg (applySubstCompat stAfter.subst fuel argTy) :=
    HasTypeU.subst env arg argTy stAfter.subst fuel h_arg
  rw [h_resolved] at h_fn_resolved
  exact HasTypeU.app env fn arg
    (applySubstCompat stAfter.subst fuel argTy)
    (applySubstCompat stAfter.subst (fuel + 1) (.var resVar))
    h_fn_resolved h_arg_resolved

/--
Unification-aware projection hook: if substitution-resolving `recvTy` yields a
closed anon-record shape whose selected field is the resolved projection
variable, projection typing is derivable directly in `HasTypeU`.
-/
def ProjUnifySoundHookUResolved : Prop :=
  ∀ env recv label recvTy stBefore stAfter fuel fieldVar restVar rowFields,
    HasTypeU env recv recvTy →
    unify stBefore fuel recvTy (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter →
    applySubstCompat stAfter.subst fuel recvTy = .anonRecord (.mk rowFields none) →
    RowFields.get rowFields label = some (applySubstCompat stAfter.subst fuel (.var fieldVar)) →
    HasTypeU env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar))

/-- `ProjUnifySoundHookUResolved` is derivable from `HasTypeU.subst`. -/
theorem projUnifySoundHookUResolved_proved : ProjUnifySoundHookUResolved := by
  intro env recv label recvTy stBefore stAfter fuel fieldVar restVar rowFields
    h_recv _ h_resolved h_get
  have h_recv_resolved : HasTypeU env recv (applySubstCompat stAfter.subst fuel recvTy) :=
    HasTypeU.subst env recv recvTy stAfter.subst fuel h_recv
  rw [h_resolved] at h_recv_resolved
  exact HasTypeU.proj env recv rowFields label
    (applySubstCompat stAfter.subst fuel (.var fieldVar))
    h_recv_resolved h_get

/--
Bridge lemma for the app weak-hook equality premise:
if the app unification success factors through a `bindTypeVar` step on the
result variable and the final substitution is idempotent, the needed equality
follows from `bindTypeVarConsistentIdempotent`.
-/
theorem app_unify_result_eq_of_bindTypeVar_idempotent
    (stBefore : UnifyState) (fuel : Nat) (retTy : Ty) (resVar : TypeVarId) (stAfter : UnifyState)
    (h_bind : bindTypeVar stBefore resVar retTy fuel = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubst stAfter.subst (fuel + 1) (.var resVar) =
      applySubst stAfter.subst (fuel + 1) retTy := by
  have h :=
    bindTypeVarConsistentIdempotent stBefore resVar retTy fuel stAfter h_bind h_idemp
  simpa using h

/--
Function-app bridge slice: if the function-parameter phase is known successful
and the return-type phase is known to be a `bindTypeVar` success, idempotence
is sufficient to derive the weak-hook equality premise.
-/
theorem app_unify_result_eq_of_function_tail_bind_idempotent
    (st stTail stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (_h_params : unifyTyList st fuel (.cons argTy .nil) (.cons argTy .nil) = .ok stTail)
    (h_tail_bind : bindTypeVar stTail resVar retTy fuel = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubst stAfter.subst (fuel + 1) (.var resVar) =
      applySubst stAfter.subst (fuel + 1) retTy :=
  app_unify_result_eq_of_bindTypeVar_idempotent stTail fuel retTy resVar stAfter h_tail_bind h_idemp

/--
Packaged app-branch bridge: expose exactly the equality premise needed by
`AppUnifySoundHookWeak`, assuming explicit function-branch shape witnesses.
-/
theorem app_unify_result_eq_of_unify_function_shape_idempotent
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_shape :
      ∃ stTail,
        unifyTyList st fuel (.cons argTy .nil) (.cons argTy .nil) = .ok stTail ∧
        bindTypeVar stTail resVar retTy fuel = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubst stAfter.subst (fuel + 1) (.var resVar) =
      applySubst stAfter.subst (fuel + 1) retTy := by
  rcases h_shape with ⟨stTail, h_params, h_tail_bind⟩
  exact app_unify_result_eq_of_function_tail_bind_idempotent
    st stTail stAfter fuel argTy retTy resVar h_params h_tail_bind h_idemp

/--
Decompose app-branch unification success into parameter-list and return-tail
success, assuming the resolved heads are the expected function shapes and the
BEq fast-path is not taken.
-/
theorem app_unify_function_shape_witness_of_success_resolved_heads
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_head_l :
      applySubstCompat st.subst fuel (.function (.cons argTy .nil) retTy) =
        .function (.cons argTy .nil) retTy)
    (h_head_r :
      applySubstCompat st.subst fuel (.function (.cons argTy .nil) (.var resVar)) =
        .function (.cons argTy .nil) (.var resVar))
    (h_beq :
      (applySubstCompat st.subst fuel (.function (.cons argTy .nil) retTy)
        == applySubstCompat st.subst fuel (.function (.cons argTy .nil) (.var resVar))) = false)
    (h_unify :
      unify st (fuel + 1) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter) :
    ∃ stTail,
      unifyTyList st fuel (.cons argTy .nil) (.cons argTy .nil) = .ok stTail ∧
      unify stTail fuel retTy (.var resVar) = .ok stAfter := by
  have h_beq' :
      ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false := by
    simpa [h_head_l, h_head_r] using h_beq
  have h_unify' :
      (match unifyTyList st fuel (.cons argTy .nil) (.cons argTy .nil) with
        | .ok st' => unify st' fuel retTy (.var resVar)
        | e => e) = .ok stAfter := by
    simpa [unify, h_head_l, h_head_r, h_beq'] using h_unify
  cases h_params : unifyTyList st fuel (.cons argTy .nil) (.cons argTy .nil) with
  | err e =>
    simp [h_params] at h_unify'
  | ok stTail =>
    refine ⟨stTail, ?_, ?_⟩
    · simp
    · simpa [h_params] using h_unify'

/--
Derive resolved app/function heads from no-op domain assumptions on the
argument type, return type, and result variable.
-/
theorem app_unify_resolved_heads_of_noop_domain
    (st : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_arg_type : ∀ v ∈ freeTypeVars argTy, st.subst.typeMap v = none)
    (h_arg_row : ∀ v ∈ freeRowVars argTy, st.subst.rowMap v = none)
    (h_ret_type : ∀ v ∈ freeTypeVars retTy, st.subst.typeMap v = none)
    (h_ret_row : ∀ v ∈ freeRowVars retTy, st.subst.rowMap v = none)
    (h_res_unbound : st.subst.typeMap resVar = none) :
    applySubstCompat st.subst fuel (.function (.cons argTy .nil) retTy) =
      .function (.cons argTy .nil) retTy
    ∧
    applySubstCompat st.subst fuel (.function (.cons argTy .nil) (.var resVar)) =
      .function (.cons argTy .nil) (.var resVar) := by
  obtain ⟨h_noop_ty, _, _, _⟩ := applySubst_noop st.subst fuel
  constructor
  · exact h_noop_ty (.function (.cons argTy .nil) retTy) (by
      intro v hv
      simp [freeTypeVars, freeTypeVarsTyList] at hv
      rcases hv with hv | hv
      · exact h_arg_type v hv
      · exact h_ret_type v hv
    ) (by
      intro v hv
      simp [freeRowVars, freeRowVarsTyList] at hv
      rcases hv with hv | hv
      · exact h_arg_row v hv
      · exact h_ret_row v hv
    )
  · exact h_noop_ty (.function (.cons argTy .nil) (.var resVar)) (by
      intro v hv
      simp [freeTypeVars, freeTypeVarsTyList] at hv
      rcases hv with hv | hv
      · exact h_arg_type v hv
      · have hv' : v = resVar := by simpa [freeTypeVars] using hv
        cases hv'
        exact h_res_unbound
    ) (by
      intro v hv
      simp [freeRowVars, freeRowVarsTyList] at hv
      exact h_arg_row v hv
    )

/-- Reusable no-op domain contract for app-branch bridge lemmas. -/
structure AppUnifyNoopDomain (st : UnifyState) (argTy retTy : Ty) (resVar : TypeVarId) : Prop where
  argTypeNone : ∀ v ∈ freeTypeVars argTy, st.subst.typeMap v = none
  argRowNone : ∀ v ∈ freeRowVars argTy, st.subst.rowMap v = none
  retTypeNone : ∀ v ∈ freeTypeVars retTy, st.subst.typeMap v = none
  retRowNone : ∀ v ∈ freeRowVars retTy, st.subst.rowMap v = none
  resUnbound : st.subst.typeMap resVar = none

/-- Type-level freshness invariant: variables at/above `nextTypeVar` are unbound. -/
def TypeVarsAboveNextUnbound (st : UnifyState) : Prop :=
  ∀ v, st.nextTypeVar ≤ v → st.subst.typeMap v = none

/-- Base state satisfies `TypeVarsAboveNextUnbound`. -/
theorem typeVarsAboveNextUnbound_empty : TypeVarsAboveNextUnbound UnifyState.empty := by
  intro v _
  simp [UnifyState.empty, Subst.empty]

/-- Any state with empty substitution satisfies the above-threshold invariant. -/
theorem typeVarsAboveNextUnbound_of_subst_empty
    (st : UnifyState) (h_empty : st.subst = Subst.empty) :
    TypeVarsAboveNextUnbound st := by
  intro v _
  simp [h_empty, Subst.empty]

/-- Raising only `nextTypeVar` preserves the above-threshold unbound invariant. -/
theorem typeVarsAboveNextUnbound_with_nextTypeVar
    (st : UnifyState) (next' : Nat)
    (h_inv : TypeVarsAboveNextUnbound st)
    (h_le : st.nextTypeVar ≤ next') :
    TypeVarsAboveNextUnbound { st with nextTypeVar := next' } := by
  intro v hv
  exact h_inv v (Nat.le_trans h_le hv)

/-- Empty substitution satisfies the app no-op domain contract for all types. -/
theorem appUnifyNoopDomain_of_subst_empty
    (st : UnifyState) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_empty : st.subst = Subst.empty) :
    AppUnifyNoopDomain st argTy retTy resVar := by
  refine ⟨?_, ?_, ?_, ?_, ?_⟩
  · intro v _
    simp [h_empty, Subst.empty]
  · intro v _
    simp [h_empty, Subst.empty]
  · intro v _
    simp [h_empty, Subst.empty]
  · intro v _
    simp [h_empty, Subst.empty]
  · simp [h_empty, Subst.empty]

/--
Lift app no-op domain assumptions back through substitution extension:
if a final substitution extends the current substitution and has no bindings on
the relevant vars, then the current substitution also has none.
-/
theorem appUnifyNoopDomain_of_extends_final_none
    (st stFinal : UnifyState) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_ext : Subst.Extends st.subst stFinal.subst)
    (h_arg_type_final : ∀ v ∈ freeTypeVars argTy, stFinal.subst.typeMap v = none)
    (h_arg_row_final : ∀ v ∈ freeRowVars argTy, stFinal.subst.rowMap v = none)
    (h_ret_type_final : ∀ v ∈ freeTypeVars retTy, stFinal.subst.typeMap v = none)
    (h_ret_row_final : ∀ v ∈ freeRowVars retTy, stFinal.subst.rowMap v = none)
    (h_res_unbound_final : stFinal.subst.typeMap resVar = none) :
    AppUnifyNoopDomain st argTy retTy resVar := by
  refine ⟨?_, ?_, ?_, ?_, ?_⟩
  · intro v hv
    have hnone := h_arg_type_final v hv
    cases hst : st.subst.typeMap v with
    | none => rfl
    | some ty =>
      have hsome : stFinal.subst.typeMap v = some ty := h_ext.typeExt v ty hst
      rw [hsome] at hnone
      contradiction
  · intro v hv
    have hnone := h_arg_row_final v hv
    cases hst : st.subst.rowMap v with
    | none => rfl
    | some r =>
      have hsome : stFinal.subst.rowMap v = some r := h_ext.rowExt v r hst
      rw [hsome] at hnone
      contradiction
  · intro v hv
    have hnone := h_ret_type_final v hv
    cases hst : st.subst.typeMap v with
    | none => rfl
    | some ty =>
      have hsome : stFinal.subst.typeMap v = some ty := h_ext.typeExt v ty hst
      rw [hsome] at hnone
      contradiction
  · intro v hv
    have hnone := h_ret_row_final v hv
    cases hst : st.subst.rowMap v with
    | none => rfl
    | some r =>
      have hsome : stFinal.subst.rowMap v = some r := h_ext.rowExt v r hst
      rw [hsome] at hnone
      contradiction
  · have hnone := h_res_unbound_final
    cases hst : st.subst.typeMap resVar with
    | none => rfl
    | some ty =>
      have hsome : stFinal.subst.typeMap resVar = some ty := h_ext.typeExt resVar ty hst
      rw [hsome] at hnone
      contradiction

/--
Variant of `appUnifyNoopDomain_of_extends_final_none` that does not require
final-state unboundness for `resVar`; the result-variable unboundness is
provided directly for the starting state.
-/
theorem appUnifyNoopDomain_of_extends_final_none_with_res_unbound
    (st stFinal : UnifyState) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_ext : Subst.Extends st.subst stFinal.subst)
    (h_arg_type_final : ∀ v ∈ freeTypeVars argTy, stFinal.subst.typeMap v = none)
    (h_arg_row_final : ∀ v ∈ freeRowVars argTy, stFinal.subst.rowMap v = none)
    (h_ret_type_final : ∀ v ∈ freeTypeVars retTy, stFinal.subst.typeMap v = none)
    (h_ret_row_final : ∀ v ∈ freeRowVars retTy, stFinal.subst.rowMap v = none)
    (h_res_unbound_start : st.subst.typeMap resVar = none) :
    AppUnifyNoopDomain st argTy retTy resVar := by
  refine ⟨?_, ?_, ?_, ?_, h_res_unbound_start⟩
  · intro v hv
    have hnone := h_arg_type_final v hv
    cases hst : st.subst.typeMap v with
    | none => rfl
    | some ty =>
      have hsome : stFinal.subst.typeMap v = some ty := h_ext.typeExt v ty hst
      rw [hsome] at hnone
      contradiction
  · intro v hv
    have hnone := h_arg_row_final v hv
    cases hst : st.subst.rowMap v with
    | none => rfl
    | some r =>
      have hsome : stFinal.subst.rowMap v = some r := h_ext.rowExt v r hst
      rw [hsome] at hnone
      contradiction
  · intro v hv
    have hnone := h_ret_type_final v hv
    cases hst : st.subst.typeMap v with
    | none => rfl
    | some ty =>
      have hsome : stFinal.subst.typeMap v = some ty := h_ext.typeExt v ty hst
      rw [hsome] at hnone
      contradiction
  · intro v hv
    have hnone := h_ret_row_final v hv
    cases hst : st.subst.rowMap v with
    | none => rfl
    | some r =>
      have hsome : stFinal.subst.rowMap v = some r := h_ext.rowExt v r hst
      rw [hsome] at hnone
      contradiction

/-- Unboundness of all vars at/above `nextTypeVar` implies fresh var unbound. -/
theorem freshTypeVar_unbound_of_above_none
    (st : UnifyState)
    (h_above_none : ∀ v, st.nextTypeVar ≤ v → st.subst.typeMap v = none) :
    (st.freshTypeVar).2.subst.typeMap (st.freshTypeVar).1 = none := by
  simp [UnifyState.freshTypeVar]
  exact h_above_none st.nextTypeVar (Nat.le_refl _)

/-- Freshness projection from `TypeVarsAboveNextUnbound`. -/
theorem freshTypeVar_unbound_of_typeVarsAboveNextUnbound
    (st : UnifyState) (h_inv : TypeVarsAboveNextUnbound st) :
    (st.freshTypeVar).2.subst.typeMap (st.freshTypeVar).1 = none :=
  freshTypeVar_unbound_of_above_none st h_inv

/-- `freshTypeVar` preserves `TypeVarsAboveNextUnbound` on the resulting state. -/
theorem typeVarsAboveNextUnbound_after_freshTypeVar
    (st : UnifyState) (h_inv : TypeVarsAboveNextUnbound st) :
    TypeVarsAboveNextUnbound (st.freshTypeVar).2 := by
  simpa [UnifyState.freshTypeVar] using
    typeVarsAboveNextUnbound_with_nextTypeVar st (st.nextTypeVar + 1) h_inv
      (Nat.le_succ _)

/--
Binding a variable strictly below `nextTypeVar` preserves the above-threshold
unbound invariant.
-/
theorem typeVarsAboveNextUnbound_bindTypeVar_lt_next
    (st st' : UnifyState) (v : TypeVarId) (ty : Ty) (fuel : Nat)
    (h_inv : TypeVarsAboveNextUnbound st)
    (h_lt : v < st.nextTypeVar)
    (h_bind : bindTypeVar st v ty fuel = .ok st') :
    TypeVarsAboveNextUnbound st' := by
  unfold bindTypeVar at h_bind
  split at h_bind
  · simp [UnifyResult.ok.injEq] at h_bind
    subst h_bind
    exact h_inv
  · split at h_bind
    · exact absurd h_bind (by intro h'; exact UnifyResult.noConfusion h')
    · simp [UnifyResult.ok.injEq] at h_bind
      subst h_bind
      intro w hw
      have h_old : st.subst.typeMap w = none := h_inv w hw
      have hvw : v ≠ w := Nat.ne_of_lt (Nat.lt_of_lt_of_le h_lt hw)
      have hwv : w ≠ v := hvw.symm
      simpa [Subst.bindType, hwv] using h_old

/--
Specialized preservation step for the app fresh-result-variable shape:
after `freshTypeVar`, any successful `bindTypeVar` on that fresh variable
preserves above-threshold unboundness.
-/
theorem typeVarsAboveNextUnbound_after_bind_fresh
    (st st' : UnifyState) (ty : Ty) (fuel : Nat)
    (h_inv : TypeVarsAboveNextUnbound st)
    (h_bind :
      bindTypeVar (st.freshTypeVar).2 (st.freshTypeVar).1 ty fuel = .ok st') :
    TypeVarsAboveNextUnbound st' := by
  have h_inv_fresh : TypeVarsAboveNextUnbound (st.freshTypeVar).2 :=
    typeVarsAboveNextUnbound_after_freshTypeVar st h_inv
  have h_lt : (st.freshTypeVar).1 < (st.freshTypeVar).2.nextTypeVar := by
    simp [UnifyState.freshTypeVar]
  exact typeVarsAboveNextUnbound_bindTypeVar_lt_next
    (st := (st.freshTypeVar).2) (st' := st') (v := (st.freshTypeVar).1)
    (ty := ty) (fuel := fuel) h_inv_fresh h_lt h_bind

/--
Contract derivation for the common app case where `resVar` is chosen as the
fresh type variable from `st`.
-/
theorem appUnifyNoopDomain_of_extends_final_none_with_freshRes
    (st stFinal : UnifyState) (argTy retTy : Ty)
    (h_ext : Subst.Extends st.subst stFinal.subst)
    (h_arg_type_final : ∀ v ∈ freeTypeVars argTy, stFinal.subst.typeMap v = none)
    (h_arg_row_final : ∀ v ∈ freeRowVars argTy, stFinal.subst.rowMap v = none)
    (h_ret_type_final : ∀ v ∈ freeTypeVars retTy, stFinal.subst.typeMap v = none)
    (h_ret_row_final : ∀ v ∈ freeRowVars retTy, stFinal.subst.rowMap v = none)
    (h_inv : TypeVarsAboveNextUnbound st) :
    AppUnifyNoopDomain st argTy retTy (st.freshTypeVar).1 := by
  have h_res_unbound_start : st.subst.typeMap (st.freshTypeVar).1 = none := by
    simpa [UnifyState.freshTypeVar] using h_inv st.nextTypeVar (Nat.le_refl _)
  exact appUnifyNoopDomain_of_extends_final_none_with_res_unbound
    st stFinal argTy retTy (st.freshTypeVar).1
    h_ext h_arg_type_final h_arg_row_final h_ret_type_final h_ret_row_final h_res_unbound_start

/--
If argument/return types are closed (no free type/row vars), app no-op domain
reduces to unboundness of the result variable in the starting substitution.
-/
theorem appUnifyNoopDomain_of_closed_types
    (st : UnifyState) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = [])
    (h_res_unbound : st.subst.typeMap resVar = none) :
    AppUnifyNoopDomain st argTy retTy resVar := by
  refine ⟨?_, ?_, ?_, ?_, h_res_unbound⟩
  · intro v hv
    rw [h_arg_ftv] at hv
    cases hv
  · intro v hv
    rw [h_arg_frv] at hv
    cases hv
  · intro v hv
    rw [h_ret_ftv] at hv
    cases hv
  · intro v hv
    rw [h_ret_frv] at hv
    cases hv

/--
Convenience contract for app branches with fresh result variable and closed
argument/return types under the above-`nextTypeVar` unbound invariant.
-/
theorem appUnifyNoopDomain_of_closed_types_with_freshRes
    (st : UnifyState) (argTy retTy : Ty)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = [])
    (h_inv : TypeVarsAboveNextUnbound st) :
    AppUnifyNoopDomain st argTy retTy (st.freshTypeVar).1 := by
  have h_res_unbound : st.subst.typeMap (st.freshTypeVar).1 = none :=
    freshTypeVar_unbound_of_typeVarsAboveNextUnbound st h_inv
  exact appUnifyNoopDomain_of_closed_types st argTy retTy (st.freshTypeVar).1
    h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_res_unbound

/--
Empty-substitution specialization of `appUnifyNoopDomain_of_closed_types_with_freshRes`.
-/
theorem appUnifyNoopDomain_of_closed_types_with_freshRes_of_subst_empty
    (st : UnifyState) (argTy retTy : Ty)
    (h_empty : st.subst = Subst.empty)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = []) :
    AppUnifyNoopDomain st argTy retTy (st.freshTypeVar).1 := by
  have h_inv : TypeVarsAboveNextUnbound st :=
    typeVarsAboveNextUnbound_of_subst_empty st h_empty
  exact appUnifyNoopDomain_of_closed_types_with_freshRes
    st argTy retTy h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv

/-- A closed type (no free type vars) cannot be a type variable. -/
theorem closed_type_not_var
    (ty : Ty) (h_closed : freeTypeVars ty = []) :
    ∀ v, ty ≠ .var v := by
  intro v h_eq
  rw [h_eq, freeTypeVars] at h_closed
  simp at h_closed

/-- Closed types are fixed points of `applySubstCompat` at any fuel. -/
theorem applySubstCompat_closed
    (s : Subst) (fuel : Nat) (ty : Ty)
    (h_ftv : freeTypeVars ty = [])
    (h_frv : freeRowVars ty = []) :
    applySubstCompat s fuel ty = ty := by
  obtain ⟨h_noop_ty, _, _, _⟩ := applySubst_noop s fuel
  have h_type_none : ∀ v ∈ freeTypeVars ty, s.typeMap v = none := by
    intro v hv
    have : False := by simp [h_ftv] at hv
    exact False.elim this
  have h_row_none : ∀ rv ∈ freeRowVars ty, s.rowMap rv = none := by
    intro rv hv
    have : False := by simp [h_frv] at hv
    exact False.elim this
  simpa using h_noop_ty ty h_type_none h_row_none

/-- Contract wrapper for `app_unify_resolved_heads_of_noop_domain`. -/
theorem app_unify_resolved_heads_of_contract
    (st : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_dom : AppUnifyNoopDomain st argTy retTy resVar) :
    applySubstCompat st.subst fuel (.function (.cons argTy .nil) retTy) =
      .function (.cons argTy .nil) retTy
    ∧
    applySubstCompat st.subst fuel (.function (.cons argTy .nil) (.var resVar)) =
      .function (.cons argTy .nil) (.var resVar) :=
  app_unify_resolved_heads_of_noop_domain st fuel argTy retTy resVar
    h_dom.argTypeNone h_dom.argRowNone h_dom.retTypeNone h_dom.retRowNone h_dom.resUnbound

/--
Success decomposition variant that discharges resolved-head assumptions from
no-op domain conditions.
-/
theorem app_unify_function_shape_witness_of_success_noop_domain
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_arg_type : ∀ v ∈ freeTypeVars argTy, st.subst.typeMap v = none)
    (h_arg_row : ∀ v ∈ freeRowVars argTy, st.subst.rowMap v = none)
    (h_ret_type : ∀ v ∈ freeTypeVars retTy, st.subst.typeMap v = none)
    (h_ret_row : ∀ v ∈ freeRowVars retTy, st.subst.rowMap v = none)
    (h_res_unbound : st.subst.typeMap resVar = none)
    (h_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false)
    (h_unify :
      unify st (fuel + 1) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter) :
    ∃ stTail,
      unifyTyList st fuel (.cons argTy .nil) (.cons argTy .nil) = .ok stTail ∧
      unify stTail fuel retTy (.var resVar) = .ok stAfter := by
  have h_heads := app_unify_resolved_heads_of_noop_domain
    st fuel argTy retTy resVar h_arg_type h_arg_row h_ret_type h_ret_row h_res_unbound
  rcases h_heads with ⟨h_head_l, h_head_r⟩
  have h_beq :
      (applySubstCompat st.subst fuel (.function (.cons argTy .nil) retTy)
        == applySubstCompat st.subst fuel (.function (.cons argTy .nil) (.var resVar))) = false := by
    simpa [h_head_l, h_head_r] using h_beq_raw
  exact app_unify_function_shape_witness_of_success_resolved_heads
    st stAfter fuel argTy retTy resVar h_head_l h_head_r h_beq h_unify

/-- Contract wrapper for `app_unify_function_shape_witness_of_success_noop_domain`. -/
theorem app_unify_function_shape_witness_of_success_contract
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_dom : AppUnifyNoopDomain st argTy retTy resVar)
    (h_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false)
    (h_unify :
      unify st (fuel + 1) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter) :
    ∃ stTail,
      unifyTyList st fuel (.cons argTy .nil) (.cons argTy .nil) = .ok stTail ∧
      unify stTail fuel retTy (.var resVar) = .ok stAfter :=
  app_unify_function_shape_witness_of_success_noop_domain
    st stAfter fuel argTy retTy resVar
    h_dom.argTypeNone h_dom.argRowNone h_dom.retTypeNone h_dom.retRowNone h_dom.resUnbound
    h_beq_raw h_unify

/--
If singleton-parameter list unification succeeds against itself, the resulting
state is unchanged.
-/
theorem unifyTyList_singleton_self_success_state_eq
    (st stTail : UnifyState) (fuel : Nat) (argTy : Ty)
    (h_params :
      unifyTyList st fuel (.cons argTy .nil) (.cons argTy .nil) = .ok stTail) :
    stTail = st := by
  cases fuel with
  | zero =>
    simp [unifyTyList] at h_params
  | succ fuel' =>
    simp [unifyTyList] at h_params
    cases h_unify : unify st fuel' argTy argTy with
    | err e =>
      simp [h_unify] at h_params
    | ok stMid =>
      cases fuel' with
      | zero =>
        simp [h_unify, unifyTyList] at h_params
      | succ fuel'' =>
        simp [h_unify, unifyTyList] at h_params
        have h_refl : unify st (fuel'' + 1) argTy argTy = .ok st := by
          simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
            (unifyReflexive' st fuel'' argTy)
        rw [h_unify] at h_refl
        cases h_refl
        simpa using h_params.symm

/-- Closed singleton type-lists are fixed points of substitution at any fuel. -/
theorem applySubstTyList_nil (s : Subst) (fuel : Nat) :
    applySubstTyList s fuel .nil = .nil := by
  cases fuel with
  | zero =>
    simp [applySubstTyList]
  | succ fuel' =>
    simp [applySubstTyList]

/-- Closed singleton type-lists are fixed points of substitution at any fuel. -/
theorem applySubstTyList_singleton_closed
    (s : Subst) (fuel : Nat) (ty : Ty)
    (h_ftv : freeTypeVars ty = [])
    (h_frv : freeRowVars ty = []) :
    applySubstTyList s fuel (.cons ty .nil) = .cons ty .nil := by
  cases fuel with
  | zero =>
    simp [applySubstTyList]
  | succ fuel' =>
    have h_closed : applySubst s fuel' ty = ty := by
      simpa [applySubstCompat] using
        (applySubstCompat_closed s fuel' ty h_ftv h_frv)
    simp [applySubstTyList, applySubstTyList_nil, h_closed]

/-- For equal single-parameter function heads, BEq-false implies tail BEq-false. -/
theorem app_function_beq_false_implies_tail_beq_false
    (argTy retTy : Ty) (resVar : TypeVarId)
    (h_fn_beq :
      ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false) :
    (retTy == .var resVar) = false := by
  have h_params_refl : (beqTyList (.cons argTy .nil) (.cons argTy .nil)) = true := by
    simpa using beqTyList_refl (.cons argTy .nil)
  cases h_tail : (retTy == .var resVar) with
  | false =>
    rfl
  | true =>
    have h_tail' : beqTy retTy (.var resVar) = true := by
      simpa [BEq.beq] using h_tail
    have h_fn_true :
        ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = true := by
      simp [BEq.beq, beqTy, h_params_refl, h_tail']
    rw [h_fn_true] at h_fn_beq
    contradiction

/-- If return type is not a variable, app-function BEq is false. -/
theorem app_function_beq_false_of_not_var
    (argTy retTy : Ty) (resVar : TypeVarId)
    (h_not_var : ∀ v, retTy ≠ .var v) :
    ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false := by
  have h_params_refl : (beqTyList (.cons argTy .nil) (.cons argTy .nil)) = true := by
    simpa using beqTyList_refl (.cons argTy .nil)
  cases retTy with
  | var v =>
    exfalso
    exact h_not_var v rfl
  | int | intN _ _ | float | floatN _ | decimal _ _ | bool | string | html | markdown | atom | date | dateTime | unit | dynamic
    | list _ | map _ _ | set _ | option _ | result _ _ | existential _ _ | fixedSizeList _ _ | tensor _ _ | sum _ _ | «opaque» _ _
    | function _ _ | functionEff _ _ _ | «forall» _ _ | app _ _ | constructor _ _ _ | record _ _ | anonRecord _ | dataframe _ | groupedFrame _ _ | tagged _ _ | column _ | stream _ | task _ | actor _ | arc _
    | row _ | tuple _ =>
      simp [BEq.beq, beqTy, h_params_refl]

/--
Bridge from raw app unification success to result-variable equality: if the
function/function branch heads are resolved, BEq fast-path is excluded, and the
tail `unify` success can be reinterpreted as a `bindTypeVar` success, then the
idempotent equality premise follows.
-/
theorem app_unify_result_eq_of_unify_success_resolved_heads_tail_bind_idempotent
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_head_l :
      applySubstCompat st.subst fuel (.function (.cons argTy .nil) retTy) =
        .function (.cons argTy .nil) retTy)
    (h_head_r :
      applySubstCompat st.subst fuel (.function (.cons argTy .nil) (.var resVar)) =
        .function (.cons argTy .nil) (.var resVar))
    (h_beq :
      (applySubstCompat st.subst fuel (.function (.cons argTy .nil) retTy)
        == applySubstCompat st.subst fuel (.function (.cons argTy .nil) (.var resVar))) = false)
    (h_unify :
      unify st (fuel + 1) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_tail_to_bind :
      ∀ stTail,
        unify stTail fuel retTy (.var resVar) = .ok stAfter →
        bindTypeVar stTail resVar retTy fuel = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubst stAfter.subst (fuel + 1) (.var resVar) =
      applySubst stAfter.subst (fuel + 1) retTy := by
  rcases app_unify_function_shape_witness_of_success_resolved_heads
      st stAfter fuel argTy retTy resVar h_head_l h_head_r h_beq h_unify with
    ⟨stTail, h_params, h_tail_unify⟩
  have h_tail_bind : bindTypeVar stTail resVar retTy fuel = .ok stAfter :=
    h_tail_to_bind stTail h_tail_unify
  exact app_unify_result_eq_of_function_tail_bind_idempotent
    st stTail stAfter fuel argTy retTy resVar h_params h_tail_bind h_idemp

/--
Tail-branch contract: when tail unification is run at successor fuel with
resolved heads and BEq fast-path excluded, success is exactly a `bindTypeVar`
success on the result variable.
-/
theorem tail_unify_to_bindTypeVar_of_success_resolved_heads_nonbeq
    (st stAfter : UnifyState) (fuel : Nat) (retTy : Ty) (resVar : TypeVarId)
    (h_not_var : ∀ v, retTy ≠ .var v)
    (h_head_l : applySubstCompat st.subst fuel retTy = retTy)
    (h_head_r : applySubstCompat st.subst fuel (.var resVar) = .var resVar)
    (h_beq :
      (applySubstCompat st.subst fuel retTy
        == applySubstCompat st.subst fuel (.var resVar)) = false)
    (h_unify : unify st (fuel + 1) retTy (.var resVar) = .ok stAfter) :
    bindTypeVar st resVar retTy fuel = .ok stAfter := by
  have h_beq' : (retTy == .var resVar) = false := by
    simpa [h_head_l, h_head_r] using h_beq
  cases retTy with
  | var v =>
    exfalso
    exact h_not_var v rfl
  | int | intN _ _ | float | floatN _ | decimal _ _ | bool | string | html | markdown | atom | date | dateTime | unit | dynamic
    | list _ | map _ _ | set _ | option _ | result _ _ | existential _ _ | fixedSizeList _ _ | tensor _ _ | sum _ _ | «opaque» _ _
    | function _ _ | functionEff _ _ _ | «forall» _ _ | app _ _ | constructor _ _ _ | record _ _ | anonRecord _ | dataframe _ | groupedFrame _ _ | tagged _ _ | column _ | stream _ | task _ | actor _ | arc _
    | row _ | tuple _ =>
      simpa [unify, h_head_l, h_head_r, h_beq'] using h_unify

/--
Tail-branch equality contract without return-shape restriction: under resolved
heads + non-BEq, successful tail unification yields the result-variable
equality directly (using idempotence in the variable-head case).
-/
theorem tail_unify_result_eq_of_success_resolved_heads_nonbeq_idempotent
    (st stAfter : UnifyState) (fuel : Nat) (retTy : Ty) (resVar : TypeVarId)
    (h_head_l : applySubstCompat st.subst fuel retTy = retTy)
    (h_head_r : applySubstCompat st.subst fuel (.var resVar) = .var resVar)
    (h_beq :
      (applySubstCompat st.subst fuel retTy
        == applySubstCompat st.subst fuel (.var resVar)) = false)
    (h_unify : unify st (fuel + 1) retTy (.var resVar) = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubst stAfter.subst (fuel + 1) (.var resVar) =
      applySubst stAfter.subst (fuel + 1) retTy := by
  by_cases hvar : ∃ v, retTy = .var v
  · rcases hvar with ⟨v, rfl⟩
    have h_beq' : ((.var v : Ty) == (.var resVar : Ty)) = false := by
      simpa [h_head_l, h_head_r] using h_beq
    have h_bind : bindTypeVar st v (.var resVar) fuel = .ok stAfter := by
      simpa [unify, h_head_l, h_head_r, h_beq'] using h_unify
    have h_eq :=
      bindTypeVarConsistentIdempotent st v (.var resVar) fuel stAfter h_bind h_idemp
    simpa using h_eq.symm
  · have h_not_var : ∀ v, retTy ≠ .var v := by
      intro v hv
      exact hvar ⟨v, hv⟩
    have h_bind : bindTypeVar st resVar retTy fuel = .ok stAfter :=
      tail_unify_to_bindTypeVar_of_success_resolved_heads_nonbeq
        st stAfter fuel retTy resVar h_not_var h_head_l h_head_r h_beq h_unify
    exact app_unify_result_eq_of_bindTypeVar_idempotent
      st fuel retTy resVar stAfter h_bind h_idemp

/--
Shifted app bridge: with an outer app unification run at `fuel + 2`, no-op
domains and tail non-BEq/non-variable assumptions are enough to recover the
result-variable equality at `fuel + 1`.
-/
theorem app_unify_result_eq_of_unify_success_noop_domain_tail_nonbeq_idempotent_succ
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_arg_type : ∀ v ∈ freeTypeVars argTy, st.subst.typeMap v = none)
    (h_arg_row : ∀ v ∈ freeRowVars argTy, st.subst.rowMap v = none)
    (h_ret_type : ∀ v ∈ freeTypeVars retTy, st.subst.typeMap v = none)
    (h_ret_row : ∀ v ∈ freeRowVars retTy, st.subst.rowMap v = none)
    (h_res_unbound : st.subst.typeMap resVar = none)
    (h_fn_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false)
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubst stAfter.subst (fuel + 1) (.var resVar) =
      applySubst stAfter.subst (fuel + 1) retTy := by
  rcases app_unify_function_shape_witness_of_success_noop_domain
      st stAfter (fuel + 1) argTy retTy resVar
      h_arg_type h_arg_row h_ret_type h_ret_row h_res_unbound
      h_fn_beq_raw h_unify with
    ⟨stTail, h_params, h_tail_unify⟩
  have h_tail_eq : stTail = st :=
    unifyTyList_singleton_self_success_state_eq st stTail (fuel + 1) argTy h_params
  have h_tail_unify_st : unify st (fuel + 1) retTy (.var resVar) = .ok stAfter := by
    simpa [h_tail_eq] using h_tail_unify
  have h_head_l_tail : applySubstCompat st.subst fuel retTy = retTy := by
    obtain ⟨h_noop_ty, _, _, _⟩ := applySubst_noop st.subst fuel
    exact h_noop_ty retTy h_ret_type h_ret_row
  have h_head_r_tail : applySubstCompat st.subst fuel (.var resVar) = .var resVar := by
    cases fuel with
    | zero =>
      simp [applySubstCompat, applySubst]
    | succ fuel' =>
      simp [applySubstCompat, applySubst, h_res_unbound]
  have h_tail_beq :
      (applySubstCompat st.subst fuel retTy == applySubstCompat st.subst fuel (.var resVar)) = false := by
      have h_tail_beq_raw : (retTy == .var resVar) = false :=
        app_function_beq_false_implies_tail_beq_false argTy retTy resVar h_fn_beq_raw
      simpa [h_head_l_tail, h_head_r_tail] using h_tail_beq_raw
  exact tail_unify_result_eq_of_success_resolved_heads_nonbeq_idempotent
    st stAfter fuel retTy resVar h_head_l_tail h_head_r_tail h_tail_beq h_tail_unify_st h_idemp

/-- Contract wrapper for shifted app equality bridge. -/
theorem app_unify_result_eq_of_unify_success_contract_succ
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_dom : AppUnifyNoopDomain st argTy retTy resVar)
    (h_fn_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false)
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubst stAfter.subst (fuel + 1) (.var resVar) =
      applySubst stAfter.subst (fuel + 1) retTy :=
  app_unify_result_eq_of_unify_success_noop_domain_tail_nonbeq_idempotent_succ
    st stAfter fuel argTy retTy resVar
    h_dom.argTypeNone h_dom.argRowNone h_dom.retTypeNone h_dom.retRowNone h_dom.resUnbound
    h_fn_beq_raw h_unify h_idemp

/--
Shifted app bridge to tail binding only: from outer app-unify success at
`fuel+2`, no-op domain + tail non-BEq/non-variable assumptions recover the
tail `bindTypeVar` success at fuel.
-/
theorem app_unify_tail_bind_of_success_noop_domain_tail_nonbeq_succ
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_arg_type : ∀ v ∈ freeTypeVars argTy, st.subst.typeMap v = none)
    (h_arg_row : ∀ v ∈ freeRowVars argTy, st.subst.rowMap v = none)
    (h_ret_type : ∀ v ∈ freeTypeVars retTy, st.subst.typeMap v = none)
    (h_ret_row : ∀ v ∈ freeRowVars retTy, st.subst.rowMap v = none)
    (h_res_unbound : st.subst.typeMap resVar = none)
    (h_fn_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false)
    (h_not_var : ∀ v, retTy ≠ .var v)
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter) :
    bindTypeVar st resVar retTy fuel = .ok stAfter := by
  rcases app_unify_function_shape_witness_of_success_noop_domain
      st stAfter (fuel + 1) argTy retTy resVar
      h_arg_type h_arg_row h_ret_type h_ret_row h_res_unbound
      h_fn_beq_raw h_unify with
    ⟨stTail, h_params, h_tail_unify⟩
  have h_tail_eq : stTail = st :=
    unifyTyList_singleton_self_success_state_eq st stTail (fuel + 1) argTy h_params
  have h_tail_unify_st : unify st (fuel + 1) retTy (.var resVar) = .ok stAfter := by
    simpa [h_tail_eq] using h_tail_unify
  have h_head_l_tail : applySubstCompat st.subst fuel retTy = retTy := by
    obtain ⟨h_noop_ty, _, _, _⟩ := applySubst_noop st.subst fuel
    exact h_noop_ty retTy h_ret_type h_ret_row
  have h_head_r_tail : applySubstCompat st.subst fuel (.var resVar) = .var resVar := by
    cases fuel with
    | zero =>
      simp [applySubstCompat, applySubst]
    | succ fuel' =>
      simp [applySubstCompat, applySubst, h_res_unbound]
  have h_tail_beq :
      (applySubstCompat st.subst fuel retTy == applySubstCompat st.subst fuel (.var resVar)) = false := by
    have h_tail_beq_raw : (retTy == .var resVar) = false :=
      app_function_beq_false_implies_tail_beq_false argTy retTy resVar h_fn_beq_raw
    simpa [h_head_l_tail, h_head_r_tail] using h_tail_beq_raw
  exact tail_unify_to_bindTypeVar_of_success_resolved_heads_nonbeq
    st stAfter fuel retTy resVar h_not_var h_head_l_tail h_head_r_tail h_tail_beq h_tail_unify_st

/-- Contract wrapper for shifted app tail-bind bridge. -/
theorem app_unify_tail_bind_of_success_contract_succ
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_dom : AppUnifyNoopDomain st argTy retTy resVar)
    (h_fn_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false)
    (h_not_var : ∀ v, retTy ≠ .var v)
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter) :
    bindTypeVar st resVar retTy fuel = .ok stAfter :=
  app_unify_tail_bind_of_success_noop_domain_tail_nonbeq_succ
    st stAfter fuel argTy retTy resVar
    h_dom.argTypeNone h_dom.argRowNone h_dom.retTypeNone h_dom.retRowNone h_dom.resUnbound
    h_fn_beq_raw h_not_var h_unify

/--
App-tail-bind success preserves the above-threshold unbound invariant when the
bound result variable is known to be below `nextTypeVar`.
-/
theorem typeVarsAboveNextUnbound_after_app_unify_tail_bind_contract_succ
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_inv : TypeVarsAboveNextUnbound st)
    (h_lt : resVar < st.nextTypeVar)
    (h_dom : AppUnifyNoopDomain st argTy retTy resVar)
    (h_fn_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false)
    (h_not_var : ∀ v, retTy ≠ .var v)
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter) :
    TypeVarsAboveNextUnbound stAfter := by
  have h_bind :
      bindTypeVar st resVar retTy fuel = .ok stAfter :=
    app_unify_tail_bind_of_success_contract_succ
      st stAfter fuel argTy retTy resVar h_dom h_fn_beq_raw h_not_var h_unify
  exact typeVarsAboveNextUnbound_bindTypeVar_lt_next
    st stAfter resVar retTy fuel h_inv h_lt h_bind

/--
Fresh-result specialization of invariant transport across the app tail-bind
contract: after one `freshTypeVar` step, the contract result preserves the
above-threshold unbound invariant.
-/
theorem typeVarsAboveNextUnbound_after_app_unify_tail_bind_contract_succ_fresh
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty)
    (h_inv : TypeVarsAboveNextUnbound st)
    (h_dom : AppUnifyNoopDomain (st.freshTypeVar).2 argTy retTy (st.freshTypeVar).1)
    (h_fn_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) ==
        (Ty.function (.cons argTy .nil) (.var (st.freshTypeVar).1))) = false)
    (h_not_var : ∀ v, retTy ≠ .var v)
    (h_unify :
      unify (st.freshTypeVar).2 (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter) :
    TypeVarsAboveNextUnbound stAfter := by
  have h_inv_fresh : TypeVarsAboveNextUnbound (st.freshTypeVar).2 :=
    typeVarsAboveNextUnbound_after_freshTypeVar st h_inv
  have h_lt_fresh : (st.freshTypeVar).1 < (st.freshTypeVar).2.nextTypeVar := by
    simp [UnifyState.freshTypeVar]
  exact typeVarsAboveNextUnbound_after_app_unify_tail_bind_contract_succ
    (st := (st.freshTypeVar).2) (stAfter := stAfter) (fuel := fuel)
    (argTy := argTy) (retTy := retTy) (resVar := (st.freshTypeVar).1)
    h_inv_fresh h_lt_fresh h_dom h_fn_beq_raw h_not_var h_unify

/--
Shifted app tail-bind bridge specialized to closed arg/ret types and fresh
result variable under the above-`nextTypeVar` invariant.
-/
theorem app_unify_tail_bind_of_success_closed_fresh_succ
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = [])
    (h_inv : TypeVarsAboveNextUnbound st)
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter) :
    bindTypeVar st (st.freshTypeVar).1 retTy fuel = .ok stAfter := by
  let h_dom : AppUnifyNoopDomain st argTy retTy (st.freshTypeVar).1 :=
    appUnifyNoopDomain_of_closed_types_with_freshRes
      st argTy retTy h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv
  have h_not_var : ∀ v, retTy ≠ .var v := closed_type_not_var retTy h_ret_ftv
  have h_fn_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) ==
        (Ty.function (.cons argTy .nil) (.var (st.freshTypeVar).1))) = false :=
    app_function_beq_false_of_not_var argTy retTy (st.freshTypeVar).1 h_not_var
  exact app_unify_tail_bind_of_success_contract_succ
    st stAfter fuel argTy retTy (st.freshTypeVar).1 h_dom h_fn_beq_raw h_not_var h_unify

/--
Empty-substitution specialization of the closed+fresh shifted app tail-bind
bridge.
-/
theorem app_unify_tail_bind_of_success_closed_fresh_succ_of_subst_empty
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty)
    (h_empty : st.subst = Subst.empty)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = [])
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter) :
    bindTypeVar st (st.freshTypeVar).1 retTy fuel = .ok stAfter := by
  have h_inv : TypeVarsAboveNextUnbound st :=
    typeVarsAboveNextUnbound_of_subst_empty st h_empty
  exact app_unify_tail_bind_of_success_closed_fresh_succ
    st stAfter fuel argTy retTy
    h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv h_unify

/--
Shifted app equality bridge specialized to closed arg/ret types and fresh
result variable under the above-`nextTypeVar` invariant.
-/
theorem app_unify_result_eq_of_success_closed_fresh_succ
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = [])
    (h_inv : TypeVarsAboveNextUnbound st)
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubst stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1) =
      applySubst stAfter.subst (fuel + 1) retTy := by
  let h_dom : AppUnifyNoopDomain st argTy retTy (st.freshTypeVar).1 :=
    appUnifyNoopDomain_of_closed_types_with_freshRes
      st argTy retTy h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv
  have h_not_var : ∀ v, retTy ≠ .var v := closed_type_not_var retTy h_ret_ftv
  have h_fn_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) ==
        (Ty.function (.cons argTy .nil) (.var (st.freshTypeVar).1))) = false :=
    app_function_beq_false_of_not_var argTy retTy (st.freshTypeVar).1 h_not_var
  exact app_unify_result_eq_of_unify_success_contract_succ
    st stAfter fuel argTy retTy (st.freshTypeVar).1 h_dom h_fn_beq_raw h_unify h_idemp

/--
Empty-substitution specialization of the closed+fresh shifted app result-eq
bridge.
-/
theorem app_unify_result_eq_of_success_closed_fresh_succ_of_subst_empty
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty)
    (h_empty : st.subst = Subst.empty)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = [])
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubst stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1) =
      applySubst stAfter.subst (fuel + 1) retTy := by
  have h_inv : TypeVarsAboveNextUnbound st :=
    typeVarsAboveNextUnbound_of_subst_empty st h_empty
  exact app_unify_result_eq_of_success_closed_fresh_succ
    st stAfter fuel argTy retTy
    h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv h_unify h_idemp

/--
Closed-type app bridge in `HasTypeU`: when app unification succeeds against a
fresh result variable and the shifted result-equality contract holds, app
typing follows end-to-end without additional hooks.
-/
theorem app_unify_resolved_fn_shape_of_success_closed_fresh_succ
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = [])
    (h_inv : TypeVarsAboveNextUnbound st)
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubstCompat stAfter.subst (fuel + 1) (.function (.cons argTy .nil) retTy) =
      .function
        (.cons (applySubstCompat stAfter.subst fuel argTy) .nil)
        (applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1)) := by
  have h_res_eq :
      applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1) =
        applySubstCompat stAfter.subst (fuel + 1) retTy :=
    app_unify_result_eq_of_success_closed_fresh_succ
      st stAfter fuel argTy retTy h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv h_unify h_idemp
  have h_ret_closed_fuel :
      applySubstCompat stAfter.subst fuel retTy = retTy :=
    applySubstCompat_closed stAfter.subst fuel retTy h_ret_ftv h_ret_frv
  have h_ret_closed_succ :
      applySubstCompat stAfter.subst (fuel + 1) retTy = retTy :=
    applySubstCompat_closed stAfter.subst (fuel + 1) retTy h_ret_ftv h_ret_frv
  have h_arg_closed :
      applySubstCompat stAfter.subst fuel argTy = argTy :=
    applySubstCompat_closed stAfter.subst fuel argTy h_arg_ftv h_arg_frv
  have h_resolved_ret :
      applySubstCompat stAfter.subst fuel retTy =
        applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1) := by
    calc
      applySubstCompat stAfter.subst fuel retTy = retTy := h_ret_closed_fuel
      _ = applySubstCompat stAfter.subst (fuel + 1) retTy := by
        symm
        exact h_ret_closed_succ
      _ = applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1) := by
        symm
        exact h_res_eq
  simp [applySubstCompat, applySubst, applySubstTyList_singleton_closed,
    h_arg_ftv, h_arg_frv, h_arg_closed, h_resolved_ret]

/--
Empty-substitution specialization of the closed+fresh successor-fuel app
resolved-shape bridge.
-/
theorem app_unify_resolved_fn_shape_of_success_closed_fresh_succ_of_subst_empty
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty)
    (h_empty : st.subst = Subst.empty)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = [])
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubstCompat stAfter.subst (fuel + 1) (.function (.cons argTy .nil) retTy) =
      .function
        (.cons (applySubstCompat stAfter.subst fuel argTy) .nil)
        (applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1)) := by
  have h_inv : TypeVarsAboveNextUnbound st :=
    typeVarsAboveNextUnbound_of_subst_empty st h_empty
  exact app_unify_resolved_fn_shape_of_success_closed_fresh_succ
    st stAfter fuel argTy retTy
    h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv h_unify h_idemp

/--
Packaged closed+fresh successor-fuel app resolved-shape premise.
This is the directly proved app-side premise fragment currently available for
resolved-shape-driven recursion in `HasTypeU`.
-/
def AppResolvedShapeFromUnifyClosedFreshSucc : Prop :=
  ∀ st stAfter fuel argTy retTy,
    freeTypeVars argTy = [] →
    freeRowVars argTy = [] →
    freeTypeVars retTy = [] →
    freeRowVars retTy = [] →
    TypeVarsAboveNextUnbound st →
    unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter →
    stAfter.subst.Idempotent →
    applySubstCompat stAfter.subst (fuel + 1) (.function (.cons argTy .nil) retTy) =
      .function
        (.cons (applySubstCompat stAfter.subst fuel argTy) .nil)
        (applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1))

/-- Closed+fresh successor-fuel app resolved-shape premise is provable. -/
theorem appResolvedShapeFromUnifyClosedFreshSucc_proved :
    AppResolvedShapeFromUnifyClosedFreshSucc := by
  intro st stAfter fuel argTy retTy h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv h_unify h_idemp
  exact app_unify_resolved_fn_shape_of_success_closed_fresh_succ
    st stAfter fuel argTy retTy h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv h_unify h_idemp

/--
Closed-type app bridge in `HasTypeU`: when app unification succeeds against a
fresh result variable and the shifted result-equality contract holds, app
typing follows end-to-end without additional hooks.
-/
theorem inferExprUnify_app_step_sound_hasTypeU_closed_fresh_succ
    {env : TermEnv} {fn arg : CoreExpr} {argTy retTy : Ty}
    {st stAfter : UnifyState} {fuel : Nat}
    (h_fn : HasTypeU env fn (.function (.cons argTy .nil) retTy))
    (h_arg : HasTypeU env arg argTy)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = [])
    (h_inv : TypeVarsAboveNextUnbound st)
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    HasTypeU env (.app fn arg) (applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1)) := by
  have h_resolved :
      applySubstCompat stAfter.subst (fuel + 1) (.function (.cons argTy .nil) retTy) =
        .function
          (.cons (applySubstCompat stAfter.subst fuel argTy) .nil)
          (applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1)) :=
    app_unify_resolved_fn_shape_of_success_closed_fresh_succ
      st stAfter fuel argTy retTy
      h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv h_unify h_idemp
  have h_fn_resolved :
      HasTypeU env fn
        (applySubstCompat stAfter.subst (fuel + 1) (.function (.cons argTy .nil) retTy)) :=
    HasTypeU.subst env fn (.function (.cons argTy .nil) retTy) stAfter.subst (fuel + 1) h_fn
  have h_arg_resolved :
      HasTypeU env arg (applySubstCompat stAfter.subst fuel argTy) :=
    HasTypeU.subst env arg argTy stAfter.subst fuel h_arg
  rw [h_resolved] at h_fn_resolved
  exact HasTypeU.app env fn arg
    (applySubstCompat stAfter.subst fuel argTy)
    (applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1))
    h_fn_resolved h_arg_resolved

/--
Empty-substitution specialization of the closed+fresh successor-fuel app step
soundness theorem in `HasTypeU`.
-/
theorem inferExprUnify_app_step_sound_hasTypeU_closed_fresh_succ_of_subst_empty
    {env : TermEnv} {fn arg : CoreExpr} {argTy retTy : Ty}
    {st stAfter : UnifyState} {fuel : Nat}
    (h_empty : st.subst = Subst.empty)
    (h_fn : HasTypeU env fn (.function (.cons argTy .nil) retTy))
    (h_arg : HasTypeU env arg argTy)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = [])
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    HasTypeU env (.app fn arg) (applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1)) := by
  have h_inv : TypeVarsAboveNextUnbound st :=
    typeVarsAboveNextUnbound_of_subst_empty st h_empty
  exact inferExprUnify_app_step_sound_hasTypeU_closed_fresh_succ
    h_fn h_arg h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv h_unify h_idemp

/--
Specialized `HasTypeU` app-hook fragment for the closed+fresh successor-fuel
regime where the app-side resolved-shape bridge is fully discharged.
-/
def AppUnifySoundHookUClosedFreshSucc : Prop :=
  ∀ env fn arg st stAfter fuel argTy retTy,
    HasTypeU env fn (.function (.cons argTy .nil) retTy) →
    HasTypeU env arg argTy →
    freeTypeVars argTy = [] →
    freeRowVars argTy = [] →
    freeTypeVars retTy = [] →
    freeRowVars retTy = [] →
    TypeVarsAboveNextUnbound st →
    unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter →
    stAfter.subst.Idempotent →
    HasTypeU env (.app fn arg) (applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1))

/-- Closed+fresh successor-fuel app-hook fragment is provable. -/
theorem appUnifySoundHookUClosedFreshSucc_proved :
    AppUnifySoundHookUClosedFreshSucc := by
  intro env fn arg st stAfter fuel argTy retTy
    h_fn h_arg h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv h_unify h_idemp
  exact inferExprUnify_app_step_sound_hasTypeU_closed_fresh_succ
    h_fn h_arg h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_inv h_unify h_idemp

/--
Empty-substitution specialization of the closed+fresh successor-fuel app-hook
fragment in `HasTypeU`.
-/
def AppUnifySoundHookUClosedFreshSuccEmptySubst : Prop :=
  ∀ env fn arg st stAfter fuel argTy retTy,
    st.subst = Subst.empty →
    HasTypeU env fn (.function (.cons argTy .nil) retTy) →
    HasTypeU env arg argTy →
    freeTypeVars argTy = [] →
    freeRowVars argTy = [] →
    freeTypeVars retTy = [] →
    freeRowVars retTy = [] →
    unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var (st.freshTypeVar).1)) = .ok stAfter →
    stAfter.subst.Idempotent →
    HasTypeU env (.app fn arg) (applySubstCompat stAfter.subst (fuel + 1) (.var (st.freshTypeVar).1))

/-- Empty-substitution closed+fresh successor-fuel app-hook fragment is provable. -/
theorem appUnifySoundHookUClosedFreshSuccEmptySubst_proved :
    AppUnifySoundHookUClosedFreshSuccEmptySubst := by
  intro env fn arg st stAfter fuel argTy retTy
    h_empty h_fn h_arg h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_unify h_idemp
  exact inferExprUnify_app_step_sound_hasTypeU_closed_fresh_succ_of_subst_empty
    h_empty h_fn h_arg h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_unify h_idemp

/--
Specialized shifted app-equality bridge when the starting substitution is
empty; this discharges `AppUnifyNoopDomain` automatically.
-/
theorem app_unify_result_eq_of_unify_success_empty_subst_succ
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_empty : st.subst = Subst.empty)
    (h_fn_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false)
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    applySubst stAfter.subst (fuel + 1) (.var resVar) =
      applySubst stAfter.subst (fuel + 1) retTy := by
  let h_dom : AppUnifyNoopDomain st argTy retTy resVar :=
    appUnifyNoopDomain_of_subst_empty st argTy retTy resVar h_empty
  exact app_unify_result_eq_of_unify_success_contract_succ
    st stAfter fuel argTy retTy resVar h_dom h_fn_beq_raw h_unify h_idemp

/--
Specialized shifted app-tail-bind bridge when the starting substitution is
empty; this discharges `AppUnifyNoopDomain` automatically.
-/
theorem app_unify_tail_bind_of_success_empty_subst_succ
    (st stAfter : UnifyState) (fuel : Nat) (argTy retTy : Ty) (resVar : TypeVarId)
    (h_empty : st.subst = Subst.empty)
    (h_fn_beq_raw :
      ((Ty.function (.cons argTy .nil) retTy) == (Ty.function (.cons argTy .nil) (.var resVar))) = false)
    (h_not_var : ∀ v, retTy ≠ .var v)
    (h_unify :
      unify st (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter) :
    bindTypeVar st resVar retTy fuel = .ok stAfter := by
  let h_dom : AppUnifyNoopDomain st argTy retTy resVar :=
    appUnifyNoopDomain_of_subst_empty st argTy retTy resVar h_empty
  exact app_unify_tail_bind_of_success_contract_succ
    st stAfter fuel argTy retTy resVar h_dom h_fn_beq_raw h_not_var h_unify

-- Bounded witness: the non-variable-return premise in tail bind recovery is
-- necessary in the fuel model (variable-return branch binds the left variable,
-- not necessarily the designated result variable).
private def tailBindNonVarNecessaryCounterexample : Bool :=
  let st : UnifyState := { UnifyState.empty with nextTypeVar := 2 }
  let retTy : Ty := .var 0
  let resVar : TypeVarId := 1
  match unify st 2 retTy (.var resVar), bindTypeVar st resVar retTy 1 with
  | .ok stU, .ok stB => !(stU.subst.typeMap 0 == stB.subst.typeMap 0)
  | _, _ => false

private theorem tailBindNonVarNecessaryCounterexample_true :
    tailBindNonVarNecessaryCounterexample = true := by
  native_decide

-- Bounded witness: result-variable equality at `fuel + 1` does not by itself
-- force resolved function-shape equality with parameter substitution at `fuel`.
private def appResolvedShapeCounterexample : Bool :=
  let s : Subst :=
    { typeMap := fun v => if v == 0 then some (.var 1) else none
      rowMap := fun _ => none }
  let lhs :=
    applySubstCompat s 2 (.function (.cons (.var 0) .nil) (.var 2))
  let rhs :=
    .function
      (.cons (applySubstCompat s 1 (.var 0)) .nil)
      (applySubstCompat s 2 (.var 2))
  let retEq :=
    applySubstCompat s 2 (.var 2) == applySubstCompat s 2 (.var 2)
  retEq && !(lhs == rhs)

private theorem appResolvedShapeCounterexample_true :
    appResolvedShapeCounterexample = true := by
  native_decide

/--
One-step app soundness in `HasTypeU`, parameterized by an explicit resolved
function-shape equation produced by the unification side.
-/
theorem inferExprUnify_app_step_sound_hasTypeU_resolved
    {env : TermEnv} {fn arg : CoreExpr} {fnTy argTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {resVar : TypeVarId}
    (h_fn : HasTypeU env fn fnTy)
    (h_arg : HasTypeU env arg argTy)
    (h_unify :
      unify stBefore fuel fnTy (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_resolved :
      applySubstCompat stAfter.subst fuel fnTy =
        .function
          (.cons (applySubstCompat stAfter.subst fuel argTy) .nil)
          (applySubstCompat stAfter.subst fuel (.var resVar))) :
    HasTypeU env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)) :=
  appUnifySoundHookUResolved_proved env fn arg fnTy argTy stBefore stAfter fuel resVar
    h_fn h_arg h_unify h_resolved

/--
One-step projection soundness in `HasTypeU`, parameterized by an explicit
resolved receiver-row shape produced by the unification side.
-/
theorem inferExprUnify_proj_step_sound_hasTypeU_resolved
    {env : TermEnv} {recv : CoreExpr} {label : Label} {recvTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {fieldVar : TypeVarId} {restVar : RowVarId}
    {rowFields : RowFields}
    (h_recv : HasTypeU env recv recvTy)
    (h_unify :
      unify stBefore fuel recvTy
        (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter)
    (h_resolved :
      applySubstCompat stAfter.subst fuel recvTy =
        .anonRecord (.mk rowFields none))
    (h_get :
      RowFields.get rowFields label =
        some (applySubstCompat stAfter.subst fuel (.var fieldVar))) :
    HasTypeU env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar)) :=
  projUnifySoundHookUResolved_proved
    env recv label recvTy stBefore stAfter fuel fieldVar restVar rowFields
    h_recv h_unify h_resolved h_get

/-- Build `AppUnifySoundHookU` from resolved-shape app premise. -/
theorem appUnifySoundHookU_of_resolved
    (h_resolved : AppResolvedShapeFromUnify) :
    AppUnifySoundHookU := by
  intro env fn arg fnTy argTy stBefore stAfter fuel resVar h_fn h_arg h_unify
  exact inferExprUnify_app_step_sound_hasTypeU_resolved
    h_fn h_arg h_unify (h_resolved env fn arg fnTy argTy stBefore stAfter fuel resVar h_fn h_arg h_unify)

/-- Build `ProjUnifySoundHookU` from resolved-shape projection premise. -/
theorem projUnifySoundHookU_of_resolved
    (h_resolved : ProjResolvedShapeFromUnify) :
    ProjUnifySoundHookU := by
  intro env recv label recvTy stBefore stAfter fuel fieldVar restVar h_recv h_unify
  rcases h_resolved env recv label recvTy stBefore stAfter fuel fieldVar restVar h_recv h_unify with
    ⟨rowFields, h_row, h_get⟩
  exact inferExprUnify_proj_step_sound_hasTypeU_resolved
    h_recv h_unify h_row h_get

/-- Build `HasTypeU` hook bundle from global resolved-shape premises. -/
theorem unifyHookPremisesU_of_resolved
    (h_resolved : UnifyResolvedShapePremises) :
    UnifyHookPremisesU := by
  exact ⟨
    appUnifySoundHookU_of_resolved h_resolved.1,
    projUnifySoundHookU_of_resolved h_resolved.2
  ⟩


/--
Hook-free local-step bundle in `HasTypeU`: both app and projection one-step
rules are discharged once resolved-shape witnesses are provided.
-/
def UnifyStepSoundHasTypeU : Prop :=
  AppUnifySoundHookUResolved ∧ ProjUnifySoundHookUResolved

/-- Canonical witness for `UnifyStepSoundHasTypeU`. -/
theorem unifyStepSoundHasTypeU_proved : UnifyStepSoundHasTypeU := by
  exact ⟨appUnifySoundHookUResolved_proved, projUnifySoundHookUResolved_proved⟩

/--
Resolved-shape-premise entrypoint to the local-step bundle. The bundle itself is
already dischargeable from substitution admissibility; this theorem exposes the
same entrypoint shape used by recursive resolved-premise theorems.
-/
theorem unifyStepSoundHasTypeU_of_resolved
    (h_resolved : UnifyResolvedShapePremises) :
    UnifyStepSoundHasTypeU := by
  cases h_resolved
  exact unifyStepSoundHasTypeU_proved

/-- Bundle-driven app local-step rule. -/
theorem inferExprUnify_app_step_sound_hasTypeU_from_bundle
    (h_steps : UnifyStepSoundHasTypeU)
    {env : TermEnv} {fn arg : CoreExpr} {fnTy argTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {resVar : TypeVarId}
    (h_fn : HasTypeU env fn fnTy)
    (h_arg : HasTypeU env arg argTy)
    (h_unify :
      unify stBefore fuel fnTy (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_resolved :
      applySubstCompat stAfter.subst fuel fnTy =
        .function
          (.cons (applySubstCompat stAfter.subst fuel argTy) .nil)
          (applySubstCompat stAfter.subst fuel (.var resVar))) :
    HasTypeU env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)) := by
  exact h_steps.1 env fn arg fnTy argTy stBefore stAfter fuel resVar h_fn h_arg h_unify h_resolved

/-- Bundle-driven projection local-step rule. -/
theorem inferExprUnify_proj_step_sound_hasTypeU_from_bundle
    (h_steps : UnifyStepSoundHasTypeU)
    {env : TermEnv} {recv : CoreExpr} {label : Label} {recvTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {fieldVar : TypeVarId} {restVar : RowVarId}
    {rowFields : RowFields}
    (h_recv : HasTypeU env recv recvTy)
    (h_unify :
      unify stBefore fuel recvTy
        (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter)
    (h_resolved :
      applySubstCompat stAfter.subst fuel recvTy =
        .anonRecord (.mk rowFields none))
    (h_get :
      RowFields.get rowFields label =
        some (applySubstCompat stAfter.subst fuel (.var fieldVar))) :
    HasTypeU env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar)) := by
  exact h_steps.2
    env recv label recvTy stBefore stAfter fuel fieldVar restVar rowFields
    h_recv h_unify h_resolved h_get

/-- Admissibility in `HasTypeU` is built into the judgment. -/
theorem hasTypeU_subst_admissible
    {env : TermEnv} {e : CoreExpr} {ty : Ty} {s : Subst} {fuel : Nat}
    (h_ty : HasTypeU env e ty) :
    HasTypeU env e (applySubstCompat s fuel ty) :=
  HasTypeU.subst env e ty s fuel h_ty

/--
The app-hook counterexample becomes typable in the unification-aware judgment
because substitution admissibility can be applied to the function position.
-/
theorem app_counterexample_hasTypeU :
    let env : TermEnv := [("f", .var 0)]
    let fn : CoreExpr := .var "f"
    let arg : CoreExpr := .intLit 1
    let stBefore : UnifyState := { UnifyState.empty with nextTypeVar := 2 }
    let expected : Ty := .function (.cons .int .nil) (.var 1)
    let stAfter : UnifyState := { stBefore with subst := stBefore.subst.bindType 0 expected }
    unify stBefore 1 (.var 0) expected = .ok stAfter →
    HasTypeU env (.app fn arg) (applySubstCompat stAfter.subst 1 (.var 1)) := by
  intro env fn arg stBefore expected stAfter h_unify
  have h_var : HasTypeU env fn (.var 0) := by
    exact HasTypeU.var env "f" (.var 0) (by simp [env, TermEnv.lookup])
  have h_fn_sub :
      HasTypeU env fn (.function (.cons .int .nil) (.var 1)) := by
    have h_sub := hasTypeU_subst_admissible (s := stAfter.subst) (fuel := 1) h_var
    simpa [stAfter, expected, applySubstCompat, applySubst, Subst.bindType] using h_sub
  have h_arg : HasTypeU env arg .int := HasTypeU.int env 1
  have h_app_var1 : HasTypeU env (.app fn arg) (.var 1) :=
    HasTypeU.app env fn arg .int (.var 1) h_fn_sub h_arg
  have h_app_resolved := hasTypeU_subst_admissible (s := stAfter.subst) (fuel := 1) h_app_var1
  simpa [stAfter, applySubstCompat, applySubst, Subst.bindType] using h_app_resolved

/--
Projection-hook counterexample with variable-typed receiver becomes typable in
`HasTypeU` once substitution admissibility is available.
-/
theorem proj_counterexample_hasTypeU :
    let env : TermEnv := [("r", .var 0)]
    let recv : CoreExpr := .var "r"
    let label : Label := "a"
    let stBefore : UnifyState := { UnifyState.empty with nextTypeVar := 2 }
    let expected : Ty := .anonRecord (.mk (.cons label (.var 1) .nil) none)
    let stAfter : UnifyState := { stBefore with subst := stBefore.subst.bindType 0 expected }
    unify stBefore 1 (.var 0) expected = .ok stAfter →
    HasTypeU env (.proj recv label) (applySubstCompat stAfter.subst 1 (.var 1)) := by
  intro env recv label stBefore expected stAfter h_unify
  have h_var : HasTypeU env recv (.var 0) := by
    exact HasTypeU.var env "r" (.var 0) (by simp [env, TermEnv.lookup])
  have h_recv_sub :
      HasTypeU env recv (.anonRecord (.mk (.cons label (.var 1) .nil) none)) := by
    have h_sub := hasTypeU_subst_admissible (s := stAfter.subst) (fuel := 1) h_var
    simpa [stAfter, expected, applySubstCompat, applySubst, applySubstRow,
      applySubstRowFields, Subst.bindType] using h_sub
  have h_get : RowFields.get (.cons label (.var 1) .nil) label = some (.var 1) := by
    simp [RowFields.get]
  have h_proj_var1 : HasTypeU env (.proj recv label) (.var 1) :=
    HasTypeU.proj env recv (.cons label (.var 1) .nil) label (.var 1) h_recv_sub h_get
  have h_proj_resolved := hasTypeU_subst_admissible (s := stAfter.subst) (fuel := 1) h_proj_var1
  simpa [stAfter, applySubstCompat, applySubst, Subst.bindType] using h_proj_resolved

/-- One-step app soundness: app branch correctness from typed children + unify hook. -/
theorem inferExprUnify_app_step_sound
    (h_app : AppUnifySoundHook)
    {env fn arg fnTy argTy : _}
    {stBefore stAfter : UnifyState} {fuel : Nat} {resVar : TypeVarId}
    (h_fn : HasType env fn fnTy)
    (h_arg : HasType env arg argTy)
    (h_unify : unify stBefore fuel fnTy (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter) :
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)) :=
  h_app env fn arg fnTy argTy stBefore stAfter fuel resVar h_fn h_arg h_unify

/--
One-step app soundness on the weak-hook boundary: app branch correctness from a
declaratively function-typed callee, typed argument, unification success, and
resolved result equality.
-/
theorem inferExprUnify_app_step_sound_weak
    (h_app : AppUnifySoundHookWeak)
    {env fn arg argTy retTy : _}
    {stBefore stAfter : UnifyState} {fuel : Nat} {resVar : TypeVarId}
    (h_fn : HasType env fn (.function (.cons argTy .nil) retTy))
    (h_arg : HasType env arg argTy)
    (h_unify : unify stBefore fuel
      (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_res_eq : applySubstCompat stAfter.subst fuel (.var resVar) = retTy) :
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)) :=
  h_app env fn arg argTy retTy stBefore stAfter fuel resVar h_fn h_arg h_unify h_res_eq

/--
One-step app soundness on the weak-hook boundary, derived from any strong app
hook witness through the strong→weak adapter.
-/
theorem inferExprUnify_app_step_sound_weak_of_strong
    (h_app : AppUnifySoundHook)
    {env fn arg argTy retTy : _}
    {stBefore stAfter : UnifyState} {fuel : Nat} {resVar : TypeVarId}
    (h_fn : HasType env fn (.function (.cons argTy .nil) retTy))
    (h_arg : HasType env arg argTy)
    (h_unify : unify stBefore fuel
      (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_res_eq : applySubstCompat stAfter.subst fuel (.var resVar) = retTy) :
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)) :=
  inferExprUnify_app_step_sound_weak
    (appUnifySoundHookWeak_of_appUnifySoundHook h_app) h_fn h_arg h_unify h_res_eq

/-- Bundle-driven app local-step rule on the weak-hook boundary. -/
theorem inferExprUnify_app_step_sound_weak_from_bundle
    (h_steps : UnifyHookPremisesWeak)
    {env fn arg argTy retTy : _}
    {stBefore stAfter : UnifyState} {fuel : Nat} {resVar : TypeVarId}
    (h_fn : HasType env fn (.function (.cons argTy .nil) retTy))
    (h_arg : HasType env arg argTy)
    (h_unify : unify stBefore fuel
      (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_res_eq : applySubstCompat stAfter.subst fuel (.var resVar) = retTy) :
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)) := by
  exact h_steps.1 env fn arg argTy retTy stBefore stAfter fuel resVar
    h_fn h_arg h_unify h_res_eq

/--
Strong-hook-bundle entrypoint to the weak app-step theorem surface via the
strong→weak package adapter.
-/
theorem inferExprUnify_app_step_sound_weak_from_strong_bundle
    (h_hooks : UnifyHookPremises)
    {env fn arg argTy retTy : _}
    {stBefore stAfter : UnifyState} {fuel : Nat} {resVar : TypeVarId}
    (h_fn : HasType env fn (.function (.cons argTy .nil) retTy))
    (h_arg : HasType env arg argTy)
    (h_unify : unify stBefore fuel
      (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_res_eq : applySubstCompat stAfter.subst fuel (.var resVar) = retTy) :
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)) := by
  exact inferExprUnify_app_step_sound_weak_from_bundle
    (unifyHookPremisesWeak_of_unifyHookPremises h_hooks) h_fn h_arg h_unify h_res_eq

/-- Step-bundle-driven app local-step rule on the weak-hook boundary. -/
theorem inferExprUnify_app_step_sound_weak_from_stepBundle
    (h_steps : UnifyStepSoundWeak)
    {env fn arg argTy retTy : _}
    {stBefore stAfter : UnifyState} {fuel : Nat} {resVar : TypeVarId}
    (h_fn : HasType env fn (.function (.cons argTy .nil) retTy))
    (h_arg : HasType env arg argTy)
    (h_unify : unify stBefore fuel
      (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_res_eq : applySubstCompat stAfter.subst fuel (.var resVar) = retTy) :
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)) := by
  exact h_steps.1 env fn arg argTy retTy stBefore stAfter fuel resVar
    h_fn h_arg h_unify h_res_eq

/-- Proved app local-step rule on the weak-hook boundary. -/
theorem inferExprUnify_app_step_sound_weak_proved
    {env fn arg argTy retTy : _}
    {stBefore stAfter : UnifyState} {fuel : Nat} {resVar : TypeVarId}
    (h_fn : HasType env fn (.function (.cons argTy .nil) retTy))
    (h_arg : HasType env arg argTy)
    (h_unify : unify stBefore fuel
      (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_res_eq : applySubstCompat stAfter.subst fuel (.var resVar) = retTy) :
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)) := by
  exact inferExprUnify_app_step_sound_weak_from_stepBundle
    unifyStepSoundWeak_proved h_fn h_arg h_unify h_res_eq

/--
Strong-hook-package entrypoint to the weak app local-step rule through the
canonical weak-step bundle.
-/
theorem inferExprUnify_app_step_sound_weak_from_unifyHookPremises
    (h_hooks : UnifyHookPremises)
    {env fn arg argTy retTy : _}
    {stBefore stAfter : UnifyState} {fuel : Nat} {resVar : TypeVarId}
    (h_fn : HasType env fn (.function (.cons argTy .nil) retTy))
    (h_arg : HasType env arg argTy)
    (h_unify : unify stBefore fuel
      (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var resVar)) = .ok stAfter)
    (h_res_eq : applySubstCompat stAfter.subst fuel (.var resVar) = retTy) :
    HasType env (.app fn arg) (applySubstCompat stAfter.subst fuel (.var resVar)) := by
  exact inferExprUnify_app_step_sound_weak_from_stepBundle
    (unifyStepSoundWeak_of_unifyHookPremises h_hooks) h_fn h_arg h_unify h_res_eq

/-- One-step projection soundness: proj branch correctness from typed receiver + unify hook. -/
theorem inferExprUnify_proj_step_sound
    (h_proj : ProjUnifySoundHook)
    {env recv : _} {label : Label} {recvTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {fieldVar : TypeVarId} {restVar : RowVarId}
    (h_recv : HasType env recv recvTy)
    (h_unify : unify stBefore fuel recvTy (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter) :
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar)) :=
  h_proj env recv label recvTy stBefore stAfter fuel fieldVar restVar h_recv h_unify

/--
One-step projection soundness on the weak-hook boundary: projection branch
correctness from a typed receiver, explicit closed-row receiver shape, and
selected-field lookup at the resolved projection type.
-/
theorem inferExprUnify_proj_step_sound_weak
    (h_proj : ProjUnifySoundHookWeak)
    {env recv : _} {label : Label} {recvTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {fieldVar : TypeVarId}
    {restVar : RowVarId} {rowFields : RowFields}
    (h_recv : HasType env recv recvTy)
    (h_recv_shape : recvTy = .anonRecord (.mk rowFields none))
    (h_unify : unify stBefore fuel recvTy
      (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter)
    (h_get : RowFields.get rowFields label =
      some (applySubstCompat stAfter.subst fuel (.var fieldVar))) :
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar)) :=
  h_proj env recv label recvTy stBefore stAfter fuel fieldVar restVar rowFields
    h_recv h_recv_shape h_unify h_get

/--
One-step projection soundness on the weak-hook boundary, derived from any
strong projection hook witness through the strong→weak adapter.
-/
theorem inferExprUnify_proj_step_sound_weak_of_strong
    (h_proj : ProjUnifySoundHook)
    {env recv : _} {label : Label} {recvTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {fieldVar : TypeVarId}
    {restVar : RowVarId} {rowFields : RowFields}
    (h_recv : HasType env recv recvTy)
    (h_recv_shape : recvTy = .anonRecord (.mk rowFields none))
    (h_unify : unify stBefore fuel recvTy
      (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter)
    (h_get : RowFields.get rowFields label =
      some (applySubstCompat stAfter.subst fuel (.var fieldVar))) :
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar)) :=
  inferExprUnify_proj_step_sound_weak
    (projUnifySoundHookWeak_of_projUnifySoundHook h_proj)
    h_recv h_recv_shape h_unify h_get

/-- Bundle-driven projection local-step rule on the weak-hook boundary. -/
theorem inferExprUnify_proj_step_sound_weak_from_bundle
    (h_steps : UnifyHookPremisesWeak)
    {env recv : _} {label : Label} {recvTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {fieldVar : TypeVarId}
    {restVar : RowVarId} {rowFields : RowFields}
    (h_recv : HasType env recv recvTy)
    (h_recv_shape : recvTy = .anonRecord (.mk rowFields none))
    (h_unify : unify stBefore fuel recvTy
      (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter)
    (h_get : RowFields.get rowFields label =
      some (applySubstCompat stAfter.subst fuel (.var fieldVar))) :
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar)) := by
  exact h_steps.2 env recv label recvTy stBefore stAfter fuel fieldVar restVar rowFields
    h_recv h_recv_shape h_unify h_get

/--
Strong-hook-bundle entrypoint to the weak projection-step theorem surface via
the strong→weak package adapter.
-/
theorem inferExprUnify_proj_step_sound_weak_from_strong_bundle
    (h_hooks : UnifyHookPremises)
    {env recv : _} {label : Label} {recvTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {fieldVar : TypeVarId}
    {restVar : RowVarId} {rowFields : RowFields}
    (h_recv : HasType env recv recvTy)
    (h_recv_shape : recvTy = .anonRecord (.mk rowFields none))
    (h_unify : unify stBefore fuel recvTy
      (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter)
    (h_get : RowFields.get rowFields label =
      some (applySubstCompat stAfter.subst fuel (.var fieldVar))) :
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar)) := by
  exact inferExprUnify_proj_step_sound_weak_from_bundle
    (unifyHookPremisesWeak_of_unifyHookPremises h_hooks)
    h_recv h_recv_shape h_unify h_get

/-- Step-bundle-driven projection local-step rule on the weak-hook boundary. -/
theorem inferExprUnify_proj_step_sound_weak_from_stepBundle
    (h_steps : UnifyStepSoundWeak)
    {env recv : _} {label : Label} {recvTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {fieldVar : TypeVarId}
    {restVar : RowVarId} {rowFields : RowFields}
    (h_recv : HasType env recv recvTy)
    (h_recv_shape : recvTy = .anonRecord (.mk rowFields none))
    (h_unify : unify stBefore fuel recvTy
      (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter)
    (h_get : RowFields.get rowFields label =
      some (applySubstCompat stAfter.subst fuel (.var fieldVar))) :
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar)) := by
  exact h_steps.2 env recv label recvTy stBefore stAfter fuel fieldVar restVar rowFields
    h_recv h_recv_shape h_unify h_get

/-- Proved projection local-step rule on the weak-hook boundary. -/
theorem inferExprUnify_proj_step_sound_weak_proved
    {env recv : _} {label : Label} {recvTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {fieldVar : TypeVarId}
    {restVar : RowVarId} {rowFields : RowFields}
    (h_recv : HasType env recv recvTy)
    (h_recv_shape : recvTy = .anonRecord (.mk rowFields none))
    (h_unify : unify stBefore fuel recvTy
      (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter)
    (h_get : RowFields.get rowFields label =
      some (applySubstCompat stAfter.subst fuel (.var fieldVar))) :
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar)) := by
  exact inferExprUnify_proj_step_sound_weak_from_stepBundle
    unifyStepSoundWeak_proved h_recv h_recv_shape h_unify h_get

/--
Strong-hook-package entrypoint to the weak projection local-step rule through
the canonical weak-step bundle.
-/
theorem inferExprUnify_proj_step_sound_weak_from_unifyHookPremises
    (h_hooks : UnifyHookPremises)
    {env recv : _} {label : Label} {recvTy : Ty}
    {stBefore stAfter : UnifyState} {fuel : Nat} {fieldVar : TypeVarId}
    {restVar : RowVarId} {rowFields : RowFields}
    (h_recv : HasType env recv recvTy)
    (h_recv_shape : recvTy = .anonRecord (.mk rowFields none))
    (h_unify : unify stBefore fuel recvTy
      (.anonRecord (.mk (.cons label (.var fieldVar) .nil) (some restVar))) = .ok stAfter)
    (h_get : RowFields.get rowFields label =
      some (applySubstCompat stAfter.subst fuel (.var fieldVar))) :
    HasType env (.proj recv label) (applySubstCompat stAfter.subst fuel (.var fieldVar)) := by
  exact inferExprUnify_proj_step_sound_weak_from_stepBundle
    (unifyStepSoundWeak_of_unifyHookPremises h_hooks)
    h_recv h_recv_shape h_unify h_get

mutual
  /-- Structural size of core expressions (for recursive proof termination). -/
  def exprSize : CoreExpr → Nat
    | .intLit _ => 1
    | .boolLit _ => 1
    | .stringLit _ => 1
    | .var _ => 1
    | .lam _ _ body => exprSize body + 1
    | .app fn arg => exprSize fn + exprSize arg + 1
    | .letE _ value body => exprSize value + exprSize body + 1
    | .record fields => fieldsSize fields + 1
    | .proj recv _ => exprSize recv + 1

  /-- Structural size of field lists (for recursive proof termination). -/
  def fieldsSize : CoreFields → Nat
    | .nil => 1
    | .cons _ e rest => exprSize e + fieldsSize rest + 1
end

mutual
  /-- Expressions whose `inferExprUnify` path never enters app/proj unification branches. -/
  inductive NoUnifyBranchesExpr : CoreExpr → Prop where
    | intLit (n : Int) : NoUnifyBranchesExpr (.intLit n)
    | boolLit (b : Bool) : NoUnifyBranchesExpr (.boolLit b)
    | stringLit (s : String) : NoUnifyBranchesExpr (.stringLit s)
    | var (name : String) : NoUnifyBranchesExpr (.var name)
    | lam (param : String) (paramTy : Ty) (body : CoreExpr)
        (h_body : NoUnifyBranchesExpr body) :
        NoUnifyBranchesExpr (.lam param paramTy body)
    | letE (name : String) (value body : CoreExpr)
        (h_value : NoUnifyBranchesExpr value)
        (h_body : NoUnifyBranchesExpr body) :
        NoUnifyBranchesExpr (.letE name value body)
    | record (fields : CoreFields)
        (h_fields : NoUnifyBranchesFields fields) :
        NoUnifyBranchesExpr (.record fields)

  /-- Field lists whose `inferFieldsUnify` path never enters app/proj unification branches. -/
  inductive NoUnifyBranchesFields : CoreFields → Prop where
    | nil : NoUnifyBranchesFields .nil
    | cons (label : Label) (e : CoreExpr) (rest : CoreFields)
        (h_head : NoUnifyBranchesExpr e)
        (h_rest : NoUnifyBranchesFields rest) :
        NoUnifyBranchesFields (.cons label e rest)
end

mutual
  /--
  Soundness of `inferExprUnify` on the fragment that never executes app/proj
  unification branches.
  -/
  theorem inferExprUnify_sound_no_unify_branches
      {e : CoreExpr}
      (h_no : NoUnifyBranchesExpr e) :
      ∀ st fuel env st' ty,
        inferExprUnify st fuel env e = .ok st' ty →
        HasType env e ty := by
    cases h_no with
    | intLit n =>
      intro st fuel env st' ty h
      simp [inferExprUnify] at h
      rcases h with ⟨_, hty⟩
      subst hty
      exact HasType.int env n
    | boolLit b =>
      intro st fuel env st' ty h
      simp [inferExprUnify] at h
      rcases h with ⟨_, hty⟩
      subst hty
      exact HasType.bool env b
    | stringLit s =>
      intro st fuel env st' ty h
      simp [inferExprUnify] at h
      rcases h with ⟨_, hty⟩
      subst hty
      exact HasType.string env s
    | var name =>
      intro st fuel env st' ty h
      cases h_lookup : TermEnv.lookup env name with
      | none =>
        simp [inferExprUnify, h_lookup] at h
      | some vty =>
        simp [inferExprUnify, h_lookup] at h
        rcases h with ⟨_, hty⟩
        subst hty
        exact HasType.var env name vty h_lookup
    | lam param paramTy body h_body =>
      intro st fuel env st' ty h
      simp [inferExprUnify] at h
      cases h_body_infer : inferExprUnify st fuel ((param, paramTy) :: env) body with
      | err e =>
        simp [h_body_infer] at h
      | ok stBody bodyTy =>
        simp [h_body_infer] at h
        rcases h with ⟨_, hty⟩
        subst hty
        exact HasType.lam env param paramTy bodyTy body
          (inferExprUnify_sound_no_unify_branches h_body st fuel ((param, paramTy) :: env) stBody bodyTy h_body_infer)
    | letE name value body h_value h_body =>
      intro st fuel env st' ty h
      simp [inferExprUnify] at h
      cases h_value_infer : inferExprUnify st fuel env value with
      | err e =>
        simp [h_value_infer] at h
      | ok stValue valueTy =>
        exact HasType.letE env name value body valueTy ty
          (inferExprUnify_sound_no_unify_branches h_value st fuel env stValue valueTy h_value_infer)
          (inferExprUnify_sound_no_unify_branches h_body stValue fuel ((name, valueTy) :: env) st' ty (by
            simpa [h_value_infer] using h))
    | record fields h_fields =>
      intro st fuel env st' ty h
      simp [inferExprUnify] at h
      cases h_fields_infer : inferFieldsUnify st fuel env fields with
      | err e =>
        simp [h_fields_infer] at h
      | ok stFields fieldsTy =>
        cases fieldsTy with
        | row rowTy =>
          cases rowTy with
          | mk rf rest =>
            cases rest with
            | some rv =>
              simp [h_fields_infer] at h
            | none =>
              simp [h_fields_infer] at h
              rcases h with ⟨_, hty⟩
              subst hty
              exact HasType.record env fields rf
                (inferFieldsUnify_sound_no_unify_branches h_fields st fuel env stFields rf (by
                  simp [h_fields_infer]))
        | int | intN _ _ | float | floatN _ | decimal _ _ | bool | string | html | markdown | atom | date | dateTime | unit =>
          simp [h_fields_infer] at h
        | list _ | map _ _ | set _ | option _ | result _ _ | existential _ _ | fixedSizeList _ _ | tensor _ _ | sum _ _ | «opaque» _ _
          | function _ _ | functionEff _ _ _ | «forall» _ _ | app _ _ | constructor _ _ _ | record _ _ | anonRecord _ | dataframe _ | groupedFrame _ _ | tagged _ _ | dynamic | column _ | stream _ | task _ | actor _ | arc _
          | var _ | tuple _ =>
          simp [h_fields_infer] at h

  /-- Field-level counterpart of `inferExprUnify_sound_no_unify_branches`. -/
  theorem inferFieldsUnify_sound_no_unify_branches
      {fs : CoreFields}
      (h_no : NoUnifyBranchesFields fs) :
      ∀ st fuel env st' rf,
        inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
        HasFieldsType env fs rf := by
    cases h_no with
    | nil =>
      intro st fuel env st' rf h
      simp [inferFieldsUnify] at h
      rcases h with ⟨_, hrf⟩
      subst hrf
      exact HasFieldsType.nil env
    | cons label e rest h_head h_rest =>
      intro st fuel env st' rf h
      simp [inferFieldsUnify] at h
      cases h_head_infer : inferExprUnify st fuel env e with
      | err e =>
        simp [h_head_infer] at h
      | ok stHead tyHead =>
        cases h_rest_infer : inferFieldsUnify stHead fuel env rest with
        | err e =>
          simp [h_head_infer, h_rest_infer] at h
        | ok stRest restTy =>
          cases restTy with
          | row rowTy =>
            cases rowTy with
            | mk restFields restVar =>
              cases restVar with
              | some rv =>
                simp [h_head_infer, h_rest_infer] at h
              | none =>
                simp [h_head_infer, h_rest_infer] at h
                rcases h with ⟨_, hrf⟩
                subst hrf
                exact HasFieldsType.cons env label e rest tyHead restFields
                  (inferExprUnify_sound_no_unify_branches h_head st fuel env stHead tyHead h_head_infer)
                  (inferFieldsUnify_sound_no_unify_branches h_rest stHead fuel env stRest restFields (by
                    simp [h_rest_infer]))
          | int | intN _ _ | float | floatN _ | decimal _ _ | bool | string | html | markdown | atom | date | dateTime | unit =>
            simp [h_head_infer, h_rest_infer] at h
          | list _ | map _ _ | set _ | option _ | result _ _ | existential _ _ | fixedSizeList _ _ | tensor _ _ | sum _ _ | «opaque» _ _
            | function _ _ | functionEff _ _ _ | «forall» _ _ | app _ _ | constructor _ _ _ | record _ _ | anonRecord _ | dataframe _ | groupedFrame _ _ | tagged _ _ | dynamic | column _ | stream _ | task _ | actor _ | arc _
            | var _ | tuple _ =>
            simp [h_head_infer, h_rest_infer] at h
end

mutual
  /--
  Completeness of unification-threaded inference on the no-unify fragment:
  syntax-directed inference can be replayed with identical result type/state.
  -/
  theorem inferExprUnify_complete_no_unify_branches
      {e : CoreExpr}
      (h_no : NoUnifyBranchesExpr e) :
      ∀ st fuel env ty,
        inferExpr env e = some ty →
        inferExprUnify st fuel env e = .ok st ty := by
    cases h_no with
    | intLit n =>
      intro st fuel env ty h_inf
      simp [inferExpr] at h_inf
      subst h_inf
      simp [inferExprUnify]
    | boolLit b =>
      intro st fuel env ty h_inf
      simp [inferExpr] at h_inf
      subst h_inf
      simp [inferExprUnify]
    | stringLit s =>
      intro st fuel env ty h_inf
      simp [inferExpr] at h_inf
      subst h_inf
      simp [inferExprUnify]
    | var name =>
      intro st fuel env ty h_inf
      cases h_lookup : TermEnv.lookup env name with
      | none =>
        simp [inferExpr, h_lookup] at h_inf
      | some vty =>
        simp [inferExpr, h_lookup] at h_inf
        subst h_inf
        simp [inferExprUnify, h_lookup]
    | lam param paramTy body h_body =>
      intro st fuel env ty h_inf
      simp [inferExpr] at h_inf
      cases h_body_alg : inferExpr ((param, paramTy) :: env) body with
      | none =>
        simp [h_body_alg] at h_inf
      | some bodyTy =>
        simp [h_body_alg] at h_inf
        subst h_inf
        have h_body_unify :
            inferExprUnify st fuel ((param, paramTy) :: env) body = .ok st bodyTy :=
          inferExprUnify_complete_no_unify_branches
            h_body st fuel ((param, paramTy) :: env) bodyTy h_body_alg
        simp [inferExprUnify, h_body_unify]
    | letE name value body h_value h_body =>
      intro st fuel env ty h_inf
      simp [inferExpr] at h_inf
      cases h_value_alg : inferExpr env value with
      | none =>
        simp [h_value_alg] at h_inf
      | some valueTy =>
        have h_value_unify :
            inferExprUnify st fuel env value = .ok st valueTy :=
          inferExprUnify_complete_no_unify_branches
            h_value st fuel env valueTy h_value_alg
        have h_body_unify :
            inferExprUnify st fuel ((name, valueTy) :: env) body = .ok st ty :=
          inferExprUnify_complete_no_unify_branches
            h_body st fuel ((name, valueTy) :: env) ty (by
              simpa [h_value_alg] using h_inf)
        simpa [inferExprUnify, h_value_unify] using h_body_unify
    | record fields h_fields =>
      intro st fuel env ty h_inf
      simp [inferExpr] at h_inf
      cases h_fields_alg : inferFields env fields with
      | none =>
        simp [h_fields_alg] at h_inf
      | some rowFields =>
        simp [h_fields_alg] at h_inf
        subst h_inf
        have h_fields_unify :
            inferFieldsUnify st fuel env fields = .ok st (.row (.mk rowFields none)) :=
          inferFieldsUnify_complete_no_unify_branches
            h_fields st fuel env rowFields h_fields_alg
        simp [inferExprUnify, h_fields_unify]

  /--
  Field-level completeness counterpart on the no-unify fragment.
  -/
  theorem inferFieldsUnify_complete_no_unify_branches
      {fs : CoreFields}
      (h_no : NoUnifyBranchesFields fs) :
      ∀ st fuel env rf,
        inferFields env fs = some rf →
        inferFieldsUnify st fuel env fs = .ok st (.row (.mk rf none)) := by
    cases h_no with
    | nil =>
      intro st fuel env rf h_inf
      simp [inferFields] at h_inf
      subst h_inf
      simp [inferFieldsUnify]
    | cons label e rest h_head h_rest =>
      intro st fuel env rf h_inf
      simp [inferFields] at h_inf
      cases h_head_alg : inferExpr env e with
      | none =>
        simp [h_head_alg] at h_inf
      | some tyHead =>
        cases h_rest_alg : inferFields env rest with
        | none =>
          simp [h_head_alg, h_rest_alg] at h_inf
        | some restFields =>
          simp [h_head_alg, h_rest_alg] at h_inf
          subst h_inf
          have h_head_unify :
              inferExprUnify st fuel env e = .ok st tyHead :=
            inferExprUnify_complete_no_unify_branches
              h_head st fuel env tyHead h_head_alg
          have h_rest_unify :
              inferFieldsUnify st fuel env rest = .ok st (.row (.mk restFields none)) :=
            inferFieldsUnify_complete_no_unify_branches
              h_rest st fuel env restFields h_rest_alg
          simp [inferFieldsUnify, h_head_unify, h_rest_unify]
end

/--
On the no-unify fragment, successful expression inference preserves
`UnifyState`.
-/
theorem inferExprUnify_state_preserved_no_unify_branches
    {e : CoreExpr}
    (h_no : NoUnifyBranchesExpr e) :
    ∀ st fuel env st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      st' = st := by
  intro st fuel env st' ty h_ok
  have h_ty : HasType env e ty :=
    inferExprUnify_sound_no_unify_branches h_no st fuel env st' ty h_ok
  have h_inf : inferExpr env e = some ty := inferExpr_complete env e ty h_ty
  have h_ok_ref :
      inferExprUnify st fuel env e = .ok st ty :=
    inferExprUnify_complete_no_unify_branches h_no st fuel env ty h_inf
  rw [h_ok] at h_ok_ref
  cases h_ok_ref
  rfl

/--
On the no-unify fragment, successful field inference preserves `UnifyState`.
-/
theorem inferFieldsUnify_state_preserved_no_unify_branches
    {fs : CoreFields}
    (h_no : NoUnifyBranchesFields fs) :
    ∀ st fuel env st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      st' = st := by
  intro st fuel env st' rf h_ok
  have h_rf : HasFieldsType env fs rf :=
    inferFieldsUnify_sound_no_unify_branches h_no st fuel env st' rf h_ok
  have h_inf : inferFields env fs = some rf := inferFields_complete env fs rf h_rf
  have h_ok_ref :
      inferFieldsUnify st fuel env fs = .ok st (.row (.mk rf none)) :=
    inferFieldsUnify_complete_no_unify_branches h_no st fuel env rf h_inf
  rw [h_ok] at h_ok_ref
  cases h_ok_ref
  rfl

/--
On the no-unify fragment, successful `inferExprUnify` runs are exactly
syntax-directed inference results with unchanged state.
-/
theorem inferExprUnify_ok_iff_inferExpr_no_unify_branches
    {e : CoreExpr}
    (h_no : NoUnifyBranchesExpr e) :
    ∀ st fuel env st' ty,
      inferExprUnify st fuel env e = .ok st' ty ↔
        st' = st ∧ inferExpr env e = some ty := by
  intro st fuel env st' ty
  constructor
  · intro h_ok
    have h_st :
        st' = st :=
      inferExprUnify_state_preserved_no_unify_branches
        h_no st fuel env st' ty h_ok
    have h_ty : HasType env e ty :=
      inferExprUnify_sound_no_unify_branches
        h_no st fuel env st' ty h_ok
    refine ⟨h_st, ?_⟩
    exact inferExpr_complete env e ty h_ty
  · intro h
    rcases h with ⟨h_st, h_inf⟩
    cases h_st
    exact inferExprUnify_complete_no_unify_branches h_no st fuel env ty h_inf

/--
Field-level counterpart of no-unify equivalence/state preservation.
-/
theorem inferFieldsUnify_ok_iff_inferFields_no_unify_branches
    {fs : CoreFields}
    (h_no : NoUnifyBranchesFields fs) :
    ∀ st fuel env st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) ↔
        st' = st ∧ inferFields env fs = some rf := by
  intro st fuel env st' rf
  constructor
  · intro h_ok
    have h_st :
        st' = st :=
      inferFieldsUnify_state_preserved_no_unify_branches
        h_no st fuel env st' rf h_ok
    have h_rf : HasFieldsType env fs rf :=
      inferFieldsUnify_sound_no_unify_branches h_no st fuel env st' rf h_ok
    refine ⟨h_st, ?_⟩
    exact inferFields_complete env fs rf h_rf
  · intro h
    rcases h with ⟨h_st, h_inf⟩
    cases h_st
    exact inferFieldsUnify_complete_no_unify_branches h_no st fuel env rf h_inf

/--
Bridge from successful no-unify `inferExprUnify` runs into the core principal
typing package.
-/
theorem principalTypingSliceCore_of_unify_success_no_unify
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty := by
  have h_inf : inferExpr env e = some ty :=
    (inferExprUnify_ok_iff_inferExpr_no_unify_branches h_no st fuel env st' ty).1 h_ok |>.2
  exact principalTypingSliceCore_of_infer h_inf

/--
Bridge from successful no-unify `inferFieldsUnify` runs into the core
principal field-typing package.
-/
theorem principalFieldTypingSliceCore_of_unify_success_no_unify
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf := by
  have h_inf : inferFields env fs = some rf :=
    (inferFieldsUnify_ok_iff_inferFields_no_unify_branches h_no st fuel env st' rf).1 h_ok |>.2
  exact principalFieldTypingSliceCore_of_infer h_inf

/-- Packaged hook-free principal/equivalence surface on the no-unify fragment. -/
def PrincipalTypingNoUnifySlice : Prop :=
  ∀ {e : CoreExpr},
    NoUnifyBranchesExpr e →
    ∀ st fuel env st' ty,
      inferExprUnify st fuel env e = .ok st' ty ↔
        st' = st ∧ inferExpr env e = some ty

/-- Field-level packaged hook-free principal/equivalence surface. -/
def PrincipalTypingNoUnifyFieldSlice : Prop :=
  ∀ {fs : CoreFields},
    NoUnifyBranchesFields fs →
    ∀ st fuel env st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) ↔
        st' = st ∧ inferFields env fs = some rf

/-- Combined expression+field no-unify principal/equivalence surface. -/
def PrincipalTypingNoUnifySlices : Prop :=
  PrincipalTypingNoUnifySlice ∧ PrincipalTypingNoUnifyFieldSlice

/-- The combined no-unify principal/equivalence surface is fully proved. -/
theorem principalTypingNoUnifySlices_proved : PrincipalTypingNoUnifySlices := by
  refine ⟨?_, ?_⟩
  · intro e h_no st fuel env st' ty
    exact inferExprUnify_ok_iff_inferExpr_no_unify_branches h_no st fuel env st' ty
  · intro fs h_no st fuel env st' rf
    exact inferFieldsUnify_ok_iff_inferFields_no_unify_branches h_no st fuel env st' rf

mutual
  /--
  Full preconditioned soundness for unification-threaded expression inference.
  App/proj branches are discharged via explicit unifier-soundness hooks.
  -/
  theorem inferExprUnify_sound_preconditioned
      (h_app : AppUnifySoundHook)
      (h_proj : ProjUnifySoundHook) :
      ∀ st fuel env e st' ty,
        inferExprUnify st fuel env e = .ok st' ty →
        HasType env e ty := by
    intro st fuel env e
    cases e with
    | intLit n =>
      intro st' ty h
      simp [inferExprUnify] at h
      rcases h with ⟨_, hty⟩
      subst hty
      exact HasType.int env n
    | boolLit b =>
      intro st' ty h
      simp [inferExprUnify] at h
      rcases h with ⟨_, hty⟩
      subst hty
      exact HasType.bool env b
    | stringLit s =>
      intro st' ty h
      simp [inferExprUnify] at h
      rcases h with ⟨_, hty⟩
      subst hty
      exact HasType.string env s
    | var name =>
      intro st' ty h
      cases h_lookup : TermEnv.lookup env name with
      | none =>
        simp [inferExprUnify, h_lookup] at h
      | some vty =>
        simp [inferExprUnify, h_lookup] at h
        rcases h with ⟨_, hty⟩
        subst hty
        exact HasType.var env name vty h_lookup
    | lam param paramTy body =>
      intro st' ty h
      simp [inferExprUnify] at h
      cases h_body : inferExprUnify st fuel ((param, paramTy) :: env) body with
      | err err =>
        simp [h_body] at h
      | ok stBody bodyTy =>
        simp [h_body] at h
        rcases h with ⟨_, hty⟩
        subst hty
        exact HasType.lam env param paramTy bodyTy body
          (inferExprUnify_sound_preconditioned h_app h_proj st fuel ((param, paramTy) :: env) body stBody bodyTy h_body)
    | app fn arg =>
      intro st' ty h
      simp [inferExprUnify] at h
      cases h_fn : inferExprUnify st fuel env fn with
      | err err =>
        simp [h_fn] at h
      | ok stFn fnTy =>
        cases h_arg : inferExprUnify stFn fuel env arg with
        | err err =>
          simp [h_fn, h_arg] at h
        | ok stArg argTy =>
          let fresh := stArg.freshTypeVar
          cases h_unify : unify fresh.2 fuel fnTy (Ty.function (.cons argTy .nil) (.var fresh.1)) with
          | err err =>
            have h_false : False := by
              simp [h_fn, h_arg, fresh, h_unify] at h
            exact False.elim h_false
          | ok stU =>
            simp [h_fn, h_arg, fresh, h_unify] at h
            rcases h with ⟨_, hty⟩
            subst hty
            exact h_app env fn arg fnTy argTy fresh.2 stU fuel fresh.1
              (inferExprUnify_sound_preconditioned h_app h_proj st fuel env fn stFn fnTy h_fn)
              (inferExprUnify_sound_preconditioned h_app h_proj stFn fuel env arg stArg argTy h_arg)
              h_unify
    | letE name value body =>
      intro st' ty h
      simp [inferExprUnify] at h
      cases h_value : inferExprUnify st fuel env value with
      | err err =>
        simp [h_value] at h
      | ok stValue valueTy =>
        exact HasType.letE env name value body valueTy ty
          (inferExprUnify_sound_preconditioned h_app h_proj st fuel env value stValue valueTy h_value)
          (inferExprUnify_sound_preconditioned h_app h_proj stValue fuel ((name, valueTy) :: env) body st' ty (by
            simpa [h_value] using h))
    | record fields =>
      intro st' ty h
      simp [inferExprUnify] at h
      cases h_fields : inferFieldsUnify st fuel env fields with
      | err err =>
        simp [h_fields] at h
      | ok stFields fieldsTy =>
        cases fieldsTy with
        | row rowTy =>
          cases rowTy with
          | mk rf rest =>
            cases rest with
            | some rv =>
              simp [h_fields] at h
            | none =>
              simp [h_fields] at h
              rcases h with ⟨_, hty⟩
              subst hty
              exact HasType.record env fields rf
                (inferFieldsUnify_sound_preconditioned h_app h_proj st fuel env fields stFields rf (by
                  simp [h_fields]))
        | int | intN _ _ | float | floatN _ | decimal _ _ | bool | string | html | markdown | atom | date | dateTime | unit =>
          simp [h_fields] at h
        | list _ | map _ _ | set _ | option _ | result _ _ | existential _ _ | fixedSizeList _ _ | tensor _ _ | sum _ _ | «opaque» _ _
          | function _ _ | functionEff _ _ _ | «forall» _ _ | app _ _ | constructor _ _ _ | record _ _ | anonRecord _ | dataframe _ | groupedFrame _ _ | tagged _ _ | dynamic | column _ | stream _ | task _ | actor _ | arc _
          | var _ | tuple _ =>
          simp [h_fields] at h
    | proj recv label =>
      intro st' ty h
      simp [inferExprUnify] at h
      cases h_recv : inferExprUnify st fuel env recv with
      | err err =>
        simp [h_recv] at h
      | ok stRecv recvTy =>
        let freshTy := stRecv.freshTypeVar
        let freshRow := freshTy.2.freshRowVar
        cases h_unify :
            unify freshRow.2 fuel recvTy
              (Ty.anonRecord (.mk (.cons label (.var freshTy.1) .nil) (some freshRow.1))) with
        | err err =>
          have h_false : False := by
            simp [h_recv, freshTy, freshRow, h_unify] at h
          exact False.elim h_false
        | ok stU =>
          simp [h_recv, freshTy, freshRow, h_unify] at h
          rcases h with ⟨_, hty⟩
          subst hty
          exact h_proj env recv label recvTy freshRow.2 stU fuel freshTy.1 freshRow.1
            (inferExprUnify_sound_preconditioned h_app h_proj st fuel env recv stRecv recvTy h_recv)
            h_unify

  /-- Field-level counterpart of `inferExprUnify_sound_preconditioned`. -/
  theorem inferFieldsUnify_sound_preconditioned
      (h_app : AppUnifySoundHook)
      (h_proj : ProjUnifySoundHook) :
      ∀ st fuel env fs st' rf,
        inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
        HasFieldsType env fs rf := by
    intro st fuel env fs
    cases fs with
    | nil =>
      intro st' rf h
      simp [inferFieldsUnify] at h
      rcases h with ⟨_, hrf⟩
      subst hrf
      exact HasFieldsType.nil env
    | cons label e rest =>
      intro st' rf h
      simp [inferFieldsUnify] at h
      cases h_head : inferExprUnify st fuel env e with
      | err err =>
        simp [h_head] at h
      | ok stHead tyHead =>
        cases h_rest : inferFieldsUnify stHead fuel env rest with
        | err err =>
          simp [h_head, h_rest] at h
        | ok stRest restTy =>
          cases restTy with
          | row rowTy =>
            cases rowTy with
            | mk restFields restVar =>
              cases restVar with
              | some rv =>
                simp [h_head, h_rest] at h
              | none =>
                simp [h_head, h_rest] at h
                rcases h with ⟨_, hrf⟩
                subst hrf
                exact HasFieldsType.cons env label e rest tyHead restFields
                  (inferExprUnify_sound_preconditioned h_app h_proj st fuel env e stHead tyHead h_head)
                  (inferFieldsUnify_sound_preconditioned h_app h_proj stHead fuel env rest stRest restFields (by
                    simp [h_rest]))
          | int | intN _ _ | float | floatN _ | decimal _ _ | bool | string | html | markdown | atom | date | dateTime | unit =>
            simp [h_head, h_rest] at h
          | list _ | map _ _ | set _ | option _ | result _ _ | existential _ _ | fixedSizeList _ _ | tensor _ _ | sum _ _ | «opaque» _ _
            | function _ _ | functionEff _ _ _ | «forall» _ _ | app _ _ | constructor _ _ _ | record _ _ | anonRecord _ | dataframe _ | groupedFrame _ _ | tagged _ _ | dynamic | column _ | stream _ | task _ | actor _ | arc _
            | var _ | tuple _ =>
            simp [h_head, h_rest] at h
end

mutual
  /--
  Direct `HasTypeU` recursive soundness for unification-threaded inference.
  App/proj branches are discharged via `HasTypeU`-targeted hook interfaces.
  -/
  theorem inferExprUnify_sound_preconditioned_hasTypeU_direct
      (h_app : AppUnifySoundHookU)
      (h_proj : ProjUnifySoundHookU) :
      ∀ st fuel env e st' ty,
        inferExprUnify st fuel env e = .ok st' ty →
        HasTypeU env e ty := by
    intro st fuel env e
    cases e with
    | intLit n =>
      intro st' ty h
      simp [inferExprUnify] at h
      rcases h with ⟨_, hty⟩
      subst hty
      exact HasTypeU.int env n
    | boolLit b =>
      intro st' ty h
      simp [inferExprUnify] at h
      rcases h with ⟨_, hty⟩
      subst hty
      exact HasTypeU.bool env b
    | stringLit s =>
      intro st' ty h
      simp [inferExprUnify] at h
      rcases h with ⟨_, hty⟩
      subst hty
      exact HasTypeU.string env s
    | var name =>
      intro st' ty h
      cases h_lookup : TermEnv.lookup env name with
      | none =>
        simp [inferExprUnify, h_lookup] at h
      | some vty =>
        simp [inferExprUnify, h_lookup] at h
        rcases h with ⟨_, hty⟩
        subst hty
        exact HasTypeU.var env name vty h_lookup
    | lam param paramTy body =>
      intro st' ty h
      simp [inferExprUnify] at h
      cases h_body : inferExprUnify st fuel ((param, paramTy) :: env) body with
      | err err =>
        simp [h_body] at h
      | ok stBody bodyTy =>
        simp [h_body] at h
        rcases h with ⟨_, hty⟩
        subst hty
        exact HasTypeU.lam env param paramTy bodyTy body
          (inferExprUnify_sound_preconditioned_hasTypeU_direct h_app h_proj
            st fuel ((param, paramTy) :: env) body stBody bodyTy h_body)
    | app fn arg =>
      intro st' ty h
      simp [inferExprUnify] at h
      cases h_fn : inferExprUnify st fuel env fn with
      | err err =>
        simp [h_fn] at h
      | ok stFn fnTy =>
        cases h_arg : inferExprUnify stFn fuel env arg with
        | err err =>
          simp [h_fn, h_arg] at h
        | ok stArg argTy =>
          let fresh := stArg.freshTypeVar
          cases h_unify : unify fresh.2 fuel fnTy (Ty.function (.cons argTy .nil) (.var fresh.1)) with
          | err err =>
            have h_false : False := by
              simp [h_fn, h_arg, fresh, h_unify] at h
            exact False.elim h_false
          | ok stU =>
            simp [h_fn, h_arg, fresh, h_unify] at h
            rcases h with ⟨_, hty⟩
            subst hty
            exact h_app env fn arg fnTy argTy fresh.2 stU fuel fresh.1
              (inferExprUnify_sound_preconditioned_hasTypeU_direct h_app h_proj st fuel env fn stFn fnTy h_fn)
              (inferExprUnify_sound_preconditioned_hasTypeU_direct h_app h_proj stFn fuel env arg stArg argTy h_arg)
              h_unify
    | letE name value body =>
      intro st' ty h
      simp [inferExprUnify] at h
      cases h_value : inferExprUnify st fuel env value with
      | err err =>
        simp [h_value] at h
      | ok stValue valueTy =>
        exact HasTypeU.letE env name value body valueTy ty
          (inferExprUnify_sound_preconditioned_hasTypeU_direct h_app h_proj st fuel env value stValue valueTy h_value)
          (inferExprUnify_sound_preconditioned_hasTypeU_direct h_app h_proj stValue fuel ((name, valueTy) :: env) body st' ty (by
            simpa [h_value] using h))
    | record fields =>
      intro st' ty h
      simp [inferExprUnify] at h
      cases h_fields : inferFieldsUnify st fuel env fields with
      | err err =>
        simp [h_fields] at h
      | ok stFields fieldsTy =>
        cases fieldsTy with
        | row rowTy =>
          cases rowTy with
          | mk rf rest =>
            cases rest with
            | some rv =>
              simp [h_fields] at h
            | none =>
              simp [h_fields] at h
              rcases h with ⟨_, hty⟩
              subst hty
              exact HasTypeU.record env fields rf
                (inferFieldsUnify_sound_preconditioned_hasTypeU_direct h_app h_proj st fuel env fields stFields rf (by
                  simp [h_fields]))
        | int | intN _ _ | float | floatN _ | decimal _ _ | bool | string | html | markdown | atom | date | dateTime | unit =>
          simp [h_fields] at h
        | list _ | map _ _ | set _ | option _ | result _ _ | existential _ _ | fixedSizeList _ _ | tensor _ _ | sum _ _ | «opaque» _ _
          | function _ _ | functionEff _ _ _ | «forall» _ _ | app _ _ | constructor _ _ _ | record _ _ | anonRecord _ | dataframe _ | groupedFrame _ _ | tagged _ _ | dynamic | column _ | stream _ | task _ | actor _ | arc _
          | var _ | tuple _ =>
          simp [h_fields] at h
    | proj recv label =>
      intro st' ty h
      simp [inferExprUnify] at h
      cases h_recv : inferExprUnify st fuel env recv with
      | err err =>
        simp [h_recv] at h
      | ok stRecv recvTy =>
        let freshTy := stRecv.freshTypeVar
        let freshRow := freshTy.2.freshRowVar
        cases h_unify :
            unify freshRow.2 fuel recvTy
              (Ty.anonRecord (.mk (.cons label (.var freshTy.1) .nil) (some freshRow.1))) with
        | err err =>
          have h_false : False := by
            simp [h_recv, freshTy, freshRow, h_unify] at h
          exact False.elim h_false
        | ok stU =>
          simp [h_recv, freshTy, freshRow, h_unify] at h
          rcases h with ⟨_, hty⟩
          subst hty
          exact h_proj env recv label recvTy freshRow.2 stU fuel freshTy.1 freshRow.1
            (inferExprUnify_sound_preconditioned_hasTypeU_direct h_app h_proj st fuel env recv stRecv recvTy h_recv)
            h_unify

  theorem inferFieldsUnify_sound_preconditioned_hasTypeU_direct
      (h_app : AppUnifySoundHookU)
      (h_proj : ProjUnifySoundHookU) :
      ∀ st fuel env fs st' rf,
        inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
        HasFieldsTypeU env fs rf := by
    intro st fuel env fs
    cases fs with
    | nil =>
      intro st' rf h
      simp [inferFieldsUnify] at h
      rcases h with ⟨_, hrf⟩
      subst hrf
      exact HasFieldsTypeU.nil env
    | cons label e rest =>
      intro st' rf h
      simp [inferFieldsUnify] at h
      cases h_head : inferExprUnify st fuel env e with
      | err err =>
        simp [h_head] at h
      | ok stHead tyHead =>
        cases h_rest : inferFieldsUnify stHead fuel env rest with
        | err err =>
          simp [h_head, h_rest] at h
        | ok stRest restTy =>
          cases restTy with
          | row rowTy =>
            cases rowTy with
            | mk restFields restVar =>
              cases restVar with
              | some rv =>
                simp [h_head, h_rest] at h
              | none =>
                simp [h_head, h_rest] at h
                rcases h with ⟨_, hrf⟩
                subst hrf
                exact HasFieldsTypeU.cons env label e rest tyHead restFields
                  (inferExprUnify_sound_preconditioned_hasTypeU_direct h_app h_proj st fuel env e stHead tyHead h_head)
                  (inferFieldsUnify_sound_preconditioned_hasTypeU_direct h_app h_proj stHead fuel env rest stRest restFields (by
                    simp [h_rest]))
          | int | intN _ _ | float | floatN _ | decimal _ _ | bool | string | html | markdown | atom | date | dateTime | unit =>
            simp [h_head, h_rest] at h
          | list _ | map _ _ | set _ | option _ | result _ _ | existential _ _ | fixedSizeList _ _ | tensor _ _ | sum _ _ | «opaque» _ _
            | function _ _ | functionEff _ _ _ | «forall» _ _ | app _ _ | constructor _ _ _ | record _ _ | anonRecord _ | dataframe _ | groupedFrame _ _ | tagged _ _ | dynamic | column _ | stream _ | task _ | actor _ | arc _
            | var _ | tuple _ =>
            simp [h_head, h_rest] at h
end

/--
Determinism of `inferExprUnify`: for fixed `(st, fuel, env, e)`, successful
results are unique in both state and type.
-/
theorem inferExprUnify_deterministic
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    {st₁ st₂ : UnifyState} {ty₁ ty₂ : Ty}
    (h₁ : inferExprUnify st fuel env e = .ok st₁ ty₁)
    (h₂ : inferExprUnify st fuel env e = .ok st₂ ty₂) :
    st₁ = st₂ ∧ ty₁ = ty₂ := by
  rw [h₁] at h₂
  cases h₂
  exact ⟨rfl, rfl⟩

/--
Type uniqueness from the full preconditioned theorem: once an `inferExprUnify`
run succeeds, any declarative typing derivation for the same expression has the
same type.
-/
theorem inferExprUnify_type_unique_preconditioned
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    {st st' : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr} {ty ty' : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_ty' : HasType env e ty') :
    ty' = ty := by
  have h_ty : HasType env e ty :=
    inferExprUnify_sound_preconditioned h_app h_proj st fuel env e st' ty h_ok
  have h_alg : inferExpr env e = some ty := inferExpr_complete env e ty h_ty
  have h_alg' : inferExpr env e = some ty' := inferExpr_complete env e ty' h_ty'
  rw [h_alg] at h_alg'
  injection h_alg' with h_eq
  exact h_eq.symm

/--
Packaged principal-typing slice on the current preconditioned boundary.

Given one successful `inferExprUnify` run, this bundle exports:
- uniqueness of successful algorithmic outputs at the same input,
- uniqueness against any declarative typing derivation,
- and agreement with the syntax-directed `inferExpr` result.
-/
structure PrincipalTypingSlicePreconditioned
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  deterministic :
    ∀ {st'' : UnifyState} {ty'' : Ty},
      inferExprUnify st fuel env e = .ok st'' ty'' →
      st'' = st' ∧ ty'' = ty
  declarativeUnique :
    ∀ {ty' : Ty}, HasType env e ty' → ty' = ty
  inferExprAgrees :
    inferExpr env e = some ty

theorem principalTypingSlicePreconditioned_of_success
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty := by
  refine {
    deterministic := ?_
    declarativeUnique := ?_
    inferExprAgrees := ?_
  }
  · intro st'' ty'' h_ok'
    exact inferExprUnify_deterministic st fuel env e h_ok' h_ok
  · intro ty' h_ty'
    exact inferExprUnify_type_unique_preconditioned h_app h_proj h_ok h_ty'
  · have h_ty : HasType env e ty :=
      inferExprUnify_sound_preconditioned h_app h_proj st fuel env e st' ty h_ok
    exact inferExpr_complete env e ty h_ty

/--
Determinism of `inferFieldsUnify`: for fixed `(st, fuel, env, fs)`, successful
results are unique in both state and closed row-fields payload.
-/
theorem inferFieldsUnify_deterministic
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    {st₁ st₂ : UnifyState} {rf₁ rf₂ : RowFields}
    (h₁ : inferFieldsUnify st fuel env fs = .ok st₁ (.row (.mk rf₁ none)))
    (h₂ : inferFieldsUnify st fuel env fs = .ok st₂ (.row (.mk rf₂ none))) :
    st₁ = st₂ ∧ rf₁ = rf₂ := by
  rw [h₁] at h₂
  cases h₂
  exact ⟨rfl, rfl⟩

/--
Row-fields uniqueness from the full preconditioned theorem: once an
`inferFieldsUnify` run succeeds, any declarative field typing derivation for
the same field list has the same row-fields payload.
-/
theorem inferFieldsUnify_row_unique_preconditioned
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    {st st' : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {rf rf' : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_rf' : HasFieldsType env fs rf') :
    rf' = rf := by
  have h_rf : HasFieldsType env fs rf :=
    inferFieldsUnify_sound_preconditioned h_app h_proj st fuel env fs st' rf h_ok
  exact hasFieldsType_unique h_rf' h_rf

/--
Packaged preconditioned principal-field-typing slice.

Given one successful `inferFieldsUnify` run, this bundle exports:
- uniqueness of successful algorithmic outputs at the same input,
- uniqueness against any declarative field typing derivation,
- and agreement with the syntax-directed `inferFields` result.
-/
structure PrincipalFieldTypingSlicePreconditioned
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  deterministic :
    ∀ {st'' : UnifyState} {rf'' : RowFields},
      inferFieldsUnify st fuel env fs = .ok st'' (.row (.mk rf'' none)) →
      st'' = st' ∧ rf'' = rf
  declarativeUnique :
    ∀ {rf' : RowFields}, HasFieldsType env fs rf' → rf' = rf
  inferFieldsAgrees :
    inferFields env fs = some rf

theorem principalFieldTypingSlicePreconditioned_of_success
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf := by
  refine {
    deterministic := ?_
    declarativeUnique := ?_
    inferFieldsAgrees := ?_
  }
  · intro st'' rf'' h_ok'
    exact inferFieldsUnify_deterministic st fuel env fs h_ok' h_ok
  · intro rf' h_rf'
    exact inferFieldsUnify_row_unique_preconditioned h_app h_proj h_ok h_rf'
  · have h_rf : HasFieldsType env fs rf :=
      inferFieldsUnify_sound_preconditioned h_app h_proj st fuel env fs st' rf h_ok
    exact inferFields_complete env fs rf h_rf

/--
Bundle-entry variant of `principalFieldTypingSlicePreconditioned_of_success`.
-/
theorem principalFieldTypingSlicePreconditioned_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  exact principalFieldTypingSlicePreconditioned_of_success
    h_hooks.1 h_hooks.2 st fuel env fs st' rf h_ok

/--
Successful preconditioned `inferFieldsUnify` runs induce the core principal
field-typing package on the same `(env, fs, rf)` surface.
-/
theorem principalFieldTypingSliceCore_of_preconditioned_success
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf := by
  have h_pre :
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
    principalFieldTypingSlicePreconditioned_of_success h_app h_proj st fuel env fs st' rf h_ok
  exact principalFieldTypingSliceCore_of_infer h_pre.inferFieldsAgrees

/--
Bundle-entry variant of `principalFieldTypingSliceCore_of_preconditioned_success`.
-/
theorem principalFieldTypingSliceCore_of_preconditioned_success_from_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf := by
  exact principalFieldTypingSliceCore_of_preconditioned_success
    h_hooks.1 h_hooks.2 st fuel env fs st' rf h_ok

/--
If a core principal-field-typing package is already available for
`(env, fs, rf)`, any successful `inferFieldsUnify` run to that same row-fields
payload yields the full preconditioned principal field-typing bundle,
independent of hook assumptions.
-/
theorem principalFieldTypingSlicePreconditioned_of_success_of_core_principal
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_core : PrincipalFieldTypingSliceCore env fs rf)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf := by
  intro h_app h_proj
  refine {
    deterministic := ?_
    declarativeUnique := ?_
    inferFieldsAgrees := ?_
  }
  · intro st'' rf'' h_ok'
    exact inferFieldsUnify_deterministic st fuel env fs h_ok' h_ok
  · intro rf' h_rf'
    exact h_core.unique h_rf'
  · exact inferFields_complete env fs rf h_core.sound

/--
Hook-independent preconditioned principal field-typing bundle on the no-unify
fragment.
-/
theorem principalFieldTypingSlicePreconditioned_of_success_no_unify
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf := by
  have h_core : PrincipalFieldTypingSliceCore env fs rf :=
    principalFieldTypingSliceCore_of_unify_success_no_unify h_no h_ok
  exact principalFieldTypingSlicePreconditioned_of_success_of_core_principal
    h_core h_ok

/--
Bundle-entry variant of
`principalFieldTypingSlicePreconditioned_of_success_no_unify`.
-/
theorem principalFieldTypingSlicePreconditioned_of_success_no_unify_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  exact principalFieldTypingSlicePreconditioned_of_success_no_unify
    h_no h_ok h_hooks.1 h_hooks.2

/--
On successful field runs, the preconditioned principal field slice and core
principal field slice are equivalent.
-/
theorem principalFieldTypingSlicePreconditioned_iff_core_of_success
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf := by
  constructor
  · intro h_pre
    exact principalFieldTypingSliceCore_of_infer h_pre.inferFieldsAgrees
  · intro h_core
    exact principalFieldTypingSlicePreconditioned_of_success_of_core_principal
      h_core h_ok h_app h_proj

/--
Bundle-entry variant of `principalFieldTypingSlicePreconditioned_iff_core_of_success`.
-/
theorem principalFieldTypingSlicePreconditioned_iff_core_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf := by
  exact principalFieldTypingSlicePreconditioned_iff_core_of_success
    h_hooks.1 h_hooks.2 st fuel env fs st' rf h_ok

/--
Packaged no-unify field principal bridge: one successful hook-free
`inferFieldsUnify` run yields both the core principal field package and the
preconditioned principal field package.
-/
structure PrincipalFieldNoUnifyBridgeBundle
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  core : PrincipalFieldTypingSliceCore env fs rf
  preconditioned : PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf

/--
Construct the no-unify field bridge bundle from one successful hook-free
`inferFieldsUnify` run.
-/
theorem principalFieldNoUnifyBridgeBundle_of_success
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldNoUnifyBridgeBundle h_app h_proj st fuel env fs st' rf := by
  intro h_app h_proj
  let h_core : PrincipalFieldTypingSliceCore env fs rf :=
    principalFieldTypingSliceCore_of_unify_success_no_unify h_no h_ok
  refine {
    core := h_core
    preconditioned := ?_
  }
  exact principalFieldTypingSlicePreconditioned_of_success_of_core_principal
    h_core h_ok h_app h_proj

/--
Bundle-entry variant of `principalFieldNoUnifyBridgeBundle_of_success`.
-/
theorem principalFieldNoUnifyBridgeBundle_of_success_from_hook_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  exact principalFieldNoUnifyBridgeBundle_of_success h_no h_ok h_hooks.1 h_hooks.2

/--
Bundle-entry variant of `principalTypingSlicePreconditioned_of_success`.
-/
theorem principalTypingSlicePreconditioned_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  exact principalTypingSlicePreconditioned_of_success
    h_hooks.1 h_hooks.2 st fuel env e st' ty h_ok

/--
On successful expression runs, the preconditioned principal slice and core
principal slice are equivalent.
-/
theorem principalTypingSlicePreconditioned_iff_core_of_success
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty := by
  constructor
  · intro h_pre
    exact principalTypingSliceCore_of_infer h_pre.inferExprAgrees
  · intro h_core
    refine {
      deterministic := ?_
      declarativeUnique := ?_
      inferExprAgrees := ?_
    }
    · intro st'' ty'' h_ok'
      exact inferExprUnify_deterministic st fuel env e h_ok' h_ok
    · intro ty' h_ty'
      exact h_core.unique h_ty'
    · exact inferExpr_complete env e ty h_core.sound

/--
Bundle-entry variant of `principalTypingSlicePreconditioned_iff_core_of_success`.
-/
theorem principalTypingSlicePreconditioned_iff_core_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty := by
  exact principalTypingSlicePreconditioned_iff_core_of_success
    h_hooks.1 h_hooks.2 st fuel env e st' ty h_ok

/--
Packaged successful-run preconditioned↔core principality slice for expressions.
-/
def PrincipalPreconditionedExprCoreIffSlice : Prop :=
  ∀ (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty),
    inferExprUnify st fuel env e = .ok st' ty →
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty)

/--
Packaged successful-run preconditioned↔core principality slice for fields.
-/
def PrincipalPreconditionedFieldCoreIffSlice : Prop :=
  ∀ (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields),
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf)

/-- Combined successful-run preconditioned↔core principality slice. -/
def PrincipalPreconditionedCoreIffSlices : Prop :=
  PrincipalPreconditionedExprCoreIffSlice ∧ PrincipalPreconditionedFieldCoreIffSlice

/-- The combined preconditioned↔core principality slice is fully proved. -/
theorem principalPreconditionedCoreIffSlices_proved : PrincipalPreconditionedCoreIffSlices := by
  refine ⟨?_, ?_⟩
  · intro h_hooks st fuel env e st' ty h_ok
    exact principalTypingSlicePreconditioned_iff_core_of_success_from_bundle
      h_hooks st fuel env e st' ty h_ok
  · intro h_hooks st fuel env fs st' rf h_ok
    exact principalFieldTypingSlicePreconditioned_iff_core_of_success_from_bundle
      h_hooks st fuel env fs st' rf h_ok

/--
One-hop projection: expression branch from combined preconditioned↔core slice.
-/
theorem principalPreconditionedCoreIffSlices_expr
    (h_slice : PrincipalPreconditionedCoreIffSlices)
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  h_slice.1 h_hooks st fuel env e st' ty h_ok

/--
One-hop projection: field branch from combined preconditioned↔core slice.
-/
theorem principalPreconditionedCoreIffSlices_field
    (h_slice : PrincipalPreconditionedCoreIffSlices)
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  h_slice.2 h_hooks st fuel env fs st' rf h_ok

/--
Successful preconditioned `inferExprUnify` runs induce the core principal
typing package on the same `(env, e, ty)` surface.
-/
theorem principalTypingSliceCore_of_preconditioned_success
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty := by
  have h_pre :
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
    principalTypingSlicePreconditioned_of_success h_app h_proj st fuel env e st' ty h_ok
  exact principalTypingSliceCore_of_infer h_pre.inferExprAgrees

/--
Bundle-entry variant of `principalTypingSliceCore_of_preconditioned_success`.
-/
theorem principalTypingSliceCore_of_preconditioned_success_from_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty := by
  exact principalTypingSliceCore_of_preconditioned_success
    h_hooks.1 h_hooks.2 st fuel env e st' ty h_ok

/--
If a core principal-typing package is already available for `(env, e, ty)`,
any successful `inferExprUnify` run to that same type yields the full
preconditioned principal bundle, independent of hook assumptions.
-/
theorem principalTypingSlicePreconditioned_of_success_of_core_principal
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_core : PrincipalTypingSliceCore env e ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty := by
  intro h_app h_proj
  refine {
    deterministic := ?_
    declarativeUnique := ?_
    inferExprAgrees := ?_
  }
  · intro st'' ty'' h_ok'
    exact inferExprUnify_deterministic st fuel env e h_ok' h_ok
  · intro ty' h_ty'
    exact h_core.unique h_ty'
  · exact inferExpr_complete env e ty h_core.sound

/--
Hook-independent principal-typing bundle on the no-unify fragment.

When `e` never executes app/proj unification branches, successful
`inferExprUnify` runs determine the same principal consequences as the
preconditioned bundle, independent of app/proj hook assumptions.
-/
theorem principalTypingSlicePreconditioned_of_success_no_unify
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty := by
  have h_core : PrincipalTypingSliceCore env e ty :=
    principalTypingSliceCore_of_unify_success_no_unify h_no h_ok
  exact principalTypingSlicePreconditioned_of_success_of_core_principal
    h_core h_ok

/--
Bundle-entry variant of `principalTypingSlicePreconditioned_of_success_no_unify`.
-/
theorem principalTypingSlicePreconditioned_of_success_no_unify_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  exact principalTypingSlicePreconditioned_of_success_no_unify
    h_no h_ok h_hooks.1 h_hooks.2

/--
Packaged no-unify principal bridge: one successful hook-free `inferExprUnify`
run yields both the core principal package and the preconditioned principal
package.
-/
structure PrincipalNoUnifyBridgeBundle
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  core : PrincipalTypingSliceCore env e ty
  preconditioned : PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty

/--
Construct the no-unify bridge bundle from one successful hook-free
`inferExprUnify` run.
-/
theorem principalNoUnifyBridgeBundle_of_success
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalNoUnifyBridgeBundle h_app h_proj st fuel env e st' ty := by
  intro h_app h_proj
  let h_core : PrincipalTypingSliceCore env e ty :=
    principalTypingSliceCore_of_unify_success_no_unify h_no h_ok
  refine {
    core := h_core
    preconditioned := ?_
  }
  exact principalTypingSlicePreconditioned_of_success_of_core_principal
    h_core h_ok h_app h_proj

/--
Bundle-entry variant of `principalNoUnifyBridgeBundle_of_success`.
-/
theorem principalNoUnifyBridgeBundle_of_success_from_hook_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  exact principalNoUnifyBridgeBundle_of_success h_no h_ok h_hooks.1 h_hooks.2

/-- Packaged no-unify expression principal bridge slice (bundle-entry form). -/
def PrincipalNoUnifyExprBridgeSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    (h_hooks : UnifyHookPremises) →
    PrincipalNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env e st' ty

/-- Packaged no-unify field principal bridge slice (bundle-entry form). -/
def PrincipalNoUnifyFieldBridgeSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    (h_hooks : UnifyHookPremises) →
    PrincipalFieldNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env fs st' rf

/-- Combined no-unify principal bridge slice across expressions and fields. -/
def PrincipalNoUnifyBridgeSlices : Prop :=
  PrincipalNoUnifyExprBridgeSlice ∧ PrincipalNoUnifyFieldBridgeSlice

/-- The combined no-unify principal bridge slice is fully proved. -/
theorem principalNoUnifyBridgeSlices_proved : PrincipalNoUnifyBridgeSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok h_hooks
    exact principalNoUnifyBridgeBundle_of_success_from_hook_bundle
      h_no h_ok h_hooks
  · intro st fuel env fs st' rf h_no h_ok h_hooks
    exact principalFieldNoUnifyBridgeBundle_of_success_from_hook_bundle
      h_no h_ok h_hooks

/-- One-hop projection: expression branch from combined no-unify bridge slice. -/
theorem principalNoUnifyBridgeSlices_expr
    (h_slice : PrincipalNoUnifyBridgeSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  h_slice.1 h_no h_ok h_hooks

/-- One-hop projection: field branch from combined no-unify bridge slice. -/
theorem principalNoUnifyBridgeSlices_field
    (h_slice : PrincipalNoUnifyBridgeSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  h_slice.2 h_no h_ok h_hooks

/--
Combined M4 principal boundary bridge suite.

This packages the two capstones needed at the current boundary:
- hook-free no-unify bridge slices, and
- successful-run preconditioned↔core equivalence slices.
-/
structure PrincipalBoundaryBridgeSuite : Prop where
  noUnify : PrincipalNoUnifyBridgeSlices
  preconditionedCoreIff : PrincipalPreconditionedCoreIffSlices

/-- Explicit component alias for `PrincipalBoundaryBridgeSuite`. -/
abbrev PrincipalBoundaryBridgeSuiteComponents : Prop :=
  PrincipalNoUnifyBridgeSlices ∧ PrincipalPreconditionedCoreIffSlices

/-- The combined principal boundary bridge suite is fully proved. -/
theorem principalBoundaryBridgeSuite_proved : PrincipalBoundaryBridgeSuite := by
  refine {
    noUnify := principalNoUnifyBridgeSlices_proved
    preconditionedCoreIff := principalPreconditionedCoreIffSlices_proved
  }

/-- `PrincipalBoundaryBridgeSuite` is equivalent to its explicit components. -/
theorem principalBoundaryBridgeSuite_iff_components :
    PrincipalBoundaryBridgeSuite ↔ PrincipalBoundaryBridgeSuiteComponents := by
  constructor
  · intro h_suite
    exact ⟨h_suite.noUnify, h_suite.preconditionedCoreIff⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2⟩

/-- Build `PrincipalBoundaryBridgeSuite` from explicit components. -/
theorem principalBoundaryBridgeSuite_of_components
    (h_comp : PrincipalBoundaryBridgeSuiteComponents) :
    PrincipalBoundaryBridgeSuite :=
  (principalBoundaryBridgeSuite_iff_components).2 h_comp

/-- Decompose `PrincipalBoundaryBridgeSuite` into explicit components. -/
theorem principalBoundaryBridgeSuite_as_components
    (h_suite : PrincipalBoundaryBridgeSuite) :
    PrincipalBoundaryBridgeSuiteComponents :=
  (principalBoundaryBridgeSuite_iff_components).1 h_suite

/-- Direct components-route decomposition for `PrincipalBoundaryBridgeSuite`. -/
theorem principalBoundaryBridgeSuite_as_components_of_components
    (h_comp : PrincipalBoundaryBridgeSuiteComponents) :
    PrincipalBoundaryBridgeSuiteComponents :=
  (principalBoundaryBridgeSuite_iff_components).1
    (principalBoundaryBridgeSuite_of_components h_comp)

/-- One-hop expression no-unify bridge projection from the suite. -/
theorem principalBoundaryBridgeSuite_noUnify_expr
    (h_suite : PrincipalBoundaryBridgeSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyBridgeSlices_expr h_suite.noUnify h_no h_ok h_hooks

/-- One-hop field no-unify bridge projection from the suite. -/
theorem principalBoundaryBridgeSuite_noUnify_field
    (h_suite : PrincipalBoundaryBridgeSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyBridgeSlices_field h_suite.noUnify h_no h_ok h_hooks

/-- One-hop expression preconditioned↔core equivalence projection from suite. -/
theorem principalBoundaryBridgeSuite_preconditionedCoreIff_expr
    (h_suite : PrincipalBoundaryBridgeSuite)
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffSlices_expr
    h_suite.preconditionedCoreIff h_hooks st fuel env e st' ty h_ok

/-- One-hop field preconditioned↔core equivalence projection from suite. -/
theorem principalBoundaryBridgeSuite_preconditionedCoreIff_field
    (h_suite : PrincipalBoundaryBridgeSuite)
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffSlices_field
    h_suite.preconditionedCoreIff h_hooks st fuel env fs st' rf h_ok

/--
Convenience wrapper: derive core principality from successful no-unify
expression inference via the proved boundary suite.
-/
theorem principalNoUnifyCoreExpr_of_success_via_suite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty := by
  exact (principalBoundaryBridgeSuite_noUnify_expr
      principalBoundaryBridgeSuite_proved h_no h_ok h_hooks).core

/--
Convenience wrapper: derive preconditioned principality from successful
no-unify expression inference via the proved boundary suite.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_suite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  exact (principalBoundaryBridgeSuite_noUnify_expr
      principalBoundaryBridgeSuite_proved h_no h_ok h_hooks).preconditioned

/--
Convenience wrapper: derive core field principality from successful no-unify
field inference via the proved boundary suite.
-/
theorem principalNoUnifyCoreField_of_success_via_suite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf := by
  exact (principalBoundaryBridgeSuite_noUnify_field
      principalBoundaryBridgeSuite_proved h_no h_ok h_hooks).core

/--
Convenience wrapper: derive preconditioned field principality from successful
no-unify field inference via the proved boundary suite.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_suite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  exact (principalBoundaryBridgeSuite_noUnify_field
      principalBoundaryBridgeSuite_proved h_no h_ok h_hooks).preconditioned

/-- Bundled-seed alias for no-unify core expression via the proved boundary suite. -/
theorem principalNoUnifyCoreExpr_of_success_via_suite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_suite h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify preconditioned expression via the proved boundary suite. -/
theorem principalNoUnifyPreconditionedExpr_of_success_via_suite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_suite h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify core field via the proved boundary suite. -/
theorem principalNoUnifyCoreField_of_success_via_suite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_suite h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify preconditioned field via the proved boundary suite. -/
theorem principalNoUnifyPreconditionedField_of_success_via_suite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_suite h_no h_ok h_hooks

/--
Convenience wrapper: convert preconditioned -> core principality on successful
expression runs via the proved boundary suite.
-/
theorem principalCoreExpr_of_preconditioned_success_via_suite
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_pre : PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty) :
    PrincipalTypingSliceCore env e ty := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_expr
      principalBoundaryBridgeSuite_proved h_hooks st fuel env e st' ty h_ok).1 h_pre

/--
Convenience wrapper: convert core -> preconditioned principality on successful
expression runs via the proved boundary suite.
-/
theorem principalPreconditionedExpr_of_core_success_via_suite
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_core : PrincipalTypingSliceCore env e ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_expr
      principalBoundaryBridgeSuite_proved h_hooks st fuel env e st' ty h_ok).2 h_core

/--
Convenience wrapper: convert preconditioned -> core field principality on
successful field runs via the proved boundary suite.
-/
theorem principalCoreField_of_preconditioned_success_via_suite
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_pre : PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf) :
    PrincipalFieldTypingSliceCore env fs rf := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_field
      principalBoundaryBridgeSuite_proved h_hooks st fuel env fs st' rf h_ok).1 h_pre

/--
Convenience wrapper: convert core -> preconditioned field principality on
successful field runs via the proved boundary suite.
-/
theorem principalPreconditionedField_of_core_success_via_suite
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_core : PrincipalFieldTypingSliceCore env fs rf) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_field
      principalBoundaryBridgeSuite_proved h_hooks st fuel env fs st' rf h_ok).2 h_core

/--
Coherence (expression): the suite's no-unify preconditioned witness implies the
suite's core witness through the suite's preconditioned↔core equivalence.
-/
theorem principalBoundaryBridgeSuite_noUnify_expr_coherent_core
    (h_suite : PrincipalBoundaryBridgeSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_expr
      h_suite h_hooks st fuel env e st' ty h_ok).1
        ((principalBoundaryBridgeSuite_noUnify_expr
          h_suite h_no h_ok h_hooks).preconditioned)

/--
Coherence (expression): the suite's no-unify core witness implies the suite's
preconditioned witness through the suite's preconditioned↔core equivalence.
-/
theorem principalBoundaryBridgeSuite_noUnify_expr_coherent_preconditioned
    (h_suite : PrincipalBoundaryBridgeSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_expr
      h_suite h_hooks st fuel env e st' ty h_ok).2
        ((principalBoundaryBridgeSuite_noUnify_expr
          h_suite h_no h_ok h_hooks).core)

/--
Coherence (field): the suite's no-unify preconditioned witness implies the
suite's core witness through the suite's preconditioned↔core equivalence.
-/
theorem principalBoundaryBridgeSuite_noUnify_field_coherent_core
    (h_suite : PrincipalBoundaryBridgeSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_field
      h_suite h_hooks st fuel env fs st' rf h_ok).1
        ((principalBoundaryBridgeSuite_noUnify_field
          h_suite h_no h_ok h_hooks).preconditioned)

/--
Coherence (field): the suite's no-unify core witness implies the suite's
preconditioned witness through the suite's preconditioned↔core equivalence.
-/
theorem principalBoundaryBridgeSuite_noUnify_field_coherent_preconditioned
    (h_suite : PrincipalBoundaryBridgeSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_field
      h_suite h_hooks st fuel env fs st' rf h_ok).2
        ((principalBoundaryBridgeSuite_noUnify_field
          h_suite h_no h_ok h_hooks).core)

/--
No-unify expression capstone from the principal boundary suite.

Packages the no-unify bridge witness and successful-run
preconditioned↔core equivalence in one theorem surface.
-/
structure PrincipalBoundaryNoUnifyExprCapstone
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  noUnify : PrincipalNoUnifyBridgeBundle h_app h_proj st fuel env e st' ty
  preconditionedCoreIff :
    PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty

/--
Construct the no-unify expression capstone directly from successful no-unify
inference via the proved principal boundary suite.
-/
theorem principalBoundaryNoUnifyExprCapstone_of_success_via_suite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyExprCapstone
      h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  refine {
    noUnify := principalBoundaryBridgeSuite_noUnify_expr
      principalBoundaryBridgeSuite_proved h_no h_ok h_hooks
    preconditionedCoreIff := principalBoundaryBridgeSuite_preconditionedCoreIff_expr
      principalBoundaryBridgeSuite_proved h_hooks st fuel env e st' ty h_ok
  }

/-- Bundled-seed alias for suite-based no-unify expression capstone construction. -/
theorem principalBoundaryNoUnifyExprCapstone_of_success_via_suite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyExprCapstone
      h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalBoundaryNoUnifyExprCapstone_of_success_via_suite
    h_no h_ok h_hooks

/--
Unbundled-hook entrypoint for the no-unify expression capstone.
-/
theorem principalBoundaryNoUnifyExprCapstone_of_success
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalBoundaryNoUnifyExprCapstone
        h_app h_proj st fuel env e st' ty := by
  intro h_app h_proj
  exact principalBoundaryNoUnifyExprCapstone_of_success_via_suite
    h_no h_ok ⟨h_app, h_proj⟩

/--
Bundle-entry variant of `principalBoundaryNoUnifyExprCapstone_of_success`.
-/
theorem principalBoundaryNoUnifyExprCapstone_of_success_from_hook_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyExprCapstone
      h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  exact principalBoundaryNoUnifyExprCapstone_of_success
    h_no h_ok h_hooks.1 h_hooks.2

/-- One-hop projection: core expression principality from the expression capstone. -/
theorem principalBoundaryNoUnifyExprCapstone_core
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_cap : PrincipalBoundaryNoUnifyExprCapstone
      h_app h_proj st fuel env e st' ty) :
    PrincipalTypingSliceCore env e ty :=
  h_cap.noUnify.core

/-- One-hop projection: preconditioned expression principality from the capstone. -/
theorem principalBoundaryNoUnifyExprCapstone_preconditioned
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_cap : PrincipalBoundaryNoUnifyExprCapstone
      h_app h_proj st fuel env e st' ty) :
    PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  h_cap.noUnify.preconditioned

/--
Coherence (expression capstone): no-unify preconditioned witness implies the
core witness through the packaged successful-run equivalence.
-/
theorem principalBoundaryNoUnifyExprCapstone_coherent_core
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_cap : PrincipalBoundaryNoUnifyExprCapstone
      h_app h_proj st fuel env e st' ty) :
    PrincipalTypingSliceCore env e ty := by
  exact h_cap.preconditionedCoreIff.1 h_cap.noUnify.preconditioned

/--
Coherence (expression capstone): no-unify core witness implies the
preconditioned witness through the packaged successful-run equivalence.
-/
theorem principalBoundaryNoUnifyExprCapstone_coherent_preconditioned
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_cap : PrincipalBoundaryNoUnifyExprCapstone
      h_app h_proj st fuel env e st' ty) :
    PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty := by
  exact h_cap.preconditionedCoreIff.2 h_cap.noUnify.core

/--
No-unify field capstone from the principal boundary suite.

Packages the field no-unify bridge witness and successful-run
preconditioned↔core equivalence in one theorem surface.
-/
structure PrincipalBoundaryNoUnifyFieldCapstone
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  noUnify : PrincipalFieldNoUnifyBridgeBundle h_app h_proj st fuel env fs st' rf
  preconditionedCoreIff :
    PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf

/--
Construct the no-unify field capstone directly from successful no-unify field
inference via the proved principal boundary suite.
-/
theorem principalBoundaryNoUnifyFieldCapstone_of_success_via_suite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyFieldCapstone
      h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  refine {
    noUnify := principalBoundaryBridgeSuite_noUnify_field
      principalBoundaryBridgeSuite_proved h_no h_ok h_hooks
    preconditionedCoreIff := principalBoundaryBridgeSuite_preconditionedCoreIff_field
      principalBoundaryBridgeSuite_proved h_hooks st fuel env fs st' rf h_ok
  }

/-- Bundled-seed alias for suite-based no-unify field capstone construction. -/
theorem principalBoundaryNoUnifyFieldCapstone_of_success_via_suite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyFieldCapstone
      h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalBoundaryNoUnifyFieldCapstone_of_success_via_suite
    h_no h_ok h_hooks

/--
Unbundled-hook entrypoint for the no-unify field capstone.
-/
theorem principalBoundaryNoUnifyFieldCapstone_of_success
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalBoundaryNoUnifyFieldCapstone
        h_app h_proj st fuel env fs st' rf := by
  intro h_app h_proj
  exact principalBoundaryNoUnifyFieldCapstone_of_success_via_suite
    h_no h_ok ⟨h_app, h_proj⟩

/--
Bundle-entry variant of `principalBoundaryNoUnifyFieldCapstone_of_success`.
-/
theorem principalBoundaryNoUnifyFieldCapstone_of_success_from_hook_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyFieldCapstone
      h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  exact principalBoundaryNoUnifyFieldCapstone_of_success
    h_no h_ok h_hooks.1 h_hooks.2

/-- One-hop projection: core field principality from the field capstone. -/
theorem principalBoundaryNoUnifyFieldCapstone_core
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundaryNoUnifyFieldCapstone
      h_app h_proj st fuel env fs st' rf) :
    PrincipalFieldTypingSliceCore env fs rf :=
  h_cap.noUnify.core

/-- One-hop projection: preconditioned field principality from the field capstone. -/
theorem principalBoundaryNoUnifyFieldCapstone_preconditioned
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundaryNoUnifyFieldCapstone
      h_app h_proj st fuel env fs st' rf) :
    PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  h_cap.noUnify.preconditioned

/--
Coherence (field capstone): no-unify preconditioned witness implies the
core witness through the packaged successful-run equivalence.
-/
theorem principalBoundaryNoUnifyFieldCapstone_coherent_core
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundaryNoUnifyFieldCapstone
      h_app h_proj st fuel env fs st' rf) :
    PrincipalFieldTypingSliceCore env fs rf := by
  exact h_cap.preconditionedCoreIff.1 h_cap.noUnify.preconditioned

/--
Coherence (field capstone): no-unify core witness implies the
preconditioned witness through the packaged successful-run equivalence.
-/
theorem principalBoundaryNoUnifyFieldCapstone_coherent_preconditioned
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundaryNoUnifyFieldCapstone
      h_app h_proj st fuel env fs st' rf) :
    PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf := by
  exact h_cap.preconditionedCoreIff.2 h_cap.noUnify.core

/-- Packaged no-unify expression principal capstone slice. -/
def PrincipalBoundaryNoUnifyExprCapstoneSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    (h_hooks : UnifyHookPremises) →
    PrincipalBoundaryNoUnifyExprCapstone
      h_hooks.1 h_hooks.2 st fuel env e st' ty

/-- Packaged no-unify field principal capstone slice. -/
def PrincipalBoundaryNoUnifyFieldCapstoneSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    (h_hooks : UnifyHookPremises) →
    PrincipalBoundaryNoUnifyFieldCapstone
      h_hooks.1 h_hooks.2 st fuel env fs st' rf

/-- Combined no-unify principal capstone slice across expressions and fields. -/
def PrincipalBoundaryNoUnifyCapstoneSlices : Prop :=
  PrincipalBoundaryNoUnifyExprCapstoneSlice ∧
    PrincipalBoundaryNoUnifyFieldCapstoneSlice

/-- The combined no-unify principal capstone slice is fully proved. -/
theorem principalBoundaryNoUnifyCapstoneSlices_proved :
    PrincipalBoundaryNoUnifyCapstoneSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok h_hooks
    exact principalBoundaryNoUnifyExprCapstone_of_success_via_suite
      h_no h_ok h_hooks
  · intro st fuel env fs st' rf h_no h_ok h_hooks
    exact principalBoundaryNoUnifyFieldCapstone_of_success_via_suite
      h_no h_ok h_hooks

/--
One-hop projection: expression branch from combined no-unify principal capstone
slice.
-/
theorem principalBoundaryNoUnifyCapstoneSlices_expr
    (h_slice : PrincipalBoundaryNoUnifyCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyExprCapstone
      h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  h_slice.1 h_no h_ok h_hooks

/-- One-hop projection: field branch from combined no-unify principal capstone slice. -/
theorem principalBoundaryNoUnifyCapstoneSlices_field
    (h_slice : PrincipalBoundaryNoUnifyCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyFieldCapstone
      h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  h_slice.2 h_no h_ok h_hooks

/--
One-hop projection: core expression principality from combined no-unify
principal capstone slices.
-/
theorem principalBoundaryNoUnifyCapstoneSlices_expr_core
    (h_slice : PrincipalBoundaryNoUnifyCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  (principalBoundaryNoUnifyCapstoneSlices_expr
    h_slice h_no h_ok h_hooks).noUnify.core

/--
One-hop projection: preconditioned expression principality from combined
no-unify principal capstone slices.
-/
theorem principalBoundaryNoUnifyCapstoneSlices_expr_preconditioned
    (h_slice : PrincipalBoundaryNoUnifyCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  (principalBoundaryNoUnifyCapstoneSlices_expr
    h_slice h_no h_ok h_hooks).noUnify.preconditioned

/--
One-hop projection: successful-run expression preconditioned↔core equivalence
from combined no-unify principal capstone slices.
-/
theorem principalBoundaryNoUnifyCapstoneSlices_expr_preconditionedCoreIff
    (h_slice : PrincipalBoundaryNoUnifyCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalBoundaryNoUnifyCapstoneSlices_expr
    h_slice h_no h_ok h_hooks).preconditionedCoreIff

/--
One-hop projection: core field principality from combined no-unify
principal capstone slices.
-/
theorem principalBoundaryNoUnifyCapstoneSlices_field_core
    (h_slice : PrincipalBoundaryNoUnifyCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalBoundaryNoUnifyCapstoneSlices_field
    h_slice h_no h_ok h_hooks).noUnify.core

/--
One-hop projection: preconditioned field principality from combined
no-unify principal capstone slices.
-/
theorem principalBoundaryNoUnifyCapstoneSlices_field_preconditioned
    (h_slice : PrincipalBoundaryNoUnifyCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  (principalBoundaryNoUnifyCapstoneSlices_field
    h_slice h_no h_ok h_hooks).noUnify.preconditioned

/--
One-hop projection: successful-run field preconditioned↔core equivalence
from combined no-unify principal capstone slices.
-/
theorem principalBoundaryNoUnifyCapstoneSlices_field_preconditionedCoreIff
    (h_slice : PrincipalBoundaryNoUnifyCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalBoundaryNoUnifyCapstoneSlices_field
    h_slice h_no h_ok h_hooks).preconditionedCoreIff

/--
Transport preconditioned expression principality across hook witnesses on the
same successful `inferExprUnify` run.
-/
theorem principalTypingSlicePreconditioned_transport_hooks_of_success
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_pre : PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty) :
    PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty := by
  have h_core : PrincipalTypingSliceCore env e ty :=
    (principalTypingSlicePreconditioned_iff_core_of_success
      h_app₁ h_proj₁ st fuel env e st' ty h_ok).1 h_pre
  exact (principalTypingSlicePreconditioned_iff_core_of_success
      h_app₂ h_proj₂ st fuel env e st' ty h_ok).2 h_core

/--
Hook irrelevance (expression): on a fixed successful `inferExprUnify` run,
preconditioned principality is independent of which hook witnesses are used.
-/
theorem principalTypingSlicePreconditioned_hook_irrelevant_of_success
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) := by
  constructor
  · intro h_pre
    exact principalTypingSlicePreconditioned_transport_hooks_of_success h_ok h_pre
  · intro h_pre
    exact principalTypingSlicePreconditioned_transport_hooks_of_success h_ok h_pre

/--
Transport preconditioned field principality across hook witnesses on the same
successful `inferFieldsUnify` run.
-/
theorem principalFieldTypingSlicePreconditioned_transport_hooks_of_success
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_pre : PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf) :
    PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf := by
  have h_core : PrincipalFieldTypingSliceCore env fs rf :=
    (principalFieldTypingSlicePreconditioned_iff_core_of_success
      h_app₁ h_proj₁ st fuel env fs st' rf h_ok).1 h_pre
  exact (principalFieldTypingSlicePreconditioned_iff_core_of_success
      h_app₂ h_proj₂ st fuel env fs st' rf h_ok).2 h_core

/--
Hook irrelevance (field): on a fixed successful `inferFieldsUnify` run,
preconditioned field principality is independent of hook witnesses.
-/
theorem principalFieldTypingSlicePreconditioned_hook_irrelevant_of_success
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) := by
  constructor
  · intro h_pre
    exact principalFieldTypingSlicePreconditioned_transport_hooks_of_success h_ok h_pre
  · intro h_pre
    exact principalFieldTypingSlicePreconditioned_transport_hooks_of_success h_ok h_pre

/--
Packaged hook-irrelevance slice for expression principality on successful runs.
-/
def PrincipalPreconditionedHookIrrelevanceExprSlice : Prop :=
  ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    inferExprUnify st fuel env e = .ok st' ty →
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)

/--
Packaged hook-irrelevance slice for field principality on successful runs.
-/
def PrincipalPreconditionedHookIrrelevanceFieldSlice : Prop :=
  ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)

/-- Combined preconditioned-hook-irrelevance principal slice across expressions and fields. -/
def PrincipalPreconditionedHookIrrelevanceSlices : Prop :=
  PrincipalPreconditionedHookIrrelevanceExprSlice ∧
    PrincipalPreconditionedHookIrrelevanceFieldSlice

/-- The combined preconditioned-hook-irrelevance principal slice is fully proved. -/
theorem principalPreconditionedHookIrrelevanceSlices_proved :
    PrincipalPreconditionedHookIrrelevanceSlices := by
  refine ⟨?_, ?_⟩
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂ st fuel env e st' ty h_ok
    exact principalTypingSlicePreconditioned_hook_irrelevant_of_success h_ok
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂ st fuel env fs st' rf h_ok
    exact principalFieldTypingSlicePreconditioned_hook_irrelevant_of_success h_ok

/--
One-hop projection: expression branch from the combined preconditioned
hook-irrelevance principal slice.
-/
theorem principalPreconditionedHookIrrelevanceSlices_expr
    (h_slice : PrincipalPreconditionedHookIrrelevanceSlices)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  h_slice.1 h_ok

/--
One-hop projection: field branch from the combined preconditioned
hook-irrelevance principal slice.
-/
theorem principalPreconditionedHookIrrelevanceSlices_field
    (h_slice : PrincipalPreconditionedHookIrrelevanceSlices)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  h_slice.2 h_ok

/--
General successful-run all-hooks expression capstone.

Unlike the no-unify all-hooks capstone, this applies to arbitrary successful
`inferExprUnify` runs and is constructed from one hook witness pair.
-/
structure PrincipalPreconditionedExprAllHooksCapstone
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  core : PrincipalTypingSliceCore env e ty
  preconditionedAny :
    ∀ h_app h_proj, PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty)

/--
Construct the general successful-run all-hooks expression capstone from one
hook witness pair.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty := by
  have h_pre0 :
      PrincipalTypingSlicePreconditioned h_app0 h_proj0 st fuel env e st' ty :=
    principalTypingSlicePreconditioned_of_success h_app0 h_proj0 st fuel env e st' ty h_ok
  have h_core : PrincipalTypingSliceCore env e ty :=
    (principalTypingSlicePreconditioned_iff_core_of_success
      h_app0 h_proj0 st fuel env e st' ty h_ok).1 h_pre0
  refine {
    core := h_core
    preconditionedAny := ?_
    preconditionedAnyIffCore := ?_
  }
  · intro h_app h_proj
    exact (principalTypingSlicePreconditioned_iff_core_of_success
      h_app h_proj st fuel env e st' ty h_ok).2 h_core
  · intro h_app h_proj
    exact principalTypingSlicePreconditioned_iff_core_of_success
      h_app h_proj st fuel env e st' ty h_ok

/--
General successful-run all-hooks field capstone.

Field-side analogue of `PrincipalPreconditionedExprAllHooksCapstone`.
-/
structure PrincipalPreconditionedFieldAllHooksCapstone
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  core : PrincipalFieldTypingSliceCore env fs rf
  preconditionedAny :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf)

/--
Construct the general successful-run all-hooks field capstone from one hook
witness pair.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf := by
  have h_pre0 :
      PrincipalFieldTypingSlicePreconditioned h_app0 h_proj0 st fuel env fs st' rf :=
    principalFieldTypingSlicePreconditioned_of_success
      h_app0 h_proj0 st fuel env fs st' rf h_ok
  have h_core : PrincipalFieldTypingSliceCore env fs rf :=
    (principalFieldTypingSlicePreconditioned_iff_core_of_success
      h_app0 h_proj0 st fuel env fs st' rf h_ok).1 h_pre0
  refine {
    core := h_core
    preconditionedAny := ?_
    preconditionedAnyIffCore := ?_
  }
  · intro h_app h_proj
    exact (principalFieldTypingSlicePreconditioned_iff_core_of_success
      h_app h_proj st fuel env fs st' rf h_ok).2 h_core
  · intro h_app h_proj
    exact principalFieldTypingSlicePreconditioned_iff_core_of_success
      h_app h_proj st fuel env fs st' rf h_ok

/-- Packaged general all-hooks expression capstone slice over successful runs. -/
def PrincipalPreconditionedAllHooksExprCapstoneSlice : Prop :=
  ∀ (_h_app0 : AppUnifySoundHook) (_h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty

/-- Packaged general all-hooks field capstone slice over successful runs. -/
def PrincipalPreconditionedAllHooksFieldCapstoneSlice : Prop :=
  ∀ (_h_app0 : AppUnifySoundHook) (_h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf

/-- Combined general all-hooks capstone slices across expressions and fields. -/
def PrincipalPreconditionedAllHooksCapstoneSlices : Prop :=
  PrincipalPreconditionedAllHooksExprCapstoneSlice ∧
    PrincipalPreconditionedAllHooksFieldCapstoneSlice

/-- The combined general all-hooks capstone slices are fully proved. -/
theorem principalPreconditionedAllHooksCapstoneSlices_proved :
    PrincipalPreconditionedAllHooksCapstoneSlices := by
  refine ⟨?_, ?_⟩
  · intro h_app0 h_proj0 st fuel env e st' ty h_ok
    exact principalPreconditionedExprAllHooksCapstone_of_success
      h_app0 h_proj0 h_ok
  · intro h_app0 h_proj0 st fuel env fs st' rf h_ok
    exact principalPreconditionedFieldAllHooksCapstone_of_success
      h_app0 h_proj0 h_ok

/-- One-hop expression branch projection from general all-hooks capstone slices. -/
theorem principalPreconditionedAllHooksCapstoneSlices_expr
    (h_slice : PrincipalPreconditionedAllHooksCapstoneSlices)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  h_slice.1 h_app0 h_proj0 h_ok

/-- One-hop field branch projection from general all-hooks capstone slices. -/
theorem principalPreconditionedAllHooksCapstoneSlices_field
    (h_slice : PrincipalPreconditionedAllHooksCapstoneSlices)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  h_slice.2 h_app0 h_proj0 h_ok

/--
Coherence (general all-hooks expression capstone): any two hook witnesses yield
equivalent preconditioned principality on the same successful run.
-/
theorem principalPreconditionedExprAllHooksCapstone_hook_irrelevant
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_cap : PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook} :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) := by
  constructor
  · intro h_pre
    have h_core : PrincipalTypingSliceCore env e ty :=
      (h_cap.preconditionedAnyIffCore h_app₁ h_proj₁).1 h_pre
    exact (h_cap.preconditionedAnyIffCore h_app₂ h_proj₂).2 h_core
  · intro h_pre
    have h_core : PrincipalTypingSliceCore env e ty :=
      (h_cap.preconditionedAnyIffCore h_app₂ h_proj₂).1 h_pre
    exact (h_cap.preconditionedAnyIffCore h_app₁ h_proj₁).2 h_core

/--
Coherence (general all-hooks field capstone): any two hook witnesses yield
equivalent preconditioned field principality on the same successful run.
-/
theorem principalPreconditionedFieldAllHooksCapstone_hook_irrelevant
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_cap : PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook} :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) := by
  constructor
  · intro h_pre
    have h_core : PrincipalFieldTypingSliceCore env fs rf :=
      (h_cap.preconditionedAnyIffCore h_app₁ h_proj₁).1 h_pre
    exact (h_cap.preconditionedAnyIffCore h_app₂ h_proj₂).2 h_core
  · intro h_pre
    have h_core : PrincipalFieldTypingSliceCore env fs rf :=
      (h_cap.preconditionedAnyIffCore h_app₂ h_proj₂).1 h_pre
    exact (h_cap.preconditionedAnyIffCore h_app₁ h_proj₁).2 h_core

/--
Run-level expression bundle for arbitrary successful all-hooks principality.

This packages:
- the full all-hooks capstone consequences, and
- fixed-run preconditioned hook-irrelevance.
-/
structure PrincipalPreconditionedExprAllHooksRunBundle
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  capstone : PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty
  hookIrrelevant :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
        ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)

/--
Run-level field bundle for arbitrary successful all-hooks principality.

Field-side analogue of `PrincipalPreconditionedExprAllHooksRunBundle`.
-/
structure PrincipalPreconditionedFieldAllHooksRunBundle
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  capstone : PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf
  hookIrrelevant :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
        ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)

/--
Construct an expression run-level all-hooks bundle from an existing capstone.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_capstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_cap : PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty := by
  refine {
    capstone := h_cap
    hookIrrelevant := ?_
  }
  intro h_app₁ h_proj₁ h_app₂ h_proj₂
  exact principalPreconditionedExprAllHooksCapstone_hook_irrelevant
    h_cap

/--
Construct a field run-level all-hooks bundle from an existing capstone.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_capstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_cap : PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf := by
  refine {
    capstone := h_cap
    hookIrrelevant := ?_
  }
  intro h_app₁ h_proj₁ h_app₂ h_proj₂
  exact principalPreconditionedFieldAllHooksCapstone_hook_irrelevant
    h_cap

/--
Construct an expression run-level all-hooks bundle from one successful run and
one baseline hook pair.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty := by
  exact principalPreconditionedExprAllHooksRunBundle_of_capstone
    (principalPreconditionedExprAllHooksCapstone_of_success h_app0 h_proj0 h_ok)

/--
Construct a field run-level all-hooks bundle from one successful field run and
one baseline hook pair.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf := by
  exact principalPreconditionedFieldAllHooksRunBundle_of_capstone
    (principalPreconditionedFieldAllHooksCapstone_of_success h_app0 h_proj0 h_ok)

/--
Bundle-entry variant of `principalPreconditionedExprAllHooksRunBundle_of_success`.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty := by
  exact principalPreconditionedExprAllHooksRunBundle_of_success
    h_seed.1 h_seed.2 h_ok

/--
Bundle-entry variant of `principalPreconditionedFieldAllHooksRunBundle_of_success`.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf := by
  exact principalPreconditionedFieldAllHooksRunBundle_of_success
    h_seed.1 h_seed.2 h_ok

/--
Project the core expression principality consequence from a run-level all-hooks
bundle.
-/
theorem principalPreconditionedExprAllHooksRunBundle_core
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_bundle : PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty) :
    PrincipalTypingSliceCore env e ty :=
  h_bundle.capstone.core

/--
Project the any-hooks expression preconditioned principality consequence from a
run-level all-hooks bundle.
-/
theorem principalPreconditionedExprAllHooksRunBundle_preconditioned_anyHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_bundle : PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  h_bundle.capstone.preconditionedAny

/--
Project the bundled-hook expression preconditioned principality consequence from
a run-level all-hooks bundle.
-/
theorem principalPreconditionedExprAllHooksRunBundle_preconditioned
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_bundle : PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  h_bundle.capstone.preconditionedAny h_hooks.1 h_hooks.2

/--
Project the any-hooks expression preconditioned↔core equivalence consequence
from a run-level all-hooks bundle.
-/
theorem principalPreconditionedExprAllHooksRunBundle_preconditionedCoreIff_anyHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_bundle : PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  h_bundle.capstone.preconditionedAnyIffCore

/--
Project the bundled-hook expression preconditioned↔core equivalence consequence
from a run-level all-hooks bundle.
-/
theorem principalPreconditionedExprAllHooksRunBundle_preconditionedCoreIff
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_bundle : PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  h_bundle.capstone.preconditionedAnyIffCore h_hooks.1 h_hooks.2

/--
Project fixed-run expression hook-irrelevance from a run-level all-hooks
bundle.
-/
theorem principalPreconditionedExprAllHooksRunBundle_hook_irrelevant
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_bundle : PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  h_bundle.hookIrrelevant

/--
Project the core field principality consequence from a run-level all-hooks
bundle.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_core
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_bundle : PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf) :
    PrincipalFieldTypingSliceCore env fs rf :=
  h_bundle.capstone.core

/--
Project the any-hooks field preconditioned principality consequence from a
run-level all-hooks bundle.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_preconditioned_anyHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_bundle : PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  h_bundle.capstone.preconditionedAny

/--
Project the bundled-hook field preconditioned principality consequence from a
run-level all-hooks bundle.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_preconditioned
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_bundle : PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf)
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  h_bundle.capstone.preconditionedAny h_hooks.1 h_hooks.2

/--
Project the any-hooks field preconditioned↔core equivalence consequence from a
run-level all-hooks bundle.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_preconditionedCoreIff_anyHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_bundle : PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  h_bundle.capstone.preconditionedAnyIffCore

/--
Project the bundled-hook field preconditioned↔core equivalence consequence from
a run-level all-hooks bundle.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_preconditionedCoreIff
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_bundle : PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf)
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  h_bundle.capstone.preconditionedAnyIffCore h_hooks.1 h_hooks.2

/--
Project fixed-run field hook-irrelevance from a run-level all-hooks bundle.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_hook_irrelevant
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_bundle : PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  h_bundle.hookIrrelevant

/--
Packaged arbitrary-success expression run-bundle slice for all-hooks principality.
-/
def PrincipalPreconditionedAllHooksRunBundleExprSlice : Prop :=
  ∀ (_h_app0 : AppUnifySoundHook) (_h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty

/--
Packaged arbitrary-success field run-bundle slice for all-hooks principality.
-/
def PrincipalPreconditionedAllHooksRunBundleFieldSlice : Prop :=
  ∀ (_h_app0 : AppUnifySoundHook) (_h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf

/--
Combined arbitrary-success run-bundle slices across expressions and fields.
-/
def PrincipalPreconditionedAllHooksRunBundleSlices : Prop :=
  PrincipalPreconditionedAllHooksRunBundleExprSlice ∧
    PrincipalPreconditionedAllHooksRunBundleFieldSlice

/--
The combined arbitrary-success run-bundle slices are fully proved.
-/
theorem principalPreconditionedAllHooksRunBundleSlices_proved :
    PrincipalPreconditionedAllHooksRunBundleSlices := by
  refine ⟨?_, ?_⟩
  · intro h_app0 h_proj0 st fuel env e st' ty h_ok
    exact principalPreconditionedExprAllHooksRunBundle_of_success
      h_app0 h_proj0 h_ok
  · intro h_app0 h_proj0 st fuel env fs st' rf h_ok
    exact principalPreconditionedFieldAllHooksRunBundle_of_success
      h_app0 h_proj0 h_ok

/--
One-hop expression projection from combined arbitrary-success run-bundle slices.
-/
theorem principalPreconditionedAllHooksRunBundleSlices_expr
    (h_slice : PrincipalPreconditionedAllHooksRunBundleSlices)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  h_slice.1 h_app0 h_proj0 h_ok

/--
One-hop field projection from combined arbitrary-success run-bundle slices.
-/
theorem principalPreconditionedAllHooksRunBundleSlices_field
    (h_slice : PrincipalPreconditionedAllHooksRunBundleSlices)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  h_slice.2 h_app0 h_proj0 h_ok

/--
Derive the global preconditioned hook-irrelevance slices directly from general
all-hooks capstone slices.
-/
theorem principalPreconditionedHookIrrelevanceSlices_of_allHooksCapstones
    (h_caps : PrincipalPreconditionedAllHooksCapstoneSlices) :
    PrincipalPreconditionedHookIrrelevanceSlices := by
  refine ⟨?_, ?_⟩
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂ st fuel env e st' ty h_ok
    exact principalPreconditionedExprAllHooksCapstone_hook_irrelevant
      (principalPreconditionedAllHooksCapstoneSlices_expr
        h_caps h_app₁ h_proj₁ h_ok)
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂ st fuel env fs st' rf h_ok
    exact principalPreconditionedFieldAllHooksCapstone_hook_irrelevant
      (principalPreconditionedAllHooksCapstoneSlices_field
        h_caps h_app₁ h_proj₁ h_ok)

/--
Top-level suite for the general all-hooks successful-run layer.
-/
structure PrincipalPreconditionedAllHooksSuite : Prop where
  capstones : PrincipalPreconditionedAllHooksCapstoneSlices
  irrelevance : PrincipalPreconditionedHookIrrelevanceSlices
  runBundles : PrincipalPreconditionedAllHooksRunBundleSlices

/-- Explicit component alias for `PrincipalPreconditionedAllHooksSuite`. -/
abbrev PrincipalPreconditionedAllHooksSuiteComponents : Prop :=
  PrincipalPreconditionedAllHooksCapstoneSlices
    ∧ PrincipalPreconditionedHookIrrelevanceSlices
    ∧ PrincipalPreconditionedAllHooksRunBundleSlices

/-- The general all-hooks successful-run suite is fully proved. -/
theorem principalPreconditionedAllHooksSuite_proved :
    PrincipalPreconditionedAllHooksSuite := by
  refine {
    capstones := principalPreconditionedAllHooksCapstoneSlices_proved
    irrelevance := principalPreconditionedHookIrrelevanceSlices_of_allHooksCapstones
      principalPreconditionedAllHooksCapstoneSlices_proved
    runBundles := principalPreconditionedAllHooksRunBundleSlices_proved
  }

/-- `PrincipalPreconditionedAllHooksSuite` is equivalent to explicit components. -/
theorem principalPreconditionedAllHooksSuite_iff_components :
    PrincipalPreconditionedAllHooksSuite
      ↔ PrincipalPreconditionedAllHooksSuiteComponents := by
  constructor
  · intro h_suite
    exact ⟨h_suite.capstones, h_suite.irrelevance, h_suite.runBundles⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2.1, h_comp.2.2⟩

/-- Build `PrincipalPreconditionedAllHooksSuite` from explicit components. -/
theorem principalPreconditionedAllHooksSuite_of_components
    (h_comp : PrincipalPreconditionedAllHooksSuiteComponents) :
    PrincipalPreconditionedAllHooksSuite :=
  (principalPreconditionedAllHooksSuite_iff_components).2 h_comp

/-- Decompose `PrincipalPreconditionedAllHooksSuite` into explicit components. -/
theorem principalPreconditionedAllHooksSuite_as_components
    (h_suite : PrincipalPreconditionedAllHooksSuite) :
    PrincipalPreconditionedAllHooksSuiteComponents :=
  (principalPreconditionedAllHooksSuite_iff_components).1 h_suite

/-- Direct components-route decomposition for `PrincipalPreconditionedAllHooksSuite`. -/
theorem principalPreconditionedAllHooksSuite_as_components_of_components
    (h_comp : PrincipalPreconditionedAllHooksSuiteComponents) :
    PrincipalPreconditionedAllHooksSuiteComponents :=
  (principalPreconditionedAllHooksSuite_iff_components).1
    (principalPreconditionedAllHooksSuite_of_components h_comp)

/-- One-hop expression capstone projection from general all-hooks suite. -/
theorem principalPreconditionedAllHooksSuite_capstone_expr
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedAllHooksCapstoneSlices_expr
    h_suite.capstones h_app0 h_proj0 h_ok

/-- One-hop field capstone projection from general all-hooks suite. -/
theorem principalPreconditionedAllHooksSuite_capstone_field
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedAllHooksCapstoneSlices_field
    h_suite.capstones h_app0 h_proj0 h_ok

/-- One-hop expression irrelevance projection from general all-hooks suite. -/
theorem principalPreconditionedAllHooksSuite_irrelevance_expr
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedHookIrrelevanceSlices_expr h_suite.irrelevance h_ok

/-- One-hop field irrelevance projection from general all-hooks suite. -/
theorem principalPreconditionedAllHooksSuite_irrelevance_field
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedHookIrrelevanceSlices_field h_suite.irrelevance h_ok

/-- One-hop expression run-bundle projection from general all-hooks suite. -/
theorem principalPreconditionedAllHooksSuite_runBundle_expr
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedAllHooksRunBundleSlices_expr
    h_suite.runBundles h_app0 h_proj0 h_ok

/-- One-hop field run-bundle projection from general all-hooks suite. -/
theorem principalPreconditionedAllHooksSuite_runBundle_field
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedAllHooksRunBundleSlices_field
    h_suite.runBundles h_app0 h_proj0 h_ok

/--
General-all-hooks suite convenience wrapper: derive the expression run-bundle
surface from an arbitrary successful run.
-/
theorem principalGeneralAllHooksRunBundleExpr_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedAllHooksSuite_runBundle_expr
    h_suite h_app0 h_proj0 h_ok

/--
General-all-hooks suite convenience wrapper: derive the field run-bundle
surface from an arbitrary successful field run.
-/
theorem principalGeneralAllHooksRunBundleField_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedAllHooksSuite_runBundle_field
    h_suite h_app0 h_proj0 h_ok

/--
General-all-hooks suite convenience wrapper: derive core expression principality
from an arbitrary successful run.
-/
theorem principalGeneralAllHooksCoreExpr_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  (principalPreconditionedAllHooksSuite_capstone_expr
    h_suite h_app0 h_proj0 h_ok).core

/--
General-all-hooks suite convenience wrapper: derive preconditioned expression
principality for any hook witnesses from an arbitrary successful run.
-/
theorem principalGeneralAllHooksPreconditionedExpr_anyHooks_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  (principalPreconditionedAllHooksSuite_capstone_expr
    h_suite h_app0 h_proj0 h_ok).preconditionedAny

/--
General-all-hooks suite convenience wrapper: derive preconditioned expression
principality for a bundled hook witness from an arbitrary successful run.
-/
theorem principalGeneralAllHooksPreconditionedExpr_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  (principalGeneralAllHooksPreconditionedExpr_anyHooks_of_success
    h_suite h_app0 h_proj0 h_ok) h_hooks.1 h_hooks.2

/--
General-all-hooks suite convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalGeneralAllHooksPreconditionedCoreIffExpr_anyHooks_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  (principalPreconditionedAllHooksSuite_capstone_expr
    h_suite h_app0 h_proj0 h_ok).preconditionedAnyIffCore

/--
General-all-hooks suite convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalGeneralAllHooksPreconditionedCoreIffExpr_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalGeneralAllHooksPreconditionedCoreIffExpr_anyHooks_of_success
    h_suite h_app0 h_proj0 h_ok) h_hooks.1 h_hooks.2

/--
General-all-hooks suite convenience wrapper: derive fixed-run expression
hook-irrelevance from an arbitrary successful run.
-/
theorem principalGeneralAllHooksPreconditionedExpr_hookIrrelevant_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedAllHooksSuite_irrelevance_expr h_suite h_ok

/--
General-all-hooks suite convenience wrapper: derive core field principality
from an arbitrary successful field run.
-/
theorem principalGeneralAllHooksCoreField_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalPreconditionedAllHooksSuite_capstone_field
    h_suite h_app0 h_proj0 h_ok).core

/--
General-all-hooks suite convenience wrapper: derive preconditioned field
principality for any hook witnesses from an arbitrary successful field run.
-/
theorem principalGeneralAllHooksPreconditionedField_anyHooks_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  (principalPreconditionedAllHooksSuite_capstone_field
    h_suite h_app0 h_proj0 h_ok).preconditionedAny

/--
General-all-hooks suite convenience wrapper: derive preconditioned field
principality for a bundled hook witness from an arbitrary successful field run.
-/
theorem principalGeneralAllHooksPreconditionedField_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  (principalGeneralAllHooksPreconditionedField_anyHooks_of_success
    h_suite h_app0 h_proj0 h_ok) h_hooks.1 h_hooks.2

/--
General-all-hooks suite convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalGeneralAllHooksPreconditionedCoreIffField_anyHooks_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalPreconditionedAllHooksSuite_capstone_field
    h_suite h_app0 h_proj0 h_ok).preconditionedAnyIffCore

/--
General-all-hooks suite convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalGeneralAllHooksPreconditionedCoreIffField_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalGeneralAllHooksPreconditionedCoreIffField_anyHooks_of_success
    h_suite h_app0 h_proj0 h_ok) h_hooks.1 h_hooks.2

/--
General-all-hooks suite convenience wrapper: derive fixed-run field
hook-irrelevance from an arbitrary successful field run.
-/
theorem principalGeneralAllHooksPreconditionedField_hookIrrelevant_of_success
    (h_suite : PrincipalPreconditionedAllHooksSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedAllHooksSuite_irrelevance_field h_suite h_ok

/--
General-all-hooks-suite capstone wrapper: package the full expression
successful-run all-hooks principal boundary from one successful run and one
baseline hook witness pair.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedAllHooksSuite_capstone_expr
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok

/--
General-all-hooks-suite capstone wrapper: package the full field successful-run
all-hooks principal boundary from one successful field run and one baseline hook
witness pair.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedAllHooksSuite_capstone_field
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok

/--
General-all-hooks-suite capstone wrapper: bundled-hook variant for expression
successful-run all-hooks principal boundary packaging.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok

/--
General-all-hooks-suite capstone wrapper: bundled-hook variant for field
successful-run all-hooks principal boundary packaging.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok

/--
General-all-hooks-suite run-bundle wrapper: package capstone + hook-irrelevance
for expression successful runs from one baseline hook witness pair.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalGeneralAllHooksRunBundleExpr_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok

/--
General-all-hooks-suite run-bundle wrapper: package capstone + hook-irrelevance
for successful field runs from one baseline hook witness pair.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalGeneralAllHooksRunBundleField_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok

/--
Bundle-entry variant of
`principalPreconditionedExprAllHooksRunBundle_of_success_via_generalAllHooksSuite`.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok

/--
Bundle-entry variant of
`principalPreconditionedFieldAllHooksRunBundle_of_success_via_generalAllHooksSuite`.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok

/--
General-all-hooks-suite convenience wrapper: derive core expression principality
from an arbitrary successful `inferExprUnify` run.
-/
theorem principalCoreExpr_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalGeneralAllHooksCoreExpr_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok

/--
General-all-hooks-suite convenience wrapper: derive preconditioned expression
principality for any hook witnesses from an arbitrary successful run.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalGeneralAllHooksPreconditionedExpr_anyHooks_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok

/--
General-all-hooks-suite convenience wrapper: derive preconditioned expression
principality for a bundled hook witness from an arbitrary successful run.
-/
theorem principalPreconditionedExpr_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalGeneralAllHooksPreconditionedExpr_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok h_hooks

/--
General-all-hooks-suite convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalGeneralAllHooksPreconditionedCoreIffExpr_anyHooks_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok

/--
General-all-hooks-suite convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalPreconditionedCoreIffExpr_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalGeneralAllHooksPreconditionedCoreIffExpr_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok h_hooks

/--
General-all-hooks-suite convenience wrapper: derive core field principality
from an arbitrary successful `inferFieldsUnify` run.
-/
theorem principalCoreField_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalGeneralAllHooksCoreField_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok

/--
General-all-hooks-suite convenience wrapper: derive preconditioned field
principality for any hook witnesses from an arbitrary successful run.
-/
theorem principalPreconditionedField_anyHooks_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalGeneralAllHooksPreconditionedField_anyHooks_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok

/--
General-all-hooks-suite convenience wrapper: derive preconditioned field
principality for a bundled hook witness from an arbitrary successful run.
-/
theorem principalPreconditionedField_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalGeneralAllHooksPreconditionedField_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok h_hooks

/--
General-all-hooks-suite convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalGeneralAllHooksPreconditionedCoreIffField_anyHooks_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok

/--
General-all-hooks-suite convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalPreconditionedCoreIffField_of_success_via_generalAllHooksSuite
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalGeneralAllHooksPreconditionedCoreIffField_of_success
    principalPreconditionedAllHooksSuite_proved h_app0 h_proj0 h_ok h_hooks

/--
General-all-hooks-suite convenience wrapper: bundled-baseline variant for core
expression principality from an arbitrary successful run.
-/
theorem principalCoreExpr_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_via_generalAllHooksSuite h_seed.1 h_seed.2 h_ok

/--
General-all-hooks-suite convenience wrapper: bundled-baseline variant for
preconditioned expression principality (any target hooks) from an arbitrary
successful run.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok

/--
General-all-hooks-suite convenience wrapper: bundled-baseline variant for
fixed-run expression preconditioned↔core equivalence (any target hooks) from an
arbitrary successful run.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok

/--
General-all-hooks-suite convenience wrapper: bundled-baseline variant for core
field principality from an arbitrary successful field run.
-/
theorem principalCoreField_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_via_generalAllHooksSuite h_seed.1 h_seed.2 h_ok

/--
General-all-hooks-suite convenience wrapper: bundled-baseline variant for
preconditioned field principality (any target hooks) from an arbitrary
successful field run.
-/
theorem principalPreconditionedField_anyHooks_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok

/--
General-all-hooks-suite convenience wrapper: bundled-baseline variant for
fixed-run field preconditioned↔core equivalence (any target hooks) from an
arbitrary successful field run.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok

/--
General-all-hooks-suite convenience wrapper: bundled-baseline variant for
preconditioned expression principality under a bundled target-hook witness from
an arbitrary successful run.
-/
theorem principalPreconditionedExpr_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok h_hooks

/--
General-all-hooks-suite convenience wrapper: bundled-baseline variant for
fixed-run expression preconditioned↔core equivalence under a bundled
target-hook witness from an arbitrary successful run.
-/
theorem principalPreconditionedCoreIffExpr_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok h_hooks

/--
General-all-hooks-suite convenience wrapper: bundled-baseline variant for
preconditioned field principality under a bundled target-hook witness from an
arbitrary successful field run.
-/
theorem principalPreconditionedField_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok h_hooks

/--
General-all-hooks-suite convenience wrapper: bundled-baseline variant for
fixed-run field preconditioned↔core equivalence under a bundled target-hook
witness from an arbitrary successful field run.
-/
theorem principalPreconditionedCoreIffField_of_success_via_generalAllHooksSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_via_generalAllHooksSuite
    h_seed.1 h_seed.2 h_ok h_hooks

/--
General-all-hooks-suite convenience wrapper: derive fixed-run expression
hook-irrelevance from an arbitrary successful run.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_via_generalAllHooksSuite
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalGeneralAllHooksPreconditionedExpr_hookIrrelevant_of_success
    principalPreconditionedAllHooksSuite_proved h_ok

/--
General-all-hooks-suite convenience wrapper: derive fixed-run field
hook-irrelevance from an arbitrary successful field run.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_via_generalAllHooksSuite
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalGeneralAllHooksPreconditionedField_hookIrrelevant_of_success
    principalPreconditionedAllHooksSuite_proved h_ok

/--
General-all-hooks-suite convenience wrapper: bundled-hook variant for fixed-run
expression hook-irrelevance from an arbitrary successful run.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_via_generalAllHooksSuite_from_bundle
    (_h_seed : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_via_generalAllHooksSuite h_ok

/--
General-all-hooks-suite convenience wrapper: bundled-hook variant for fixed-run
field hook-irrelevance from an arbitrary successful field run.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_via_generalAllHooksSuite_from_bundle
    (_h_seed : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_via_generalAllHooksSuite h_ok

/--
Top-level M4 principal vacuity suite.

This packages:
- no-unify principal capstones (expression+field), and
- fixed-run hook-irrelevance for preconditioned principality.
-/
structure PrincipalBoundaryVacuitySuite : Prop where
  noUnifyCapstones : PrincipalBoundaryNoUnifyCapstoneSlices
  hookIrrelevance : PrincipalPreconditionedHookIrrelevanceSlices

/-- Explicit component alias for `PrincipalBoundaryVacuitySuite`. -/
abbrev PrincipalBoundaryVacuitySuiteComponents : Prop :=
  PrincipalBoundaryNoUnifyCapstoneSlices ∧ PrincipalPreconditionedHookIrrelevanceSlices

/-- The principal vacuity suite is fully proved. -/
theorem principalBoundaryVacuitySuite_proved : PrincipalBoundaryVacuitySuite := by
  refine {
    noUnifyCapstones := principalBoundaryNoUnifyCapstoneSlices_proved
    hookIrrelevance := principalPreconditionedHookIrrelevanceSlices_proved
  }

/-- `PrincipalBoundaryVacuitySuite` is equivalent to its explicit components. -/
theorem principalBoundaryVacuitySuite_iff_components :
    PrincipalBoundaryVacuitySuite ↔ PrincipalBoundaryVacuitySuiteComponents := by
  constructor
  · intro h_suite
    exact ⟨h_suite.noUnifyCapstones, h_suite.hookIrrelevance⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2⟩

/-- Build `PrincipalBoundaryVacuitySuite` from explicit components. -/
theorem principalBoundaryVacuitySuite_of_components
    (h_comp : PrincipalBoundaryVacuitySuiteComponents) :
    PrincipalBoundaryVacuitySuite :=
  (principalBoundaryVacuitySuite_iff_components).2 h_comp

/-- Decompose `PrincipalBoundaryVacuitySuite` into explicit components. -/
theorem principalBoundaryVacuitySuite_as_components
    (h_suite : PrincipalBoundaryVacuitySuite) :
    PrincipalBoundaryVacuitySuiteComponents :=
  (principalBoundaryVacuitySuite_iff_components).1 h_suite

/-- Direct components-route decomposition for `PrincipalBoundaryVacuitySuite`. -/
theorem principalBoundaryVacuitySuite_as_components_of_components
    (h_comp : PrincipalBoundaryVacuitySuiteComponents) :
    PrincipalBoundaryVacuitySuiteComponents :=
  (principalBoundaryVacuitySuite_iff_components).1
    (principalBoundaryVacuitySuite_of_components h_comp)

/-- One-hop expression no-unify capstone projection from vacuity suite. -/
theorem principalBoundaryVacuitySuite_noUnify_expr
    (h_suite : PrincipalBoundaryVacuitySuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyExprCapstone
      h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalBoundaryNoUnifyCapstoneSlices_expr
    h_suite.noUnifyCapstones h_no h_ok h_hooks

/-- One-hop field no-unify capstone projection from vacuity suite. -/
theorem principalBoundaryVacuitySuite_noUnify_field
    (h_suite : PrincipalBoundaryVacuitySuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyFieldCapstone
      h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalBoundaryNoUnifyCapstoneSlices_field
    h_suite.noUnifyCapstones h_no h_ok h_hooks

/--
One-hop expression hook-irrelevance projection from vacuity suite.
-/
theorem principalBoundaryVacuitySuite_hookIrrelevance_expr
    (h_suite : PrincipalBoundaryVacuitySuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedHookIrrelevanceSlices_expr
    h_suite.hookIrrelevance h_ok

/--
One-hop field hook-irrelevance projection from vacuity suite.
-/
theorem principalBoundaryVacuitySuite_hookIrrelevance_field
    (h_suite : PrincipalBoundaryVacuitySuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedHookIrrelevanceSlices_field
    h_suite.hookIrrelevance h_ok

/--
No-unify all-hooks expression capstone.

This removes explicit hook parameters from the capstone surface by exporting:
- core principality,
- preconditioned principality for any hook witnesses, and
- per-hook successful-run preconditioned↔core equivalence.
-/
structure PrincipalBoundaryNoUnifyExprAllHooksCapstone
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  core : PrincipalTypingSliceCore env e ty
  preconditionedAny :
    ∀ h_app h_proj, PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty)

/--
Construct the no-unify all-hooks expression capstone from a successful no-unify
`inferExprUnify` run.
-/
theorem principalBoundaryNoUnifyExprAllHooksCapstone_of_success
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundaryNoUnifyExprAllHooksCapstone st fuel env e st' ty := by
  have h_core : PrincipalTypingSliceCore env e ty :=
    principalTypingSliceCore_of_unify_success_no_unify h_no h_ok
  refine {
    core := h_core
    preconditionedAny := ?_
    preconditionedAnyIffCore := ?_
  }
  · intro h_app h_proj
    exact principalTypingSlicePreconditioned_of_success_no_unify
      h_no h_ok h_app h_proj
  · intro h_app h_proj
    exact principalTypingSlicePreconditioned_iff_core_of_success
      h_app h_proj st fuel env e st' ty h_ok

/--
No-unify all-hooks field capstone.

Field-side analogue of `PrincipalBoundaryNoUnifyExprAllHooksCapstone`.
-/
structure PrincipalBoundaryNoUnifyFieldAllHooksCapstone
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  core : PrincipalFieldTypingSliceCore env fs rf
  preconditionedAny :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf)

/--
Construct the no-unify all-hooks field capstone from a successful no-unify
`inferFieldsUnify` run.
-/
theorem principalBoundaryNoUnifyFieldAllHooksCapstone_of_success
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundaryNoUnifyFieldAllHooksCapstone st fuel env fs st' rf := by
  have h_core : PrincipalFieldTypingSliceCore env fs rf :=
    principalFieldTypingSliceCore_of_unify_success_no_unify h_no h_ok
  refine {
    core := h_core
    preconditionedAny := ?_
    preconditionedAnyIffCore := ?_
  }
  · intro h_app h_proj
    exact principalFieldTypingSlicePreconditioned_of_success_no_unify
      h_no h_ok h_app h_proj
  · intro h_app h_proj
    exact principalFieldTypingSlicePreconditioned_iff_core_of_success
      h_app h_proj st fuel env fs st' rf h_ok

/-- Packaged no-unify all-hooks expression capstone slice. -/
def PrincipalBoundaryNoUnifyExprAllHooksCapstoneSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalBoundaryNoUnifyExprAllHooksCapstone st fuel env e st' ty

/-- Packaged no-unify all-hooks field capstone slice. -/
def PrincipalBoundaryNoUnifyFieldAllHooksCapstoneSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalBoundaryNoUnifyFieldAllHooksCapstone st fuel env fs st' rf

/-- Combined no-unify all-hooks capstone slices across expressions and fields. -/
def PrincipalBoundaryNoUnifyAllHooksCapstoneSlices : Prop :=
  PrincipalBoundaryNoUnifyExprAllHooksCapstoneSlice ∧
    PrincipalBoundaryNoUnifyFieldAllHooksCapstoneSlice

/-- The combined no-unify all-hooks capstone slices are fully proved. -/
theorem principalBoundaryNoUnifyAllHooksCapstoneSlices_proved :
    PrincipalBoundaryNoUnifyAllHooksCapstoneSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalBoundaryNoUnifyExprAllHooksCapstone_of_success h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalBoundaryNoUnifyFieldAllHooksCapstone_of_success h_no h_ok

/-- One-hop expression branch projection from all-hooks no-unify capstone slices. -/
theorem principalBoundaryNoUnifyAllHooksCapstoneSlices_expr
    (h_slice : PrincipalBoundaryNoUnifyAllHooksCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundaryNoUnifyExprAllHooksCapstone st fuel env e st' ty :=
  h_slice.1 h_no h_ok

/-- One-hop field branch projection from all-hooks no-unify capstone slices. -/
theorem principalBoundaryNoUnifyAllHooksCapstoneSlices_field
    (h_slice : PrincipalBoundaryNoUnifyAllHooksCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundaryNoUnifyFieldAllHooksCapstone st fuel env fs st' rf :=
  h_slice.2 h_no h_ok

/--
Coherence (all-hooks expression capstone): for any two hook witnesses, the
preconditioned principal slice is equivalent on the same successful run.
-/
theorem principalBoundaryNoUnifyExprAllHooksCapstone_hook_irrelevant
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_cap : PrincipalBoundaryNoUnifyExprAllHooksCapstone st fuel env e st' ty)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook} :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) := by
  constructor
  · intro h_pre
    have h_core : PrincipalTypingSliceCore env e ty :=
      (h_cap.preconditionedAnyIffCore h_app₁ h_proj₁).1 h_pre
    exact (h_cap.preconditionedAnyIffCore h_app₂ h_proj₂).2 h_core
  · intro h_pre
    have h_core : PrincipalTypingSliceCore env e ty :=
      (h_cap.preconditionedAnyIffCore h_app₂ h_proj₂).1 h_pre
    exact (h_cap.preconditionedAnyIffCore h_app₁ h_proj₁).2 h_core

/--
Coherence (all-hooks field capstone): for any two hook witnesses, the
preconditioned field principal slice is equivalent on the same successful run.
-/
theorem principalBoundaryNoUnifyFieldAllHooksCapstone_hook_irrelevant
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundaryNoUnifyFieldAllHooksCapstone st fuel env fs st' rf)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook} :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) := by
  constructor
  · intro h_pre
    have h_core : PrincipalFieldTypingSliceCore env fs rf :=
      (h_cap.preconditionedAnyIffCore h_app₁ h_proj₁).1 h_pre
    exact (h_cap.preconditionedAnyIffCore h_app₂ h_proj₂).2 h_core
  · intro h_pre
    have h_core : PrincipalFieldTypingSliceCore env fs rf :=
      (h_cap.preconditionedAnyIffCore h_app₂ h_proj₂).1 h_pre
    exact (h_cap.preconditionedAnyIffCore h_app₁ h_proj₁).2 h_core

/--
Packaged no-unify expression hook-irrelevance obtained directly from the
all-hooks capstone slice.
-/
def PrincipalBoundaryNoUnifyExprAllHooksIrrelevanceSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)

/--
Packaged no-unify field hook-irrelevance obtained directly from the all-hooks
capstone slice.
-/
def PrincipalBoundaryNoUnifyFieldAllHooksIrrelevanceSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)

/--
Combined no-unify all-hooks irrelevance slice across expressions and fields.
-/
def PrincipalBoundaryNoUnifyAllHooksIrrelevanceSlices : Prop :=
  PrincipalBoundaryNoUnifyExprAllHooksIrrelevanceSlice ∧
    PrincipalBoundaryNoUnifyFieldAllHooksIrrelevanceSlice

/--
The combined no-unify all-hooks irrelevance slices are fully proved.
-/
theorem principalBoundaryNoUnifyAllHooksIrrelevanceSlices_proved :
    PrincipalBoundaryNoUnifyAllHooksIrrelevanceSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_app₁ h_proj₁ h_app₂ h_proj₂ h_no h_ok
    exact principalBoundaryNoUnifyExprAllHooksCapstone_hook_irrelevant
      (principalBoundaryNoUnifyExprAllHooksCapstone_of_success h_no h_ok)
  · intro st fuel env fs st' rf h_app₁ h_proj₁ h_app₂ h_proj₂ h_no h_ok
    exact principalBoundaryNoUnifyFieldAllHooksCapstone_hook_irrelevant
      (principalBoundaryNoUnifyFieldAllHooksCapstone_of_success h_no h_ok)

/--
One-hop projection: expression branch from combined no-unify all-hooks
irrelevance slices.
-/
theorem principalBoundaryNoUnifyAllHooksIrrelevanceSlices_expr
    (h_slice : PrincipalBoundaryNoUnifyAllHooksIrrelevanceSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  h_slice.1 h_no h_ok

/--
One-hop projection: field branch from combined no-unify all-hooks irrelevance
slices.
-/
theorem principalBoundaryNoUnifyAllHooksIrrelevanceSlices_field
    (h_slice : PrincipalBoundaryNoUnifyAllHooksIrrelevanceSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  h_slice.2 h_no h_ok

/-- Packaged no-unify all-hooks expression run-bundle slice. -/
def PrincipalBoundaryNoUnifyExprAllHooksRunBundleSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty

/-- Packaged no-unify all-hooks field run-bundle slice. -/
def PrincipalBoundaryNoUnifyFieldAllHooksRunBundleSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf

/-- Combined no-unify all-hooks run-bundle slices across expressions and fields. -/
def PrincipalBoundaryNoUnifyAllHooksRunBundleSlices : Prop :=
  PrincipalBoundaryNoUnifyExprAllHooksRunBundleSlice ∧
    PrincipalBoundaryNoUnifyFieldAllHooksRunBundleSlice

/-- The combined no-unify all-hooks run-bundle slices are fully proved. -/
theorem principalBoundaryNoUnifyAllHooksRunBundleSlices_proved :
    PrincipalBoundaryNoUnifyAllHooksRunBundleSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    let h_cap_no : PrincipalBoundaryNoUnifyExprAllHooksCapstone st fuel env e st' ty :=
      principalBoundaryNoUnifyExprAllHooksCapstone_of_success h_no h_ok
    have h_cap_general : PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty := by
      refine {
        core := h_cap_no.core
        preconditionedAny := h_cap_no.preconditionedAny
        preconditionedAnyIffCore := h_cap_no.preconditionedAnyIffCore
      }
    exact principalPreconditionedExprAllHooksRunBundle_of_capstone h_cap_general
  · intro st fuel env fs st' rf h_no h_ok
    let h_cap_no : PrincipalBoundaryNoUnifyFieldAllHooksCapstone st fuel env fs st' rf :=
      principalBoundaryNoUnifyFieldAllHooksCapstone_of_success h_no h_ok
    have h_cap_general : PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf := by
      refine {
        core := h_cap_no.core
        preconditionedAny := h_cap_no.preconditionedAny
        preconditionedAnyIffCore := h_cap_no.preconditionedAnyIffCore
      }
    exact principalPreconditionedFieldAllHooksRunBundle_of_capstone h_cap_general

/-- One-hop expression projection from no-unify all-hooks run-bundle slices. -/
theorem principalBoundaryNoUnifyAllHooksRunBundleSlices_expr
    (h_slice : PrincipalBoundaryNoUnifyAllHooksRunBundleSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  h_slice.1 h_no h_ok

/-- One-hop field projection from no-unify all-hooks run-bundle slices. -/
theorem principalBoundaryNoUnifyAllHooksRunBundleSlices_field
    (h_slice : PrincipalBoundaryNoUnifyAllHooksRunBundleSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  h_slice.2 h_no h_ok

/--
Top-level no-unify all-hooks suite.

This packages:
- all-hooks no-unify capstones (expression+field), and
- no-unify hook-irrelevance derived from those all-hooks capstones.
-/
structure PrincipalBoundaryNoUnifyAllHooksSuite : Prop where
  capstones : PrincipalBoundaryNoUnifyAllHooksCapstoneSlices
  runBundles : PrincipalBoundaryNoUnifyAllHooksRunBundleSlices
  irrelevance : PrincipalBoundaryNoUnifyAllHooksIrrelevanceSlices

/-- Explicit component alias for `PrincipalBoundaryNoUnifyAllHooksSuite`. -/
abbrev PrincipalBoundaryNoUnifyAllHooksSuiteComponents : Prop :=
  PrincipalBoundaryNoUnifyAllHooksCapstoneSlices
    ∧ PrincipalBoundaryNoUnifyAllHooksRunBundleSlices
    ∧ PrincipalBoundaryNoUnifyAllHooksIrrelevanceSlices

/-- The no-unify all-hooks suite is fully proved. -/
theorem principalBoundaryNoUnifyAllHooksSuite_proved :
    PrincipalBoundaryNoUnifyAllHooksSuite := by
  refine {
    capstones := principalBoundaryNoUnifyAllHooksCapstoneSlices_proved
    runBundles := principalBoundaryNoUnifyAllHooksRunBundleSlices_proved
    irrelevance := principalBoundaryNoUnifyAllHooksIrrelevanceSlices_proved
  }

/-- `PrincipalBoundaryNoUnifyAllHooksSuite` is equivalent to explicit components. -/
theorem principalBoundaryNoUnifyAllHooksSuite_iff_components :
    PrincipalBoundaryNoUnifyAllHooksSuite
      ↔ PrincipalBoundaryNoUnifyAllHooksSuiteComponents := by
  constructor
  · intro h_suite
    exact ⟨h_suite.capstones, h_suite.runBundles, h_suite.irrelevance⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2.1, h_comp.2.2⟩

/-- Build `PrincipalBoundaryNoUnifyAllHooksSuite` from explicit components. -/
theorem principalBoundaryNoUnifyAllHooksSuite_of_components
    (h_comp : PrincipalBoundaryNoUnifyAllHooksSuiteComponents) :
    PrincipalBoundaryNoUnifyAllHooksSuite :=
  (principalBoundaryNoUnifyAllHooksSuite_iff_components).2 h_comp

/-- Decompose `PrincipalBoundaryNoUnifyAllHooksSuite` into explicit components. -/
theorem principalBoundaryNoUnifyAllHooksSuite_as_components
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite) :
    PrincipalBoundaryNoUnifyAllHooksSuiteComponents :=
  (principalBoundaryNoUnifyAllHooksSuite_iff_components).1 h_suite

/-- Direct components-route decomposition for `PrincipalBoundaryNoUnifyAllHooksSuite`. -/
theorem principalBoundaryNoUnifyAllHooksSuite_as_components_of_components
    (h_comp : PrincipalBoundaryNoUnifyAllHooksSuiteComponents) :
    PrincipalBoundaryNoUnifyAllHooksSuiteComponents :=
  (principalBoundaryNoUnifyAllHooksSuite_iff_components).1
    (principalBoundaryNoUnifyAllHooksSuite_of_components h_comp)

/-- One-hop expression all-hooks capstone projection from all-hooks suite. -/
theorem principalBoundaryNoUnifyAllHooksSuite_capstone_expr
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundaryNoUnifyExprAllHooksCapstone st fuel env e st' ty :=
  principalBoundaryNoUnifyAllHooksCapstoneSlices_expr
    h_suite.capstones h_no h_ok

/-- One-hop field all-hooks capstone projection from all-hooks suite. -/
theorem principalBoundaryNoUnifyAllHooksSuite_capstone_field
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundaryNoUnifyFieldAllHooksCapstone st fuel env fs st' rf :=
  principalBoundaryNoUnifyAllHooksCapstoneSlices_field
    h_suite.capstones h_no h_ok

/-- One-hop expression run-bundle projection from all-hooks no-unify suite. -/
theorem principalBoundaryNoUnifyAllHooksSuite_runBundle_expr
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryNoUnifyAllHooksRunBundleSlices_expr
    h_suite.runBundles h_no h_ok

/-- One-hop field run-bundle projection from all-hooks no-unify suite. -/
theorem principalBoundaryNoUnifyAllHooksSuite_runBundle_field
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryNoUnifyAllHooksRunBundleSlices_field
    h_suite.runBundles h_no h_ok

/--
No-unify all-hooks suite convenience wrapper: derive the expression run-bundle
surface from a successful no-unify run.
-/
theorem principalBoundaryNoUnifyRunBundleExpr_of_success_via_allHooksSuite
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryNoUnifyAllHooksSuite_runBundle_expr h_suite h_no h_ok

/-- Bundled-seed alias for no-unify all-hooks expression run-bundle construction. -/
theorem principalBoundaryNoUnifyRunBundleExpr_of_success_via_allHooksSuite_from_bundle
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryNoUnifyRunBundleExpr_of_success_via_allHooksSuite
    h_suite h_no h_ok

/--
No-unify all-hooks suite convenience wrapper: derive the field run-bundle
surface from a successful no-unify field run.
-/
theorem principalBoundaryNoUnifyRunBundleField_of_success_via_allHooksSuite
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryNoUnifyAllHooksSuite_runBundle_field h_suite h_no h_ok

/-- Bundled-seed alias for no-unify all-hooks field run-bundle construction. -/
theorem principalBoundaryNoUnifyRunBundleField_of_success_via_allHooksSuite_from_bundle
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryNoUnifyRunBundleField_of_success_via_allHooksSuite
    h_suite h_no h_ok

/--
All-hooks-suite convenience wrapper: derive the expression run-bundle surface
from a successful no-unify run.
-/
theorem principalNoUnifyRunBundleExpr_of_success_via_allHooksSuite
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryNoUnifyRunBundleExpr_of_success_via_allHooksSuite
    h_suite h_no h_ok

/--
All-hooks-suite convenience wrapper: derive the field run-bundle surface from a
successful no-unify field run.
-/
theorem principalNoUnifyRunBundleField_of_success_via_allHooksSuite
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryNoUnifyRunBundleField_of_success_via_allHooksSuite
    h_suite h_no h_ok

/-- One-hop expression irrelevance projection from all-hooks suite. -/
theorem principalBoundaryNoUnifyAllHooksSuite_irrelevance_expr
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalBoundaryNoUnifyAllHooksIrrelevanceSlices_expr
    h_suite.irrelevance h_no h_ok

/-- One-hop field irrelevance projection from all-hooks suite. -/
theorem principalBoundaryNoUnifyAllHooksSuite_irrelevance_field
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalBoundaryNoUnifyAllHooksIrrelevanceSlices_field
    h_suite.irrelevance h_no h_ok

/--
Convert a no-unify all-hooks expression capstone into the general successful-run
all-hooks expression capstone.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_noUnifyAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_cap : PrincipalBoundaryNoUnifyExprAllHooksCapstone st fuel env e st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty := by
  refine {
    core := h_cap.core
    preconditionedAny := h_cap.preconditionedAny
    preconditionedAnyIffCore := h_cap.preconditionedAnyIffCore
  }

/--
Convert a no-unify all-hooks field capstone into the general successful-run
all-hooks field capstone.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_noUnifyAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundaryNoUnifyFieldAllHooksCapstone st fuel env fs st' rf) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf := by
  refine {
    core := h_cap.core
    preconditionedAny := h_cap.preconditionedAny
    preconditionedAnyIffCore := h_cap.preconditionedAnyIffCore
  }

/--
One-hop expression projection: view a no-unify all-hooks suite capstone on a
successful no-unify run as a general successful-run all-hooks capstone.
-/
theorem principalBoundaryNoUnifyAllHooksSuite_capstone_expr_as_general
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_noUnifyAllHooks
    (principalBoundaryNoUnifyAllHooksSuite_capstone_expr h_suite h_no h_ok)

/--
One-hop field projection: view a no-unify all-hooks suite capstone on a
successful no-unify run as a general successful-run all-hooks capstone.
-/
theorem principalBoundaryNoUnifyAllHooksSuite_capstone_field_as_general
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_noUnifyAllHooks
    (principalBoundaryNoUnifyAllHooksSuite_capstone_field h_suite h_no h_ok)

/--
Construct the general all-hooks expression capstone directly from a successful
no-unify expression run.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_noUnify
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_noUnifyAllHooks
    (principalBoundaryNoUnifyExprAllHooksCapstone_of_success h_no h_ok)

/--
Construct the general all-hooks field capstone directly from a successful
no-unify field run.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_noUnify
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_noUnifyAllHooks
    (principalBoundaryNoUnifyFieldAllHooksCapstone_of_success h_no h_ok)

/--
No-unify-to-general convenience wrapper: construct an expression run-bundle from
a successful no-unify run.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_capstone
    (principalPreconditionedExprAllHooksCapstone_of_success_noUnify h_no h_ok)

/--
No-unify-to-general convenience wrapper: construct a field run-bundle from a
successful no-unify field run.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_capstone
    (principalPreconditionedFieldAllHooksCapstone_of_success_noUnify h_no h_ok)

/--
No-unify-to-general convenience wrapper: derive core expression principality
from a successful no-unify run using the general all-hooks capstone surface.
-/
theorem principalCoreExpr_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  (principalPreconditionedExprAllHooksCapstone_of_success_noUnify h_no h_ok).core

/--
No-unify-to-general convenience wrapper: derive preconditioned expression
principality for any hook witnesses from a successful no-unify run.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  (principalPreconditionedExprAllHooksCapstone_of_success_noUnify h_no h_ok).preconditionedAny

/--
No-unify-to-general convenience wrapper: derive preconditioned expression
principality for a bundled hook witness from a successful no-unify run.
-/
theorem principalPreconditionedExpr_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  (principalPreconditionedExpr_anyHooks_of_success_noUnify_via_generalAllHooks
    h_no h_ok) h_hooks.1 h_hooks.2

/--
No-unify-to-general convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for any hook witnesses from a successful
no-unify run.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  (principalPreconditionedExprAllHooksCapstone_of_success_noUnify
    h_no h_ok).preconditionedAnyIffCore

/--
No-unify-to-general convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for a bundled hook witness from a successful
no-unify run.
-/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_generalAllHooks
    h_no h_ok) h_hooks.1 h_hooks.2

/--
No-unify-to-general convenience wrapper: derive fixed-run hook irrelevance for
expression principality from a successful no-unify run.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExprAllHooksCapstone_hook_irrelevant
    (principalPreconditionedExprAllHooksCapstone_of_success_noUnify h_no h_ok)

/--
No-unify-to-general convenience wrapper: derive core field principality from a
successful no-unify field run using the general all-hooks capstone surface.
-/
theorem principalCoreField_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalPreconditionedFieldAllHooksCapstone_of_success_noUnify h_no h_ok).core

/--
No-unify-to-general convenience wrapper: derive preconditioned field
principality for any hook witnesses from a successful no-unify field run.
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  (principalPreconditionedFieldAllHooksCapstone_of_success_noUnify h_no h_ok).preconditionedAny

/--
No-unify-to-general convenience wrapper: derive preconditioned field
principality for a bundled hook witness from a successful no-unify field run.
-/
theorem principalPreconditionedField_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  (principalPreconditionedField_anyHooks_of_success_noUnify_via_generalAllHooks
    h_no h_ok) h_hooks.1 h_hooks.2

/--
No-unify-to-general convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for any hook witnesses from a successful
no-unify field run.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalPreconditionedFieldAllHooksCapstone_of_success_noUnify
    h_no h_ok).preconditionedAnyIffCore

/--
No-unify-to-general convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for a bundled hook witness from a successful
no-unify field run.
-/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_generalAllHooks
    h_no h_ok) h_hooks.1 h_hooks.2

/--
No-unify-to-general convenience wrapper: derive fixed-run hook irrelevance for
field principality from a successful no-unify run.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedFieldAllHooksCapstone_hook_irrelevant
    (principalPreconditionedFieldAllHooksCapstone_of_success_noUnify h_no h_ok)

/-- Bundled-seed alias for no-unify-to-general core expression on the general-all-hooks route. -/
theorem principalCoreExpr_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_generalAllHooks h_no h_ok

/-- Bundled-seed alias for no-unify-to-general core field on the general-all-hooks route. -/
theorem principalCoreField_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_generalAllHooks h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks expression preconditioning on the general-all-hooks route. -/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_generalAllHooks
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general expression preconditioning on the general-all-hooks route. -/
theorem principalPreconditionedExpr_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_noUnify_via_generalAllHooks
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify-to-general any-hooks expression iff preconditioning on the general-all-hooks route. -/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_generalAllHooks
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general expression iff preconditioning on the general-all-hooks route. -/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_noUnify_via_generalAllHooks
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify-to-general expression hook-irrelevance on the general-all-hooks route. -/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_generalAllHooks
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general expression run-bundle on the general-all-hooks route. -/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_generalAllHooks
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks field preconditioning on the general-all-hooks route. -/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_generalAllHooks
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general field preconditioning on the general-all-hooks route. -/
theorem principalPreconditionedField_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_noUnify_via_generalAllHooks
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify-to-general any-hooks field iff preconditioning on the general-all-hooks route. -/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_generalAllHooks
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general field iff preconditioning on the general-all-hooks route. -/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_noUnify_via_generalAllHooks
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify-to-general field hook-irrelevance on the general-all-hooks route. -/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_generalAllHooks
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general field run-bundle on the general-all-hooks route. -/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_generalAllHooks_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_generalAllHooks
    h_no h_ok

/--
Packaged no-unify-to-general expression all-hooks capstone slice.
-/
def PrincipalNoUnifyToGeneralAllHooksExprCapstoneSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty

/--
Packaged no-unify-to-general field all-hooks capstone slice.
-/
def PrincipalNoUnifyToGeneralAllHooksFieldCapstoneSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf

/--
Combined no-unify-to-general all-hooks capstone slices across expressions and
fields.
-/
def PrincipalNoUnifyToGeneralAllHooksCapstoneSlices : Prop :=
  PrincipalNoUnifyToGeneralAllHooksExprCapstoneSlice ∧
    PrincipalNoUnifyToGeneralAllHooksFieldCapstoneSlice

/--
The combined no-unify-to-general all-hooks capstone slices are fully proved.
-/
theorem principalNoUnifyToGeneralAllHooksCapstoneSlices_proved :
    PrincipalNoUnifyToGeneralAllHooksCapstoneSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalPreconditionedExprAllHooksCapstone_of_success_noUnify h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalPreconditionedFieldAllHooksCapstone_of_success_noUnify h_no h_ok

/--
One-hop expression branch projection from no-unify-to-general all-hooks
capstone slices.
-/
theorem principalNoUnifyToGeneralAllHooksCapstoneSlices_expr
    (h_slice : PrincipalNoUnifyToGeneralAllHooksCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  h_slice.1 h_no h_ok

/--
One-hop field branch projection from no-unify-to-general all-hooks capstone
slices.
-/
theorem principalNoUnifyToGeneralAllHooksCapstoneSlices_field
    (h_slice : PrincipalNoUnifyToGeneralAllHooksCapstoneSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  h_slice.2 h_no h_ok

/--
Packaged no-unify-to-general expression run-bundle slice.
-/
def PrincipalNoUnifyToGeneralAllHooksExprRunBundleSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty

/--
Packaged no-unify-to-general field run-bundle slice.
-/
def PrincipalNoUnifyToGeneralAllHooksFieldRunBundleSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf

/--
Combined no-unify-to-general all-hooks run-bundle slices across expressions and
fields.
-/
def PrincipalNoUnifyToGeneralAllHooksRunBundleSlices : Prop :=
  PrincipalNoUnifyToGeneralAllHooksExprRunBundleSlice ∧
    PrincipalNoUnifyToGeneralAllHooksFieldRunBundleSlice

/--
The combined no-unify-to-general all-hooks run-bundle slices are fully proved.
-/
theorem principalNoUnifyToGeneralAllHooksRunBundleSlices_proved :
    PrincipalNoUnifyToGeneralAllHooksRunBundleSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalPreconditionedExprAllHooksRunBundle_of_capstone
      (principalNoUnifyToGeneralAllHooksCapstoneSlices_expr
        principalNoUnifyToGeneralAllHooksCapstoneSlices_proved h_no h_ok)
  · intro st fuel env fs st' rf h_no h_ok
    exact principalPreconditionedFieldAllHooksRunBundle_of_capstone
      (principalNoUnifyToGeneralAllHooksCapstoneSlices_field
        principalNoUnifyToGeneralAllHooksCapstoneSlices_proved h_no h_ok)

/--
One-hop expression projection from no-unify-to-general all-hooks run-bundle
slices.
-/
theorem principalNoUnifyToGeneralAllHooksRunBundleSlices_expr
    (h_slice : PrincipalNoUnifyToGeneralAllHooksRunBundleSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  h_slice.1 h_no h_ok

/--
One-hop field projection from no-unify-to-general all-hooks run-bundle slices.
-/
theorem principalNoUnifyToGeneralAllHooksRunBundleSlices_field
    (h_slice : PrincipalNoUnifyToGeneralAllHooksRunBundleSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  h_slice.2 h_no h_ok

/--
Packaged no-unify-to-general expression hook-irrelevance slice.
-/
def PrincipalNoUnifyToGeneralAllHooksExprIrrelevanceSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)

/--
Packaged no-unify-to-general field hook-irrelevance slice.
-/
def PrincipalNoUnifyToGeneralAllHooksFieldIrrelevanceSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)

/--
Combined no-unify-to-general all-hooks irrelevance slices across expressions and
fields.
-/
def PrincipalNoUnifyToGeneralAllHooksIrrelevanceSlices : Prop :=
  PrincipalNoUnifyToGeneralAllHooksExprIrrelevanceSlice ∧
    PrincipalNoUnifyToGeneralAllHooksFieldIrrelevanceSlice

/--
The combined no-unify-to-general all-hooks irrelevance slices are fully proved.
-/
theorem principalNoUnifyToGeneralAllHooksIrrelevanceSlices_proved :
    PrincipalNoUnifyToGeneralAllHooksIrrelevanceSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_app₁ h_proj₁ h_app₂ h_proj₂ h_no h_ok
    exact principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_generalAllHooks
      h_no h_ok
  · intro st fuel env fs st' rf h_app₁ h_proj₁ h_app₂ h_proj₂ h_no h_ok
    exact principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_generalAllHooks
      h_no h_ok

/--
One-hop projection: expression branch from no-unify-to-general all-hooks
irrelevance slices.
-/
theorem principalNoUnifyToGeneralAllHooksIrrelevanceSlices_expr
    (h_slice : PrincipalNoUnifyToGeneralAllHooksIrrelevanceSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  h_slice.1 h_no h_ok

/--
One-hop projection: field branch from no-unify-to-general all-hooks irrelevance
slices.
-/
theorem principalNoUnifyToGeneralAllHooksIrrelevanceSlices_field
    (h_slice : PrincipalNoUnifyToGeneralAllHooksIrrelevanceSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  h_slice.2 h_no h_ok

/--
Top-level no-unify-to-general all-hooks suite.
-/
structure PrincipalNoUnifyToGeneralAllHooksSuite : Prop where
  capstones : PrincipalNoUnifyToGeneralAllHooksCapstoneSlices
  runBundles : PrincipalNoUnifyToGeneralAllHooksRunBundleSlices
  irrelevance : PrincipalNoUnifyToGeneralAllHooksIrrelevanceSlices

/-- Explicit component alias for `PrincipalNoUnifyToGeneralAllHooksSuite`. -/
abbrev PrincipalNoUnifyToGeneralAllHooksSuiteComponents : Prop :=
  PrincipalNoUnifyToGeneralAllHooksCapstoneSlices
    ∧ PrincipalNoUnifyToGeneralAllHooksRunBundleSlices
    ∧ PrincipalNoUnifyToGeneralAllHooksIrrelevanceSlices

/--
The no-unify-to-general all-hooks suite is fully proved.
-/
theorem principalNoUnifyToGeneralAllHooksSuite_proved :
    PrincipalNoUnifyToGeneralAllHooksSuite := by
  refine {
    capstones := principalNoUnifyToGeneralAllHooksCapstoneSlices_proved
    runBundles := principalNoUnifyToGeneralAllHooksRunBundleSlices_proved
    irrelevance := principalNoUnifyToGeneralAllHooksIrrelevanceSlices_proved
  }

/-- `PrincipalNoUnifyToGeneralAllHooksSuite` is equivalent to explicit components. -/
theorem principalNoUnifyToGeneralAllHooksSuite_iff_components :
    PrincipalNoUnifyToGeneralAllHooksSuite
      ↔ PrincipalNoUnifyToGeneralAllHooksSuiteComponents := by
  constructor
  · intro h_suite
    exact ⟨h_suite.capstones, h_suite.runBundles, h_suite.irrelevance⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2.1, h_comp.2.2⟩

/-- Build `PrincipalNoUnifyToGeneralAllHooksSuite` from explicit components. -/
theorem principalNoUnifyToGeneralAllHooksSuite_of_components
    (h_comp : PrincipalNoUnifyToGeneralAllHooksSuiteComponents) :
    PrincipalNoUnifyToGeneralAllHooksSuite :=
  (principalNoUnifyToGeneralAllHooksSuite_iff_components).2 h_comp

/-- Decompose `PrincipalNoUnifyToGeneralAllHooksSuite` into explicit components. -/
theorem principalNoUnifyToGeneralAllHooksSuite_as_components
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite) :
    PrincipalNoUnifyToGeneralAllHooksSuiteComponents :=
  (principalNoUnifyToGeneralAllHooksSuite_iff_components).1 h_suite

/-- Direct components-route decomposition for `PrincipalNoUnifyToGeneralAllHooksSuite`. -/
theorem principalNoUnifyToGeneralAllHooksSuite_as_components_of_components
    (h_comp : PrincipalNoUnifyToGeneralAllHooksSuiteComponents) :
    PrincipalNoUnifyToGeneralAllHooksSuiteComponents :=
  (principalNoUnifyToGeneralAllHooksSuite_iff_components).1
    (principalNoUnifyToGeneralAllHooksSuite_of_components h_comp)

/--
One-hop expression capstone projection from no-unify-to-general all-hooks
suite.
-/
theorem principalNoUnifyToGeneralAllHooksSuite_capstone_expr
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyToGeneralAllHooksCapstoneSlices_expr h_suite.capstones h_no h_ok

/--
One-hop field capstone projection from no-unify-to-general all-hooks suite.
-/
theorem principalNoUnifyToGeneralAllHooksSuite_capstone_field
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyToGeneralAllHooksCapstoneSlices_field h_suite.capstones h_no h_ok

/--
One-hop expression run-bundle projection from no-unify-to-general all-hooks
suite.
-/
theorem principalNoUnifyToGeneralAllHooksSuite_runBundle_expr
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyToGeneralAllHooksRunBundleSlices_expr h_suite.runBundles h_no h_ok

/--
One-hop field run-bundle projection from no-unify-to-general all-hooks suite.
-/
theorem principalNoUnifyToGeneralAllHooksSuite_runBundle_field
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyToGeneralAllHooksRunBundleSlices_field h_suite.runBundles h_no h_ok

/--
No-unify-to-general suite convenience wrapper: derive the expression run-bundle
surface from a successful no-unify run.
-/
theorem principalNoUnifyToGeneralRunBundleExpr_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyToGeneralAllHooksSuite_runBundle_expr h_suite h_no h_ok

/--
No-unify-to-general suite convenience wrapper: derive the field run-bundle
surface from a successful no-unify field run.
-/
theorem principalNoUnifyToGeneralRunBundleField_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyToGeneralAllHooksSuite_runBundle_field h_suite h_no h_ok

/--
One-hop expression irrelevance projection from no-unify-to-general all-hooks
suite.
-/
theorem principalNoUnifyToGeneralAllHooksSuite_irrelevance_expr
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyToGeneralAllHooksIrrelevanceSlices_expr
    h_suite.irrelevance h_no h_ok

/--
One-hop field irrelevance projection from no-unify-to-general all-hooks suite.
-/
theorem principalNoUnifyToGeneralAllHooksSuite_irrelevance_field
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyToGeneralAllHooksIrrelevanceSlices_field
    h_suite.irrelevance h_no h_ok

/--
No-unify-to-general suite convenience wrapper: derive core expression
principality from a successful no-unify expression run.
-/
theorem principalNoUnifyToGeneralCoreExpr_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  (principalNoUnifyToGeneralAllHooksSuite_capstone_expr
    h_suite h_no h_ok).core

/--
No-unify-to-general suite convenience wrapper: derive preconditioned expression
principality for any hook witnesses from a successful no-unify run.
-/
theorem principalNoUnifyToGeneralPreconditionedExpr_anyHooks_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  (principalNoUnifyToGeneralAllHooksSuite_capstone_expr
    h_suite h_no h_ok).preconditionedAny

/--
No-unify-to-general suite convenience wrapper: derive preconditioned expression
principality for a bundled hook witness from a successful no-unify run.
-/
theorem principalNoUnifyToGeneralPreconditionedExpr_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  (principalNoUnifyToGeneralPreconditionedExpr_anyHooks_of_success
    h_suite h_no h_ok) h_hooks.1 h_hooks.2

/--
No-unify-to-general suite convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalNoUnifyToGeneralPreconditionedCoreIffExpr_anyHooks_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  (principalNoUnifyToGeneralAllHooksSuite_capstone_expr
    h_suite h_no h_ok).preconditionedAnyIffCore

/--
No-unify-to-general suite convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalNoUnifyToGeneralPreconditionedCoreIffExpr_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalNoUnifyToGeneralPreconditionedCoreIffExpr_anyHooks_of_success
    h_suite h_no h_ok) h_hooks.1 h_hooks.2

/--
No-unify-to-general suite convenience wrapper: derive fixed-run expression
hook-irrelevance from a successful no-unify run.
-/
theorem principalNoUnifyToGeneralPreconditionedExpr_hookIrrelevant_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyToGeneralAllHooksSuite_irrelevance_expr
    h_suite h_no h_ok

/--
No-unify-to-general suite convenience wrapper: derive core field principality
from a successful no-unify field run.
-/
theorem principalNoUnifyToGeneralCoreField_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalNoUnifyToGeneralAllHooksSuite_capstone_field
    h_suite h_no h_ok).core

/--
No-unify-to-general suite convenience wrapper: derive preconditioned field
principality for any hook witnesses from a successful no-unify field run.
-/
theorem principalNoUnifyToGeneralPreconditionedField_anyHooks_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  (principalNoUnifyToGeneralAllHooksSuite_capstone_field
    h_suite h_no h_ok).preconditionedAny

/--
No-unify-to-general suite convenience wrapper: derive preconditioned field
principality for a bundled hook witness from a successful no-unify field run.
-/
theorem principalNoUnifyToGeneralPreconditionedField_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  (principalNoUnifyToGeneralPreconditionedField_anyHooks_of_success
    h_suite h_no h_ok) h_hooks.1 h_hooks.2

/--
No-unify-to-general suite convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalNoUnifyToGeneralPreconditionedCoreIffField_anyHooks_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalNoUnifyToGeneralAllHooksSuite_capstone_field
    h_suite h_no h_ok).preconditionedAnyIffCore

/--
No-unify-to-general suite convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalNoUnifyToGeneralPreconditionedCoreIffField_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalNoUnifyToGeneralPreconditionedCoreIffField_anyHooks_of_success
    h_suite h_no h_ok) h_hooks.1 h_hooks.2

/--
No-unify-to-general suite convenience wrapper: derive fixed-run field
hook-irrelevance from a successful no-unify field run.
-/
theorem principalNoUnifyToGeneralPreconditionedField_hookIrrelevant_of_success
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyToGeneralAllHooksSuite_irrelevance_field
    h_suite h_no h_ok

/--
Convert a general successful-run all-hooks expression capstone into the
no-unify all-hooks expression capstone shape.
-/
theorem principalBoundaryNoUnifyExprAllHooksCapstone_of_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_cap : PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty) :
    PrincipalBoundaryNoUnifyExprAllHooksCapstone st fuel env e st' ty := by
  refine {
    core := h_cap.core
    preconditionedAny := h_cap.preconditionedAny
    preconditionedAnyIffCore := h_cap.preconditionedAnyIffCore
  }

/--
Convert a general successful-run all-hooks field capstone into the
no-unify all-hooks field capstone shape.
-/
theorem principalBoundaryNoUnifyFieldAllHooksCapstone_of_generalAllHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_cap : PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf) :
    PrincipalBoundaryNoUnifyFieldAllHooksCapstone st fuel env fs st' rf := by
  refine {
    core := h_cap.core
    preconditionedAny := h_cap.preconditionedAny
    preconditionedAnyIffCore := h_cap.preconditionedAnyIffCore
  }

/--
Derive no-unify-to-general run-bundle slices from a no-unify all-hooks suite.
-/
theorem principalNoUnifyToGeneralAllHooksRunBundleSlices_of_noUnifyAllHooksSuite
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite) :
    PrincipalNoUnifyToGeneralAllHooksRunBundleSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalBoundaryNoUnifyAllHooksSuite_runBundle_expr
      h_suite h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalBoundaryNoUnifyAllHooksSuite_runBundle_field
      h_suite h_no h_ok

/--
Derive no-unify all-hooks run-bundle slices from a no-unify-to-general suite.
-/
theorem principalBoundaryNoUnifyAllHooksRunBundleSlices_of_noUnifyToGeneralAllHooksSuite
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite) :
    PrincipalBoundaryNoUnifyAllHooksRunBundleSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalNoUnifyToGeneralAllHooksSuite_runBundle_expr
      h_suite h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalNoUnifyToGeneralAllHooksSuite_runBundle_field
      h_suite h_no h_ok

/--
Canonical no-unify-to-general run-bundle slices derived from the proved no-unify
all-hooks suite.
-/
theorem principalNoUnifyToGeneralAllHooksRunBundleSlices_proved_via_noUnifyAllHooks :
    PrincipalNoUnifyToGeneralAllHooksRunBundleSlices :=
  principalNoUnifyToGeneralAllHooksRunBundleSlices_of_noUnifyAllHooksSuite
    principalBoundaryNoUnifyAllHooksSuite_proved

/--
Canonical no-unify all-hooks run-bundle slices derived from the proved
no-unify-to-general all-hooks suite.
-/
theorem principalBoundaryNoUnifyAllHooksRunBundleSlices_proved_via_noUnifyToGeneral :
    PrincipalBoundaryNoUnifyAllHooksRunBundleSlices :=
  principalBoundaryNoUnifyAllHooksRunBundleSlices_of_noUnifyToGeneralAllHooksSuite
    principalNoUnifyToGeneralAllHooksSuite_proved

/--
Derive the no-unify-to-general all-hooks suite from a no-unify all-hooks suite.
-/
theorem principalNoUnifyToGeneralAllHooksSuite_of_noUnifyAllHooksSuite
    (h_suite : PrincipalBoundaryNoUnifyAllHooksSuite) :
    PrincipalNoUnifyToGeneralAllHooksSuite := by
  refine {
    capstones := ?_
    runBundles := ?_
    irrelevance := ?_
  }
  · refine ⟨?_, ?_⟩
    · intro st fuel env e st' ty h_no h_ok
      exact principalBoundaryNoUnifyAllHooksSuite_capstone_expr_as_general
        h_suite h_no h_ok
    · intro st fuel env fs st' rf h_no h_ok
      exact principalBoundaryNoUnifyAllHooksSuite_capstone_field_as_general
        h_suite h_no h_ok
  · refine ⟨?_, ?_⟩
    · intro st fuel env e st' ty h_no h_ok
      exact principalPreconditionedExprAllHooksRunBundle_of_capstone
        (principalBoundaryNoUnifyAllHooksSuite_capstone_expr_as_general
          h_suite h_no h_ok)
    · intro st fuel env fs st' rf h_no h_ok
      exact principalPreconditionedFieldAllHooksRunBundle_of_capstone
        (principalBoundaryNoUnifyAllHooksSuite_capstone_field_as_general
          h_suite h_no h_ok)
  · refine ⟨?_, ?_⟩
    · intro st fuel env e st' ty h_app₁ h_proj₁ h_app₂ h_proj₂ h_no h_ok
      exact principalBoundaryNoUnifyAllHooksSuite_irrelevance_expr
        h_suite h_no h_ok
    · intro st fuel env fs st' rf h_app₁ h_proj₁ h_app₂ h_proj₂ h_no h_ok
      exact principalBoundaryNoUnifyAllHooksSuite_irrelevance_field
        h_suite h_no h_ok

/--
Derive the no-unify all-hooks suite from a no-unify-to-general all-hooks suite.
-/
theorem principalBoundaryNoUnifyAllHooksSuite_of_noUnifyToGeneralAllHooksSuite
    (h_suite : PrincipalNoUnifyToGeneralAllHooksSuite) :
    PrincipalBoundaryNoUnifyAllHooksSuite := by
  refine {
    capstones := ?_
    runBundles := ?_
    irrelevance := ?_
  }
  · refine ⟨?_, ?_⟩
    · intro st fuel env e st' ty h_no h_ok
      exact principalBoundaryNoUnifyExprAllHooksCapstone_of_generalAllHooks
        (principalNoUnifyToGeneralAllHooksSuite_capstone_expr h_suite h_no h_ok)
    · intro st fuel env fs st' rf h_no h_ok
      exact principalBoundaryNoUnifyFieldAllHooksCapstone_of_generalAllHooks
        (principalNoUnifyToGeneralAllHooksSuite_capstone_field h_suite h_no h_ok)
  · refine ⟨?_, ?_⟩
    · intro st fuel env e st' ty h_no h_ok
      exact principalNoUnifyToGeneralAllHooksSuite_runBundle_expr
        h_suite h_no h_ok
    · intro st fuel env fs st' rf h_no h_ok
      exact principalNoUnifyToGeneralAllHooksSuite_runBundle_field
        h_suite h_no h_ok
  · refine ⟨?_, ?_⟩
    · intro st fuel env e st' ty h_app₁ h_proj₁ h_app₂ h_proj₂ h_no h_ok
      exact principalNoUnifyToGeneralAllHooksSuite_irrelevance_expr
        h_suite h_no h_ok
    · intro st fuel env fs st' rf h_app₁ h_proj₁ h_app₂ h_proj₂ h_no h_ok
      exact principalNoUnifyToGeneralAllHooksSuite_irrelevance_field
        h_suite h_no h_ok

/--
Canonical derived no-unify-to-general suite from the proved no-unify all-hooks
suite.
-/
theorem principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks :
    PrincipalNoUnifyToGeneralAllHooksSuite :=
  principalNoUnifyToGeneralAllHooksSuite_of_noUnifyAllHooksSuite
    principalBoundaryNoUnifyAllHooksSuite_proved

/--
Canonical derived no-unify all-hooks suite from the proved no-unify-to-general
suite.
-/
theorem principalBoundaryNoUnifyAllHooksSuite_proved_via_noUnifyToGeneral :
    PrincipalBoundaryNoUnifyAllHooksSuite :=
  principalBoundaryNoUnifyAllHooksSuite_of_noUnifyToGeneralAllHooksSuite
    principalNoUnifyToGeneralAllHooksSuite_proved

/--
Convert an all-hooks expression capstone into a hook-specific no-unify
expression capstone by selecting concrete hook witnesses.
-/
theorem principalBoundaryNoUnifyExprCapstone_of_allHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_cap : PrincipalBoundaryNoUnifyExprAllHooksCapstone st fuel env e st' ty)
    (h_app : AppUnifySoundHook) (h_proj : ProjUnifySoundHook) :
    PrincipalBoundaryNoUnifyExprCapstone h_app h_proj st fuel env e st' ty := by
  refine {
    noUnify := ?_
    preconditionedCoreIff := h_cap.preconditionedAnyIffCore h_app h_proj
  }
  refine {
    core := h_cap.core
    preconditioned := h_cap.preconditionedAny h_app h_proj
  }

/--
Convert an all-hooks field capstone into a hook-specific no-unify field
capstone by selecting concrete hook witnesses.
-/
theorem principalBoundaryNoUnifyFieldCapstone_of_allHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundaryNoUnifyFieldAllHooksCapstone st fuel env fs st' rf)
    (h_app : AppUnifySoundHook) (h_proj : ProjUnifySoundHook) :
    PrincipalBoundaryNoUnifyFieldCapstone h_app h_proj st fuel env fs st' rf := by
  refine {
    noUnify := ?_
    preconditionedCoreIff := h_cap.preconditionedAnyIffCore h_app h_proj
  }
  refine {
    core := h_cap.core
    preconditioned := h_cap.preconditionedAny h_app h_proj
  }

/--
Derive the hook-specific no-unify capstone slices from the all-hooks no-unify
capstone slices.
-/
theorem principalBoundaryNoUnifyCapstoneSlices_of_allHooksCapstones
    (h_all : PrincipalBoundaryNoUnifyAllHooksCapstoneSlices) :
    PrincipalBoundaryNoUnifyCapstoneSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok h_hooks
    exact principalBoundaryNoUnifyExprCapstone_of_allHooks
      (principalBoundaryNoUnifyAllHooksCapstoneSlices_expr h_all h_no h_ok)
      h_hooks.1 h_hooks.2
  · intro st fuel env fs st' rf h_no h_ok h_hooks
    exact principalBoundaryNoUnifyFieldCapstone_of_allHooks
      (principalBoundaryNoUnifyAllHooksCapstoneSlices_field h_all h_no h_ok)
      h_hooks.1 h_hooks.2

/--
Derive the hook-specific no-unify capstone slices directly from the proved
all-hooks suite.
-/
theorem principalBoundaryNoUnifyCapstoneSlices_of_allHooksSuite :
    PrincipalBoundaryNoUnifyCapstoneSlices :=
  principalBoundaryNoUnifyCapstoneSlices_of_allHooksCapstones
    principalBoundaryNoUnifyAllHooksSuite_proved.capstones

/--
Top-level principal boundary master suite.

This aggregates the current M4 theorem surfaces:
- successful-run bridge suite (core↔preconditioned and no-unify bundles),
- vacuity suite (no-unify + fixed-run hook-irrelevance), and
- general successful-run all-hooks suite, and
- no-unify all-hooks suite (+ compatibility back to hook-specific capstones),
- and no-unify-to-general all-hooks bridge suite.
-/
structure PrincipalBoundaryMasterSuite : Prop where
  bridge : PrincipalBoundaryBridgeSuite
  vacuity : PrincipalBoundaryVacuitySuite
  allHooks : PrincipalPreconditionedAllHooksSuite
  noUnifyAllHooks : PrincipalBoundaryNoUnifyAllHooksSuite
  noUnifyHookedFromAllHooks : PrincipalBoundaryNoUnifyCapstoneSlices
  noUnifyToGeneralAllHooks : PrincipalNoUnifyToGeneralAllHooksSuite

/-- Explicit component alias for `PrincipalBoundaryMasterSuite`. -/
abbrev PrincipalBoundaryMasterSuiteComponents : Prop :=
  PrincipalBoundaryBridgeSuite
    ∧ PrincipalBoundaryVacuitySuite
    ∧ PrincipalPreconditionedAllHooksSuite
    ∧ PrincipalBoundaryNoUnifyAllHooksSuite
    ∧ PrincipalBoundaryNoUnifyCapstoneSlices
    ∧ PrincipalNoUnifyToGeneralAllHooksSuite

/-- The principal boundary master suite is fully proved. -/
theorem principalBoundaryMasterSuite_proved : PrincipalBoundaryMasterSuite := by
  refine {
    bridge := principalBoundaryBridgeSuite_proved
    vacuity := principalBoundaryVacuitySuite_proved
    allHooks := principalPreconditionedAllHooksSuite_proved
    noUnifyAllHooks := principalBoundaryNoUnifyAllHooksSuite_proved
    noUnifyHookedFromAllHooks := principalBoundaryNoUnifyCapstoneSlices_of_allHooksSuite
    noUnifyToGeneralAllHooks := principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks
  }

/-- `PrincipalBoundaryMasterSuite` is equivalent to explicit components. -/
theorem principalBoundaryMasterSuite_iff_components :
    PrincipalBoundaryMasterSuite ↔ PrincipalBoundaryMasterSuiteComponents := by
  constructor
  · intro h_suite
    exact ⟨h_suite.bridge, h_suite.vacuity, h_suite.allHooks,
      h_suite.noUnifyAllHooks, h_suite.noUnifyHookedFromAllHooks,
      h_suite.noUnifyToGeneralAllHooks⟩
  · intro h_comp
    rcases h_comp with
      ⟨h_bridge, h_vacuity, h_allHooks, h_noUnifyAllHooks,
        h_noUnifyHookedFromAllHooks, h_noUnifyToGeneralAllHooks⟩
    exact {
      bridge := h_bridge
      vacuity := h_vacuity
      allHooks := h_allHooks
      noUnifyAllHooks := h_noUnifyAllHooks
      noUnifyHookedFromAllHooks := h_noUnifyHookedFromAllHooks
      noUnifyToGeneralAllHooks := h_noUnifyToGeneralAllHooks
    }

/-- Build `PrincipalBoundaryMasterSuite` from explicit components. -/
theorem principalBoundaryMasterSuite_of_components
    (h_comp : PrincipalBoundaryMasterSuiteComponents) :
    PrincipalBoundaryMasterSuite :=
  (principalBoundaryMasterSuite_iff_components).2 h_comp

/-- Decompose `PrincipalBoundaryMasterSuite` into explicit components. -/
theorem principalBoundaryMasterSuite_as_components
    (h_suite : PrincipalBoundaryMasterSuite) :
    PrincipalBoundaryMasterSuiteComponents :=
  (principalBoundaryMasterSuite_iff_components).1 h_suite

/-- Direct components-route decomposition for `PrincipalBoundaryMasterSuite`. -/
theorem principalBoundaryMasterSuite_as_components_of_components
    (h_comp : PrincipalBoundaryMasterSuiteComponents) :
    PrincipalBoundaryMasterSuiteComponents :=
  (principalBoundaryMasterSuite_iff_components).1
    (principalBoundaryMasterSuite_of_components h_comp)

/--
One-hop expression successful-run preconditioned↔core equivalence from the
master suite.
-/
theorem principalBoundaryMasterSuite_preconditionedCoreIff_expr
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalBoundaryBridgeSuite_preconditionedCoreIff_expr
    h_suite.bridge h_hooks st fuel env e st' ty h_ok

/--
One-hop field successful-run preconditioned↔core equivalence from the master
suite.
-/
theorem principalBoundaryMasterSuite_preconditionedCoreIff_field
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalBoundaryBridgeSuite_preconditionedCoreIff_field
    h_suite.bridge h_hooks st fuel env fs st' rf h_ok

/-- One-hop expression hook-irrelevance projection from master suite. -/
theorem principalBoundaryMasterSuite_hookIrrelevance_expr
    (h_suite : PrincipalBoundaryMasterSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedHookIrrelevanceSlices_expr
    h_suite.vacuity.hookIrrelevance h_ok

/-- One-hop field hook-irrelevance projection from master suite. -/
theorem principalBoundaryMasterSuite_hookIrrelevance_field
    (h_suite : PrincipalBoundaryMasterSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedHookIrrelevanceSlices_field
    h_suite.vacuity.hookIrrelevance h_ok

/-- One-hop expression general all-hooks capstone projection from master suite. -/
theorem principalBoundaryMasterSuite_allHooks_expr
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedAllHooksSuite_capstone_expr
    h_suite.allHooks h_app0 h_proj0 h_ok

/-- One-hop field general all-hooks capstone projection from master suite. -/
theorem principalBoundaryMasterSuite_allHooks_field
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedAllHooksSuite_capstone_field
    h_suite.allHooks h_app0 h_proj0 h_ok

/-- One-hop expression general all-hooks run-bundle projection from master suite. -/
theorem principalBoundaryMasterSuite_allHooks_runBundle_expr
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedAllHooksSuite_runBundle_expr
    h_suite.allHooks h_app0 h_proj0 h_ok

/-- One-hop field general all-hooks run-bundle projection from master suite. -/
theorem principalBoundaryMasterSuite_allHooks_runBundle_field
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedAllHooksSuite_runBundle_field
    h_suite.allHooks h_app0 h_proj0 h_ok

/-- One-hop expression all-hooks no-unify capstone projection from master suite. -/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_expr
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundaryNoUnifyExprAllHooksCapstone st fuel env e st' ty :=
  principalBoundaryNoUnifyAllHooksSuite_capstone_expr
    h_suite.noUnifyAllHooks h_no h_ok

/-- One-hop field all-hooks no-unify capstone projection from master suite. -/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_field
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundaryNoUnifyFieldAllHooksCapstone st fuel env fs st' rf :=
  principalBoundaryNoUnifyAllHooksSuite_capstone_field
    h_suite.noUnifyAllHooks h_no h_ok

/-- One-hop expression all-hooks no-unify run-bundle projection from master suite. -/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_expr
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryNoUnifyAllHooksSuite_runBundle_expr
    h_suite.noUnifyAllHooks h_no h_ok

/-- One-hop field all-hooks no-unify run-bundle projection from master suite. -/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_field
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryNoUnifyAllHooksSuite_runBundle_field
    h_suite.noUnifyAllHooks h_no h_ok

/--
One-hop expression no-unify-to-general all-hooks capstone projection from
master suite.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_expr
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyToGeneralAllHooksSuite_capstone_expr
    h_suite.noUnifyToGeneralAllHooks h_no h_ok

/--
One-hop field no-unify-to-general all-hooks capstone projection from master
suite.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_field
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyToGeneralAllHooksSuite_capstone_field
    h_suite.noUnifyToGeneralAllHooks h_no h_ok

/--
One-hop expression no-unify-to-general all-hooks run-bundle projection from
master suite.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_runBundle_expr
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyToGeneralAllHooksSuite_runBundle_expr
    h_suite.noUnifyToGeneralAllHooks h_no h_ok

/--
One-hop field no-unify-to-general all-hooks run-bundle projection from master
suite.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_runBundle_field
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyToGeneralAllHooksSuite_runBundle_field
    h_suite.noUnifyToGeneralAllHooks h_no h_ok

/--
One-hop expression no-unify-to-general all-hooks irrelevance projection from
master suite.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_irrelevance_expr
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyToGeneralAllHooksSuite_irrelevance_expr
    h_suite.noUnifyToGeneralAllHooks h_no h_ok

/--
One-hop field no-unify-to-general all-hooks irrelevance projection from master
suite.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_irrelevance_field
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyToGeneralAllHooksSuite_irrelevance_field
    h_suite.noUnifyToGeneralAllHooks h_no h_ok

/--
One-hop expression no-unify-as-general all-hooks projection from master suite.
-/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_expr_as_general
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_expr h_suite h_no h_ok

/--
One-hop field no-unify-as-general all-hooks projection from master suite.
-/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_field_as_general
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_field h_suite h_no h_ok

/--
One-hop expression no-unify-as-general all-hooks run-bundle projection from
master suite.
-/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_expr_as_general
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_runBundle_expr h_suite h_no h_ok

/--
One-hop field no-unify-as-general all-hooks run-bundle projection from master
suite.
-/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_field_as_general
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_runBundle_field h_suite h_no h_ok

/--
Top-level master run-bundle suite.

This packages all run-bundle entry surfaces currently exposed through
`PrincipalBoundaryMasterSuite`:
- arbitrary successful all-hooks runs,
- successful no-unify all-hooks runs,
- and successful no-unify-to-general all-hooks runs.
-/
structure PrincipalBoundaryMasterRunBundleSuite : Prop where
  allHooksExpr :
    ∀ (_h_app0 : AppUnifySoundHook) (_h_proj0 : ProjUnifySoundHook)
      {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
      {st' : UnifyState} {ty : Ty},
      inferExprUnify st fuel env e = .ok st' ty →
      PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty
  allHooksField :
    ∀ (_h_app0 : AppUnifySoundHook) (_h_proj0 : ProjUnifySoundHook)
      {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
      {st' : UnifyState} {rf : RowFields},
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf
  noUnifyAllHooksExpr :
    ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
      {st' : UnifyState} {ty : Ty},
      NoUnifyBranchesExpr e →
      inferExprUnify st fuel env e = .ok st' ty →
      PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty
  noUnifyAllHooksField :
    ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
      {st' : UnifyState} {rf : RowFields},
      NoUnifyBranchesFields fs →
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf
  noUnifyToGeneralExpr :
    ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
      {st' : UnifyState} {ty : Ty},
      NoUnifyBranchesExpr e →
      inferExprUnify st fuel env e = .ok st' ty →
      PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty
  noUnifyToGeneralField :
    ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
      {st' : UnifyState} {rf : RowFields},
      NoUnifyBranchesFields fs →
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf

/-- Explicit component alias for `PrincipalBoundaryMasterRunBundleSuite`. -/
abbrev PrincipalBoundaryMasterRunBundleSuiteComponents : Prop :=
  PrincipalBoundaryMasterRunBundleSuite

/-- `PrincipalBoundaryMasterRunBundleSuite` is equivalent to its components alias. -/
theorem principalBoundaryMasterRunBundleSuite_iff_components :
    PrincipalBoundaryMasterRunBundleSuite
      ↔ PrincipalBoundaryMasterRunBundleSuiteComponents := by
  constructor <;> intro h <;> simpa [PrincipalBoundaryMasterRunBundleSuiteComponents] using h

/-- Build `PrincipalBoundaryMasterRunBundleSuite` from components alias. -/
theorem principalBoundaryMasterRunBundleSuite_of_components
    (h_comp : PrincipalBoundaryMasterRunBundleSuiteComponents) :
    PrincipalBoundaryMasterRunBundleSuite := by
  simpa [PrincipalBoundaryMasterRunBundleSuiteComponents] using h_comp

/-- Decompose `PrincipalBoundaryMasterRunBundleSuite` into components alias. -/
theorem principalBoundaryMasterRunBundleSuite_as_components
    (h_suite : PrincipalBoundaryMasterRunBundleSuite) :
    PrincipalBoundaryMasterRunBundleSuiteComponents := by
  simpa [PrincipalBoundaryMasterRunBundleSuiteComponents] using h_suite

/-- Direct components-route decomposition for `PrincipalBoundaryMasterRunBundleSuite`. -/
theorem principalBoundaryMasterRunBundleSuite_as_components_of_components
    (h_comp : PrincipalBoundaryMasterRunBundleSuiteComponents) :
    PrincipalBoundaryMasterRunBundleSuiteComponents := by
  simpa using h_comp

/--
Construct the master run-bundle suite from a master principal-boundary suite.
-/
theorem principalBoundaryMasterRunBundleSuite_of_master
    (h_suite : PrincipalBoundaryMasterSuite) :
    PrincipalBoundaryMasterRunBundleSuite := by
  refine {
    allHooksExpr := ?_
    allHooksField := ?_
    noUnifyAllHooksExpr := ?_
    noUnifyAllHooksField := ?_
    noUnifyToGeneralExpr := ?_
    noUnifyToGeneralField := ?_
  }
  · intro h_app0 h_proj0 st fuel env e st' ty h_ok
    exact principalBoundaryMasterSuite_allHooks_runBundle_expr
      h_suite h_app0 h_proj0 h_ok
  · intro h_app0 h_proj0 st fuel env fs st' rf h_ok
    exact principalBoundaryMasterSuite_allHooks_runBundle_field
      h_suite h_app0 h_proj0 h_ok
  · intro st fuel env e st' ty h_no h_ok
    exact principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_expr
      h_suite h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_field
      h_suite h_no h_ok
  · intro st fuel env e st' ty h_no h_ok
    exact principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_runBundle_expr
      h_suite h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_runBundle_field
      h_suite h_no h_ok

/-- Direct route decomposition from `of_master` into run-bundle suite components. -/
theorem principalBoundaryMasterRunBundleSuite_as_components_of_master
    (h_suite : PrincipalBoundaryMasterSuite) :
    PrincipalBoundaryMasterRunBundleSuiteComponents :=
  principalBoundaryMasterRunBundleSuite_as_components
    (principalBoundaryMasterRunBundleSuite_of_master h_suite)

/-- The master run-bundle suite is fully proved. -/
theorem principalBoundaryMasterRunBundleSuite_proved :
    PrincipalBoundaryMasterRunBundleSuite :=
  principalBoundaryMasterRunBundleSuite_of_master principalBoundaryMasterSuite_proved

/--
One-hop projection: arbitrary-success all-hooks expression run-bundle from the
master run-bundle suite.
-/
theorem principalBoundaryMasterRunBundleSuite_allHooks_expr
    (h_suite : PrincipalBoundaryMasterRunBundleSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  h_suite.allHooksExpr h_app0 h_proj0 h_ok

/--
One-hop projection: arbitrary-success all-hooks field run-bundle from the
master run-bundle suite.
-/
theorem principalBoundaryMasterRunBundleSuite_allHooks_field
    (h_suite : PrincipalBoundaryMasterRunBundleSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  h_suite.allHooksField h_app0 h_proj0 h_ok

/--
One-hop projection: successful no-unify all-hooks expression run-bundle from
the master run-bundle suite.
-/
theorem principalBoundaryMasterRunBundleSuite_noUnifyAllHooks_expr
    (h_suite : PrincipalBoundaryMasterRunBundleSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  h_suite.noUnifyAllHooksExpr h_no h_ok

/--
One-hop projection: successful no-unify all-hooks field run-bundle from the
master run-bundle suite.
-/
theorem principalBoundaryMasterRunBundleSuite_noUnifyAllHooks_field
    (h_suite : PrincipalBoundaryMasterRunBundleSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  h_suite.noUnifyAllHooksField h_no h_ok

/--
One-hop projection: successful no-unify-to-general expression run-bundle from
the master run-bundle suite.
-/
theorem principalBoundaryMasterRunBundleSuite_noUnifyToGeneral_expr
    (h_suite : PrincipalBoundaryMasterRunBundleSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  h_suite.noUnifyToGeneralExpr h_no h_ok

/--
One-hop projection: successful no-unify-to-general field run-bundle from the
master run-bundle suite.
-/
theorem principalBoundaryMasterRunBundleSuite_noUnifyToGeneral_field
    (h_suite : PrincipalBoundaryMasterRunBundleSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  h_suite.noUnifyToGeneralField h_no h_ok

/--
Coherence wrapper: view the no-unify all-hooks expression run-bundle projection
through the no-unify-to-general projection path.
-/
theorem principalBoundaryMasterRunBundleSuite_noUnify_expr_as_general
    (h_suite : PrincipalBoundaryMasterRunBundleSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleSuite_noUnifyToGeneral_expr h_suite h_no h_ok

/--
Coherence wrapper: view the no-unify all-hooks field run-bundle projection
through the no-unify-to-general projection path.
-/
theorem principalBoundaryMasterRunBundleSuite_noUnify_field_as_general
    (h_suite : PrincipalBoundaryMasterRunBundleSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleSuite_noUnifyToGeneral_field h_suite h_no h_ok

/--
Master-run-bundle-suite convenience wrapper: derive the arbitrary-success
all-hooks expression run-bundle from a baseline hook pair.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_via_masterRunBundleSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleSuite_allHooks_expr
    principalBoundaryMasterRunBundleSuite_proved h_app0 h_proj0 h_ok

/--
Master-run-bundle-suite convenience wrapper: derive the arbitrary-success
all-hooks field run-bundle from a baseline hook pair.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterRunBundleSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleSuite_allHooks_field
    principalBoundaryMasterRunBundleSuite_proved h_app0 h_proj0 h_ok

/--
Master-run-bundle-suite convenience wrapper: bundle-entry variant for arbitrary
successful expression run-bundles.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_via_masterRunBundleSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_via_masterRunBundleSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-run-bundle-suite convenience wrapper: bundle-entry variant for arbitrary
successful field run-bundles.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterRunBundleSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterRunBundleSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-run-bundle-suite convenience wrapper: derive the successful no-unify
expression run-bundle surface.
-/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleSuite_noUnify_expr_as_general
    principalBoundaryMasterRunBundleSuite_proved h_no h_ok

/--
Master-run-bundle-suite convenience wrapper: derive the successful no-unify
field run-bundle surface.
-/
theorem principalNoUnifyRunBundleField_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleSuite_noUnify_field_as_general
    principalBoundaryMasterRunBundleSuite_proved h_no h_ok

/--
Master-run-bundle-suite convenience wrapper: derive the successful no-unify
expression run-bundle surface.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleSuite h_no h_ok

/--
Master-run-bundle-suite convenience wrapper: derive the successful no-unify
field run-bundle surface.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_masterRunBundleSuite h_no h_ok

/--
Master-run-bundle-suite convenience wrapper: derive core expression principality
from a successful no-unify run.
-/
theorem principalNoUnifyCoreExpr_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalPreconditionedExprAllHooksRunBundle_core
    (principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleSuite h_no h_ok)

/--
Master-run-bundle-suite convenience wrapper: derive preconditioned expression
principality for any hook witnesses from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_preconditioned_anyHooks
    (principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleSuite h_no h_ok)

/--
Master-run-bundle-suite convenience wrapper: derive preconditioned expression
principality for a bundled hook witness from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  (principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok) h_hooks.1 h_hooks.2

/--
Master-run-bundle-suite convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for any hook witnesses from a successful
no-unify run.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedExprAllHooksRunBundle_preconditionedCoreIff_anyHooks
    (principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleSuite h_no h_ok)

/--
Master-run-bundle-suite convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for a bundled hook witness from a successful
no-unify run.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok) h_hooks.1 h_hooks.2

/--
Master-run-bundle-suite convenience wrapper: derive fixed-run expression
hook-irrelevance from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExprAllHooksRunBundle_hook_irrelevant
    (principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleSuite h_no h_ok)

/--
Master-run-bundle-suite convenience wrapper: derive core field principality from
a successful no-unify field run.
-/
theorem principalNoUnifyCoreField_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalPreconditionedFieldAllHooksRunBundle_core
    (principalNoUnifyRunBundleField_of_success_via_masterRunBundleSuite h_no h_ok)

/--
Master-run-bundle-suite convenience wrapper: derive preconditioned field
principality for any hook witnesses from a successful no-unify field run.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_preconditioned_anyHooks
    (principalNoUnifyRunBundleField_of_success_via_masterRunBundleSuite h_no h_ok)

/--
Master-run-bundle-suite convenience wrapper: derive preconditioned field
principality for a bundled hook witness from a successful no-unify field run.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  (principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok) h_hooks.1 h_hooks.2

/--
Master-run-bundle-suite convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for any hook witnesses from a successful
no-unify field run.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedFieldAllHooksRunBundle_preconditionedCoreIff_anyHooks
    (principalNoUnifyRunBundleField_of_success_via_masterRunBundleSuite h_no h_ok)

/--
Master-run-bundle-suite convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for a bundled hook witness from a successful
no-unify field run.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok) h_hooks.1 h_hooks.2

/--
Master-run-bundle-suite convenience wrapper: derive fixed-run field
hook-irrelevance from a successful no-unify field run.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedFieldAllHooksRunBundle_hook_irrelevant
    (principalNoUnifyRunBundleField_of_success_via_masterRunBundleSuite h_no h_ok)

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive core
expression principality from a successful no-unify run.
-/
theorem principalCoreExpr_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterRunBundleSuite h_no h_ok

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive
preconditioned expression principality for any hook witnesses from a successful
no-unify run.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive
preconditioned expression principality for a bundled hook witness from a
successful no-unify run.
-/
theorem principalPreconditionedExpr_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive
fixed-run expression preconditioned↔core equivalence for any hook witnesses
from a successful no-unify run.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive
fixed-run expression preconditioned↔core equivalence for a bundled hook witness
from a successful no-unify run.
-/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive
fixed-run expression hook-irrelevance from a successful no-unify run.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleSuite
    h_no h_ok

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive core
field principality from a successful no-unify field run.
-/
theorem principalCoreField_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterRunBundleSuite h_no h_ok

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive
preconditioned field principality for any hook witnesses from a successful
no-unify field run.
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive
preconditioned field principality for a bundled hook witness from a successful
no-unify field run.
-/
theorem principalPreconditionedField_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterRunBundleSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive
fixed-run field preconditioned↔core equivalence for any hook witnesses from a
successful no-unify field run.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive
fixed-run field preconditioned↔core equivalence for a bundled hook witness from
a successful no-unify field run.
-/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-suite no-unify-to-general convenience wrapper: derive
fixed-run field hook-irrelevance from a successful no-unify field run.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general core expression on the run-bundle suite. -/
theorem principalCoreExpr_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterRunBundleSuite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general core field on the run-bundle suite. -/
theorem principalCoreField_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterRunBundleSuite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks expression preconditioning on the run-bundle suite. -/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general expression preconditioning on the run-bundle suite. -/
theorem principalPreconditionedExpr_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify-to-general any-hooks expression iff preconditioning on the run-bundle suite. -/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general expression iff preconditioning on the run-bundle suite. -/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify-to-general expression hook-irrelevance on the run-bundle suite. -/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general expression run-bundle on the run-bundle suite. -/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks field preconditioning on the run-bundle suite. -/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general field preconditioning on the run-bundle suite. -/
theorem principalPreconditionedField_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify-to-general any-hooks field iff preconditioning on the run-bundle suite. -/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general field iff preconditioning on the run-bundle suite. -/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify-to-general field hook-irrelevance on the run-bundle suite. -/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general field run-bundle on the run-bundle suite. -/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify run-bundle expression on the run-bundle suite. -/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleSuite h_no h_ok

/-- Bundled-seed alias for no-unify run-bundle field on the run-bundle suite. -/
theorem principalNoUnifyRunBundleField_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_masterRunBundleSuite h_no h_ok

/-- Bundled-seed alias for no-unify core expression on the run-bundle suite. -/
theorem principalNoUnifyCoreExpr_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterRunBundleSuite h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks expression preconditioning on the run-bundle suite. -/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify expression preconditioning on the run-bundle suite. -/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleSuite
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify any-hooks expression iff preconditioning on the run-bundle suite. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify expression iff preconditioning on the run-bundle suite. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleSuite
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify expression hook-irrelevance on the run-bundle suite. -/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify core field on the run-bundle suite. -/
theorem principalNoUnifyCoreField_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterRunBundleSuite h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks field preconditioning on the run-bundle suite. -/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify field preconditioning on the run-bundle suite. -/
theorem principalNoUnifyPreconditionedField_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterRunBundleSuite
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify any-hooks field iff preconditioning on the run-bundle suite. -/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify field iff preconditioning on the run-bundle suite. -/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleSuite
    h_no h_ok h_hooks

/-- Bundled-seed alias for no-unify field hook-irrelevance on the run-bundle suite. -/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleSuite
    h_no h_ok

/--
Packaged no-unify expression consequences on the master-run-bundle-suite path.
-/
structure PrincipalNoUnifyExprRunBundleConsequences
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  core : PrincipalTypingSliceCore env e ty
  preconditionedAny :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
  preconditioned :
    ∀ (h_hooks : UnifyHookPremises),
      PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty)
  preconditionedIffCore :
    ∀ (h_hooks : UnifyHookPremises),
      (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty)
  hookIrrelevant :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
        ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)

/--
Packaged no-unify field consequences on the master-run-bundle-suite path.
-/
structure PrincipalNoUnifyFieldRunBundleConsequences
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  core : PrincipalFieldTypingSliceCore env fs rf
  preconditionedAny :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
  preconditioned :
    ∀ (h_hooks : UnifyHookPremises),
      PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf)
  preconditionedIffCore :
    ∀ (h_hooks : UnifyHookPremises),
      (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf)
  hookIrrelevant :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
        ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)

/--
Build packaged no-unify expression consequences from one successful no-unify run
on the master-run-bundle-suite path.
-/
theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty := by
  refine {
    core := principalCoreExpr_of_success_noUnify_via_masterRunBundleSuite h_no h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app h_proj
    exact principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleSuite
      h_no h_ok h_app h_proj
  · intro h_hooks
    exact principalPreconditionedExpr_of_success_noUnify_via_masterRunBundleSuite
      h_no h_ok h_hooks
  · intro h_app h_proj
    exact principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleSuite
      h_no h_ok h_app h_proj
  · intro h_hooks
    exact principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterRunBundleSuite
      h_no h_ok h_hooks
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleSuite
      h_no h_ok

/--
Build packaged no-unify field consequences from one successful no-unify field
run on the master-run-bundle-suite path.
-/
theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf := by
  refine {
    core := principalCoreField_of_success_noUnify_via_masterRunBundleSuite h_no h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app h_proj
    exact principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleSuite
      h_no h_ok h_app h_proj
  · intro h_hooks
    exact principalPreconditionedField_of_success_noUnify_via_masterRunBundleSuite
      h_no h_ok h_hooks
  · intro h_app h_proj
    exact principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleSuite
      h_no h_ok h_app h_proj
  · intro h_hooks
    exact principalPreconditionedCoreIffField_of_success_noUnify_via_masterRunBundleSuite
      h_no h_ok h_hooks
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleSuite
      h_no h_ok

/-- Bundled-seed alias for no-unify expression consequence bundles on the run-bundle suite. -/
theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify field consequence bundles on the run-bundle suite. -/
theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleSuite
    h_no h_ok

/--
Packaged no-unify expression consequence slice over all successful runs on the
master-run-bundle-suite path.
-/
def PrincipalNoUnifyExprRunBundleConsequenceSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty

/--
Packaged no-unify field consequence slice over all successful field runs on the
master-run-bundle-suite path.
-/
def PrincipalNoUnifyFieldRunBundleConsequenceSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf

/--
Combined no-unify consequence slices across expressions and fields on the
master-run-bundle-suite path.
-/
def PrincipalNoUnifyRunBundleConsequenceSlices : Prop :=
  PrincipalNoUnifyExprRunBundleConsequenceSlice ∧
    PrincipalNoUnifyFieldRunBundleConsequenceSlice

/--
The combined no-unify consequence slices are fully proved on the
master-run-bundle-suite path.
-/
theorem principalNoUnifyRunBundleConsequenceSlices_proved :
    PrincipalNoUnifyRunBundleConsequenceSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleSuite
      h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleSuite
      h_no h_ok

/--
One-hop expression projection from the combined no-unify consequence slices on
the master-run-bundle-suite path.
-/
theorem principalNoUnifyRunBundleConsequenceSlices_expr
    (h_slices : PrincipalNoUnifyRunBundleConsequenceSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  h_slices.1 h_no h_ok

/--
One-hop field projection from the combined no-unify consequence slices on the
master-run-bundle-suite path.
-/
theorem principalNoUnifyRunBundleConsequenceSlices_field
    (h_slices : PrincipalNoUnifyRunBundleConsequenceSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  h_slices.2 h_no h_ok

/--
Top-level master run-bundle consequence suite.

This packages the existing master run-bundle surface together with the new
master-run-bundle no-unify consequence slices.
-/
structure PrincipalBoundaryMasterRunBundleConsequenceSuite : Prop where
  runBundles : PrincipalBoundaryMasterRunBundleSuite
  noUnifyConsequences : PrincipalNoUnifyRunBundleConsequenceSlices

/-- Explicit component alias for `PrincipalBoundaryMasterRunBundleConsequenceSuite`. -/
abbrev PrincipalBoundaryMasterRunBundleConsequenceSuiteComponents : Prop :=
  PrincipalBoundaryMasterRunBundleSuite ∧ PrincipalNoUnifyRunBundleConsequenceSlices

/--
`PrincipalBoundaryMasterRunBundleConsequenceSuite` is equivalent to explicit
run-bundle + consequence components.
-/
theorem principalBoundaryMasterRunBundleConsequenceSuite_iff_components :
    PrincipalBoundaryMasterRunBundleConsequenceSuite
      ↔ PrincipalBoundaryMasterRunBundleConsequenceSuiteComponents := by
  constructor
  · intro h_suite
    exact ⟨h_suite.runBundles, h_suite.noUnifyConsequences⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2⟩

/-- Build `PrincipalBoundaryMasterRunBundleConsequenceSuite` from components. -/
theorem principalBoundaryMasterRunBundleConsequenceSuite_of_components
    (h_comp : PrincipalBoundaryMasterRunBundleConsequenceSuiteComponents) :
    PrincipalBoundaryMasterRunBundleConsequenceSuite :=
  (principalBoundaryMasterRunBundleConsequenceSuite_iff_components).2 h_comp

/-- Decompose `PrincipalBoundaryMasterRunBundleConsequenceSuite` into components. -/
theorem principalBoundaryMasterRunBundleConsequenceSuite_as_components
    (h_suite : PrincipalBoundaryMasterRunBundleConsequenceSuite) :
    PrincipalBoundaryMasterRunBundleConsequenceSuiteComponents :=
  (principalBoundaryMasterRunBundleConsequenceSuite_iff_components).1 h_suite

/-- Direct components-route decomposition for run-bundle consequence suite. -/
theorem principalBoundaryMasterRunBundleConsequenceSuite_as_components_of_components
    (h_comp : PrincipalBoundaryMasterRunBundleConsequenceSuiteComponents) :
    PrincipalBoundaryMasterRunBundleConsequenceSuiteComponents :=
  (principalBoundaryMasterRunBundleConsequenceSuite_iff_components).1
    (principalBoundaryMasterRunBundleConsequenceSuite_of_components h_comp)

/--
Construct the master run-bundle consequence suite from a master run-bundle
suite.
-/
theorem principalBoundaryMasterRunBundleConsequenceSuite_of_runBundleSuite
    (h_suite : PrincipalBoundaryMasterRunBundleSuite) :
    PrincipalBoundaryMasterRunBundleConsequenceSuite := by
  refine {
    runBundles := h_suite
    noUnifyConsequences := ?_
  }
  exact principalNoUnifyRunBundleConsequenceSlices_proved

/-- Direct route decomposition from `of_runBundleSuite` into explicit components. -/
theorem principalBoundaryMasterRunBundleConsequenceSuite_as_components_of_runBundleSuite
    (h_suite : PrincipalBoundaryMasterRunBundleSuite) :
    PrincipalBoundaryMasterRunBundleConsequenceSuiteComponents :=
  principalBoundaryMasterRunBundleConsequenceSuite_as_components
    (principalBoundaryMasterRunBundleConsequenceSuite_of_runBundleSuite h_suite)

/--
Construct the master run-bundle consequence suite from a master principal
boundary suite.
-/
theorem principalBoundaryMasterRunBundleConsequenceSuite_of_master
    (h_suite : PrincipalBoundaryMasterSuite) :
    PrincipalBoundaryMasterRunBundleConsequenceSuite :=
  principalBoundaryMasterRunBundleConsequenceSuite_of_runBundleSuite
    (principalBoundaryMasterRunBundleSuite_of_master h_suite)

/-- Direct route decomposition from `of_master` into explicit components. -/
theorem principalBoundaryMasterRunBundleConsequenceSuite_as_components_of_master
    (h_suite : PrincipalBoundaryMasterSuite) :
    PrincipalBoundaryMasterRunBundleConsequenceSuiteComponents :=
  principalBoundaryMasterRunBundleConsequenceSuite_as_components
    (principalBoundaryMasterRunBundleConsequenceSuite_of_master h_suite)

/-- The master run-bundle consequence suite is fully proved. -/
theorem principalBoundaryMasterRunBundleConsequenceSuite_proved :
    PrincipalBoundaryMasterRunBundleConsequenceSuite :=
  principalBoundaryMasterRunBundleConsequenceSuite_of_master
    principalBoundaryMasterSuite_proved

/-- Direct route decomposition from the proved consequence suite witness. -/
theorem principalBoundaryMasterRunBundleConsequenceSuite_as_components_of_proved :
    PrincipalBoundaryMasterRunBundleConsequenceSuiteComponents :=
  principalBoundaryMasterRunBundleConsequenceSuite_as_components
    principalBoundaryMasterRunBundleConsequenceSuite_proved

/--
One-hop projection: master run-bundle consequence suite from the top-level
master suite.
-/
theorem principalBoundaryMasterSuite_runBundleConsequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite) :
    PrincipalBoundaryMasterRunBundleConsequenceSuite :=
  principalBoundaryMasterRunBundleConsequenceSuite_of_master h_suite

/--
One-hop projection: no-unify expression run-bundle consequences from the master
run-bundle consequence suite.
-/
theorem principalBoundaryMasterRunBundleConsequenceSuite_noUnify_expr
    (h_suite : PrincipalBoundaryMasterRunBundleConsequenceSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyRunBundleConsequenceSlices_expr
    h_suite.noUnifyConsequences h_no h_ok

/--
One-hop projection: no-unify field run-bundle consequences from the master
run-bundle consequence suite.
-/
theorem principalBoundaryMasterRunBundleConsequenceSuite_noUnify_field
    (h_suite : PrincipalBoundaryMasterRunBundleConsequenceSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyRunBundleConsequenceSlices_field
    h_suite.noUnifyConsequences h_no h_ok

/--
One-hop projection: no-unify expression run-bundle consequences from the
top-level master suite.
-/
theorem principalBoundaryMasterSuite_noUnifyRunBundleConsequences_expr
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalBoundaryMasterRunBundleConsequenceSuite_noUnify_expr
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite) h_no h_ok

/--
One-hop projection: no-unify field run-bundle consequences from the top-level
master suite.
-/
theorem principalBoundaryMasterSuite_noUnifyRunBundleConsequences_field
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleConsequenceSuite_noUnify_field
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite) h_no h_ok

/--
Project the expression all-hooks capstone consequences out of a packaged
no-unify expression run-bundle consequence witness.
-/
theorem principalNoUnifyExprRunBundleConsequences_capstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_cons : PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty := by
  refine {
    core := h_cons.core
    preconditionedAny := h_cons.preconditionedAny
    preconditionedAnyIffCore := h_cons.preconditionedAnyIffCore
  }

/--
Project the field all-hooks capstone consequences out of a packaged
no-unify field run-bundle consequence witness.
-/
theorem principalNoUnifyFieldRunBundleConsequences_capstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_cons : PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf := by
  refine {
    core := h_cons.core
    preconditionedAny := h_cons.preconditionedAny
    preconditionedAnyIffCore := h_cons.preconditionedAnyIffCore
  }

/--
One-hop projection: no-unify-to-general expression capstone from the top-level
master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_expr_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_capstone
    (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_expr
      h_suite h_no h_ok)

/--
One-hop projection: no-unify-to-general field capstone from the top-level
master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_field_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_capstone
    (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_field
      h_suite h_no h_ok)

/--
One-hop projection: no-unify-to-general expression hook-irrelevance from the
top-level master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_irrelevance_expr_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_expr
    h_suite h_no h_ok).hookIrrelevant

/--
One-hop projection: no-unify-to-general field hook-irrelevance from the
top-level master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_irrelevance_field_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_field
    h_suite h_no h_ok).hookIrrelevant

/--
One-hop projection: no-unify-as-general expression capstone from the top-level
master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_expr_as_general_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_expr_via_consequenceSuite
    h_suite h_no h_ok

/--
One-hop projection: no-unify-as-general field capstone from the top-level
master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_field_as_general_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_field_via_consequenceSuite
    h_suite h_no h_ok

/--
One-hop projection: no-unify-as-general expression run-bundle from the
top-level master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_expr_as_general_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleSuite_noUnifyToGeneral_expr
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_no h_ok

/--
One-hop projection: no-unify-as-general field run-bundle from the top-level
master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_field_as_general_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleSuite_noUnifyToGeneral_field
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_no h_ok

/--
One-hop projection: arbitrary-success all-hooks expression capstone from the
top-level master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_allHooks_expr_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  (principalBoundaryMasterRunBundleSuite_allHooks_expr
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_app0 h_proj0 h_ok).capstone

/--
One-hop projection: arbitrary-success all-hooks field capstone from the
top-level master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_allHooks_field_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  (principalBoundaryMasterRunBundleSuite_allHooks_field
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_app0 h_proj0 h_ok).capstone

/--
One-hop projection: arbitrary-success all-hooks expression hook-irrelevance
from the top-level master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_allHooks_irrelevance_expr_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalBoundaryMasterRunBundleSuite_allHooks_expr
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_app0 h_proj0 h_ok).hookIrrelevant

/--
One-hop projection: arbitrary-success all-hooks field hook-irrelevance from the
top-level master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_allHooks_irrelevance_field_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalBoundaryMasterRunBundleSuite_allHooks_field
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_app0 h_proj0 h_ok).hookIrrelevant

/--
One-hop projection: arbitrary-success all-hooks expression run-bundle from the
top-level master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_allHooks_runBundle_expr_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleSuite_allHooks_expr
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_app0 h_proj0 h_ok

/--
One-hop projection: arbitrary-success all-hooks field run-bundle from the
top-level master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_allHooks_runBundle_field_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleSuite_allHooks_field
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_app0 h_proj0 h_ok

/--
One-hop projection: no-unify all-hooks expression run-bundle from the top-level
master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_expr_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleSuite_noUnifyAllHooks_expr
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_no h_ok

/--
One-hop projection: no-unify all-hooks field run-bundle from the top-level
master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_field_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleSuite_noUnifyAllHooks_field
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_no h_ok

/--
One-hop projection: no-unify-to-general expression run-bundle from the
top-level master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_runBundle_expr_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleSuite_noUnifyToGeneral_expr
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_no h_ok

/--
One-hop projection: no-unify-to-general field run-bundle from the top-level
master suite via the consequence-suite aggregate.
-/
theorem principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_runBundle_field_via_consequenceSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleSuite_noUnifyToGeneral_field
    (principalBoundaryMasterSuite_runBundleConsequenceSuite h_suite).runBundles
    h_no h_ok

/--
Aggregate capstone + irrelevance suite routed through the top-level master
consequence path.
-/
structure PrincipalBoundaryMasterConsequenceCapstoneSuite : Prop where
  allHooksExpr :
    ∀ (_h_app0 : AppUnifySoundHook) (_h_proj0 : ProjUnifySoundHook)
      {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
      {st' : UnifyState} {ty : Ty},
      inferExprUnify st fuel env e = .ok st' ty →
      PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty
  allHooksField :
    ∀ (_h_app0 : AppUnifySoundHook) (_h_proj0 : ProjUnifySoundHook)
      {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
      {st' : UnifyState} {rf : RowFields},
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf
  allHooksIrrelevanceExpr :
    ∀ (_h_app0 : AppUnifySoundHook) (_h_proj0 : ProjUnifySoundHook)
      {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
      {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
      {st' : UnifyState} {ty : Ty},
      inferExprUnify st fuel env e = .ok st' ty →
      (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
        ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)
  allHooksIrrelevanceField :
    ∀ (_h_app0 : AppUnifySoundHook) (_h_proj0 : ProjUnifySoundHook)
      {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
      {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
      {st' : UnifyState} {rf : RowFields},
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
        ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)
  noUnifyExpr :
    ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
      {st' : UnifyState} {ty : Ty},
      NoUnifyBranchesExpr e →
      inferExprUnify st fuel env e = .ok st' ty →
      PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty
  noUnifyField :
    ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
      {st' : UnifyState} {rf : RowFields},
      NoUnifyBranchesFields fs →
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf
  noUnifyIrrelevanceExpr :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
      {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
      {st' : UnifyState} {ty : Ty},
      NoUnifyBranchesExpr e →
      inferExprUnify st fuel env e = .ok st' ty →
      (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
        ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)
  noUnifyIrrelevanceField :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
      {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
      {st' : UnifyState} {rf : RowFields},
      NoUnifyBranchesFields fs →
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
        ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)

/-- Explicit component alias for `PrincipalBoundaryMasterConsequenceCapstoneSuite`. -/
abbrev PrincipalBoundaryMasterConsequenceCapstoneSuiteComponents : Prop :=
  PrincipalBoundaryMasterConsequenceCapstoneSuite

/-- `PrincipalBoundaryMasterConsequenceCapstoneSuite` equals its components alias. -/
theorem principalBoundaryMasterConsequenceCapstoneSuite_iff_components :
    PrincipalBoundaryMasterConsequenceCapstoneSuite
      ↔ PrincipalBoundaryMasterConsequenceCapstoneSuiteComponents := by
  constructor <;> intro h <;> simpa [PrincipalBoundaryMasterConsequenceCapstoneSuiteComponents] using h

/-- Build `PrincipalBoundaryMasterConsequenceCapstoneSuite` from components alias. -/
theorem principalBoundaryMasterConsequenceCapstoneSuite_of_components
    (h_comp : PrincipalBoundaryMasterConsequenceCapstoneSuiteComponents) :
    PrincipalBoundaryMasterConsequenceCapstoneSuite := by
  simpa [PrincipalBoundaryMasterConsequenceCapstoneSuiteComponents] using h_comp

/-- Decompose `PrincipalBoundaryMasterConsequenceCapstoneSuite` into alias. -/
theorem principalBoundaryMasterConsequenceCapstoneSuite_as_components
    (h_suite : PrincipalBoundaryMasterConsequenceCapstoneSuite) :
    PrincipalBoundaryMasterConsequenceCapstoneSuiteComponents := by
  simpa [PrincipalBoundaryMasterConsequenceCapstoneSuiteComponents] using h_suite

/-- Direct components-route decomposition for consequence-capstone suite. -/
theorem principalBoundaryMasterConsequenceCapstoneSuite_as_components_of_components
    (h_comp : PrincipalBoundaryMasterConsequenceCapstoneSuiteComponents) :
    PrincipalBoundaryMasterConsequenceCapstoneSuiteComponents := by
  simpa using h_comp

/--
Construct the master consequence capstone suite from one top-level master
suite witness.
-/
theorem principalBoundaryMasterConsequenceCapstoneSuite_of_master
    (h_suite : PrincipalBoundaryMasterSuite) :
    PrincipalBoundaryMasterConsequenceCapstoneSuite := by
  refine {
    allHooksExpr := ?_
    allHooksField := ?_
    allHooksIrrelevanceExpr := ?_
    allHooksIrrelevanceField := ?_
    noUnifyExpr := ?_
    noUnifyField := ?_
    noUnifyIrrelevanceExpr := ?_
    noUnifyIrrelevanceField := ?_
  }
  · intro h_app0 h_proj0 st fuel env e st' ty h_ok
    exact principalBoundaryMasterSuite_allHooks_expr_via_consequenceSuite
      h_suite h_app0 h_proj0 h_ok
  · intro h_app0 h_proj0 st fuel env fs st' rf h_ok
    exact principalBoundaryMasterSuite_allHooks_field_via_consequenceSuite
      h_suite h_app0 h_proj0 h_ok
  · intro h_app0 h_proj0 h_app₁ h_proj₁ h_app₂ h_proj₂ st fuel env e st' ty h_ok
    exact principalBoundaryMasterSuite_allHooks_irrelevance_expr_via_consequenceSuite
      h_suite h_app0 h_proj0 h_ok
  · intro h_app0 h_proj0 h_app₁ h_proj₁ h_app₂ h_proj₂ st fuel env fs st' rf h_ok
    exact principalBoundaryMasterSuite_allHooks_irrelevance_field_via_consequenceSuite
      h_suite h_app0 h_proj0 h_ok
  · intro st fuel env e st' ty h_no h_ok
    exact principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_expr_via_consequenceSuite
      h_suite h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_field_via_consequenceSuite
      h_suite h_no h_ok
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂ st fuel env e st' ty h_no h_ok
    exact principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_irrelevance_expr_via_consequenceSuite
      h_suite h_no h_ok
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂ st fuel env fs st' rf h_no h_ok
    exact principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_irrelevance_field_via_consequenceSuite
      h_suite h_no h_ok

/-- Direct route decomposition from `of_master` into capstone-suite components. -/
theorem principalBoundaryMasterConsequenceCapstoneSuite_as_components_of_master
    (h_suite : PrincipalBoundaryMasterSuite) :
    PrincipalBoundaryMasterConsequenceCapstoneSuiteComponents :=
  principalBoundaryMasterConsequenceCapstoneSuite_as_components
    (principalBoundaryMasterConsequenceCapstoneSuite_of_master h_suite)

/-- The master consequence capstone suite is fully proved. -/
theorem principalBoundaryMasterConsequenceCapstoneSuite_proved :
    PrincipalBoundaryMasterConsequenceCapstoneSuite :=
  principalBoundaryMasterConsequenceCapstoneSuite_of_master
    principalBoundaryMasterSuite_proved

/-- Direct route decomposition from the proved capstone-suite witness. -/
theorem principalBoundaryMasterConsequenceCapstoneSuite_as_components_of_proved :
    PrincipalBoundaryMasterConsequenceCapstoneSuiteComponents :=
  principalBoundaryMasterConsequenceCapstoneSuite_as_components
    principalBoundaryMasterConsequenceCapstoneSuite_proved

/-- One-hop projection: master consequence capstone suite from master suite. -/
theorem principalBoundaryMasterSuite_consequenceCapstoneSuite
    (h_suite : PrincipalBoundaryMasterSuite) :
    PrincipalBoundaryMasterConsequenceCapstoneSuite :=
  principalBoundaryMasterConsequenceCapstoneSuite_of_master h_suite

/--
One-hop projection: arbitrary-success all-hooks expression capstone from the
master consequence capstone suite.
-/
theorem principalBoundaryMasterConsequenceCapstoneSuite_allHooks_expr
    (h_suite : PrincipalBoundaryMasterConsequenceCapstoneSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  h_suite.allHooksExpr h_app0 h_proj0 h_ok

/--
One-hop projection: arbitrary-success all-hooks field capstone from the master
consequence capstone suite.
-/
theorem principalBoundaryMasterConsequenceCapstoneSuite_allHooks_field
    (h_suite : PrincipalBoundaryMasterConsequenceCapstoneSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  h_suite.allHooksField h_app0 h_proj0 h_ok

/--
One-hop projection: arbitrary-success all-hooks expression hook-irrelevance
from the master consequence capstone suite.
-/
theorem principalBoundaryMasterConsequenceCapstoneSuite_allHooks_irrelevance_expr
    (h_suite : PrincipalBoundaryMasterConsequenceCapstoneSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  h_suite.allHooksIrrelevanceExpr h_app0 h_proj0 h_ok

/--
One-hop projection: arbitrary-success all-hooks field hook-irrelevance from the
master consequence capstone suite.
-/
theorem principalBoundaryMasterConsequenceCapstoneSuite_allHooks_irrelevance_field
    (h_suite : PrincipalBoundaryMasterConsequenceCapstoneSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  h_suite.allHooksIrrelevanceField h_app0 h_proj0 h_ok

/--
One-hop projection: no-unify expression capstone from the master consequence
capstone suite.
-/
theorem principalBoundaryMasterConsequenceCapstoneSuite_noUnify_expr
    (h_suite : PrincipalBoundaryMasterConsequenceCapstoneSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  h_suite.noUnifyExpr h_no h_ok

/--
One-hop projection: no-unify field capstone from the master consequence
capstone suite.
-/
theorem principalBoundaryMasterConsequenceCapstoneSuite_noUnify_field
    (h_suite : PrincipalBoundaryMasterConsequenceCapstoneSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  h_suite.noUnifyField h_no h_ok

/--
One-hop projection: no-unify expression hook-irrelevance from the master
consequence capstone suite.
-/
theorem principalBoundaryMasterConsequenceCapstoneSuite_noUnify_irrelevance_expr
    (h_suite : PrincipalBoundaryMasterConsequenceCapstoneSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  h_suite.noUnifyIrrelevanceExpr h_no h_ok

/--
One-hop projection: no-unify field hook-irrelevance from the master consequence
capstone suite.
-/
theorem principalBoundaryMasterConsequenceCapstoneSuite_noUnify_irrelevance_field
    (h_suite : PrincipalBoundaryMasterConsequenceCapstoneSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  h_suite.noUnifyIrrelevanceField h_no h_ok

/--
Master-consequence-capstone-suite convenience wrapper: derive arbitrary-success
expression all-hooks capstone from a baseline hook pair.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalBoundaryMasterConsequenceCapstoneSuite_allHooks_expr
    principalBoundaryMasterConsequenceCapstoneSuite_proved h_app0 h_proj0 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: derive arbitrary-success
field all-hooks capstone from a baseline hook pair.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalBoundaryMasterConsequenceCapstoneSuite_allHooks_field
    principalBoundaryMasterConsequenceCapstoneSuite_proved h_app0 h_proj0 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for arbitrary-success expression all-hooks capstone.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for arbitrary-success field all-hooks capstone.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive expression all-hooks capstone from a successful no-unify run.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalBoundaryMasterConsequenceCapstoneSuite_noUnify_expr
    principalBoundaryMasterConsequenceCapstoneSuite_proved h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive field all-hooks capstone from a successful no-unify field run.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalBoundaryMasterConsequenceCapstoneSuite_noUnify_field
    principalBoundaryMasterConsequenceCapstoneSuite_proved h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-hook variant for expression all-hooks capstone.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-hook variant for field all-hooks capstone.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive
expression all-hooks capstone from a successful no-unify run.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive field
all-hooks capstone from a successful no-unify field run.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for expression all-hooks capstone.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for field all-hooks capstone.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite convenience wrapper: derive fixed-run
expression hook-irrelevance for arbitrary successful runs.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalBoundaryMasterConsequenceCapstoneSuite_allHooks_irrelevance_expr
    principalBoundaryMasterConsequenceCapstoneSuite_proved h_app0 h_proj0 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: derive fixed-run field
hook-irrelevance for arbitrary successful field runs.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalBoundaryMasterConsequenceCapstoneSuite_allHooks_irrelevance_field
    principalBoundaryMasterConsequenceCapstoneSuite_proved h_app0 h_proj0 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline
variant for arbitrary successful expression hook-irrelevance.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline
variant for arbitrary successful field hook-irrelevance.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive fixed-run expression hook-irrelevance from a successful no-unify run.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalBoundaryMasterConsequenceCapstoneSuite_noUnify_irrelevance_expr
    principalBoundaryMasterConsequenceCapstoneSuite_proved h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive fixed-run field hook-irrelevance from a successful no-unify field run.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalBoundaryMasterConsequenceCapstoneSuite_noUnify_irrelevance_field
    principalBoundaryMasterConsequenceCapstoneSuite_proved h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-hook variant for expression fixed-run hook-irrelevance.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-hook variant for field fixed-run hook-irrelevance.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive fixed-run
expression hook-irrelevance from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for expression fixed-run hook-irrelevance.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive fixed-run
field hook-irrelevance from a successful no-unify field run.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for field fixed-run hook-irrelevance.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite convenience wrapper: derive core expression
principality for an arbitrary successful run.
-/
theorem principalCoreExpr_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  (principalPreconditionedExprAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok).core

/--
Master-consequence-capstone-suite convenience wrapper: derive core field
principality for an arbitrary successful field run.
-/
theorem principalCoreField_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalPreconditionedFieldAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok).core

/--
Master-consequence-capstone-suite convenience wrapper: derive preconditioned
expression principality for any hook witnesses from an arbitrary successful run.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  (principalPreconditionedExprAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok).preconditionedAny

/--
Master-consequence-capstone-suite convenience wrapper: derive preconditioned
field principality for any hook witnesses from an arbitrary successful field
run.
-/
theorem principalPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  (principalPreconditionedFieldAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok).preconditionedAny

/--
Master-consequence-capstone-suite convenience wrapper: derive preconditioned
expression principality for a bundled hook witness from an arbitrary successful
run.
-/
theorem principalPreconditionedExpr_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok h_hooks.1 h_hooks.2

/--
Master-consequence-capstone-suite convenience wrapper: derive preconditioned
field principality for a bundled hook witness from an arbitrary successful field
run.
-/
theorem principalPreconditionedField_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok h_hooks.1 h_hooks.2

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for preconditioned expression principality.
-/
theorem principalPreconditionedExpr_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok h_hooks

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for preconditioned field principality.
-/
theorem principalPreconditionedField_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok h_hooks

/--
Master-consequence-capstone-suite convenience wrapper: derive expression
preconditioned↔core equivalence for any hook witnesses on an arbitrary
successful run.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  (principalPreconditionedExprAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok).preconditionedAnyIffCore

/--
Master-consequence-capstone-suite convenience wrapper: derive field
preconditioned↔core equivalence for any hook witnesses on an arbitrary
successful field run.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalPreconditionedFieldAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok).preconditionedAnyIffCore

/--
Master-consequence-capstone-suite convenience wrapper: derive expression
preconditioned↔core equivalence for a bundled hook witness on an arbitrary
successful run.
-/
theorem principalPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok h_hooks.1 h_hooks.2

/--
Master-consequence-capstone-suite convenience wrapper: derive field
preconditioned↔core equivalence for a bundled hook witness on an arbitrary
successful field run.
-/
theorem principalPreconditionedCoreIffField_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok h_hooks.1 h_hooks.2

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for expression preconditioned↔core equivalence.
-/
theorem principalPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok h_hooks

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for field preconditioned↔core equivalence.
-/
theorem principalPreconditionedCoreIffField_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok h_hooks

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for core expression principality.
-/
theorem principalCoreExpr_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for core field principality.
-/
theorem principalCoreField_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for preconditioned expression principality (any target hooks).
-/
theorem principalPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for preconditioned field principality (any target hooks).
-/
theorem principalPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for expression preconditioned↔core equivalence (any target hooks).
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for field preconditioned↔core equivalence (any target hooks).
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive core
expression principality from a successful no-unify run.
-/
theorem principalNoUnifyCoreExpr_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  (principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok).core

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive
preconditioned expression principality for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  (principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok).preconditionedAny

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive
preconditioned expression principality for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks.1 h_hooks.2

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for fixed-run preconditioned expression principality.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive fixed-run
expression preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  (principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok).preconditionedAnyIffCore

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive fixed-run
expression preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks.1 h_hooks.2

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for fixed-run expression preconditioned↔core equivalence.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive core expression principality from a successful no-unify run.
-/
theorem principalCoreExpr_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterConsequenceCapstoneSuite h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive preconditioned expression principality for any hook witnesses.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive preconditioned expression principality for a bundled hook witness.
-/
theorem principalPreconditionedExpr_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-hook variant for fixed-run preconditioned expression principality.
-/
theorem principalPreconditionedExpr_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive fixed-run expression preconditioned↔core equivalence for any hook
witnesses.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive fixed-run expression preconditioned↔core equivalence for a bundled hook
witness.
-/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-hook variant for fixed-run expression preconditioned↔core equivalence.
-/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive core
field principality from a successful no-unify field run.
-/
theorem principalNoUnifyCoreField_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok).core

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive
preconditioned field principality for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  (principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok).preconditionedAny

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive
preconditioned field principality for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks.1 h_hooks.2

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for fixed-run preconditioned field principality.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive fixed-run
field preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok).preconditionedAnyIffCore

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive fixed-run
field preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks.1 h_hooks.2

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for fixed-run field preconditioned↔core equivalence.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive core field principality from a successful no-unify field run.
-/
theorem principalCoreField_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterConsequenceCapstoneSuite h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive preconditioned field principality for any hook witnesses.
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive preconditioned field principality for a bundled hook witness.
-/
theorem principalPreconditionedField_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-hook variant for fixed-run preconditioned field principality.
-/
theorem principalPreconditionedField_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive fixed-run field preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive fixed-run field preconditioned↔core equivalence for a bundled hook
witness.
-/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-hook variant for fixed-run field preconditioned↔core equivalence.
-/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok h_hooks

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-baseline
alias for core expression principality.
-/
theorem principalNoUnifyCoreExpr_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterConsequenceCapstoneSuite h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-baseline
alias for preconditioned expression principality (any target hooks).
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-baseline
alias for expression preconditioned↔core equivalence (any target hooks).
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-baseline
alias for core field principality.
-/
theorem principalNoUnifyCoreField_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterConsequenceCapstoneSuite h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-baseline
alias for preconditioned field principality (any target hooks).
-/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-baseline
alias for field preconditioned↔core equivalence (any target hooks).
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-baseline alias for core expression principality.
-/
theorem principalCoreExpr_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    h_no h_ok h_seed

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-baseline alias for preconditioned expression principality (any target
hooks).
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    h_no h_ok h_seed

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-baseline alias for expression preconditioned↔core equivalence (any
target hooks).
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    h_no h_ok h_seed

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-baseline alias for core field principality.
-/
theorem principalCoreField_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    h_no h_ok h_seed

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-baseline alias for preconditioned field principality (any target hooks).
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    h_no h_ok h_seed

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-baseline alias for field preconditioned↔core equivalence (any target
hooks).
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    h_no h_ok h_seed

/--
Master-consequence-capstone-suite convenience wrapper: derive the arbitrary
successful expression run-bundle surface from a baseline hook pair.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty := by
  refine {
    capstone := principalPreconditionedExprAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
      h_app0 h_proj0 h_ok
    hookIrrelevant := ?_
  }
  intro h_app₁ h_proj₁ h_app₂ h_proj₂
  exact principalPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: derive the arbitrary
successful field run-bundle surface from a baseline hook pair.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterConsequenceCapstoneSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf := by
  refine {
    capstone := principalPreconditionedFieldAllHooksCapstone_of_success_via_masterConsequenceCapstoneSuite
      h_app0 h_proj0 h_ok
    hookIrrelevant := ?_
  }
  intro h_app₁ h_proj₁ h_app₂ h_proj₂
  exact principalPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstoneSuite
    h_app0 h_proj0 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for arbitrary successful expression run-bundle surface.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite convenience wrapper: bundled-baseline variant
for arbitrary successful field run-bundle surface.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterConsequenceCapstoneSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive the expression run-bundle surface from a successful no-unify run.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty := by
  refine {
    capstone := principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok
    hookIrrelevant := ?_
  }
  intro h_app₁ h_proj₁ h_app₂ h_proj₂
  exact principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
derive the field run-bundle surface from a successful no-unify field run.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf := by
  refine {
    capstone := principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok
    hookIrrelevant := ?_
  }
  intro h_app₁ h_proj₁ h_app₂ h_proj₂
  exact principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-hook variant for expression run-bundle surface.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify-to-general convenience wrapper:
bundled-hook variant for field run-bundle surface.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive the
expression run-bundle surface from a successful no-unify run.
-/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: derive the
field run-bundle surface from a successful no-unify field run.
-/
theorem principalNoUnifyRunBundleField_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for expression run-bundle surface.
-/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for field run-bundle surface.
-/
theorem principalNoUnifyRunBundleField_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: package
expression no-unify consequences from one successful run.
-/
theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty := by
  refine {
    core := principalCoreExpr_of_success_noUnify_via_masterConsequenceCapstoneSuite h_no h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app h_proj
    exact principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok h_app h_proj
  · intro h_hooks
    exact principalPreconditionedExpr_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok h_hooks
  · intro h_app h_proj
    exact principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok h_app h_proj
  · intro h_hooks
    exact principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok h_hooks
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: package field
no-unify consequences from one successful field run.
-/
theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf := by
  refine {
    core := principalCoreField_of_success_noUnify_via_masterConsequenceCapstoneSuite h_no h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app h_proj
    exact principalPreconditionedField_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok h_app h_proj
  · intro h_hooks
    exact principalPreconditionedField_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok h_hooks
  · intro h_app h_proj
    exact principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok h_app h_proj
  · intro h_hooks
    exact principalPreconditionedCoreIffField_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok h_hooks
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstoneSuite
      h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for packaged expression no-unify consequences.
-/
theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Master-consequence-capstone-suite no-unify convenience wrapper: bundled-hook
alias for packaged field no-unify consequences.
-/
theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite
    h_no h_ok

/--
Packaged no-unify expression consequence slice over all successful runs on the
master-consequence-capstone-suite route.
-/
def PrincipalNoUnifyExprRunBundleConsequenceSliceViaMasterConsequenceCapstoneSuite : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty

/--
Packaged no-unify field consequence slice over all successful field runs on the
master-consequence-capstone-suite route.
-/
def PrincipalNoUnifyFieldRunBundleConsequenceSliceViaMasterConsequenceCapstoneSuite : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf

/--
Combined no-unify consequence slices across expressions and fields on the
master-consequence-capstone-suite route.
-/
def PrincipalNoUnifyRunBundleConsequenceSlicesViaMasterConsequenceCapstoneSuite : Prop :=
  PrincipalNoUnifyExprRunBundleConsequenceSliceViaMasterConsequenceCapstoneSuite ∧
    PrincipalNoUnifyFieldRunBundleConsequenceSliceViaMasterConsequenceCapstoneSuite

/--
The combined no-unify consequence slices on the master-consequence-capstone
route are fully proved.
-/
theorem principalNoUnifyRunBundleConsequenceSlicesViaMasterConsequenceCapstoneSuite_proved :
    PrincipalNoUnifyRunBundleConsequenceSlicesViaMasterConsequenceCapstoneSuite := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalNoUnifyExprRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite
      h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalNoUnifyFieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite
      h_no h_ok

/--
One-hop projection: expression branch from the master-consequence-capstone
no-unify consequence slices.
-/
theorem principalNoUnifyRunBundleConsequenceSlicesViaMasterConsequenceCapstoneSuite_expr
    (h_slices : PrincipalNoUnifyRunBundleConsequenceSlicesViaMasterConsequenceCapstoneSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  h_slices.1 h_no h_ok

/--
One-hop projection: field branch from the master-consequence-capstone no-unify
consequence slices.
-/
theorem principalNoUnifyRunBundleConsequenceSlicesViaMasterConsequenceCapstoneSuite_field
    (h_slices : PrincipalNoUnifyRunBundleConsequenceSlicesViaMasterConsequenceCapstoneSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  h_slices.2 h_no h_ok

/--
One-hop projection: arbitrary-success all-hooks expression run-bundle from the
master run-bundle consequence suite.
-/
theorem principalBoundaryMasterRunBundleConsequenceSuite_allHooks_expr
    (h_suite : PrincipalBoundaryMasterRunBundleConsequenceSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleSuite_allHooks_expr
    h_suite.runBundles h_app0 h_proj0 h_ok

/--
One-hop projection: arbitrary-success all-hooks field run-bundle from the
master run-bundle consequence suite.
-/
theorem principalBoundaryMasterRunBundleConsequenceSuite_allHooks_field
    (h_suite : PrincipalBoundaryMasterRunBundleConsequenceSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleSuite_allHooks_field
    h_suite.runBundles h_app0 h_proj0 h_ok

/--
One-hop projection: no-unify all-hooks expression run-bundle from the master
run-bundle consequence suite.
-/
theorem principalBoundaryMasterRunBundleConsequenceSuite_noUnifyAllHooks_expr
    (h_suite : PrincipalBoundaryMasterRunBundleConsequenceSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleSuite_noUnifyAllHooks_expr
    h_suite.runBundles h_no h_ok

/--
One-hop projection: no-unify all-hooks field run-bundle from the master
run-bundle consequence suite.
-/
theorem principalBoundaryMasterRunBundleConsequenceSuite_noUnifyAllHooks_field
    (h_suite : PrincipalBoundaryMasterRunBundleConsequenceSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleSuite_noUnifyAllHooks_field
    h_suite.runBundles h_no h_ok

/--
One-hop projection: no-unify-to-general expression run-bundle from the master
run-bundle consequence suite.
-/
theorem principalBoundaryMasterRunBundleConsequenceSuite_noUnifyToGeneral_expr
    (h_suite : PrincipalBoundaryMasterRunBundleConsequenceSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleSuite_noUnifyToGeneral_expr
    h_suite.runBundles h_no h_ok

/--
One-hop projection: no-unify-to-general field run-bundle from the master
run-bundle consequence suite.
-/
theorem principalBoundaryMasterRunBundleConsequenceSuite_noUnifyToGeneral_field
    (h_suite : PrincipalBoundaryMasterRunBundleConsequenceSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleSuite_noUnifyToGeneral_field
    h_suite.runBundles h_no h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive the arbitrary
successful expression run-bundle surface from a baseline hook pair.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_via_masterRunBundleConsequenceSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleConsequenceSuite_allHooks_expr
    principalBoundaryMasterRunBundleConsequenceSuite_proved h_app0 h_proj0 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive the arbitrary
successful field run-bundle surface from a baseline hook pair.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterRunBundleConsequenceSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleConsequenceSuite_allHooks_field
    principalBoundaryMasterRunBundleConsequenceSuite_proved h_app0 h_proj0 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: bundled-baseline
variant for arbitrary successful expression run-bundle surface.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_via_masterRunBundleConsequenceSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: bundled-baseline
variant for arbitrary successful field run-bundle surface.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterRunBundleConsequenceSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive the arbitrary
successful expression all-hooks capstone from a baseline hook pair.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalBoundaryMasterSuite_allHooks_expr_via_consequenceSuite
    principalBoundaryMasterSuite_proved h_app0 h_proj0 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive the arbitrary
successful field all-hooks capstone from a baseline hook pair.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalBoundaryMasterSuite_allHooks_field_via_consequenceSuite
    principalBoundaryMasterSuite_proved h_app0 h_proj0 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: bundled-baseline
variant for arbitrary successful expression all-hooks capstone.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: bundled-baseline
variant for arbitrary successful field all-hooks capstone.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive fixed-run
expression hook-irrelevance for arbitrary successful runs.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalBoundaryMasterSuite_allHooks_irrelevance_expr_via_consequenceSuite
    principalBoundaryMasterSuite_proved h_app0 h_proj0 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive fixed-run field
hook-irrelevance for arbitrary successful field runs.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalBoundaryMasterSuite_allHooks_irrelevance_field_via_consequenceSuite
    principalBoundaryMasterSuite_proved h_app0 h_proj0 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: bundled-baseline
variant for arbitrary successful expression hook-irrelevance.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: bundled-baseline
variant for arbitrary successful field hook-irrelevance.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite
    h_seed.1 h_seed.2 h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive the no-unify
expression run-bundle surface from a successful no-unify run.
-/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterRunBundleConsequenceSuite_noUnifyAllHooks_expr
    principalBoundaryMasterRunBundleConsequenceSuite_proved h_no h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive the no-unify
field run-bundle surface from a successful no-unify field run.
-/
theorem principalNoUnifyRunBundleField_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleConsequenceSuite_noUnifyAllHooks_field
    principalBoundaryMasterRunBundleConsequenceSuite_proved h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
derive the no-unify expression run-bundle surface.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleConsequenceSuite h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
derive the no-unify field run-bundle surface.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_masterRunBundleConsequenceSuite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general expression run-bundle on the consequence suite. -/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general field run-bundle on the consequence suite. -/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive the packaged
no-unify expression consequence bundle from a successful no-unify run.
-/
theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalBoundaryMasterRunBundleConsequenceSuite_noUnify_expr
    principalBoundaryMasterRunBundleConsequenceSuite_proved h_no h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive the packaged
no-unify field consequence bundle from a successful no-unify field run.
-/
theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalBoundaryMasterRunBundleConsequenceSuite_noUnify_field
    principalBoundaryMasterRunBundleConsequenceSuite_proved h_no h_ok

/--
Cross-route coherence: successful no-unify expression runs yield packaged
consequence bundles on both the master-consequence-capstone and
master-run-bundle-consequence routes.
-/
structure PrincipalNoUnifyExprRunBundleConsequencesBothMasterConsequenceRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  viaMasterConsequenceCapstone :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty
  viaMasterRunBundleConsequence :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty

/--
Cross-route coherence constructor: successful no-unify expression runs yield
packaged consequence bundles on both the master-consequence-capstone and
master-run-bundle-consequence routes.
-/
theorem principalNoUnifyExprRunBundleConsequences_on_both_master_consequence_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequencesBothMasterConsequenceRoutes
      st fuel env e st' ty := by
  refine {
    viaMasterConsequenceCapstone :=
      principalNoUnifyExprRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite
        h_no h_ok
    viaMasterRunBundleConsequence :=
      principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
        h_no h_ok
  }

/--
Cross-route coherence: successful no-unify field runs yield packaged
consequence bundles on both the master-consequence-capstone and
master-run-bundle-consequence routes.
-/
structure PrincipalNoUnifyFieldRunBundleConsequencesBothMasterConsequenceRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  viaMasterConsequenceCapstone :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf
  viaMasterRunBundleConsequence :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf

/--
Cross-route coherence constructor: successful no-unify field runs yield
packaged consequence bundles on both the master-consequence-capstone and
master-run-bundle-consequence routes.
-/
theorem principalNoUnifyFieldRunBundleConsequences_on_both_master_consequence_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequencesBothMasterConsequenceRoutes
      st fuel env fs st' rf := by
  refine {
    viaMasterConsequenceCapstone :=
      principalNoUnifyFieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite
        h_no h_ok
    viaMasterRunBundleConsequence :=
      principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
        h_no h_ok
  }

/--
Packaged cross-route coherence slice (expression): every successful no-unify
run yields consequence bundles on both master consequence entry layers.
-/
def PrincipalNoUnifyExprRunBundleConsequencesBothMasterConsequenceRoutesSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalNoUnifyExprRunBundleConsequencesBothMasterConsequenceRoutes
      st fuel env e st' ty

/--
Packaged cross-route coherence slice (field): every successful no-unify field
run yields consequence bundles on both master consequence entry layers.
-/
def PrincipalNoUnifyFieldRunBundleConsequencesBothMasterConsequenceRoutesSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalNoUnifyFieldRunBundleConsequencesBothMasterConsequenceRoutes
      st fuel env fs st' rf

/--
Combined cross-route coherence slices over expressions and fields for the
master consequence entry layers.
-/
def PrincipalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices : Prop :=
  PrincipalNoUnifyExprRunBundleConsequencesBothMasterConsequenceRoutesSlice ∧
    PrincipalNoUnifyFieldRunBundleConsequencesBothMasterConsequenceRoutesSlice

/--
The combined cross-route coherence slices are fully proved for the master
consequence entry layers.
-/
theorem principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_proved :
    PrincipalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalNoUnifyExprRunBundleConsequences_on_both_master_consequence_routes
      h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalNoUnifyFieldRunBundleConsequences_on_both_master_consequence_routes
      h_no h_ok

/--
One-hop projection: expression branch from the cross-route coherence slices.
-/
theorem principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_expr
    (h_slices : PrincipalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequencesBothMasterConsequenceRoutes
      st fuel env e st' ty :=
  h_slices.1 h_no h_ok

/--
One-hop projection: field branch from the cross-route coherence slices.
-/
theorem principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_field
    (h_slices : PrincipalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequencesBothMasterConsequenceRoutes
      st fuel env fs st' rf :=
  h_slices.2 h_no h_ok

/--
One-hop projection: extract the master-consequence-capstone expression
consequence bundle from the cross-route coherence slices.
-/
theorem principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_expr_via_masterConsequenceCapstone
    (h_slices : PrincipalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  (principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_expr
    h_slices h_no h_ok).viaMasterConsequenceCapstone

/--
One-hop projection: extract the master-run-bundle-consequence expression
consequence bundle from the cross-route coherence slices.
-/
theorem principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_expr_via_masterRunBundleConsequence
    (h_slices : PrincipalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  (principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_expr
    h_slices h_no h_ok).viaMasterRunBundleConsequence

/--
One-hop projection: extract the master-consequence-capstone field consequence
bundle from the cross-route coherence slices.
-/
theorem principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_field_via_masterConsequenceCapstone
    (h_slices : PrincipalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  (principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_field
    h_slices h_no h_ok).viaMasterConsequenceCapstone

/--
One-hop projection: extract the master-run-bundle-consequence field consequence
bundle from the cross-route coherence slices.
-/
theorem principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_field_via_masterRunBundleConsequence
    (h_slices : PrincipalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  (principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_field
    h_slices h_no h_ok).viaMasterRunBundleConsequence

/--
Canonical projection from proved cross-route coherence slices to the
master-consequence-capstone expression consequence bundle.
-/
theorem principalNoUnifyExprRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_expr_via_masterConsequenceCapstone
    principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route coherence slices to the
master-run-bundle-consequence expression consequence bundle.
-/
theorem principalNoUnifyExprRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_expr_via_masterRunBundleConsequence
    principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route coherence slices to the
master-consequence-capstone field consequence bundle.
-/
theorem principalNoUnifyFieldRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_field_via_masterConsequenceCapstone
    principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route coherence slices to the
master-run-bundle-consequence field consequence bundle.
-/
theorem principalNoUnifyFieldRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_field_via_masterRunBundleConsequence
    principalNoUnifyRunBundleConsequencesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical capstone projection: derive no-unify expression all-hooks capstone
from the master-consequence-capstone route via cross-route consequence slices.
-/
theorem principalNoUnifyExprAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_capstone
    (principalNoUnifyExprRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_slices
      h_no h_ok)

/--
Canonical capstone projection: derive no-unify expression all-hooks capstone
from the master-run-bundle-consequence route via cross-route consequence slices.
-/
theorem principalNoUnifyExprAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_capstone
    (principalNoUnifyExprRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_slices
      h_no h_ok)

/--
Canonical capstone projection: derive no-unify field all-hooks capstone from
the master-consequence-capstone route via cross-route consequence slices.
-/
theorem principalNoUnifyFieldAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_capstone
    (principalNoUnifyFieldRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_slices
      h_no h_ok)

/--
Canonical capstone projection: derive no-unify field all-hooks capstone from
the master-run-bundle-consequence route via cross-route consequence slices.
-/
theorem principalNoUnifyFieldAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_capstone
    (principalNoUnifyFieldRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_slices
      h_no h_ok)

/--
Cross-route coherence: successful no-unify expression runs yield all-hooks
capstones on both the master-consequence-capstone and
master-run-bundle-consequence routes.
-/
structure PrincipalNoUnifyExprAllHooksCapstonesBothMasterConsequenceRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  viaMasterConsequenceCapstone :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty
  viaMasterRunBundleConsequence :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty

/--
Cross-route coherence constructor: successful no-unify expression runs yield
all-hooks capstones on both master consequence routes.
-/
theorem principalNoUnifyExprAllHooksCapstones_on_both_master_consequence_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprAllHooksCapstonesBothMasterConsequenceRoutes
      st fuel env e st' ty := by
  refine {
    viaMasterConsequenceCapstone :=
      principalNoUnifyExprAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_slices
        h_no h_ok
    viaMasterRunBundleConsequence :=
      principalNoUnifyExprAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_slices
        h_no h_ok
  }

/--
Cross-route coherence: successful no-unify field runs yield all-hooks capstones
on both the master-consequence-capstone and master-run-bundle-consequence
routes.
-/
structure PrincipalNoUnifyFieldAllHooksCapstonesBothMasterConsequenceRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  viaMasterConsequenceCapstone :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf
  viaMasterRunBundleConsequence :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf

/--
Cross-route coherence constructor: successful no-unify field runs yield
all-hooks capstones on both master consequence routes.
-/
theorem principalNoUnifyFieldAllHooksCapstones_on_both_master_consequence_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldAllHooksCapstonesBothMasterConsequenceRoutes
      st fuel env fs st' rf := by
  refine {
    viaMasterConsequenceCapstone :=
      principalNoUnifyFieldAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_slices
        h_no h_ok
    viaMasterRunBundleConsequence :=
      principalNoUnifyFieldAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_slices
        h_no h_ok
  }

/--
Packaged cross-route capstone coherence slice (expression): every successful
no-unify run yields all-hooks capstones on both master consequence routes.
-/
def PrincipalNoUnifyExprAllHooksCapstonesBothMasterConsequenceRoutesSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalNoUnifyExprAllHooksCapstonesBothMasterConsequenceRoutes
      st fuel env e st' ty

/--
Packaged cross-route capstone coherence slice (field): every successful
no-unify field run yields all-hooks capstones on both master consequence
routes.
-/
def PrincipalNoUnifyFieldAllHooksCapstonesBothMasterConsequenceRoutesSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalNoUnifyFieldAllHooksCapstonesBothMasterConsequenceRoutes
      st fuel env fs st' rf

/--
Combined cross-route all-hooks capstone coherence slices over expressions and
fields for the master consequence entry layers.
-/
def PrincipalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices : Prop :=
  PrincipalNoUnifyExprAllHooksCapstonesBothMasterConsequenceRoutesSlice ∧
    PrincipalNoUnifyFieldAllHooksCapstonesBothMasterConsequenceRoutesSlice

/--
The combined cross-route all-hooks capstone coherence slices are fully proved
for the master consequence entry layers.
-/
theorem principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_proved :
    PrincipalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalNoUnifyExprAllHooksCapstones_on_both_master_consequence_routes
      h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalNoUnifyFieldAllHooksCapstones_on_both_master_consequence_routes
      h_no h_ok

/--
One-hop projection: expression branch from the cross-route all-hooks capstone
coherence slices.
-/
theorem principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_expr
    (h_slices : PrincipalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprAllHooksCapstonesBothMasterConsequenceRoutes
      st fuel env e st' ty :=
  h_slices.1 h_no h_ok

/--
One-hop projection: field branch from the cross-route all-hooks capstone
coherence slices.
-/
theorem principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_field
    (h_slices : PrincipalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldAllHooksCapstonesBothMasterConsequenceRoutes
      st fuel env fs st' rf :=
  h_slices.2 h_no h_ok

/--
One-hop projection: extract the master-consequence-capstone expression
all-hooks capstone from cross-route capstone coherence slices.
-/
theorem principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_expr_via_masterConsequenceCapstone
    (h_slices : PrincipalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  (principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_expr
    h_slices h_no h_ok).viaMasterConsequenceCapstone

/--
One-hop projection: extract the master-run-bundle-consequence expression
all-hooks capstone from cross-route capstone coherence slices.
-/
theorem principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_expr_via_masterRunBundleConsequence
    (h_slices : PrincipalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  (principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_expr
    h_slices h_no h_ok).viaMasterRunBundleConsequence

/--
One-hop projection: extract the master-consequence-capstone field all-hooks
capstone from cross-route capstone coherence slices.
-/
theorem principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_field_via_masterConsequenceCapstone
    (h_slices : PrincipalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  (principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_field
    h_slices h_no h_ok).viaMasterConsequenceCapstone

/--
One-hop projection: extract the master-run-bundle-consequence field all-hooks
capstone from cross-route capstone coherence slices.
-/
theorem principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_field_via_masterRunBundleConsequence
    (h_slices : PrincipalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  (principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_field
    h_slices h_no h_ok).viaMasterRunBundleConsequence

/--
Canonical projection from proved cross-route capstone coherence slices to the
master-consequence-capstone expression all-hooks capstone.
-/
theorem principalNoUnifyExprAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_capstone_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_expr_via_masterConsequenceCapstone
    principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route capstone coherence slices to the
master-run-bundle-consequence expression all-hooks capstone.
-/
theorem principalNoUnifyExprAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_capstone_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_expr_via_masterRunBundleConsequence
    principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route capstone coherence slices to the
master-consequence-capstone field all-hooks capstone.
-/
theorem principalNoUnifyFieldAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_capstone_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_field_via_masterConsequenceCapstone
    principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route capstone coherence slices to the
master-run-bundle-consequence field all-hooks capstone.
-/
theorem principalNoUnifyFieldAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_capstone_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_field_via_masterRunBundleConsequence
    principalNoUnifyAllHooksCapstonesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Cross-route coherence: successful no-unify expression runs yield all-hooks
run bundles on both the master-consequence-capstone and
master-run-bundle-consequence routes.
-/
structure PrincipalNoUnifyExprAllHooksRunBundlesBothMasterConsequenceRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  viaMasterConsequenceCapstone :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty
  viaMasterRunBundleConsequence :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty

/--
Cross-route coherence constructor: successful no-unify expression runs yield
all-hooks run bundles on both master consequence routes.
-/
theorem principalNoUnifyExprAllHooksRunBundles_on_both_master_consequence_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprAllHooksRunBundlesBothMasterConsequenceRoutes
      st fuel env e st' ty := by
  refine {
    viaMasterConsequenceCapstone :=
      principalPreconditionedExprAllHooksRunBundle_of_capstone
        (principalNoUnifyExprAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_capstone_slices
          h_no h_ok)
    viaMasterRunBundleConsequence :=
      principalPreconditionedExprAllHooksRunBundle_of_capstone
        (principalNoUnifyExprAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_capstone_slices
          h_no h_ok)
  }

/--
Cross-route coherence: successful no-unify field runs yield all-hooks run
bundles on both the master-consequence-capstone and
master-run-bundle-consequence routes.
-/
structure PrincipalNoUnifyFieldAllHooksRunBundlesBothMasterConsequenceRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  viaMasterConsequenceCapstone :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf
  viaMasterRunBundleConsequence :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf

/--
Cross-route coherence constructor: successful no-unify field runs yield
all-hooks run bundles on both master consequence routes.
-/
theorem principalNoUnifyFieldAllHooksRunBundles_on_both_master_consequence_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldAllHooksRunBundlesBothMasterConsequenceRoutes
      st fuel env fs st' rf := by
  refine {
    viaMasterConsequenceCapstone :=
      principalPreconditionedFieldAllHooksRunBundle_of_capstone
        (principalNoUnifyFieldAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_capstone_slices
          h_no h_ok)
    viaMasterRunBundleConsequence :=
      principalPreconditionedFieldAllHooksRunBundle_of_capstone
        (principalNoUnifyFieldAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_capstone_slices
          h_no h_ok)
  }

/--
Packaged cross-route run-bundle coherence slice (expression): every successful
no-unify run yields all-hooks run bundles on both master consequence routes.
-/
def PrincipalNoUnifyExprAllHooksRunBundlesBothMasterConsequenceRoutesSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalNoUnifyExprAllHooksRunBundlesBothMasterConsequenceRoutes
      st fuel env e st' ty

/--
Packaged cross-route run-bundle coherence slice (field): every successful
no-unify field run yields all-hooks run bundles on both master consequence
routes.
-/
def PrincipalNoUnifyFieldAllHooksRunBundlesBothMasterConsequenceRoutesSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalNoUnifyFieldAllHooksRunBundlesBothMasterConsequenceRoutes
      st fuel env fs st' rf

/--
Combined cross-route all-hooks run-bundle coherence slices over expressions and
fields for the master consequence entry layers.
-/
def PrincipalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices : Prop :=
  PrincipalNoUnifyExprAllHooksRunBundlesBothMasterConsequenceRoutesSlice ∧
    PrincipalNoUnifyFieldAllHooksRunBundlesBothMasterConsequenceRoutesSlice

/--
The combined cross-route all-hooks run-bundle coherence slices are fully proved
for the master consequence entry layers.
-/
theorem principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_proved :
    PrincipalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalNoUnifyExprAllHooksRunBundles_on_both_master_consequence_routes
      h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalNoUnifyFieldAllHooksRunBundles_on_both_master_consequence_routes
      h_no h_ok

/--
One-hop projection: expression branch from the cross-route all-hooks
run-bundle coherence slices.
-/
theorem principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_expr
    (h_slices : PrincipalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprAllHooksRunBundlesBothMasterConsequenceRoutes
      st fuel env e st' ty :=
  h_slices.1 h_no h_ok

/--
One-hop projection: field branch from the cross-route all-hooks run-bundle
coherence slices.
-/
theorem principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_field
    (h_slices : PrincipalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldAllHooksRunBundlesBothMasterConsequenceRoutes
      st fuel env fs st' rf :=
  h_slices.2 h_no h_ok

/--
One-hop projection: extract the master-consequence-capstone expression
all-hooks run bundle from cross-route run-bundle coherence slices.
-/
theorem principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_expr_via_masterConsequenceCapstone
    (h_slices : PrincipalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  (principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_expr
    h_slices h_no h_ok).viaMasterConsequenceCapstone

/--
One-hop projection: extract the master-run-bundle-consequence expression
all-hooks run bundle from cross-route run-bundle coherence slices.
-/
theorem principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_expr_via_masterRunBundleConsequence
    (h_slices : PrincipalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  (principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_expr
    h_slices h_no h_ok).viaMasterRunBundleConsequence

/--
One-hop projection: extract the master-consequence-capstone field all-hooks
run bundle from cross-route run-bundle coherence slices.
-/
theorem principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_field_via_masterConsequenceCapstone
    (h_slices : PrincipalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  (principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_field
    h_slices h_no h_ok).viaMasterConsequenceCapstone

/--
One-hop projection: extract the master-run-bundle-consequence field all-hooks
run bundle from cross-route run-bundle coherence slices.
-/
theorem principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_field_via_masterRunBundleConsequence
    (h_slices : PrincipalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  (principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_field
    h_slices h_no h_ok).viaMasterRunBundleConsequence

/--
Canonical projection from proved cross-route run-bundle coherence slices to
the master-consequence-capstone expression all-hooks run bundle.
-/
theorem principalNoUnifyRunBundleExpr_via_masterConsequenceCapstone_from_cross_route_runBundle_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_expr_via_masterConsequenceCapstone
    principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route run-bundle coherence slices to
the master-run-bundle-consequence expression all-hooks run bundle.
-/
theorem principalNoUnifyRunBundleExpr_via_masterRunBundleConsequence_from_cross_route_runBundle_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_expr_via_masterRunBundleConsequence
    principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route run-bundle coherence slices to
the master-consequence-capstone field all-hooks run bundle.
-/
theorem principalNoUnifyRunBundleField_via_masterConsequenceCapstone_from_cross_route_runBundle_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_field_via_masterConsequenceCapstone
    principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route run-bundle coherence slices to
the master-run-bundle-consequence field all-hooks run bundle.
-/
theorem principalNoUnifyRunBundleField_via_masterRunBundleConsequence_from_cross_route_runBundle_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_field_via_masterRunBundleConsequence
    principalNoUnifyAllHooksRunBundlesBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Cross-route coherence: successful no-unify expression runs yield fixed-run
hook-irrelevance witnesses on both the master-consequence-capstone and
master-run-bundle-consequence routes.
-/
structure PrincipalNoUnifyExprHookIrrelevanceBothMasterConsequenceRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  viaMasterConsequenceCapstone :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
        ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)
  viaMasterRunBundleConsequence :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
        ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)

/--
Cross-route coherence constructor: successful no-unify expression runs yield
fixed-run hook-irrelevance witnesses on both master consequence routes.
-/
theorem principalNoUnifyExprHookIrrelevance_on_both_master_consequence_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprHookIrrelevanceBothMasterConsequenceRoutes
      st fuel env e st' ty := by
  refine {
    viaMasterConsequenceCapstone :=
      (principalNoUnifyExprRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_slices
        h_no h_ok).hookIrrelevant
    viaMasterRunBundleConsequence :=
      (principalNoUnifyExprRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_slices
        h_no h_ok).hookIrrelevant
  }

/--
Cross-route coherence: successful no-unify field runs yield fixed-run
hook-irrelevance witnesses on both the master-consequence-capstone and
master-run-bundle-consequence routes.
-/
structure PrincipalNoUnifyFieldHookIrrelevanceBothMasterConsequenceRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  viaMasterConsequenceCapstone :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
        ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)
  viaMasterRunBundleConsequence :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
        ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)

/--
Cross-route coherence constructor: successful no-unify field runs yield
fixed-run hook-irrelevance witnesses on both master consequence routes.
-/
theorem principalNoUnifyFieldHookIrrelevance_on_both_master_consequence_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldHookIrrelevanceBothMasterConsequenceRoutes
      st fuel env fs st' rf := by
  refine {
    viaMasterConsequenceCapstone :=
      (principalNoUnifyFieldRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_slices
        h_no h_ok).hookIrrelevant
    viaMasterRunBundleConsequence :=
      (principalNoUnifyFieldRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_slices
        h_no h_ok).hookIrrelevant
  }

/--
Packaged cross-route irrelevance coherence slice (expression): every successful
no-unify run yields fixed-run hook-irrelevance witnesses on both master
consequence routes.
-/
def PrincipalNoUnifyExprHookIrrelevanceBothMasterConsequenceRoutesSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalNoUnifyExprHookIrrelevanceBothMasterConsequenceRoutes
      st fuel env e st' ty

/--
Packaged cross-route irrelevance coherence slice (field): every successful
no-unify field run yields fixed-run hook-irrelevance witnesses on both master
consequence routes.
-/
def PrincipalNoUnifyFieldHookIrrelevanceBothMasterConsequenceRoutesSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalNoUnifyFieldHookIrrelevanceBothMasterConsequenceRoutes
      st fuel env fs st' rf

/--
Combined cross-route fixed-run hook-irrelevance coherence slices over
expressions and fields for the master consequence entry layers.
-/
def PrincipalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices : Prop :=
  PrincipalNoUnifyExprHookIrrelevanceBothMasterConsequenceRoutesSlice ∧
    PrincipalNoUnifyFieldHookIrrelevanceBothMasterConsequenceRoutesSlice

/--
The combined cross-route fixed-run hook-irrelevance coherence slices are fully
proved for the master consequence entry layers.
-/
theorem principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_proved :
    PrincipalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalNoUnifyExprHookIrrelevance_on_both_master_consequence_routes
      h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalNoUnifyFieldHookIrrelevance_on_both_master_consequence_routes
      h_no h_ok

/--
One-hop projection: expression branch from the cross-route fixed-run
hook-irrelevance coherence slices.
-/
theorem principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_expr
    (h_slices : PrincipalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprHookIrrelevanceBothMasterConsequenceRoutes
      st fuel env e st' ty :=
  h_slices.1 h_no h_ok

/--
One-hop projection: field branch from the cross-route fixed-run
hook-irrelevance coherence slices.
-/
theorem principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_field
    (h_slices : PrincipalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldHookIrrelevanceBothMasterConsequenceRoutes
      st fuel env fs st' rf :=
  h_slices.2 h_no h_ok

/--
One-hop projection: extract the master-consequence-capstone expression
fixed-run hook-irrelevance witness from cross-route irrelevance slices.
-/
theorem principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_expr_via_masterConsequenceCapstone
    (h_slices : PrincipalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_expr
    h_slices h_no h_ok).viaMasterConsequenceCapstone

/--
One-hop projection: extract the master-run-bundle-consequence expression
fixed-run hook-irrelevance witness from cross-route irrelevance slices.
-/
theorem principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_expr_via_masterRunBundleConsequence
    (h_slices : PrincipalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_expr
    h_slices h_no h_ok).viaMasterRunBundleConsequence

/--
One-hop projection: extract the master-consequence-capstone field fixed-run
hook-irrelevance witness from cross-route irrelevance slices.
-/
theorem principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_field_via_masterConsequenceCapstone
    (h_slices : PrincipalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_field
    h_slices h_no h_ok).viaMasterConsequenceCapstone

/--
One-hop projection: extract the master-run-bundle-consequence field fixed-run
hook-irrelevance witness from cross-route irrelevance slices.
-/
theorem principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_field_via_masterRunBundleConsequence
    (h_slices : PrincipalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_field
    h_slices h_no h_ok).viaMasterRunBundleConsequence

/--
Canonical projection from proved cross-route irrelevance coherence slices to
the master-consequence-capstone expression fixed-run hook-irrelevance witness.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_irrelevance_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_expr_via_masterConsequenceCapstone
    principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route irrelevance coherence slices to
the master-run-bundle-consequence expression fixed-run hook-irrelevance
witness.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_irrelevance_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_expr_via_masterRunBundleConsequence
    principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route irrelevance coherence slices to
the master-consequence-capstone field fixed-run hook-irrelevance witness.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_irrelevance_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_field_via_masterConsequenceCapstone
    principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Canonical projection from proved cross-route irrelevance coherence slices to
the master-run-bundle-consequence field fixed-run hook-irrelevance witness.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_irrelevance_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_field_via_masterRunBundleConsequence
    principalNoUnifyHookIrrelevanceBothMasterConsequenceRoutesSlices_proved h_no h_ok

/--
Per-run all-hooks theorem surface exported by one master consequence route for
no-unify expression runs.
-/
structure PrincipalNoUnifyExprAllHooksRouteSurface
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  consequences : PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty
  capstone : PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty
  runBundle : PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty
  irrelevance :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
        ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)

/--
Per-run all-hooks theorem surface exported by one master consequence route for
no-unify field runs.
-/
structure PrincipalNoUnifyFieldAllHooksRouteSurface
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  consequences : PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf
  capstone : PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf
  runBundle : PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf
  irrelevance :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
        ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)

/--
Cross-route coherence: successful no-unify expression runs export complete
all-hooks route surfaces on both master consequence routes.
-/
structure PrincipalNoUnifyExprAllHooksRouteSurfaceBothMasterConsequenceRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  viaMasterConsequenceCapstone :
    PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty
  viaMasterRunBundleConsequence :
    PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty

/--
Cross-route coherence: successful no-unify field runs export complete all-hooks
route surfaces on both master consequence routes.
-/
structure PrincipalNoUnifyFieldAllHooksRouteSurfaceBothMasterConsequenceRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  viaMasterConsequenceCapstone :
    PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf
  viaMasterRunBundleConsequence :
    PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf

/--
Cross-route coherence constructor: successful no-unify expression runs export
complete all-hooks route surfaces on both master consequence routes.
-/
theorem principalNoUnifyExprAllHooksRouteSurface_on_both_master_consequence_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprAllHooksRouteSurfaceBothMasterConsequenceRoutes
      st fuel env e st' ty := by
  refine {
    viaMasterConsequenceCapstone := {
      consequences :=
        principalNoUnifyExprRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_slices
          h_no h_ok
      capstone :=
        principalNoUnifyExprAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_capstone_slices
          h_no h_ok
      runBundle :=
        principalNoUnifyRunBundleExpr_via_masterConsequenceCapstone_from_cross_route_runBundle_slices
          h_no h_ok
      irrelevance :=
        principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_irrelevance_slices
          h_no h_ok
    }
    viaMasterRunBundleConsequence := {
      consequences :=
        principalNoUnifyExprRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_slices
          h_no h_ok
      capstone :=
        principalNoUnifyExprAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_capstone_slices
          h_no h_ok
      runBundle :=
        principalNoUnifyRunBundleExpr_via_masterRunBundleConsequence_from_cross_route_runBundle_slices
          h_no h_ok
      irrelevance :=
        principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_irrelevance_slices
          h_no h_ok
    }
  }

/--
Cross-route coherence constructor: successful no-unify field runs export
complete all-hooks route surfaces on both master consequence routes.
-/
theorem principalNoUnifyFieldAllHooksRouteSurface_on_both_master_consequence_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldAllHooksRouteSurfaceBothMasterConsequenceRoutes
      st fuel env fs st' rf := by
  refine {
    viaMasterConsequenceCapstone := {
      consequences :=
        principalNoUnifyFieldRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_slices
          h_no h_ok
      capstone :=
        principalNoUnifyFieldAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_capstone_slices
          h_no h_ok
      runBundle :=
        principalNoUnifyRunBundleField_via_masterConsequenceCapstone_from_cross_route_runBundle_slices
          h_no h_ok
      irrelevance :=
        principalNoUnifyPreconditionedField_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_irrelevance_slices
          h_no h_ok
    }
    viaMasterRunBundleConsequence := {
      consequences :=
        principalNoUnifyFieldRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_slices
          h_no h_ok
      capstone :=
        principalNoUnifyFieldAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_capstone_slices
          h_no h_ok
      runBundle :=
        principalNoUnifyRunBundleField_via_masterRunBundleConsequence_from_cross_route_runBundle_slices
          h_no h_ok
      irrelevance :=
        principalNoUnifyPreconditionedField_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_irrelevance_slices
          h_no h_ok
    }
  }

/--
Packaged cross-route all-hooks route-surface coherence slice (expression):
every successful no-unify run exports complete all-hooks surfaces on both
master consequence routes.
-/
def PrincipalNoUnifyExprAllHooksRouteSurfaceBothMasterConsequenceRoutesSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty},
    NoUnifyBranchesExpr e →
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalNoUnifyExprAllHooksRouteSurfaceBothMasterConsequenceRoutes
      st fuel env e st' ty

/--
Packaged cross-route all-hooks route-surface coherence slice (field): every
successful no-unify field run exports complete all-hooks surfaces on both
master consequence routes.
-/
def PrincipalNoUnifyFieldAllHooksRouteSurfaceBothMasterConsequenceRoutesSlice : Prop :=
  ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields},
    NoUnifyBranchesFields fs →
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalNoUnifyFieldAllHooksRouteSurfaceBothMasterConsequenceRoutes
      st fuel env fs st' rf

/--
Combined cross-route all-hooks route-surface coherence slices over expressions
and fields for the master consequence entry layers.
-/
def PrincipalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices : Prop :=
  PrincipalNoUnifyExprAllHooksRouteSurfaceBothMasterConsequenceRoutesSlice ∧
    PrincipalNoUnifyFieldAllHooksRouteSurfaceBothMasterConsequenceRoutesSlice

/--
The combined cross-route all-hooks route-surface coherence slices are fully
proved for the master consequence entry layers.
-/
theorem principalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices_proved :
    PrincipalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices := by
  refine ⟨?_, ?_⟩
  · intro st fuel env e st' ty h_no h_ok
    exact principalNoUnifyExprAllHooksRouteSurface_on_both_master_consequence_routes
      h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalNoUnifyFieldAllHooksRouteSurface_on_both_master_consequence_routes
      h_no h_ok

/--
One-hop projection: expression branch from the cross-route all-hooks
route-surface coherence slices.
-/
theorem principalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices_expr
    (h_slices : PrincipalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprAllHooksRouteSurfaceBothMasterConsequenceRoutes
      st fuel env e st' ty :=
  h_slices.1 h_no h_ok

/--
One-hop projection: field branch from the cross-route all-hooks route-surface
coherence slices.
-/
theorem principalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices_field
    (h_slices : PrincipalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldAllHooksRouteSurfaceBothMasterConsequenceRoutes
      st fuel env fs st' rf :=
  h_slices.2 h_no h_ok

/--
Canonical projection from proved cross-route all-hooks route-surface slices to
the master-consequence-capstone expression route surface.
-/
theorem principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty :=
  (principalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices_expr
    principalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices_proved
    h_no h_ok).viaMasterConsequenceCapstone

/--
Canonical projection from proved cross-route all-hooks route-surface slices to
the master-run-bundle-consequence expression route surface.
-/
theorem principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty :=
  (principalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices_expr
    principalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices_proved
    h_no h_ok).viaMasterRunBundleConsequence

/--
Canonical projection from proved cross-route all-hooks route-surface slices to
the master-consequence-capstone field route surface.
-/
theorem principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf :=
  (principalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices_field
    principalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices_proved
    h_no h_ok).viaMasterConsequenceCapstone

/--
Canonical projection from proved cross-route all-hooks route-surface slices to
the master-run-bundle-consequence field route surface.
-/
theorem principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf :=
  (principalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices_field
    principalNoUnifyAllHooksRouteSurfaceBothMasterConsequenceRoutesSlices_proved
    h_no h_ok).viaMasterRunBundleConsequence

/--
Canonical capstone projection from proved route-surface slices to the
master-consequence-capstone route.
-/
theorem principalNoUnifyExprAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  (principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok).capstone

/--
Canonical capstone projection from proved route-surface slices to the
master-run-bundle-consequence route.
-/
theorem principalNoUnifyExprAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  (principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok).capstone

/--
Canonical capstone projection from proved route-surface slices to the
master-consequence-capstone field route.
-/
theorem principalNoUnifyFieldAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  (principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok).capstone

/--
Canonical capstone projection from proved route-surface slices to the
master-run-bundle-consequence field route.
-/
theorem principalNoUnifyFieldAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  (principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok).capstone

/--
Canonical run-bundle projection from proved route-surface slices to the
master-consequence-capstone route.
-/
theorem principalNoUnifyRunBundleExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  (principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok).runBundle

/--
Canonical run-bundle projection from proved route-surface slices to the
master-run-bundle-consequence route.
-/
theorem principalNoUnifyRunBundleExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  (principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok).runBundle

/--
Canonical run-bundle projection from proved route-surface slices to the
master-consequence-capstone field route.
-/
theorem principalNoUnifyRunBundleField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  (principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok).runBundle

/--
Canonical run-bundle projection from proved route-surface slices to the
master-run-bundle-consequence field route.
-/
theorem principalNoUnifyRunBundleField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  (principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok).runBundle

/--
Canonical consequence-bundle projection from proved route-surface slices to
the master-consequence-capstone route.
-/
theorem principalNoUnifyExprRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  (principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok).consequences

/--
Canonical consequence-bundle projection from proved route-surface slices to
the master-run-bundle-consequence route.
-/
theorem principalNoUnifyExprRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  (principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok).consequences

/--
Canonical consequence-bundle projection from proved route-surface slices to
the master-consequence-capstone field route.
-/
theorem principalNoUnifyFieldRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  (principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok).consequences

/--
Canonical consequence-bundle projection from proved route-surface slices to
the master-run-bundle-consequence field route.
-/
theorem principalNoUnifyFieldRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  (principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok).consequences

/--
Canonical fixed-run hook-irrelevance projection from proved route-surface
slices to the master-consequence-capstone route.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok).irrelevance

/--
Canonical fixed-run hook-irrelevance projection from proved route-surface
slices to the master-run-bundle-consequence route.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok).irrelevance

/--
Canonical fixed-run hook-irrelevance projection from proved route-surface
slices to the master-consequence-capstone field route.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok).irrelevance

/--
Canonical fixed-run hook-irrelevance projection from proved route-surface
slices to the master-run-bundle-consequence field route.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok).irrelevance

/-- One-hop core projection from an expression all-hooks route surface. -/
theorem principalNoUnifyExprAllHooksRouteSurface_core
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_surface : PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty) :
    PrincipalTypingSliceCore env e ty :=
  h_surface.consequences.core

/-- One-hop core projection from a field all-hooks route surface. -/
theorem principalNoUnifyFieldAllHooksRouteSurface_core
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_surface : PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf) :
    PrincipalFieldTypingSliceCore env fs rf :=
  h_surface.consequences.core

/-- One-hop any-hooks preconditioned projection from an expression route surface. -/
theorem principalNoUnifyExprAllHooksRouteSurface_preconditioned_anyHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_surface : PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  h_surface.consequences.preconditionedAny

/-- One-hop any-hooks preconditioned projection from a field route surface. -/
theorem principalNoUnifyFieldAllHooksRouteSurface_preconditioned_anyHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_surface : PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  h_surface.consequences.preconditionedAny

/-- One-hop bundled-target preconditioned projection from an expression route surface. -/
theorem principalNoUnifyExprAllHooksRouteSurface_preconditioned
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_surface : PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  h_surface.consequences.preconditioned h_hooks

/-- One-hop bundled-target preconditioned projection from a field route surface. -/
theorem principalNoUnifyFieldAllHooksRouteSurface_preconditioned
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_surface : PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf)
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  h_surface.consequences.preconditioned h_hooks

/--
One-hop any-hooks `preconditioned ↔ core` projection from an expression
all-hooks route surface.
-/
theorem principalNoUnifyExprAllHooksRouteSurface_preconditionedCoreIff_anyHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_surface : PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  h_surface.consequences.preconditionedAnyIffCore

/--
One-hop any-hooks `preconditioned ↔ core` projection from a field all-hooks
route surface.
-/
theorem principalNoUnifyFieldAllHooksRouteSurface_preconditionedCoreIff_anyHooks
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_surface : PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  h_surface.consequences.preconditionedAnyIffCore

/--
One-hop bundled-target `preconditioned ↔ core` projection from an expression
all-hooks route surface.
-/
theorem principalNoUnifyExprAllHooksRouteSurface_preconditionedCoreIff
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_surface : PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  h_surface.consequences.preconditionedIffCore h_hooks

/--
One-hop bundled-target `preconditioned ↔ core` projection from a field
all-hooks route surface.
-/
theorem principalNoUnifyFieldAllHooksRouteSurface_preconditionedCoreIff
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_surface : PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf)
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  h_surface.consequences.preconditionedIffCore h_hooks

/--
Canonical core projection from proved route-surface slices to the
master-consequence-capstone route.
-/
theorem principalNoUnifyCoreExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyExprAllHooksRouteSurface_core
    (principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical core projection from proved route-surface slices to the
master-consequence-capstone field route.
-/
theorem principalNoUnifyCoreField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyFieldAllHooksRouteSurface_core
    (principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical any-hooks preconditioned projection from proved route-surface slices
to the master-consequence-capstone route.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyExprAllHooksRouteSurface_preconditioned_anyHooks
    (principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical any-hooks preconditioned projection from proved route-surface slices
to the master-consequence-capstone field route.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksRouteSurface_preconditioned_anyHooks
    (principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical any-hooks `preconditioned ↔ core` projection from proved route-surface
slices to the master-consequence-capstone route.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyExprAllHooksRouteSurface_preconditionedCoreIff_anyHooks
    (principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical any-hooks `preconditioned ↔ core` projection from proved route-surface
slices to the master-consequence-capstone field route.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyFieldAllHooksRouteSurface_preconditionedCoreIff_anyHooks
    (principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical bundled-target preconditioned projection from proved route-surface
slices to the master-consequence-capstone route.
-/
theorem principalNoUnifyPreconditionedExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyExprAllHooksRouteSurface_preconditioned
    (principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
      h_no h_ok)
    h_hooks

/--
Canonical bundled-target preconditioned projection from proved route-surface
slices to the master-consequence-capstone field route.
-/
theorem principalNoUnifyPreconditionedField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksRouteSurface_preconditioned
    (principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
      h_no h_ok)
    h_hooks

/--
Canonical bundled-target `preconditioned ↔ core` projection from proved
route-surface slices to the master-consequence-capstone route.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyExprAllHooksRouteSurface_preconditionedCoreIff
    (principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
      h_no h_ok)
    h_hooks

/--
Canonical bundled-target `preconditioned ↔ core` projection from proved
route-surface slices to the master-consequence-capstone field route.
-/
theorem principalNoUnifyPreconditionedCoreIffField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyFieldAllHooksRouteSurface_preconditionedCoreIff
    (principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
      h_no h_ok)
    h_hooks

/--
Canonical core projection from proved route-surface slices to the
master-run-bundle-consequence route.
-/
theorem principalNoUnifyCoreExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyExprAllHooksRouteSurface_core
    (principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical core projection from proved route-surface slices to the
master-run-bundle-consequence field route.
-/
theorem principalNoUnifyCoreField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyFieldAllHooksRouteSurface_core
    (principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical any-hooks preconditioned projection from proved route-surface slices
to the master-run-bundle-consequence route.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyExprAllHooksRouteSurface_preconditioned_anyHooks
    (principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical any-hooks preconditioned projection from proved route-surface slices
to the master-run-bundle-consequence field route.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksRouteSurface_preconditioned_anyHooks
    (principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical any-hooks `preconditioned ↔ core` projection from proved route-surface
slices to the master-run-bundle-consequence route.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyExprAllHooksRouteSurface_preconditionedCoreIff_anyHooks
    (principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical any-hooks `preconditioned ↔ core` projection from proved route-surface
slices to the master-run-bundle-consequence field route.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyFieldAllHooksRouteSurface_preconditionedCoreIff_anyHooks
    (principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
      h_no h_ok)

/--
Canonical bundled-target preconditioned projection from proved route-surface
slices to the master-run-bundle-consequence route.
-/
theorem principalNoUnifyPreconditionedExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyExprAllHooksRouteSurface_preconditioned
    (principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
      h_no h_ok)
    h_hooks

/--
Canonical bundled-target preconditioned projection from proved route-surface
slices to the master-run-bundle-consequence field route.
-/
theorem principalNoUnifyPreconditionedField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksRouteSurface_preconditioned
    (principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
      h_no h_ok)
    h_hooks

/--
Canonical bundled-target `preconditioned ↔ core` projection from proved
route-surface slices to the master-run-bundle-consequence route.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyExprAllHooksRouteSurface_preconditionedCoreIff
    (principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
      h_no h_ok)
    h_hooks

/--
Canonical bundled-target `preconditioned ↔ core` projection from proved
route-surface slices to the master-run-bundle-consequence field route.
-/
theorem principalNoUnifyPreconditionedCoreIffField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyFieldAllHooksRouteSurface_preconditionedCoreIff
    (principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
      h_no h_ok)
    h_hooks

/-- Bundled-seed alias for capstone-route core expression projection. -/
theorem principalNoUnifyCoreExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route core field projection. -/
theorem principalNoUnifyCoreField_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route any-hooks expression projection. -/
theorem principalNoUnifyPreconditionedExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route any-hooks field projection. -/
theorem principalNoUnifyPreconditionedField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route any-hooks expression iff projection. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route any-hooks field iff projection. -/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route run-bundle expression projection. -/
theorem principalNoUnifyRunBundleExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route run-bundle field projection. -/
theorem principalNoUnifyRunBundleField_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route consequence expression projection. -/
theorem principalNoUnifyExprRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route consequence field projection. -/
theorem principalNoUnifyFieldRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route all-hooks capstone expression projection. -/
theorem principalNoUnifyExprAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route all-hooks capstone field projection. -/
theorem principalNoUnifyFieldAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route core expression projection. -/
theorem principalNoUnifyCoreExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route core field projection. -/
theorem principalNoUnifyCoreField_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route any-hooks expression projection. -/
theorem principalNoUnifyPreconditionedExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route any-hooks field projection. -/
theorem principalNoUnifyPreconditionedField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route any-hooks expression iff projection. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route any-hooks field iff projection. -/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route run-bundle expression projection. -/
theorem principalNoUnifyRunBundleExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route run-bundle field projection. -/
theorem principalNoUnifyRunBundleField_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route consequence expression projection. -/
theorem principalNoUnifyExprRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route consequence field projection. -/
theorem principalNoUnifyFieldRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route all-hooks capstone expression projection. -/
theorem principalNoUnifyExprAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route all-hooks capstone field projection. -/
theorem principalNoUnifyFieldAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route expression all-hooks route surface. -/
theorem principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty :=
  principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route field all-hooks route surface. -/
theorem principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route expression all-hooks route surface. -/
theorem principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty :=
  principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route field all-hooks route surface. -/
theorem principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route bundled-target expression preconditioned projection. -/
theorem principalNoUnifyPreconditionedExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_seed : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok h_seed

/-- Bundled-seed alias for capstone-route bundled-target field preconditioned projection. -/
theorem principalNoUnifyPreconditionedField_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok h_seed

/-- Bundled-seed alias for run-bundle-route bundled-target expression preconditioned projection. -/
theorem principalNoUnifyPreconditionedExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_seed : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok h_seed

/-- Bundled-seed alias for run-bundle-route bundled-target field preconditioned projection. -/
theorem principalNoUnifyPreconditionedField_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok h_seed

/-- Bundled-seed alias for capstone-route bundled-target expression iff projection. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok h_seed

/-- Bundled-seed alias for capstone-route bundled-target field iff projection. -/
theorem principalNoUnifyPreconditionedCoreIffField_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok h_seed

/-- Bundled-seed alias for run-bundle-route bundled-target expression iff projection. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok h_seed

/-- Bundled-seed alias for run-bundle-route bundled-target field iff projection. -/
theorem principalNoUnifyPreconditionedCoreIffField_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok h_seed

/-- Bundled-seed alias for capstone-route expression hook-irrelevance projection. -/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route field hook-irrelevance projection. -/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route expression hook-irrelevance projection. -/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route field hook-irrelevance projection. -/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical core projection: derive no-unify expression core principality from
the master-consequence-capstone route via cross-route consequence slices.
-/
theorem principalNoUnifyCoreExpr_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical core projection: derive no-unify field core principality from the
master-consequence-capstone route via cross-route consequence slices.
-/
theorem principalNoUnifyCoreField_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical any-hooks projection: derive no-unify expression preconditioned
principality from the master-consequence-capstone route via cross-route
consequence slices.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical any-hooks projection: derive no-unify field preconditioned principality
from the master-consequence-capstone route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical bundled-target projection: derive no-unify expression preconditioned
principality from the master-consequence-capstone route via cross-route
consequence slices.
-/
theorem principalNoUnifyPreconditionedExpr_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok h_hooks

/--
Canonical bundled-target projection: derive no-unify field preconditioned
principality from the master-consequence-capstone route via cross-route
consequence slices.
-/
theorem principalNoUnifyPreconditionedField_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok h_hooks

/--
Bundled-hook alias for expression preconditioned principality on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
Bundled-hook alias for field preconditioned principality on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
Canonical any-hooks `preconditioned ↔ core` projection for expressions from the
master-consequence-capstone route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical any-hooks `preconditioned ↔ core` projection for fields from the
master-consequence-capstone route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical bundled-target `preconditioned ↔ core` projection for expressions
from the master-consequence-capstone route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok h_hooks

/--
Canonical bundled-target `preconditioned ↔ core` projection for fields from
the master-consequence-capstone route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedCoreIffField_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok h_hooks

/--
Bundled-hook alias for expression `preconditioned ↔ core` equivalence on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
Bundled-hook alias for field `preconditioned ↔ core` equivalence on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffField_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
Canonical fixed-run hook-irrelevance projection for expressions from the
master-consequence-capstone route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_irrelevance_slices
    h_no h_ok

/--
Canonical fixed-run hook-irrelevance projection for fields from the
master-consequence-capstone route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_irrelevance_slices
    h_no h_ok

/--
Canonical core projection: derive no-unify expression core principality from
the master-run-bundle-consequence route via cross-route consequence slices.
-/
theorem principalNoUnifyCoreExpr_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical core projection: derive no-unify field core principality from the
master-run-bundle-consequence route via cross-route consequence slices.
-/
theorem principalNoUnifyCoreField_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical any-hooks projection: derive no-unify expression preconditioned
principality from the master-run-bundle-consequence route via cross-route
consequence slices.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical any-hooks projection: derive no-unify field preconditioned principality
from the master-run-bundle-consequence route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical bundled-target projection: derive no-unify expression preconditioned
principality from the master-run-bundle-consequence route via cross-route
consequence slices.
-/
theorem principalNoUnifyPreconditionedExpr_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok h_hooks

/--
Canonical bundled-target projection: derive no-unify field preconditioned
principality from the master-run-bundle-consequence route via cross-route
consequence slices.
-/
theorem principalNoUnifyPreconditionedField_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok h_hooks

/--
Bundled-hook alias for expression preconditioned principality on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
Bundled-hook alias for field preconditioned principality on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
Canonical any-hooks `preconditioned ↔ core` projection for expressions from the
master-run-bundle-consequence route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical any-hooks `preconditioned ↔ core` projection for fields from the
master-run-bundle-consequence route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Canonical bundled-target `preconditioned ↔ core` projection for expressions
from the master-run-bundle-consequence route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok h_hooks

/--
Canonical bundled-target `preconditioned ↔ core` projection for fields from
the master-run-bundle-consequence route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedCoreIffField_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok h_hooks

/--
Bundled-hook alias for expression `preconditioned ↔ core` equivalence on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
Bundled-hook alias for field `preconditioned ↔ core` equivalence on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffField_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
Long-form no-unify-to-general alias: expression core principality on the
master-consequence-capstone cross-route surface.
-/
theorem principalCoreExpr_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: field core principality on the
master-consequence-capstone cross-route surface.
-/
theorem principalCoreField_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: expression preconditioned principality
for any hooks on the master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: field preconditioned principality for any
hooks on the master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: expression preconditioned↔core for any
hooks on the master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: field preconditioned↔core for any hooks on
the master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: expression fixed-run hook-irrelevance on
the master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: field fixed-run hook-irrelevance on the
master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: expression core principality on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: field core principality on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalCoreField_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: expression preconditioned principality for
any hooks on the master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: field preconditioned principality for any
hooks on the master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: expression preconditioned↔core for any
hooks on the master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: field preconditioned↔core for any hooks on
the master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: expression fixed-run hook-irrelevance on
the master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Long-form no-unify-to-general alias: field fixed-run hook-irrelevance on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Bundled-hook alias for long-form expression core principality on the
master-consequence-capstone cross-route surface.
-/
theorem principalCoreExpr_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form field core principality on the
master-consequence-capstone cross-route surface.
-/
theorem principalCoreField_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form expression any-hooks preconditioned principality
on the master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form field any-hooks preconditioned principality on
the master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form expression any-hooks `preconditioned ↔ core`
equivalence on the master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form field any-hooks `preconditioned ↔ core`
equivalence on the master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form expression hook-irrelevance on the
master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form field hook-irrelevance on the
master-consequence-capstone cross-route surface.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression core principality on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyCoreExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: field core principality on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyCoreField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression any-hooks preconditioned principality
on the master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: field any-hooks preconditioned principality on
the master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression preconditioned principality on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: field preconditioned principality on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: bundled-hook variant for expression preconditioned
principality on the master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: bundled-hook variant for field preconditioned
principality on the master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: expression any-hooks `preconditioned ↔ core`
equivalence on the master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: field any-hooks `preconditioned ↔ core`
equivalence on the master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression `preconditioned ↔ core` equivalence on
the master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: field `preconditioned ↔ core` equivalence on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: bundled-hook variant for expression
`preconditioned ↔ core` equivalence on the master-consequence-capstone
cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: bundled-hook variant for field
`preconditioned ↔ core` equivalence on the master-consequence-capstone
cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: expression fixed-run hook-irrelevance on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: field fixed-run hook-irrelevance on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: bundled-hook variant for expression fixed-run
hook-irrelevance on the master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: bundled-hook variant for field fixed-run
hook-irrelevance on the master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression run-bundle surface on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: field run-bundle surface on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyRunBundleField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression packaged consequence bundle on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: field packaged consequence bundle on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression all-hooks capstone on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: field all-hooks capstone on the
master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: bundled-hook variant for expression all-hooks
capstone on the master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: bundled-hook variant for field all-hooks capstone
on the master-consequence-capstone cross-route surface.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route core expression no-unify parity. -/
theorem principalNoUnifyCoreExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route core field no-unify parity. -/
theorem principalNoUnifyCoreField_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route any-hooks expression no-unify parity. -/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route any-hooks field no-unify parity. -/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route any-hooks expression iff parity. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route any-hooks field iff parity. -/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route run-bundle expression no-unify parity. -/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route run-bundle field no-unify parity. -/
theorem principalNoUnifyRunBundleField_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route expression consequence no-unify parity. -/
theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route field consequence no-unify parity. -/
theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form expression core principality on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form field core principality on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalCoreField_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form expression any-hooks preconditioned principality
on the master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form field any-hooks preconditioned principality on
the master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form expression any-hooks `preconditioned ↔ core`
equivalence on the master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form field any-hooks `preconditioned ↔ core`
equivalence on the master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form expression hook-irrelevance on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
Bundled-hook alias for long-form field hook-irrelevance on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression core principality on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyCoreExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: field core principality on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyCoreField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression any-hooks preconditioned principality
on the master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: field any-hooks preconditioned principality on
the master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression preconditioned principality on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: field preconditioned principality on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: bundled-hook variant for expression preconditioned
principality on the master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: bundled-hook variant for field preconditioned
principality on the master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: expression any-hooks `preconditioned ↔ core`
equivalence on the master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: field any-hooks `preconditioned ↔ core`
equivalence on the master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression `preconditioned ↔ core` equivalence on
the master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: field `preconditioned ↔ core` equivalence on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: bundled-hook variant for expression
`preconditioned ↔ core` equivalence on the master-run-bundle-consequence
cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: bundled-hook variant for field
`preconditioned ↔ core` equivalence on the master-run-bundle-consequence
cross-route surface.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

/--
No-unify naming-parity alias: expression fixed-run hook-irrelevance on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: field fixed-run hook-irrelevance on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: bundled-hook variant for expression fixed-run
hook-irrelevance on the master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: bundled-hook variant for field fixed-run
hook-irrelevance on the master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression run-bundle surface on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: field run-bundle surface on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyRunBundleField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression packaged consequence bundle on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: field packaged consequence bundle on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: expression all-hooks capstone on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: field all-hooks capstone on the
master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
No-unify naming-parity alias: bundled-hook variant for expression all-hooks
capstone on the master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
No-unify naming-parity alias: bundled-hook variant for field all-hooks capstone
on the master-run-bundle-consequence cross-route surface.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route core expression no-unify parity. -/
theorem principalNoUnifyCoreExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route core field no-unify parity. -/
theorem principalNoUnifyCoreField_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route any-hooks expression no-unify parity. -/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route any-hooks field no-unify parity. -/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route any-hooks expression iff parity. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route any-hooks field iff parity. -/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route run-bundle expression no-unify parity. -/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route run-bundle field no-unify parity. -/
theorem principalNoUnifyRunBundleField_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route expression consequence no-unify parity. -/
theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route field consequence no-unify parity. -/
theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

/--
Canonical fixed-run hook-irrelevance projection for expressions from the
master-run-bundle-consequence route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalNoUnifyExprRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok).hookIrrelevant

/--
Canonical fixed-run hook-irrelevance projection for fields from the
master-run-bundle-consequence route via cross-route consequence slices.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalNoUnifyFieldRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok).hookIrrelevant

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
derive the expression all-hooks capstone from a successful no-unify run.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_capstone
    (principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
      h_no h_ok)

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
derive the field all-hooks capstone from a successful no-unify field run.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_capstone
    (principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
      h_no h_ok)

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive the
expression all-hooks capstone from a successful no-unify run.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive the
field all-hooks capstone from a successful no-unify field run.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
bundled-hook variant for expression all-hooks capstone.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
bundled-hook variant for field all-hooks capstone.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper:
bundled-hook alias for expression all-hooks capstone.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper:
bundled-hook alias for field all-hooks capstone.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive core expression
principality from a successful no-unify run.
-/
theorem principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  (principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).core

/--
Master-run-bundle-consequence-suite convenience wrapper: derive core field
principality from a successful no-unify field run.
-/
theorem principalCoreField_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).core

/--
Master-run-bundle-consequence-suite convenience wrapper: derive preconditioned
expression principality for any hook witnesses from a successful no-unify run.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  (principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).preconditionedAny

/--
Master-run-bundle-consequence-suite convenience wrapper: derive preconditioned
field principality for any hook witnesses from a successful no-unify field run.
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  (principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).preconditionedAny

/--
Master-run-bundle-consequence-suite convenience wrapper: derive preconditioned
expression principality for a bundled hook witness from a successful no-unify
run.
-/
theorem principalPreconditionedExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  (principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).preconditioned h_hooks

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
bundled-hook variant for fixed-run preconditioned expression principality.
-/
theorem principalPreconditionedExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite convenience wrapper: derive preconditioned
field principality for a bundled hook witness from a successful no-unify field
run.
-/
theorem principalPreconditionedField_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  (principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).preconditioned h_hooks

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
bundled-hook variant for fixed-run preconditioned field principality.
-/
theorem principalPreconditionedField_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite convenience wrapper: derive fixed-run
expression preconditioned↔core equivalence for any hook witnesses from a
successful no-unify run.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  (principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).preconditionedAnyIffCore

/--
Master-run-bundle-consequence-suite convenience wrapper: derive fixed-run
field preconditioned↔core equivalence for any hook witnesses from a successful
no-unify field run.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).preconditionedAnyIffCore

/-- Bundled-seed alias for no-unify-to-general core expression on the consequence suite. -/
theorem principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general core field on the consequence suite. -/
theorem principalCoreField_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks expression preconditioning on the consequence suite. -/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks field preconditioning on the consequence suite. -/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks expression iff preconditioning on the consequence suite. -/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks field iff preconditioning on the consequence suite. -/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite convenience wrapper: derive fixed-run
expression preconditioned↔core equivalence for a bundled hook witness from a
successful no-unify run.
-/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).preconditionedIffCore h_hooks

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
bundled-hook variant for fixed-run expression preconditioned↔core equivalence.
-/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for a bundled hook witness from a successful
no-unify field run.
-/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).preconditionedIffCore h_hooks

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
bundled-hook variant for fixed-run field preconditioned↔core equivalence.
-/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite convenience wrapper: derive fixed-run
expression hook-irrelevance from a successful no-unify run.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).hookIrrelevant

/--
Master-run-bundle-consequence-suite convenience wrapper: derive fixed-run field
hook-irrelevance from a successful no-unify field run.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok).hookIrrelevant

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
bundled-hook variant for fixed-run expression hook-irrelevance.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify-to-general convenience wrapper:
bundled-hook variant for fixed-run field hook-irrelevance.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive core
expression principality from a successful no-unify run.
-/
theorem principalNoUnifyCoreExpr_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive
preconditioned expression principality for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive
preconditioned expression principality for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper:
bundled-hook alias for fixed-run preconditioned expression principality.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive
fixed-run expression preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive
fixed-run expression preconditioned↔core equivalence for a bundled hook
witness.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper:
bundled-hook alias for fixed-run expression preconditioned↔core equivalence.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive
fixed-run expression hook-irrelevance.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper:
bundled-hook alias for fixed-run expression hook-irrelevance.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive core
field principality from a successful no-unify field run.
-/
theorem principalNoUnifyCoreField_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterRunBundleConsequenceSuite h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive
preconditioned field principality for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive
preconditioned field principality for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper:
bundled-hook alias for fixed-run preconditioned field principality.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive
fixed-run field preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive
fixed-run field preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper:
bundled-hook alias for fixed-run field preconditioned↔core equivalence.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok h_hooks

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper: derive
fixed-run field hook-irrelevance.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
Master-run-bundle-consequence-suite no-unify convenience wrapper:
bundled-hook alias for fixed-run field hook-irrelevance.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify core expression on the consequence suite. -/
theorem principalNoUnifyCoreExpr_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify core field on the consequence suite. -/
theorem principalNoUnifyCoreField_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks expression preconditioning. -/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks field preconditioning. -/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks expression iff preconditioning. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks field iff preconditioning. -/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify run-bundle expression on the consequence suite. -/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify run-bundle field on the consequence suite. -/
theorem principalNoUnifyRunBundleField_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify expression consequence bundle on the consequence suite. -/
theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify field consequence bundle on the consequence suite. -/
theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite
    h_no h_ok

/--
One-hop expression hook-specific no-unify capstone projection (derived from
all-hooks compatibility) from the master suite.
-/
theorem principalBoundaryMasterSuite_noUnifyHookedFromAllHooks_expr
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyExprCapstone
      h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalBoundaryNoUnifyCapstoneSlices_expr
    h_suite.noUnifyHookedFromAllHooks h_no h_ok h_hooks

/--
One-hop field hook-specific no-unify capstone projection (derived from
all-hooks compatibility) from the master suite.
-/
theorem principalBoundaryMasterSuite_noUnifyHookedFromAllHooks_field
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundaryNoUnifyFieldCapstone
      h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalBoundaryNoUnifyCapstoneSlices_field
    h_suite.noUnifyHookedFromAllHooks h_no h_ok h_hooks

/--
Master-suite capstone wrapper: package the full expression successful-run
all-hooks principal boundary from one successful run and one baseline hook
witness pair.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedAllHooksSuite_capstone_expr
    h_suite.allHooks h_app0 h_proj0 h_ok

/--
Master-suite capstone wrapper: package the full field successful-run all-hooks
principal boundary from one successful field run and one baseline hook witness
pair.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedAllHooksSuite_capstone_field
    h_suite.allHooks h_app0 h_proj0 h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive the expression
all-hooks capstone from a successful no-unify run.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_expr_via_consequenceSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive the field
all-hooks capstone from a successful no-unify field run.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_field_via_consequenceSuite
    h_suite h_no h_ok

/--
Master-suite no-unify convenience wrapper: derive the expression all-hooks
capstone from a successful no-unify run.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify convenience wrapper: derive the field all-hooks capstone
from a successful no-unify field run.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: bundled-hook variant for
expression all-hooks capstone.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: bundled-hook variant for
field all-hooks capstone.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify convenience wrapper: bundled-hook alias for expression
all-hooks capstone.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_of_success_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify convenience wrapper: bundled-hook alias for field
all-hooks capstone.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_of_success_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite capstone wrapper: bundled-hook variant for expression successful-run
all-hooks principal boundary packaging.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok

/--
Master-suite capstone wrapper: bundled-hook variant for field successful-run
all-hooks principal boundary packaging.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok

/--
Master-suite run-bundle wrapper: package capstone + hook-irrelevance for
expression successful runs from one baseline hook witness pair.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalGeneralAllHooksRunBundleExpr_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok

/--
Master-suite run-bundle wrapper: package capstone + hook-irrelevance for
successful field runs from one baseline hook witness pair.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalGeneralAllHooksRunBundleField_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok

/--
Bundle-entry variant of
`principalPreconditionedExprAllHooksRunBundle_of_success_via_masterSuite`.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok

/--
Bundle-entry variant of
`principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterSuite`.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok

/--
Master-suite convenience wrapper: derive fixed-run expression hook-irrelevance
for arbitrary successful runs.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalBoundaryMasterSuite_allHooks_irrelevance_expr_via_consequenceSuite
    h_suite h_app0 h_proj0 h_ok

/--
Master-suite convenience wrapper: derive fixed-run field hook-irrelevance for
arbitrary successful field runs.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook) (h_proj0 : ProjUnifySoundHook)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalBoundaryMasterSuite_allHooks_irrelevance_field_via_consequenceSuite
    h_suite h_app0 h_proj0 h_ok

/--
Master-suite convenience wrapper: bundled-baseline variant for arbitrary
successful expression hook-irrelevance.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok

/--
Master-suite convenience wrapper: bundled-baseline variant for arbitrary
successful field hook-irrelevance.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok

/--
Master-suite convenience wrapper: derive core expression principality from an
arbitrary successful run via the embedded general all-hooks layer.
-/
theorem principalCoreExpr_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalGeneralAllHooksCoreExpr_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok

/--
Master-suite convenience wrapper: derive preconditioned expression principality
for any hook witnesses from an arbitrary successful run.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalGeneralAllHooksPreconditionedExpr_anyHooks_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok

/--
Master-suite convenience wrapper: derive preconditioned expression principality
for a bundled hook witness from an arbitrary successful run.
-/
theorem principalPreconditionedExpr_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalGeneralAllHooksPreconditionedExpr_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok h_hooks

/--
Master-suite convenience wrapper: derive fixed-run expression preconditioned↔core
equivalence for any hook witnesses from an arbitrary successful run.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalGeneralAllHooksPreconditionedCoreIffExpr_anyHooks_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok

/--
Master-suite convenience wrapper: derive fixed-run expression preconditioned↔core
equivalence for a bundled hook witness from an arbitrary successful run.
-/
theorem principalPreconditionedCoreIffExpr_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalGeneralAllHooksPreconditionedCoreIffExpr_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok h_hooks

/--
Master-suite convenience wrapper: derive core field principality from an
arbitrary successful field run via the embedded general all-hooks layer.
-/
theorem principalCoreField_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalGeneralAllHooksCoreField_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok

/--
Master-suite convenience wrapper: derive preconditioned field principality for
any hook witnesses from an arbitrary successful field run.
-/
theorem principalPreconditionedField_anyHooks_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalGeneralAllHooksPreconditionedField_anyHooks_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok

/--
Master-suite convenience wrapper: derive preconditioned field principality for
a bundled hook witness from an arbitrary successful field run.
-/
theorem principalPreconditionedField_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalGeneralAllHooksPreconditionedField_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok h_hooks

/--
Master-suite convenience wrapper: derive fixed-run field preconditioned↔core
equivalence for any hook witnesses from an arbitrary successful field run.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalGeneralAllHooksPreconditionedCoreIffField_anyHooks_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok

/--
Master-suite convenience wrapper: derive fixed-run field preconditioned↔core
equivalence for a bundled hook witness from an arbitrary successful field run.
-/
theorem principalPreconditionedCoreIffField_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalGeneralAllHooksPreconditionedCoreIffField_of_success
    h_suite.allHooks h_app0 h_proj0 h_ok h_hooks

/--
Master-suite convenience wrapper: bundled-baseline variant for core expression
principality from an arbitrary successful run.
-/
theorem principalCoreExpr_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_via_masterSuite h_suite h_seed.1 h_seed.2 h_ok

/--
Master-suite convenience wrapper: bundled-baseline variant for preconditioned
expression principality (any target hooks) from an arbitrary successful run.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok

/--
Master-suite convenience wrapper: bundled-baseline variant for fixed-run
expression preconditioned↔core equivalence (any target hooks) from an arbitrary
successful run.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok

/--
Master-suite convenience wrapper: bundled-baseline variant for core field
principality from an arbitrary successful field run.
-/
theorem principalCoreField_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_via_masterSuite h_suite h_seed.1 h_seed.2 h_ok

/--
Master-suite convenience wrapper: bundled-baseline variant for preconditioned
field principality (any target hooks) from an arbitrary successful field run.
-/
theorem principalPreconditionedField_anyHooks_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok

/--
Master-suite convenience wrapper: bundled-baseline variant for fixed-run field
preconditioned↔core equivalence (any target hooks) from an arbitrary successful
field run.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok

/--
Master-suite convenience wrapper: bundled-baseline variant for preconditioned
expression principality under a bundled target-hook witness from an arbitrary
successful run.
-/
theorem principalPreconditionedExpr_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok h_hooks

/--
Master-suite convenience wrapper: bundled-baseline variant for fixed-run
expression preconditioned↔core equivalence under a bundled target-hook witness
from an arbitrary successful run.
-/
theorem principalPreconditionedCoreIffExpr_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok h_hooks

/--
Master-suite convenience wrapper: bundled-baseline variant for preconditioned
field principality under a bundled target-hook witness from an arbitrary
successful field run.
-/
theorem principalPreconditionedField_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok h_hooks

/--
Master-suite convenience wrapper: bundled-baseline variant for fixed-run field
preconditioned↔core equivalence under a bundled target-hook witness from an
arbitrary successful field run.
-/
theorem principalPreconditionedCoreIffField_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_via_masterSuite
    h_suite h_seed.1 h_seed.2 h_ok h_hooks

/--
Master-suite no-unify convenience wrapper: derive core expression principality
from a successful no-unify expression run.
-/
theorem principalNoUnifyCoreExpr_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_expr
    h_suite h_no h_ok).core

/--
Master-suite no-unify convenience wrapper: derive preconditioned expression
principality for any hook witnesses from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_expr
    h_suite h_no h_ok).preconditionedAny

/--
Master-suite no-unify convenience wrapper: derive preconditioned expression
principality for a bundled hook witness from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_expr
    h_suite h_no h_ok).preconditioned h_hooks

/--
Master-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
preconditioned expression principality.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify-to-general convenience wrapper: derive core expression
principality from a successful no-unify run.
-/
theorem principalCoreExpr_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterSuite h_suite h_no h_ok

/--
Master-suite convenience wrapper: derive the expression run-bundle surface from
a successful no-unify run.
-/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_runBundle_expr_via_consequenceSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive the expression
run-bundle surface from a successful no-unify run.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_masterSuite h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive preconditioned
expression principality for any hook witnesses from a successful no-unify run.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive preconditioned
expression principality for a bundled hook witness from a successful no-unify
run.
-/
theorem principalPreconditionedExpr_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify-to-general convenience wrapper: bundled-hook variant for
fixed-run preconditioned expression principality.
-/
theorem principalPreconditionedExpr_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_expr
    h_suite h_no h_ok).preconditionedAnyIffCore

/--
Master-suite no-unify convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite
    h_suite h_no h_ok) h_hooks.1 h_hooks.2

/--
Master-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
expression preconditioned↔core equivalence.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify-to-general convenience wrapper: derive fixed-run
expression preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive fixed-run
expression preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify-to-general convenience wrapper: bundled-hook variant for
fixed-run expression preconditioned↔core equivalence.
-/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify convenience wrapper: derive core field principality from
a successful no-unify field run.
-/
theorem principalNoUnifyCoreField_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_field
    h_suite h_no h_ok).core

/--
Master-suite no-unify convenience wrapper: derive preconditioned field
principality for any hook witnesses from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_field
    h_suite h_no h_ok).preconditionedAny

/--
Master-suite no-unify convenience wrapper: derive preconditioned field
principality for a bundled hook witness from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_field
    h_suite h_no h_ok).preconditioned h_hooks

/--
Master-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
preconditioned field principality.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify-to-general convenience wrapper: derive core field
principality from a successful no-unify field run.
-/
theorem principalCoreField_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterSuite h_suite h_no h_ok

/--
Master-suite convenience wrapper: derive the field run-bundle surface from a
successful no-unify field run.
-/
theorem principalNoUnifyRunBundleField_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_runBundle_field_via_consequenceSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive the field
run-bundle surface from a successful no-unify field run.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_masterSuite h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive preconditioned
field principality for any hook witnesses from a successful no-unify run.
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive preconditioned
field principality for a bundled hook witness from a successful no-unify run.
-/
theorem principalPreconditionedField_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify-to-general convenience wrapper: bundled-hook variant for
fixed-run preconditioned field principality.
-/
theorem principalPreconditionedField_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_field
    h_suite h_no h_ok).preconditionedAnyIffCore

/--
Master-suite no-unify convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite
    h_suite h_no h_ok) h_hooks.1 h_hooks.2

/--
Master-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
field preconditioned↔core equivalence.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify-to-general convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify-to-general convenience wrapper: bundled-hook variant for
fixed-run field preconditioned↔core equivalence.
-/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok h_hooks

/--
Master-suite no-unify convenience wrapper: derive fixed-run expression
hook-irrelevance from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_expr
    h_suite h_no h_ok).hookIrrelevant

/--
Master-suite no-unify convenience wrapper: derive fixed-run field
hook-irrelevance from a successful no-unify field run.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalBoundaryMasterSuite_noUnifyRunBundleConsequences_field
    h_suite h_no h_ok).hookIrrelevant

/--
Master-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
expression hook-irrelevance.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
field hook-irrelevance.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterSuite
    h_suite h_no h_ok

/-- Bundled-seed alias for no-unify core expression on the master suite. -/
theorem principalNoUnifyCoreExpr_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterSuite h_suite h_no h_ok

/-- Bundled-seed alias for no-unify core field on the master suite. -/
theorem principalNoUnifyCoreField_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterSuite h_suite h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks expression preconditioning on the master suite. -/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterSuite
    h_suite h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks field preconditioning on the master suite. -/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterSuite
    h_suite h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks expression iff preconditioning on the master suite. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite
    h_suite h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks field iff preconditioning on the master suite. -/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite
    h_suite h_no h_ok

/-- Bundled-seed alias for no-unify run-bundle expression on the master suite. -/
theorem principalNoUnifyRunBundleExpr_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_masterSuite h_suite h_no h_ok

/-- Bundled-seed alias for no-unify run-bundle field on the master suite. -/
theorem principalNoUnifyRunBundleField_of_success_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_masterSuite h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive fixed-run
expression hook-irrelevance from a successful no-unify run.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: derive fixed-run field
hook-irrelevance from a successful no-unify field run.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterSuite
    (h_suite : PrincipalBoundaryMasterSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: bundled-hook variant for
fixed-run expression hook-irrelevance.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/--
Master-suite no-unify-to-general convenience wrapper: bundled-hook variant for
fixed-run field hook-irrelevance.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general core expression on the master suite. -/
theorem principalCoreExpr_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterSuite h_suite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general core field on the master suite. -/
theorem principalCoreField_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterSuite h_suite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks expression preconditioning on the master suite. -/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks field preconditioning on the master suite. -/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks expression iff preconditioning on the master suite. -/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks field iff preconditioning on the master suite. -/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general expression run-bundle on the master suite. -/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general field run-bundle on the master suite. -/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterSuite_from_bundle
    (h_suite : PrincipalBoundaryMasterSuite)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterSuite
    h_suite h_no h_ok

/--
All-hooks-suite convenience wrapper: derive core expression principality from a
successful no-unify expression run.
-/
theorem principalNoUnifyCoreExpr_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyToGeneralCoreExpr_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive the expression
all-hooks capstone from a successful no-unify run.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_noUnify h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive the field
all-hooks capstone from a successful no-unify field run.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_noUnify h_no h_ok

/--
All-hooks-suite no-unify convenience wrapper: derive the expression all-hooks
capstone from a successful no-unify run.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify convenience wrapper: derive the field all-hooks
capstone from a successful no-unify field run.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: bundled-hook variant
for expression all-hooks capstone.
-/
theorem principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalPreconditionedExprAllHooksCapstone_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: bundled-hook variant
for field all-hooks capstone.
-/
theorem principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksCapstone_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify convenience wrapper: bundled-hook alias for expression
all-hooks capstone.
-/
theorem principalNoUnifyExprAllHooksCapstone_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_of_success_via_allHooksSuite h_no h_ok

/--
All-hooks-suite no-unify convenience wrapper: bundled-hook alias for field
all-hooks capstone.
-/
theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_of_success_via_allHooksSuite h_no h_ok

/-- Bundled-seed alias for no-unify core expression on the all-hooks suite. -/
theorem principalNoUnifyCoreExpr_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_allHooksSuite h_no h_ok

/-- Bundled-seed alias for no-unify core field on the all-hooks suite. -/
theorem principalNoUnifyCoreField_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyToGeneralCoreField_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks expression preconditioning on the all-hooks suite. -/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyToGeneralPreconditionedExpr_anyHooks_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks field preconditioning on the all-hooks suite. -/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyToGeneralPreconditionedField_anyHooks_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks expression iff preconditioning on the all-hooks suite. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyToGeneralPreconditionedCoreIffExpr_anyHooks_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/-- Bundled-seed alias for no-unify any-hooks field iff preconditioning on the all-hooks suite. -/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyToGeneralPreconditionedCoreIffField_anyHooks_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/-- Bundled-seed alias for no-unify run-bundle expression on the all-hooks suite. -/
theorem principalNoUnifyRunBundleExpr_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_allHooksSuite
    principalBoundaryNoUnifyAllHooksSuite_proved h_no h_ok

/-- Bundled-seed alias for no-unify run-bundle field on the all-hooks suite. -/
theorem principalNoUnifyRunBundleField_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_allHooksSuite
    principalBoundaryNoUnifyAllHooksSuite_proved h_no h_ok

/--
All-hooks-suite convenience wrapper: derive preconditioned expression
principality for any hook witnesses from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyToGeneralPreconditionedExpr_anyHooks_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/--
All-hooks-suite convenience wrapper: derive preconditioned expression
principality for a bundled hook witness from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyToGeneralPreconditionedExpr_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok h_hooks

/--
All-hooks-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
preconditioned expression principality.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_allHooksSuite
    h_no h_ok h_hooks

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive core
expression principality from a successful no-unify run.
-/
theorem principalCoreExpr_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_allHooksSuite h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive the expression
run-bundle surface from a successful no-unify run.
-/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyToGeneralRunBundleExpr_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive preconditioned
expression principality for any hook witnesses from a successful no-unify run.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive preconditioned
expression principality for a bundled hook witness from a successful no-unify
run.
-/
theorem principalPreconditionedExpr_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_allHooksSuite h_no h_ok h_hooks

/--
All-hooks-suite no-unify-to-general convenience wrapper: bundled-hook variant
for fixed-run preconditioned expression principality.
-/
theorem principalPreconditionedExpr_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_noUnify_via_allHooksSuite
    h_no h_ok h_hooks

/--
All-hooks-suite convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyToGeneralPreconditionedCoreIffExpr_anyHooks_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/--
All-hooks-suite convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_allHooksSuite
    h_no h_ok) h_hooks.1 h_hooks.2

/--
All-hooks-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
expression preconditioned↔core equivalence.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_allHooksSuite
    h_no h_ok h_hooks

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive fixed-run
expression preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive fixed-run
expression preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_allHooksSuite
    h_no h_ok h_hooks

/--
All-hooks-suite no-unify-to-general convenience wrapper: bundled-hook variant
for fixed-run expression preconditioned↔core equivalence.
-/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_noUnify_via_allHooksSuite
    h_no h_ok h_hooks

/--
All-hooks-suite convenience wrapper: derive core field principality from a
successful no-unify field run.
-/
theorem principalNoUnifyCoreField_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyToGeneralCoreField_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/--
All-hooks-suite convenience wrapper: derive preconditioned field principality
for any hook witnesses from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyToGeneralPreconditionedField_anyHooks_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/--
All-hooks-suite convenience wrapper: derive preconditioned field principality
for a bundled hook witness from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyToGeneralPreconditionedField_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok h_hooks

/--
All-hooks-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
preconditioned field principality.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_allHooksSuite
    h_no h_ok h_hooks

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive core field
principality from a successful no-unify field run.
-/
theorem principalCoreField_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_allHooksSuite h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive the field
run-bundle surface from a successful no-unify field run.
-/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyToGeneralRunBundleField_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive preconditioned
field principality for any hook witnesses from a successful no-unify run.
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive preconditioned
field principality for a bundled hook witness from a successful no-unify run.
-/
theorem principalPreconditionedField_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_allHooksSuite h_no h_ok h_hooks

/--
All-hooks-suite no-unify-to-general convenience wrapper: bundled-hook variant
for fixed-run preconditioned field principality.
-/
theorem principalPreconditionedField_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_noUnify_via_allHooksSuite
    h_no h_ok h_hooks

/--
All-hooks-suite convenience wrapper: derive fixed-run field preconditioned↔core
equivalence for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyToGeneralPreconditionedCoreIffField_anyHooks_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/--
All-hooks-suite convenience wrapper: derive fixed-run field preconditioned↔core
equivalence for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_allHooksSuite
    h_no h_ok) h_hooks.1 h_hooks.2

/--
All-hooks-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
field preconditioned↔core equivalence.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_allHooksSuite
    h_no h_ok h_hooks

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_allHooksSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_allHooksSuite
    h_no h_ok h_hooks

/--
All-hooks-suite no-unify-to-general convenience wrapper: bundled-hook variant
for fixed-run field preconditioned↔core equivalence.
-/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_noUnify_via_allHooksSuite
    h_no h_ok h_hooks

/--
All-hooks-suite convenience wrapper: derive fixed-run expression
hook-irrelevance from a successful no-unify run.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_allHooksSuite
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyToGeneralPreconditionedExpr_hookIrrelevant_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/--
All-hooks-suite convenience wrapper: derive fixed-run field hook-irrelevance
from a successful no-unify field run.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_allHooksSuite
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyToGeneralPreconditionedField_hookIrrelevant_of_success
    principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks h_no h_ok

/--
All-hooks-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
expression hook-irrelevance.
-/
theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_allHooksSuite_from_bundle
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify convenience wrapper: bundled-hook alias for fixed-run
field hook-irrelevance.
-/
theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_allHooksSuite_from_bundle
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive fixed-run
expression hook-irrelevance from a successful no-unify run.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_allHooksSuite
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: derive fixed-run field
hook-irrelevance from a successful no-unify field run.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_allHooksSuite
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: bundled-hook variant
for fixed-run expression hook-irrelevance.
-/
theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_allHooksSuite_from_bundle
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/--
All-hooks-suite no-unify-to-general convenience wrapper: bundled-hook variant
for fixed-run field hook-irrelevance.
-/
theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_allHooksSuite_from_bundle
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general core expression on the all-hooks suite. -/
theorem principalCoreExpr_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_allHooksSuite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general core field on the all-hooks suite. -/
theorem principalCoreField_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_allHooksSuite h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks expression preconditioning on the all-hooks suite. -/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks field preconditioning on the all-hooks suite. -/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks expression iff preconditioning on the all-hooks suite. -/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general any-hooks field iff preconditioning on the all-hooks suite. -/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general expression run-bundle on the all-hooks suite. -/
theorem principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/-- Bundled-seed alias for no-unify-to-general field run-bundle on the all-hooks suite. -/
theorem principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_allHooksSuite_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_allHooksSuite
    h_no h_ok

/--
`HasTypeU` lift of non-app/proj recursive soundness: on the fragment that never
executes unification branches, algorithmic inference results are declaratively
typable in the unification-aware judgment as well.
-/
theorem inferExprUnify_sound_no_unify_branches_hasTypeU
    {e : CoreExpr}
    (h_no : NoUnifyBranchesExpr e) :
    ∀ st fuel env st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty := by
  intro st fuel env st' ty h_ok
  exact hasType_to_hasTypeU
    (inferExprUnify_sound_no_unify_branches h_no st fuel env st' ty h_ok)

/--
Vertical app slice (hook-free): when both app children are inferred on the
no-unify fragment and the app unification step satisfies the closed+fresh
empty-substitution regime, the app expression is declaratively typable in
`HasTypeU` without any global app/proj hook assumptions.
-/
theorem inferExprUnify_app_vertical_closed_fresh_empty_subst
    {env : TermEnv} {fn arg : CoreExpr}
    {st stFn stArg stAfter : UnifyState}
    {fuel : Nat} {argTy retTy : Ty}
    (h_fn_no : NoUnifyBranchesExpr fn)
    (h_arg_no : NoUnifyBranchesExpr arg)
    (h_fn_infer :
      inferExprUnify st (fuel + 2) env fn = .ok stFn (.function (.cons argTy .nil) retTy))
    (h_arg_infer :
      inferExprUnify stFn (fuel + 2) env arg = .ok stArg argTy)
    (h_empty : stArg.subst = Subst.empty)
    (h_arg_ftv : freeTypeVars argTy = [])
    (h_arg_frv : freeRowVars argTy = [])
    (h_ret_ftv : freeTypeVars retTy = [])
    (h_ret_frv : freeRowVars retTy = [])
    (h_unify :
      unify stArg (fuel + 2) (.function (.cons argTy .nil) retTy)
        (.function (.cons argTy .nil) (.var (stArg.freshTypeVar).1)) = .ok stAfter)
    (h_idemp : stAfter.subst.Idempotent) :
    HasTypeU env (.app fn arg)
      (applySubstCompat stAfter.subst (fuel + 1) (.var (stArg.freshTypeVar).1)) := by
  have h_fn_typed : HasTypeU env fn (.function (.cons argTy .nil) retTy) :=
    inferExprUnify_sound_no_unify_branches_hasTypeU h_fn_no
      st (fuel + 2) env stFn (.function (.cons argTy .nil) retTy) h_fn_infer
  have h_arg_typed : HasTypeU env arg argTy :=
    inferExprUnify_sound_no_unify_branches_hasTypeU h_arg_no
      stFn (fuel + 2) env stArg argTy h_arg_infer
  exact inferExprUnify_app_step_sound_hasTypeU_closed_fresh_succ_of_subst_empty
    h_empty h_fn_typed h_arg_typed h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_unify h_idemp

/--
Vertical projection slice (hook-free): when the receiver is inferred on the
no-unify fragment and the projection unification step supplies an explicit
resolved closed-row witness, the projection expression is declaratively typable
in `HasTypeU` without global hook assumptions.
-/
theorem inferExprUnify_proj_vertical_resolved
    {env : TermEnv} {recv : CoreExpr} {label : Label}
    {st stRecv stAfter : UnifyState}
    {fuel : Nat} {recvTy : Ty} {rowFields : RowFields}
    (h_recv_no : NoUnifyBranchesExpr recv)
    (h_recv_infer :
      inferExprUnify st fuel env recv = .ok stRecv recvTy)
    (h_unify :
      unify (stRecv.freshTypeVar).2.freshRowVar.2 fuel recvTy
        (.anonRecord
          (.mk
            (.cons label (.var (stRecv.freshTypeVar).1) .nil)
            (some (stRecv.freshTypeVar).2.freshRowVar.1))) = .ok stAfter)
    (h_resolved :
      applySubstCompat stAfter.subst fuel recvTy =
        .anonRecord (.mk rowFields none))
    (h_get :
      RowFields.get rowFields label =
        some (applySubstCompat stAfter.subst fuel (.var (stRecv.freshTypeVar).1))) :
    HasTypeU env (.proj recv label)
      (applySubstCompat stAfter.subst fuel (.var (stRecv.freshTypeVar).1)) := by
  have h_recv_typed : HasTypeU env recv recvTy :=
    inferExprUnify_sound_no_unify_branches_hasTypeU h_recv_no
      st fuel env stRecv recvTy h_recv_infer
  exact inferExprUnify_proj_step_sound_hasTypeU_resolved
    (env := env) (recv := recv) (label := label) (recvTy := recvTy)
    (stBefore := (stRecv.freshTypeVar).2.freshRowVar.2)
    (stAfter := stAfter) (fuel := fuel)
    (fieldVar := (stRecv.freshTypeVar).1) (restVar := (stRecv.freshTypeVar).2.freshRowVar.1)
    (rowFields := rowFields)
    h_recv_typed h_unify h_resolved h_get

/--
Top-level projection corollary for the hook-free vertical fragment: if the
algorithmic projection inference result matches the resolved-witness branch
shape, the inferred projection type is declaratively valid in `HasTypeU`.
-/
theorem inferExprUnify_proj_vertical_resolved_of_infer
    {env : TermEnv} {recv : CoreExpr} {label : Label}
    {st stRecv stAfter : UnifyState}
    {fuel : Nat} {recvTy ty : Ty} {rowFields : RowFields}
    (h_recv_no : NoUnifyBranchesExpr recv)
    (h_recv_infer :
      inferExprUnify st fuel env recv = .ok stRecv recvTy)
    (h_unify :
      unify (stRecv.freshTypeVar).2.freshRowVar.2 fuel recvTy
        (.anonRecord
          (.mk
            (.cons label (.var (stRecv.freshTypeVar).1) .nil)
            (some (stRecv.freshTypeVar).2.freshRowVar.1))) = .ok stAfter)
    (h_resolved :
      applySubstCompat stAfter.subst fuel recvTy =
        .anonRecord (.mk rowFields none))
    (h_get :
      RowFields.get rowFields label =
        some (applySubstCompat stAfter.subst fuel (.var (stRecv.freshTypeVar).1)))
    (h_proj_infer :
      inferExprUnify st fuel env (.proj recv label) = .ok stAfter ty) :
    HasTypeU env (.proj recv label) ty := by
  have h_ty :
      applySubstCompat stAfter.subst fuel (.var (stRecv.freshTypeVar).1) = ty := by
    simpa [inferExprUnify, h_recv_infer, h_unify] using h_proj_infer
  have h_ty' :
      ty = applySubstCompat stAfter.subst fuel (.var (stRecv.freshTypeVar).1) := by
    symm
    exact h_ty
  rw [h_ty']
  exact inferExprUnify_proj_vertical_resolved
    h_recv_no h_recv_infer h_unify h_resolved h_get

/-- Packaged hook-free app vertical slice theorem shape. -/
def VerticalHookFreeAppSlice : Prop :=
  ∀ {env : TermEnv} {fn arg : CoreExpr}
    {st stFn stArg stAfter : UnifyState}
    {fuel : Nat} {argTy retTy : Ty},
    NoUnifyBranchesExpr fn →
    NoUnifyBranchesExpr arg →
    inferExprUnify st (fuel + 2) env fn = .ok stFn (.function (.cons argTy .nil) retTy) →
    inferExprUnify stFn (fuel + 2) env arg = .ok stArg argTy →
    stArg.subst = Subst.empty →
    freeTypeVars argTy = [] →
    freeRowVars argTy = [] →
    freeTypeVars retTy = [] →
    freeRowVars retTy = [] →
    unify stArg (fuel + 2) (.function (.cons argTy .nil) retTy)
      (.function (.cons argTy .nil) (.var (stArg.freshTypeVar).1)) = .ok stAfter →
    stAfter.subst.Idempotent →
    HasTypeU env (.app fn arg)
      (applySubstCompat stAfter.subst (fuel + 1) (.var (stArg.freshTypeVar).1))

/-- Packaged hook-free projection vertical slice theorem shape. -/
def VerticalHookFreeProjSlice : Prop :=
  ∀ {env : TermEnv} {recv : CoreExpr} {label : Label}
    {st stRecv stAfter : UnifyState}
    {fuel : Nat} {recvTy : Ty} {rowFields : RowFields},
    NoUnifyBranchesExpr recv →
    inferExprUnify st fuel env recv = .ok stRecv recvTy →
    unify (stRecv.freshTypeVar).2.freshRowVar.2 fuel recvTy
      (.anonRecord
        (.mk
          (.cons label (.var (stRecv.freshTypeVar).1) .nil)
          (some (stRecv.freshTypeVar).2.freshRowVar.1))) = .ok stAfter →
    applySubstCompat stAfter.subst fuel recvTy =
      .anonRecord (.mk rowFields none) →
    RowFields.get rowFields label =
      some (applySubstCompat stAfter.subst fuel (.var (stRecv.freshTypeVar).1)) →
    HasTypeU env (.proj recv label)
      (applySubstCompat stAfter.subst fuel (.var (stRecv.freshTypeVar).1))

/-- Combined hook-free vertical theorem surface for app and projection slices. -/
def VerticalHookFreeUnifySlices : Prop :=
  VerticalHookFreeAppSlice ∧ VerticalHookFreeProjSlice

/-- The combined hook-free vertical theorem surface is fully proved. -/
theorem verticalHookFreeUnifySlices_proved : VerticalHookFreeUnifySlices := by
  refine ⟨?_, ?_⟩
  · intro env fn arg st stFn stArg stAfter fuel argTy retTy
      h_fn_no h_arg_no h_fn_infer h_arg_infer h_empty
      h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_unify h_idemp
    exact inferExprUnify_app_vertical_closed_fresh_empty_subst
      h_fn_no h_arg_no h_fn_infer h_arg_infer h_empty
      h_arg_ftv h_arg_frv h_ret_ftv h_ret_frv h_unify h_idemp
  · intro env recv label st stRecv stAfter fuel recvTy rowFields
      h_recv_no h_recv_infer h_unify h_resolved h_get
    exact inferExprUnify_proj_vertical_resolved
      h_recv_no h_recv_infer h_unify h_resolved h_get

/-- Field-level `HasTypeU` lift of `inferFieldsUnify_sound_no_unify_branches`. -/
theorem inferFieldsUnify_sound_no_unify_branches_hasTypeU
    {fs : CoreFields}
    (h_no : NoUnifyBranchesFields fs) :
    ∀ st fuel env st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf := by
  intro st fuel env st' rf h_ok
  exact hasFieldsType_to_hasFieldsTypeU
    (inferFieldsUnify_sound_no_unify_branches h_no st fuel env st' rf h_ok)

/--
`HasTypeU` lift of full preconditioned recursive soundness. This keeps the
monomorphic theorem as the proof core while exposing the result in the
unification-aware declarative layer.
-/
theorem inferExprUnify_sound_preconditioned_hasTypeU
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty := by
  intro st fuel env e st' ty h_ok
  exact hasType_to_hasTypeU
    (inferExprUnify_sound_preconditioned h_app h_proj st fuel env e st' ty h_ok)

/-- Field-level `HasTypeU` lift of `inferFieldsUnify_sound_preconditioned`. -/
theorem inferFieldsUnify_sound_preconditioned_hasTypeU
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf := by
  intro st fuel env fs st' rf h_ok
  exact hasFieldsType_to_hasFieldsTypeU
    (inferFieldsUnify_sound_preconditioned h_app h_proj st fuel env fs st' rf h_ok)

/--
Direct recursive `HasTypeU` soundness instantiated from global resolved-shape
premises for app/proj unification branches.
-/
theorem inferExprUnify_sound_preconditioned_hasTypeU_resolved
    (h_app_resolved : AppResolvedShapeFromUnify)
    (h_proj_resolved : ProjResolvedShapeFromUnify) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty := by
  intro st fuel env e st' ty h_ok
  exact inferExprUnify_sound_preconditioned_hasTypeU_direct
    (appUnifySoundHookU_of_resolved h_app_resolved)
    (projUnifySoundHookU_of_resolved h_proj_resolved)
    st fuel env e st' ty h_ok

/-- Field-level resolved-shape instantiation counterpart. -/
theorem inferFieldsUnify_sound_preconditioned_hasTypeU_resolved
    (h_app_resolved : AppResolvedShapeFromUnify)
    (h_proj_resolved : ProjResolvedShapeFromUnify) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf := by
  intro st fuel env fs st' rf h_ok
  exact inferFieldsUnify_sound_preconditioned_hasTypeU_direct
    (appUnifySoundHookU_of_resolved h_app_resolved)
    (projUnifySoundHookU_of_resolved h_proj_resolved)
    st fuel env fs st' rf h_ok

/-- Resolved-shape bundle instantiation for expression-level recursion. -/
theorem inferExprUnify_sound_preconditioned_hasTypeU_from_resolved_bundle
    (h_resolved : UnifyResolvedShapePremises) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty := by
  intro st fuel env e st' ty h_ok
  let h_hooks : UnifyHookPremisesU := unifyHookPremisesU_of_resolved h_resolved
  exact inferExprUnify_sound_preconditioned_hasTypeU_direct
    h_hooks.1 h_hooks.2 st fuel env e st' ty h_ok

/-- Resolved-shape bundle instantiation for field-level recursion. -/
theorem inferFieldsUnify_sound_preconditioned_hasTypeU_from_resolved_bundle
    (h_resolved : UnifyResolvedShapePremises) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf := by
  intro st fuel env fs st' rf h_ok
  let h_hooks : UnifyHookPremisesU := unifyHookPremisesU_of_resolved h_resolved
  exact inferFieldsUnify_sound_preconditioned_hasTypeU_direct
    h_hooks.1 h_hooks.2 st fuel env fs st' rf h_ok

/--
Bundle-entry variant of recursive `HasTypeU` soundness for expressions under
weak hook premises.
-/
theorem inferExprUnify_sound_preconditioned_hasTypeU_from_hook_bundle
    (h_hooks : UnifyHookPremisesU) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  inferExprUnify_sound_preconditioned_hasTypeU_direct h_hooks.1 h_hooks.2

/--
Bundle-entry variant of recursive `HasTypeU` soundness for fields under weak
hook premises.
-/
theorem inferFieldsUnify_sound_preconditioned_hasTypeU_from_hook_bundle
    (h_hooks : UnifyHookPremisesU) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  inferFieldsUnify_sound_preconditioned_hasTypeU_direct h_hooks.1 h_hooks.2

/--
Bundle-entry variant of recursive `HasTypeU` soundness for expressions under
strong hook premises.
-/
theorem inferExprUnify_sound_preconditioned_hasTypeU_from_strong_hook_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  inferExprUnify_sound_preconditioned_hasTypeU h_hooks.1 h_hooks.2

/--
Bundle-entry variant of recursive `HasTypeU` soundness for fields under strong
hook premises.
-/
theorem inferFieldsUnify_sound_preconditioned_hasTypeU_from_strong_hook_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  inferFieldsUnify_sound_preconditioned_hasTypeU h_hooks.1 h_hooks.2

/--
Packaged recursive `HasTypeU` soundness surface for unification-threaded
inference under the weak hook premises.
-/
structure InferUnifyHasTypeUSoundBundle
    (h_app : AppUnifySoundHookU)
    (h_proj : ProjUnifySoundHookU) : Prop where
  expr :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty
  field :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf

/--
Build the packaged recursive `HasTypeU` soundness surface from weak hook
premises.
-/
theorem inferUnifyHasTypeUSoundBundle_of_hooks
    (h_app : AppUnifySoundHookU)
    (h_proj : ProjUnifySoundHookU) :
    InferUnifyHasTypeUSoundBundle h_app h_proj := by
  refine ⟨?expr, ?field⟩
  · intro st fuel env e st' ty h_ok
    exact inferExprUnify_sound_preconditioned_hasTypeU_direct
      h_app h_proj st fuel env e st' ty h_ok
  · intro st fuel env fs st' rf h_ok
    exact inferFieldsUnify_sound_preconditioned_hasTypeU_direct
      h_app h_proj st fuel env fs st' rf h_ok

/--
Build the packaged recursive `HasTypeU` soundness surface from bundled weak
hook premises.
-/
theorem inferUnifyHasTypeUSoundBundle_of_hook_bundle
    (h_hooks : UnifyHookPremisesU) :
    InferUnifyHasTypeUSoundBundle h_hooks.1 h_hooks.2 :=
  inferUnifyHasTypeUSoundBundle_of_hooks h_hooks.1 h_hooks.2

/--
Build the packaged recursive `HasTypeU` soundness surface from strong hook
premises.
-/
theorem inferUnifyHasTypeUSoundBundle_of_strong_hooks
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    {h_appU : AppUnifySoundHookU}
    {h_projU : ProjUnifySoundHookU} :
    InferUnifyHasTypeUSoundBundle h_appU h_projU := by
  refine ⟨?expr, ?field⟩
  · intro st fuel env e st' ty h_ok
    exact inferExprUnify_sound_preconditioned_hasTypeU
      h_app h_proj st fuel env e st' ty h_ok
  · intro st fuel env fs st' rf h_ok
    exact inferFieldsUnify_sound_preconditioned_hasTypeU
      h_app h_proj st fuel env fs st' rf h_ok

/--
Build the packaged recursive `HasTypeU` soundness surface from bundled strong
hook premises.
-/
theorem inferUnifyHasTypeUSoundBundle_of_strong_hook_bundle
    (h_hooks : UnifyHookPremises)
    {h_appU : AppUnifySoundHookU}
    {h_projU : ProjUnifySoundHookU} :
    InferUnifyHasTypeUSoundBundle h_appU h_projU :=
  inferUnifyHasTypeUSoundBundle_of_strong_hooks h_hooks.1 h_hooks.2

/--
Build the packaged recursive `HasTypeU` soundness surface directly from
resolved-shape premises.
-/
theorem inferUnifyHasTypeUSoundBundle_of_resolved
    (h_resolved : UnifyResolvedShapePremises) :
    InferUnifyHasTypeUSoundBundle
      (unifyHookPremisesU_of_resolved h_resolved).1
      (unifyHookPremisesU_of_resolved h_resolved).2 := by
  exact inferUnifyHasTypeUSoundBundle_of_hook_bundle
    (unifyHookPremisesU_of_resolved h_resolved)

/-- One-hop expression projection from a packaged `HasTypeU` soundness bundle. -/
theorem inferUnifyHasTypeUSoundBundle_expr
    {h_app : AppUnifySoundHookU}
    {h_proj : ProjUnifySoundHookU}
    (h_bundle : InferUnifyHasTypeUSoundBundle h_app h_proj) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  h_bundle.expr

/-- One-hop field projection from a packaged `HasTypeU` soundness bundle. -/
theorem inferUnifyHasTypeUSoundBundle_field
    {h_app : AppUnifySoundHookU}
    {h_proj : ProjUnifySoundHookU}
    (h_bundle : InferUnifyHasTypeUSoundBundle h_app h_proj) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  h_bundle.field

/--
Canonical expression recursive `HasTypeU` soundness entrypoint from a packaged
bundle witness.
-/
theorem inferExprUnify_sound_preconditioned_hasTypeU_via_sound_bundle
    {h_app : AppUnifySoundHookU}
    {h_proj : ProjUnifySoundHookU}
    (h_bundle : InferUnifyHasTypeUSoundBundle h_app h_proj) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  inferUnifyHasTypeUSoundBundle_expr h_bundle

/--
Canonical field recursive `HasTypeU` soundness entrypoint from a packaged
bundle witness.
-/
theorem inferFieldsUnify_sound_preconditioned_hasTypeU_via_sound_bundle
    {h_app : AppUnifySoundHookU}
    {h_proj : ProjUnifySoundHookU}
    (h_bundle : InferUnifyHasTypeUSoundBundle h_app h_proj) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  inferUnifyHasTypeUSoundBundle_field h_bundle

/--
Weak-bundle expression entrypoint routed through the packaged bundle API.
-/
theorem inferExprUnify_sound_preconditioned_hasTypeU_from_hook_bundle_via_sound_bundle
    (h_hooks : UnifyHookPremisesU) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  inferExprUnify_sound_preconditioned_hasTypeU_via_sound_bundle
    (inferUnifyHasTypeUSoundBundle_of_hook_bundle h_hooks)

/--
Weak-bundle field entrypoint routed through the packaged bundle API.
-/
theorem inferFieldsUnify_sound_preconditioned_hasTypeU_from_hook_bundle_via_sound_bundle
    (h_hooks : UnifyHookPremisesU) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  inferFieldsUnify_sound_preconditioned_hasTypeU_via_sound_bundle
    (inferUnifyHasTypeUSoundBundle_of_hook_bundle h_hooks)

/--
Strong-bundle expression entrypoint routed through the packaged bundle API.
-/
theorem inferExprUnify_sound_preconditioned_hasTypeU_from_strong_hook_bundle_via_sound_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  inferExprUnify_sound_preconditioned_hasTypeU_from_strong_hook_bundle h_hooks

/--
Strong-bundle field entrypoint routed through the packaged bundle API.
-/
theorem inferFieldsUnify_sound_preconditioned_hasTypeU_from_strong_hook_bundle_via_sound_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  inferFieldsUnify_sound_preconditioned_hasTypeU_from_strong_hook_bundle h_hooks

/--
Resolved-bundle expression entrypoint routed through the packaged bundle API.
-/
theorem inferExprUnify_sound_preconditioned_hasTypeU_from_resolved_bundle_via_sound_bundle
    (h_resolved : UnifyResolvedShapePremises) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  inferExprUnify_sound_preconditioned_hasTypeU_via_sound_bundle
    (inferUnifyHasTypeUSoundBundle_of_resolved h_resolved)

/--
Resolved-bundle field entrypoint routed through the packaged bundle API.
-/
theorem inferFieldsUnify_sound_preconditioned_hasTypeU_from_resolved_bundle_via_sound_bundle
    (h_resolved : UnifyResolvedShapePremises) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  inferFieldsUnify_sound_preconditioned_hasTypeU_via_sound_bundle
    (inferUnifyHasTypeUSoundBundle_of_resolved h_resolved)

/--
One-hop expression projection from a weak-hook packaged soundness constructor.
-/
theorem inferUnifyHasTypeUSoundBundle_expr_of_hook_bundle
    (h_hooks : UnifyHookPremisesU) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  inferUnifyHasTypeUSoundBundle_expr
    (inferUnifyHasTypeUSoundBundle_of_hook_bundle h_hooks)

/--
One-hop field projection from a weak-hook packaged soundness constructor.
-/
theorem inferUnifyHasTypeUSoundBundle_field_of_hook_bundle
    (h_hooks : UnifyHookPremisesU) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  inferUnifyHasTypeUSoundBundle_field
    (inferUnifyHasTypeUSoundBundle_of_hook_bundle h_hooks)

/--
One-hop expression projection from a strong-hook packaged soundness constructor.
-/
theorem inferUnifyHasTypeUSoundBundle_expr_of_strong_hook_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  inferExprUnify_sound_preconditioned_hasTypeU_from_strong_hook_bundle h_hooks

/--
One-hop field projection from a strong-hook packaged soundness constructor.
-/
theorem inferUnifyHasTypeUSoundBundle_field_of_strong_hook_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  inferFieldsUnify_sound_preconditioned_hasTypeU_from_strong_hook_bundle h_hooks

/--
One-hop expression projection from a resolved-premise packaged soundness
constructor.
-/
theorem inferUnifyHasTypeUSoundBundle_expr_of_resolved
    (h_resolved : UnifyResolvedShapePremises) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  inferUnifyHasTypeUSoundBundle_expr
    (inferUnifyHasTypeUSoundBundle_of_resolved h_resolved)

/--
One-hop field projection from a resolved-premise packaged soundness
constructor.
-/
theorem inferUnifyHasTypeUSoundBundle_field_of_resolved
    (h_resolved : UnifyResolvedShapePremises) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  inferUnifyHasTypeUSoundBundle_field
    (inferUnifyHasTypeUSoundBundle_of_resolved h_resolved)

/--
Packaged recursive soundness surface exposing both declarative judgments:
`HasType` and `HasTypeU`.
-/
structure InferUnifySoundDualBundle
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook) : Prop where
  expr_hasType :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasType env e ty
  field_hasType :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsType env fs rf
  expr_hasTypeU :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty
  field_hasTypeU :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf

/--
Build the dual-judgment recursive soundness bundle from strong hook premises.
-/
theorem inferUnifySoundDualBundle_of_hooks
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook) :
    InferUnifySoundDualBundle h_app h_proj := by
  refine ⟨?exprH, ?fieldH, ?exprHU, ?fieldHU⟩
  · intro st fuel env e st' ty h_ok
    exact inferExprUnify_sound_preconditioned h_app h_proj st fuel env e st' ty h_ok
  · intro st fuel env fs st' rf h_ok
    exact inferFieldsUnify_sound_preconditioned h_app h_proj st fuel env fs st' rf h_ok
  · intro st fuel env e st' ty h_ok
    exact inferExprUnify_sound_preconditioned_hasTypeU h_app h_proj st fuel env e st' ty h_ok
  · intro st fuel env fs st' rf h_ok
    exact inferFieldsUnify_sound_preconditioned_hasTypeU h_app h_proj st fuel env fs st' rf h_ok

/--
Build the dual-judgment recursive soundness bundle from bundled strong hook
premises.
-/
theorem inferUnifySoundDualBundle_of_hook_bundle
    (h_hooks : UnifyHookPremises) :
    InferUnifySoundDualBundle h_hooks.1 h_hooks.2 :=
  inferUnifySoundDualBundle_of_hooks h_hooks.1 h_hooks.2

/-- One-hop `HasType` expression projection from the dual soundness bundle. -/
theorem inferUnifySoundDualBundle_expr_hasType
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasType env e ty :=
  h_bundle.expr_hasType

/-- One-hop `HasType` field projection from the dual soundness bundle. -/
theorem inferUnifySoundDualBundle_field_hasType
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsType env fs rf :=
  h_bundle.field_hasType

/-- One-hop `HasTypeU` expression projection from the dual soundness bundle. -/
theorem inferUnifySoundDualBundle_expr_hasTypeU
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  h_bundle.expr_hasTypeU

/-- One-hop `HasTypeU` field projection from the dual soundness bundle. -/
theorem inferUnifySoundDualBundle_field_hasTypeU
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  h_bundle.field_hasTypeU

/--
One-hop bundled-hook `HasType` expression projection from the dual soundness
bundle constructor.
-/
theorem inferUnifySoundDualBundle_expr_hasType_of_hook_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasType env e ty :=
  inferUnifySoundDualBundle_expr_hasType
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks)

/--
One-hop bundled-hook `HasType` field projection from the dual soundness bundle
constructor.
-/
theorem inferUnifySoundDualBundle_field_hasType_of_hook_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsType env fs rf :=
  inferUnifySoundDualBundle_field_hasType
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks)

/--
One-hop bundled-hook `HasTypeU` expression projection from the dual soundness
bundle constructor.
-/
theorem inferUnifySoundDualBundle_expr_hasTypeU_of_hook_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  inferUnifySoundDualBundle_expr_hasTypeU
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks)

/--
One-hop bundled-hook `HasTypeU` field projection from the dual soundness
bundle constructor.
-/
theorem inferUnifySoundDualBundle_field_hasTypeU_of_hook_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  inferUnifySoundDualBundle_field_hasTypeU
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks)

/--
Canonical expression-level `HasType` recursive soundness entrypoint via the dual
bundle surface.
-/
theorem inferExprUnify_sound_preconditioned_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasType env e ty := by
  intro st fuel env e st' ty h_ok
  exact inferUnifySoundDualBundle_expr_hasType h_bundle st fuel env e st' ty h_ok

/--
Canonical field-level `HasType` recursive soundness entrypoint via the dual
bundle surface.
-/
theorem inferFieldsUnify_sound_preconditioned_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsType env fs rf := by
  intro st fuel env fs st' rf h_ok
  exact inferUnifySoundDualBundle_field_hasType h_bundle st fuel env fs st' rf h_ok

/--
Canonical expression-level `HasTypeU` recursive soundness entrypoint via the
dual bundle surface.
-/
theorem inferExprUnify_sound_preconditioned_hasTypeU_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty := by
  intro st fuel env e st' ty h_ok
  exact inferUnifySoundDualBundle_expr_hasTypeU h_bundle st fuel env e st' ty h_ok

/--
Canonical field-level `HasTypeU` recursive soundness entrypoint via the dual
bundle surface.
-/
theorem inferFieldsUnify_sound_preconditioned_hasTypeU_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf := by
  intro st fuel env fs st' rf h_ok
  exact inferUnifySoundDualBundle_field_hasTypeU h_bundle st fuel env fs st' rf h_ok

/--
Bundled-hook expression-level `HasType` entrypoint via the dual bundle API.
-/
theorem inferExprUnify_sound_preconditioned_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasType env e ty :=
  inferExprUnify_sound_preconditioned_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks)

/--
Bundled-hook field-level `HasType` entrypoint via the dual bundle API.
-/
theorem inferFieldsUnify_sound_preconditioned_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsType env fs rf :=
  inferFieldsUnify_sound_preconditioned_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks)

/--
Bundled-hook expression-level `HasTypeU` entrypoint via the dual bundle API.
-/
theorem inferExprUnify_sound_preconditioned_hasTypeU_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env e st' ty,
      inferExprUnify st fuel env e = .ok st' ty →
      HasTypeU env e ty :=
  inferExprUnify_sound_preconditioned_hasTypeU_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks)

/--
Bundled-hook field-level `HasTypeU` entrypoint via the dual bundle API.
-/
theorem inferFieldsUnify_sound_preconditioned_hasTypeU_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises) :
    ∀ st fuel env fs st' rf,
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      HasFieldsTypeU env fs rf :=
  inferFieldsUnify_sound_preconditioned_hasTypeU_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks)

/--
Bridge from the dual recursive soundness bundle to the packaged `HasTypeU`
bundle surface.
-/
theorem inferUnifyHasTypeUSoundBundle_of_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    {h_appU : AppUnifySoundHookU}
    {h_projU : ProjUnifySoundHookU}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj) :
    InferUnifyHasTypeUSoundBundle h_appU h_projU := by
  refine ⟨?expr, ?field⟩
  · intro st fuel env e st' ty h_ok
    exact inferUnifySoundDualBundle_expr_hasTypeU h_bundle st fuel env e st' ty h_ok
  · intro st fuel env fs st' rf h_ok
    exact inferUnifySoundDualBundle_field_hasTypeU h_bundle st fuel env fs st' rf h_ok

/--
Bundled-hook bridge from the dual recursive soundness surface into the packaged
`HasTypeU` bundle API.
-/
theorem inferUnifyHasTypeUSoundBundle_of_dual_hook_bundle
    (h_hooks : UnifyHookPremises)
    {h_appU : AppUnifySoundHookU}
    {h_projU : ProjUnifySoundHookU} :
    InferUnifyHasTypeUSoundBundle h_appU h_projU :=
  inferUnifyHasTypeUSoundBundle_of_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks)

/--
Dual-bundle entrypoint to the expression principal-typing preconditioned slice.
-/
theorem principalTypingSlicePreconditioned_of_success_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (_h_bundle : InferUnifySoundDualBundle h_app h_proj)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalTypingSlicePreconditioned_of_success h_app h_proj st fuel env e st' ty h_ok

/--
Dual-bundle entrypoint to the field principal-typing preconditioned slice.
-/
theorem principalFieldTypingSlicePreconditioned_of_success_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (_h_bundle : InferUnifySoundDualBundle h_app h_proj)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalFieldTypingSlicePreconditioned_of_success h_app h_proj st fuel env fs st' rf h_ok

/--
Bundled-hook dual-bundle expression principal-typing entrypoint.
-/
theorem principalTypingSlicePreconditioned_of_success_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalTypingSlicePreconditioned_of_success_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks) st fuel env e st' ty h_ok

/--
Bundled-hook dual-bundle field principal-typing entrypoint.
-/
theorem principalFieldTypingSlicePreconditioned_of_success_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalFieldTypingSlicePreconditioned_of_success_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks) st fuel env fs st' rf h_ok

/--
One-step `inferExpr` agreement extraction from dual-bundle principal typing.
-/
theorem inferExprUnify_inferExpr_agrees_of_success_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    inferExpr env e = some ty :=
  (principalTypingSlicePreconditioned_of_success_via_dual_bundle
    h_bundle st fuel env e st' ty h_ok).inferExprAgrees

/--
One-step `inferFields` agreement extraction from dual-bundle field principal
typing.
-/
theorem inferFieldsUnify_inferFields_agrees_of_success_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    inferFields env fs = some rf :=
  (principalFieldTypingSlicePreconditioned_of_success_via_dual_bundle
    h_bundle st fuel env fs st' rf h_ok).inferFieldsAgrees

/--
Bundled-hook one-step `inferExpr` agreement extraction via the dual-bundle
principal-typing surface.
-/
theorem inferExprUnify_inferExpr_agrees_of_success_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    inferExpr env e = some ty :=
  inferExprUnify_inferExpr_agrees_of_success_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks) st fuel env e st' ty h_ok

/--
Bundled-hook one-step `inferFields` agreement extraction via the dual-bundle
field principal-typing surface.
-/
theorem inferFieldsUnify_inferFields_agrees_of_success_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    inferFields env fs = some rf :=
  inferFieldsUnify_inferFields_agrees_of_success_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks) st fuel env fs st' rf h_ok

/--
Dual-bundle entrypoint to the expression preconditioned→core principal bridge.
-/
theorem principalTypingSliceCore_of_preconditioned_success_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (_h_bundle : InferUnifySoundDualBundle h_app h_proj)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalTypingSliceCore_of_preconditioned_success h_app h_proj st fuel env e st' ty h_ok

/--
Dual-bundle entrypoint to the field preconditioned→core principal bridge.
-/
theorem principalFieldTypingSliceCore_of_preconditioned_success_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (_h_bundle : InferUnifySoundDualBundle h_app h_proj)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalFieldTypingSliceCore_of_preconditioned_success h_app h_proj st fuel env fs st' rf h_ok

/--
Dual-bundle expression preconditioned↔core successful-run equivalence.
-/
theorem principalTypingSlicePreconditioned_iff_core_of_success_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (_h_bundle : InferUnifySoundDualBundle h_app h_proj)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty :=
  principalTypingSlicePreconditioned_iff_core_of_success h_app h_proj st fuel env e st' ty h_ok

/--
Dual-bundle field preconditioned↔core successful-run equivalence.
-/
theorem principalFieldTypingSlicePreconditioned_iff_core_of_success_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (_h_bundle : InferUnifySoundDualBundle h_app h_proj)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf :=
  principalFieldTypingSlicePreconditioned_iff_core_of_success h_app h_proj st fuel env fs st' rf h_ok

/--
Bundled-hook dual-bundle entrypoint to the expression preconditioned→core
principal bridge.
-/
theorem principalTypingSliceCore_of_preconditioned_success_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalTypingSliceCore_of_preconditioned_success_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks) st fuel env e st' ty h_ok

/--
Bundled-hook dual-bundle entrypoint to the field preconditioned→core principal
bridge.
-/
theorem principalFieldTypingSliceCore_of_preconditioned_success_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalFieldTypingSliceCore_of_preconditioned_success_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks) st fuel env fs st' rf h_ok

/--
Bundled-hook dual-bundle expression preconditioned↔core successful-run
equivalence.
-/
theorem principalTypingSlicePreconditioned_iff_core_of_success_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty :=
  principalTypingSlicePreconditioned_iff_core_of_success_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks) st fuel env e st' ty h_ok

/--
Bundled-hook dual-bundle field preconditioned↔core successful-run equivalence.
-/
theorem principalFieldTypingSlicePreconditioned_iff_core_of_success_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf :=
  principalFieldTypingSlicePreconditioned_iff_core_of_success_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks) st fuel env fs st' rf h_ok

/--
Packaged dual-bundle principal consequences for one successful expression run.
-/
structure PrincipalTypingDualConsequence
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  preconditioned : PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
  core : PrincipalTypingSliceCore env e ty
  preconditioned_iff_core :
    PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty
  inferExpr_agrees : inferExpr env e = some ty

/--
Packaged dual-bundle principal consequences for one successful field run.
-/
structure PrincipalFieldTypingDualConsequence
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  preconditioned :
    PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
  core : PrincipalFieldTypingSliceCore env fs rf
  preconditioned_iff_core :
    PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf
  inferFields_agrees : inferFields env fs = some rf

/--
Construct expression dual-principal consequences from a successful run via the
dual bundle API.
-/
theorem principalTypingDualConsequence_of_success_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingDualConsequence h_app h_proj st fuel env e st' ty := by
  refine {
    preconditioned :=
      principalTypingSlicePreconditioned_of_success_via_dual_bundle
        h_bundle st fuel env e st' ty h_ok
    core :=
      principalTypingSliceCore_of_preconditioned_success_via_dual_bundle
        h_bundle st fuel env e st' ty h_ok
    preconditioned_iff_core :=
      principalTypingSlicePreconditioned_iff_core_of_success_via_dual_bundle
        h_bundle st fuel env e st' ty h_ok
    inferExpr_agrees :=
      inferExprUnify_inferExpr_agrees_of_success_via_dual_bundle
        h_bundle st fuel env e st' ty h_ok
  }

/--
Construct field dual-principal consequences from a successful run via the dual
bundle API.
-/
theorem principalFieldTypingDualConsequence_of_success_via_dual_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : InferUnifySoundDualBundle h_app h_proj)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingDualConsequence h_app h_proj st fuel env fs st' rf := by
  refine {
    preconditioned :=
      principalFieldTypingSlicePreconditioned_of_success_via_dual_bundle
        h_bundle st fuel env fs st' rf h_ok
    core :=
      principalFieldTypingSliceCore_of_preconditioned_success_via_dual_bundle
        h_bundle st fuel env fs st' rf h_ok
    preconditioned_iff_core :=
      principalFieldTypingSlicePreconditioned_iff_core_of_success_via_dual_bundle
        h_bundle st fuel env fs st' rf h_ok
    inferFields_agrees :=
      inferFieldsUnify_inferFields_agrees_of_success_via_dual_bundle
        h_bundle st fuel env fs st' rf h_ok
  }

/--
Bundled-hook dual-bundle expression principal consequences for one successful
run.
-/
theorem principalTypingDualConsequence_of_success_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalTypingDualConsequence_of_success_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks) st fuel env e st' ty h_ok

/--
Bundled-hook dual-bundle field principal consequences for one successful run.
-/
theorem principalFieldTypingDualConsequence_of_success_from_hook_bundle_via_dual_bundle
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalFieldTypingDualConsequence_of_success_via_dual_bundle
    (inferUnifySoundDualBundle_of_hook_bundle h_hooks) st fuel env fs st' rf h_ok

/-- One-hop expression preconditioned projection from dual consequence bundle. -/
theorem principalTypingDualConsequence_preconditioned
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_conseq : PrincipalTypingDualConsequence h_app h_proj st fuel env e st' ty) :
    PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  h_conseq.preconditioned

/-- One-hop expression core projection from dual consequence bundle. -/
theorem principalTypingDualConsequence_core
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_conseq : PrincipalTypingDualConsequence h_app h_proj st fuel env e st' ty) :
    PrincipalTypingSliceCore env e ty :=
  h_conseq.core

/-- One-hop expression preconditioned↔core projection from dual bundle. -/
theorem principalTypingDualConsequence_iff_core
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_conseq : PrincipalTypingDualConsequence h_app h_proj st fuel env e st' ty) :
    PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty :=
  h_conseq.preconditioned_iff_core

/-- One-hop expression algorithmic-agreement projection from dual bundle. -/
theorem principalTypingDualConsequence_inferExpr_agrees
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_conseq : PrincipalTypingDualConsequence h_app h_proj st fuel env e st' ty) :
    inferExpr env e = some ty :=
  h_conseq.inferExpr_agrees

/-- One-hop field preconditioned projection from dual consequence bundle. -/
theorem principalFieldTypingDualConsequence_preconditioned
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_conseq : PrincipalFieldTypingDualConsequence h_app h_proj st fuel env fs st' rf) :
    PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  h_conseq.preconditioned

/-- One-hop field core projection from dual consequence bundle. -/
theorem principalFieldTypingDualConsequence_core
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_conseq : PrincipalFieldTypingDualConsequence h_app h_proj st fuel env fs st' rf) :
    PrincipalFieldTypingSliceCore env fs rf :=
  h_conseq.core

/-- One-hop field preconditioned↔core projection from dual bundle. -/
theorem principalFieldTypingDualConsequence_iff_core
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_conseq : PrincipalFieldTypingDualConsequence h_app h_proj st fuel env fs st' rf) :
    PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf :=
  h_conseq.preconditioned_iff_core

/-- One-hop field algorithmic-agreement projection from dual bundle. -/
theorem principalFieldTypingDualConsequence_inferFields_agrees
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_conseq : PrincipalFieldTypingDualConsequence h_app h_proj st fuel env fs st' rf) :
    inferFields env fs = some rf :=
  h_conseq.inferFields_agrees

/--
Packaged successful-run dual principal consequence slice for expressions.
-/
def PrincipalDualExprConsequenceSlice : Prop :=
  ∀ (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty),
    inferExprUnify st fuel env e = .ok st' ty →
    PrincipalTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env e st' ty

/--
Packaged successful-run dual principal consequence slice for fields.
-/
def PrincipalDualFieldConsequenceSlice : Prop :=
  ∀ (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields),
    inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
    PrincipalFieldTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env fs st' rf

/-- Combined successful-run dual principal consequence slice. -/
def PrincipalDualConsequenceSlices : Prop :=
  PrincipalDualExprConsequenceSlice ∧ PrincipalDualFieldConsequenceSlice

/-- The combined dual principal consequence slice is fully proved. -/
theorem principalDualConsequenceSlices_proved : PrincipalDualConsequenceSlices := by
  refine ⟨?expr, ?field⟩
  · intro h_hooks st fuel env e st' ty h_ok
    exact principalTypingDualConsequence_of_success_from_hook_bundle_via_dual_bundle
      h_hooks st fuel env e st' ty h_ok
  · intro h_hooks st fuel env fs st' rf h_ok
    exact principalFieldTypingDualConsequence_of_success_from_hook_bundle_via_dual_bundle
      h_hooks st fuel env fs st' rf h_ok

/--
One-hop expression projection from the combined dual principal consequence
slice.
-/
theorem principalDualConsequenceSlices_expr
    (h_slice : PrincipalDualConsequenceSlices)
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  h_slice.1 h_hooks st fuel env e st' ty h_ok

/--
One-hop field projection from the combined dual principal consequence slice.
-/
theorem principalDualConsequenceSlices_field
    (h_slice : PrincipalDualConsequenceSlices)
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  h_slice.2 h_hooks st fuel env fs st' rf h_ok

/--
Canonical expression dual consequence entrypoint via the proved combined slice.
-/
theorem principalTypingDualConsequence_of_success_via_proved_slice
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalDualConsequenceSlices_expr
    principalDualConsequenceSlices_proved h_hooks st fuel env e st' ty h_ok

/--
Canonical field dual consequence entrypoint via the proved combined slice.
-/
theorem principalFieldTypingDualConsequence_of_success_via_proved_slice
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalDualConsequenceSlices_field
    principalDualConsequenceSlices_proved h_hooks st fuel env fs st' rf h_ok

/--
One-step `inferExpr` agreement extraction from the proved dual consequence
slice.
-/
theorem inferExprUnify_inferExpr_agrees_of_success_via_dual_proved_slice
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    inferExpr env e = some ty :=
  principalTypingDualConsequence_inferExpr_agrees
    (principalTypingDualConsequence_of_success_via_proved_slice
      h_hooks st fuel env e st' ty h_ok)

/--
One-step `inferFields` agreement extraction from the proved dual consequence
slice.
-/
theorem inferFieldsUnify_inferFields_agrees_of_success_via_dual_proved_slice
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    inferFields env fs = some rf :=
  principalFieldTypingDualConsequence_inferFields_agrees
    (principalFieldTypingDualConsequence_of_success_via_proved_slice
      h_hooks st fuel env fs st' rf h_ok)

/--
Compatibility: the combined dual consequence slice implies the existing
preconditioned↔core principal slice.
-/
theorem principalPreconditionedCoreIffSlices_of_dualConsequenceSlices
    (h_dual : PrincipalDualConsequenceSlices) :
    PrincipalPreconditionedCoreIffSlices := by
  refine ⟨?expr, ?field⟩
  · intro h_hooks st fuel env e st' ty h_ok
    exact (principalDualConsequenceSlices_expr h_dual h_hooks st fuel env e st' ty h_ok).preconditioned_iff_core
  · intro h_hooks st fuel env fs st' rf h_ok
    exact (principalDualConsequenceSlices_field h_dual h_hooks st fuel env fs st' rf h_ok).preconditioned_iff_core

/--
Compatibility: the existing preconditioned↔core principal slice implies the
combined dual consequence slice.
-/
theorem principalDualConsequenceSlices_of_principalPreconditionedCoreIffSlices
    (h_iff : PrincipalPreconditionedCoreIffSlices) :
    PrincipalDualConsequenceSlices := by
  refine ⟨?expr, ?field⟩
  · intro h_hooks st fuel env e st' ty h_ok
    let h_pre : PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
      principalTypingSlicePreconditioned_of_success_from_bundle h_hooks st fuel env e st' ty h_ok
    let h_bridge :
        PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
          ↔ PrincipalTypingSliceCore env e ty :=
      principalPreconditionedCoreIffSlices_expr h_iff h_hooks st fuel env e st' ty h_ok
    refine {
      preconditioned := h_pre
      core := h_bridge.mp h_pre
      preconditioned_iff_core := h_bridge
      inferExpr_agrees := h_pre.inferExprAgrees
    }
  · intro h_hooks st fuel env fs st' rf h_ok
    let h_pre :
        PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
      principalFieldTypingSlicePreconditioned_of_success_from_bundle h_hooks st fuel env fs st' rf h_ok
    let h_bridge :
        PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
          ↔ PrincipalFieldTypingSliceCore env fs rf :=
      principalPreconditionedCoreIffSlices_field h_iff h_hooks st fuel env fs st' rf h_ok
    refine {
      preconditioned := h_pre
      core := h_bridge.mp h_pre
      preconditioned_iff_core := h_bridge
      inferFields_agrees := h_pre.inferFieldsAgrees
    }

/-- The dual and preconditioned↔core slice surfaces are equivalent. -/
theorem principalDualConsequenceSlices_iff_principalPreconditionedCoreIffSlices :
    PrincipalDualConsequenceSlices ↔ PrincipalPreconditionedCoreIffSlices := by
  constructor
  · intro h_dual
    exact principalPreconditionedCoreIffSlices_of_dualConsequenceSlices h_dual
  · intro h_iff
    exact principalDualConsequenceSlices_of_principalPreconditionedCoreIffSlices h_iff

/--
Canonical compatibility witness: recover the existing preconditioned↔core slice
from the proved dual consequence slice.
-/
theorem principalPreconditionedCoreIffSlices_proved_via_dualConsequence :
    PrincipalPreconditionedCoreIffSlices :=
  principalPreconditionedCoreIffSlices_of_dualConsequenceSlices
    principalDualConsequenceSlices_proved

/--
Canonical compatibility witness: recover the dual consequence slice from the
existing proved preconditioned↔core slice.
-/
theorem principalDualConsequenceSlices_proved_via_principalPreconditionedCoreIff :
    PrincipalDualConsequenceSlices :=
  principalDualConsequenceSlices_of_principalPreconditionedCoreIffSlices
    principalPreconditionedCoreIffSlices_proved

/--
Drop the extra dual consequence facets to recover the existing expression
bridge-bundle surface.
-/
theorem principalNoUnifyBridgeBundle_of_dualConsequence
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_dual : PrincipalTypingDualConsequence h_app h_proj st fuel env e st' ty) :
    PrincipalNoUnifyBridgeBundle h_app h_proj st fuel env e st' ty := by
  exact {
    core := h_dual.core
    preconditioned := h_dual.preconditioned
  }

/--
Drop the extra dual consequence facets to recover the existing field
bridge-bundle surface.
-/
theorem principalFieldNoUnifyBridgeBundle_of_dualConsequence
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_dual : PrincipalFieldTypingDualConsequence h_app h_proj st fuel env fs st' rf) :
    PrincipalFieldNoUnifyBridgeBundle h_app h_proj st fuel env fs st' rf := by
  exact {
    core := h_dual.core
    preconditioned := h_dual.preconditioned
  }

/--
Lift an expression bridge bundle into the richer dual consequence surface on a
successful run.
-/
theorem principalTypingDualConsequence_of_noUnifyBridgeBundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_bundle : PrincipalNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env e st' ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  refine {
    preconditioned := h_bundle.preconditioned
    core := h_bundle.core
    preconditioned_iff_core := ?_
    inferExpr_agrees := h_bundle.preconditioned.inferExprAgrees
  }
  exact principalTypingSlicePreconditioned_iff_core_of_success_from_bundle
    h_hooks st fuel env e st' ty h_ok

/--
Lift a field bridge bundle into the richer dual consequence surface on a
successful run.
-/
theorem principalFieldTypingDualConsequence_of_noUnifyBridgeBundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_bundle : PrincipalFieldNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env fs st' rf)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  refine {
    preconditioned := h_bundle.preconditioned
    core := h_bundle.core
    preconditioned_iff_core := ?_
    inferFields_agrees := h_bundle.preconditioned.inferFieldsAgrees
  }
  exact principalFieldTypingSlicePreconditioned_iff_core_of_success_from_bundle
    h_hooks st fuel env fs st' rf h_ok

/--
On successful expression runs, dual consequence bundles and expression bridge
bundles are equivalent surfaces.
-/
theorem principalTypingDualConsequence_iff_noUnifyBridgeBundle_of_success
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  constructor
  · intro h_dual
    exact principalNoUnifyBridgeBundle_of_dualConsequence h_dual
  · intro h_bundle
    exact principalTypingDualConsequence_of_noUnifyBridgeBundle h_hooks h_bundle h_ok

/--
On successful field runs, dual consequence bundles and field bridge bundles are
equivalent surfaces.
-/
theorem principalFieldTypingDualConsequence_iff_noUnifyBridgeBundle_of_success
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingDualConsequence h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldNoUnifyBridgeBundle h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  constructor
  · intro h_dual
    exact principalFieldNoUnifyBridgeBundle_of_dualConsequence h_dual
  · intro h_bundle
    exact principalFieldTypingDualConsequence_of_noUnifyBridgeBundle h_hooks h_bundle h_ok

/--
Compatibility: the combined dual consequence slice implies the existing
no-unify bridge slice.
-/
theorem principalNoUnifyBridgeSlices_of_dualConsequenceSlices
    (h_dual : PrincipalDualConsequenceSlices) :
    PrincipalNoUnifyBridgeSlices := by
  refine ⟨?expr, ?field⟩
  · intro st fuel env e st' ty _h_no h_ok h_hooks
    exact principalNoUnifyBridgeBundle_of_dualConsequence
      (principalDualConsequenceSlices_expr h_dual h_hooks st fuel env e st' ty h_ok)
  · intro st fuel env fs st' rf _h_no h_ok h_hooks
    exact principalFieldNoUnifyBridgeBundle_of_dualConsequence
      (principalDualConsequenceSlices_field h_dual h_hooks st fuel env fs st' rf h_ok)

/--
Compatibility: the combined dual consequence slice implies the full principal
boundary bridge suite.
-/
theorem principalBoundaryBridgeSuite_of_dualConsequenceSlices
    (h_dual : PrincipalDualConsequenceSlices) :
    PrincipalBoundaryBridgeSuite := by
  refine {
    noUnify := principalNoUnifyBridgeSlices_of_dualConsequenceSlices h_dual
    preconditionedCoreIff := principalPreconditionedCoreIffSlices_of_dualConsequenceSlices h_dual
  }

/--
Canonical suite adapter from the proved combined dual consequence slice.
-/
theorem principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices :
    PrincipalBoundaryBridgeSuite :=
  principalBoundaryBridgeSuite_of_dualConsequenceSlices
    principalDualConsequenceSlices_proved

/--
Compatibility: the principal boundary bridge suite implies the combined dual
consequence slice.
-/
theorem principalDualConsequenceSlices_of_principalBoundaryBridgeSuite
    (h_suite : PrincipalBoundaryBridgeSuite) :
    PrincipalDualConsequenceSlices :=
  principalDualConsequenceSlices_of_principalPreconditionedCoreIffSlices
    h_suite.preconditionedCoreIff

/-- The boundary bridge suite and dual consequence slice surfaces are equivalent. -/
theorem principalBoundaryBridgeSuite_iff_dualConsequenceSlices :
    PrincipalBoundaryBridgeSuite ↔ PrincipalDualConsequenceSlices := by
  constructor
  · intro h_suite
    exact principalDualConsequenceSlices_of_principalBoundaryBridgeSuite h_suite
  · intro h_dual
    exact principalBoundaryBridgeSuite_of_dualConsequenceSlices h_dual

/--
Canonical dual-slice adapter from the existing proved boundary bridge suite.
-/
theorem principalDualConsequenceSlices_proved_via_principalBoundaryBridgeSuite :
    PrincipalDualConsequenceSlices :=
  principalDualConsequenceSlices_of_principalBoundaryBridgeSuite
    principalBoundaryBridgeSuite_proved

/--
Lift any dual-consequence-slice witness into the top-level master suite.
-/
theorem principalBoundaryMasterSuite_of_dualConsequenceSlices
    (h_dual : PrincipalDualConsequenceSlices) :
    PrincipalBoundaryMasterSuite := by
  refine {
    bridge := principalBoundaryBridgeSuite_of_dualConsequenceSlices h_dual
    vacuity := principalBoundaryVacuitySuite_proved
    allHooks := principalPreconditionedAllHooksSuite_proved
    noUnifyAllHooks := principalBoundaryNoUnifyAllHooksSuite_proved
    noUnifyHookedFromAllHooks := principalBoundaryNoUnifyCapstoneSlices_of_allHooksSuite
    noUnifyToGeneralAllHooks := principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks
  }

/--
Any top-level master suite witness yields the dual consequence slice through its
embedded bridge layer.
-/
theorem principalDualConsequenceSlices_of_principalBoundaryMasterSuite
    (h_suite : PrincipalBoundaryMasterSuite) :
    PrincipalDualConsequenceSlices :=
  principalDualConsequenceSlices_of_principalBoundaryBridgeSuite h_suite.bridge

/--
The dual consequence slice surface and top-level master suite are equivalent.
-/
theorem principalBoundaryMasterSuite_iff_dualConsequenceSlices :
    PrincipalBoundaryMasterSuite ↔ PrincipalDualConsequenceSlices := by
  constructor
  · intro h_suite
    exact principalDualConsequenceSlices_of_principalBoundaryMasterSuite h_suite
  · intro h_dual
    exact principalBoundaryMasterSuite_of_dualConsequenceSlices h_dual

/--
Canonical top-level master-suite witness routed through the dual-derived bridge
suite.
-/
theorem principalBoundaryMasterSuite_proved_via_dualConsequenceSlices :
    PrincipalBoundaryMasterSuite :=
  principalBoundaryMasterSuite_of_dualConsequenceSlices
    principalDualConsequenceSlices_proved

/--
Packaged current row-polymorphic principality boundary:
- the top-level principal boundary master suite, and
- the proved hook-free app/projection vertical slice.
-/
structure PrincipalRowPolyBoundaryBundle where
  principalBoundary : PrincipalBoundaryMasterSuite
  hookFreeVertical : VerticalHookFreeUnifySlices

/--
Build the current row-polymorphic principality boundary package from any
master principal-boundary witness.
-/
theorem principalRowPolyBoundaryBundle_of_master
    (h_master : PrincipalBoundaryMasterSuite) :
    PrincipalRowPolyBoundaryBundle := by
  refine {
    principalBoundary := h_master
    hookFreeVertical := verticalHookFreeUnifySlices_proved
  }

/-- Canonical current row-polymorphic principality boundary package. -/
theorem principalRowPolyBoundaryBundle_proved :
    PrincipalRowPolyBoundaryBundle :=
  principalRowPolyBoundaryBundle_of_master principalBoundaryMasterSuite_proved

/-- Dual-routed canonical current row-polymorphic principality boundary package. -/
theorem principalRowPolyBoundaryBundle_proved_via_dualConsequenceSlices :
    PrincipalRowPolyBoundaryBundle :=
  principalRowPolyBoundaryBundle_of_master
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices

/-- One-hop projection of the principal boundary surface from the package. -/
theorem principalRowPolyBoundaryBundle_principal
    (h_bundle : PrincipalRowPolyBoundaryBundle) :
    PrincipalBoundaryMasterSuite :=
  h_bundle.principalBoundary

/-- One-hop projection of the hook-free vertical app/proj slice from the package. -/
theorem principalRowPolyBoundaryBundle_vertical
    (h_bundle : PrincipalRowPolyBoundaryBundle) :
    VerticalHookFreeUnifySlices :=
  h_bundle.hookFreeVertical

/-- One-hop projection of the dual consequence slice from the packaged boundary. -/
theorem principalRowPolyBoundaryBundle_dual
    (h_bundle : PrincipalRowPolyBoundaryBundle) :
    PrincipalDualConsequenceSlices :=
  principalDualConsequenceSlices_of_principalBoundaryMasterSuite h_bundle.principalBoundary

/--
Build the row-polymorphic boundary bundle from the dual principal slice plus
an explicit hook-free vertical slice witness.
-/
theorem principalRowPolyBoundaryBundle_of_dual_and_vertical
    (h_dual : PrincipalDualConsequenceSlices)
    (h_vertical : VerticalHookFreeUnifySlices) :
    PrincipalRowPolyBoundaryBundle := by
  refine {
    principalBoundary := principalBoundaryMasterSuite_of_dualConsequenceSlices h_dual
    hookFreeVertical := h_vertical
  }

/--
The row-polymorphic boundary package is equivalent to providing:
- a dual principal consequence slice witness, and
- a hook-free vertical slice witness.
-/
theorem principalRowPolyBoundaryBundle_iff_dual_and_vertical :
    PrincipalRowPolyBoundaryBundle
      ↔ (PrincipalDualConsequenceSlices ∧ VerticalHookFreeUnifySlices) := by
  constructor
  · intro h_bundle
    exact ⟨principalRowPolyBoundaryBundle_dual h_bundle, h_bundle.hookFreeVertical⟩
  · intro h_pair
    exact principalRowPolyBoundaryBundle_of_dual_and_vertical h_pair.1 h_pair.2

/--
One-hop expression successful-run preconditioned↔core equivalence from the
row-polymorphic boundary bundle.
-/
theorem principalRowPolyBoundaryBundle_preconditionedCoreIff_expr
    (h_bundle : PrincipalRowPolyBoundaryBundle)
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalBoundaryMasterSuite_preconditionedCoreIff_expr
    h_bundle.principalBoundary h_hooks st fuel env e st' ty h_ok

/--
One-hop field successful-run preconditioned↔core equivalence from the
row-polymorphic boundary bundle.
-/
theorem principalRowPolyBoundaryBundle_preconditionedCoreIff_field
    (h_bundle : PrincipalRowPolyBoundaryBundle)
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalBoundaryMasterSuite_preconditionedCoreIff_field
    h_bundle.principalBoundary h_hooks st fuel env fs st' rf h_ok

/-- One-hop projection of the hook-free app vertical slice from the bundle. -/
theorem principalRowPolyBoundaryBundle_vertical_app
    (h_bundle : PrincipalRowPolyBoundaryBundle) :
    VerticalHookFreeAppSlice :=
  h_bundle.hookFreeVertical.1

/-- One-hop projection of the hook-free projection vertical slice from the bundle. -/
theorem principalRowPolyBoundaryBundle_vertical_proj
    (h_bundle : PrincipalRowPolyBoundaryBundle) :
    VerticalHookFreeProjSlice :=
  h_bundle.hookFreeVertical.2

/--
Packaged current row-polymorphic boundary + recursive dual-judgment soundness
for a fixed hook pair.
-/
structure PrincipalRowPolyBoundarySoundBundle
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook) : Prop where
  boundary : PrincipalRowPolyBoundaryBundle
  soundDual : InferUnifySoundDualBundle h_app h_proj

/--
Build the row-polymorphic boundary+soundness package from hook premises using
the canonical boundary capstone.
-/
theorem principalRowPolyBoundarySoundBundle_of_hooks
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook) :
    PrincipalRowPolyBoundarySoundBundle h_app h_proj := by
  refine {
    boundary := principalRowPolyBoundaryBundle_proved
    soundDual := inferUnifySoundDualBundle_of_hooks h_app h_proj
  }

/--
Dual-routed boundary variant of the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_of_hooks_via_dualConsequenceSlices
    (h_app : AppUnifySoundHook)
    (h_proj : ProjUnifySoundHook) :
    PrincipalRowPolyBoundarySoundBundle h_app h_proj := by
  refine {
    boundary := principalRowPolyBoundaryBundle_proved_via_dualConsequenceSlices
    soundDual := inferUnifySoundDualBundle_of_hooks h_app h_proj
  }

/-- Bundled-hook constructor for the row-polymorphic boundary+soundness package. -/
theorem principalRowPolyBoundarySoundBundle_of_hook_bundle
    (h_hooks : UnifyHookPremises) :
    PrincipalRowPolyBoundarySoundBundle h_hooks.1 h_hooks.2 :=
  principalRowPolyBoundarySoundBundle_of_hooks h_hooks.1 h_hooks.2

/-- One-hop boundary projection from the row-polymorphic boundary+soundness package. -/
theorem principalRowPolyBoundarySoundBundle_boundary
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj) :
    PrincipalRowPolyBoundaryBundle :=
  h_bundle.boundary

/-- One-hop dual-soundness projection from the row-polymorphic boundary+soundness package. -/
theorem principalRowPolyBoundarySoundBundle_soundDual
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj) :
    InferUnifySoundDualBundle h_app h_proj :=
  h_bundle.soundDual

/--
The boundary+soundness package is equivalent to providing:
- a row-polymorphic boundary bundle witness, and
- a dual recursive-soundness bundle witness for the same hook pair.
-/
theorem principalRowPolyBoundarySoundBundle_iff_boundary_and_soundDual
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook} :
    PrincipalRowPolyBoundarySoundBundle h_app h_proj
      ↔ (PrincipalRowPolyBoundaryBundle ∧ InferUnifySoundDualBundle h_app h_proj) := by
  constructor
  · intro h_bundle
    exact ⟨h_bundle.boundary, h_bundle.soundDual⟩
  · intro h_pair
    exact ⟨h_pair.1, h_pair.2⟩

/--
Expression `HasType` recursive soundness one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_expr_hasType
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasType env e ty :=
  h_bundle.soundDual.expr_hasType st fuel env e st' ty h_ok

/--
Field `HasFieldsType` recursive soundness one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_field_hasType
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsType env fs rf :=
  h_bundle.soundDual.field_hasType st fuel env fs st' rf h_ok

/--
Expression `HasTypeU` recursive soundness one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_expr_hasTypeU
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasTypeU env e ty :=
  h_bundle.soundDual.expr_hasTypeU st fuel env e st' ty h_ok

/--
Field `HasFieldsTypeU` recursive soundness one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_field_hasTypeU
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsTypeU env fs rf :=
  h_bundle.soundDual.field_hasTypeU st fuel env fs st' rf h_ok

/--
Expression core principality one-hop wrapper from the row-polymorphic
boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_coreExpr_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok

/--
Expression bundled-hook preconditioned principality one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok h_hooks

/--
Expression bundled-hook preconditioned↔core one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok h_hooks

/--
Field core principality one-hop wrapper from the row-polymorphic
boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_coreField_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok

/--
Field bundled-hook preconditioned principality one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok h_hooks

/--
Field bundled-hook preconditioned↔core one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok h_hooks

/--
Expression any-hooks preconditioned principality one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok

/--
Expression any-hooks preconditioned↔core one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok

/--
Field any-hooks preconditioned principality one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok

/--
Field any-hooks preconditioned↔core one-hop wrapper from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok

/--
Expression core principality one-hop wrapper for successful no-unify runs from
the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_coreExpr_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok

/--
Expression bundled-hook preconditioned principality one-hop wrapper for
successful no-unify runs from the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok h_hooks

/--
Expression bundled-hook preconditioned↔core one-hop wrapper for successful
no-unify runs from the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok h_hooks

/--
Field core principality one-hop wrapper for successful no-unify runs from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_coreField_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok

/--
Field bundled-hook preconditioned principality one-hop wrapper for successful
no-unify runs from the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok h_hooks

/--
Field bundled-hook preconditioned↔core one-hop wrapper for successful no-unify
runs from the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok h_hooks

/--
Expression any-hooks preconditioned principality one-hop wrapper for successful
no-unify runs from the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok

/--
Expression any-hooks preconditioned↔core one-hop wrapper for successful
no-unify runs from the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok

/--
Field any-hooks preconditioned principality one-hop wrapper for successful
no-unify runs from the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok

/--
Field any-hooks preconditioned↔core one-hop wrapper for successful no-unify
runs from the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok

/--
Expression all-hooks run-bundle one-hop wrapper for arbitrary successful runs
from the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_runBundleExpr_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok

/--
Field all-hooks run-bundle one-hop wrapper for arbitrary successful runs from
the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_runBundleField_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok

/--
Expression all-hooks run-bundle one-hop wrapper for successful no-unify runs
from the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_runBundleExpr_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok

/--
Field all-hooks run-bundle one-hop wrapper for successful no-unify runs from
the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_runBundleField_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok

/--
Expression hook-irrelevance one-hop wrapper for arbitrary successful runs from
the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok

/--
Field hook-irrelevance one-hop wrapper for arbitrary successful runs from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_via_masterSuite
    h_bundle.boundary.principalBoundary h_app h_proj h_ok

/--
Expression hook-irrelevance one-hop wrapper for successful no-unify runs from
the row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok

/--
Field hook-irrelevance one-hop wrapper for successful no-unify runs from the
row-polymorphic boundary+soundness package.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_noUnify
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterSuite
    h_bundle.boundary.principalBoundary h_no h_ok

/--
Expression core principality routed through the capstone run-bundle path on
arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_coreExpr_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalPreconditionedExprAllHooksRunBundle_core
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success h_bundle h_ok)

/--
Field core principality routed through the capstone run-bundle path on
arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_coreField_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalPreconditionedFieldAllHooksRunBundle_core
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success h_bundle h_ok)

/--
Expression hook-irrelevance routed through the capstone run-bundle path on
arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExprAllHooksRunBundle_hook_irrelevant
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success h_bundle h_ok)

/--
Field hook-irrelevance routed through the capstone run-bundle path on
arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedFieldAllHooksRunBundle_hook_irrelevant
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success h_bundle h_ok)

/--
Expression core principality routed through the capstone run-bundle path on
successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_coreExpr_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalPreconditionedExprAllHooksRunBundle_core
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success_noUnify
      h_bundle h_no h_ok)

/--
Field core principality routed through the capstone run-bundle path on
successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_coreField_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalPreconditionedFieldAllHooksRunBundle_core
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success_noUnify
      h_bundle h_no h_ok)

/--
Expression hook-irrelevance routed through the capstone run-bundle path on
successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExprAllHooksRunBundle_hook_irrelevant
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success_noUnify
      h_bundle h_no h_ok)

/--
Field hook-irrelevance routed through the capstone run-bundle path on
successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedFieldAllHooksRunBundle_hook_irrelevant
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success_noUnify
      h_bundle h_no h_ok)

/--
Expression any-hooks preconditioned principality routed through the capstone
run-bundle path on arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_preconditioned_anyHooks
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success h_bundle h_ok)

/--
Field any-hooks preconditioned principality routed through the capstone
run-bundle path on arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_preconditioned_anyHooks
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success h_bundle h_ok)

/--
Expression bundled-hook preconditioned principality routed through the capstone
run-bundle path on arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_preconditioned
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success h_bundle h_ok)
    h_hooks

/--
Field bundled-hook preconditioned principality routed through the capstone
run-bundle path on arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_preconditioned
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success h_bundle h_ok)
    h_hooks

/--
Expression any-hooks preconditioned↔core equivalence routed through the
capstone run-bundle path on arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedExprAllHooksRunBundle_preconditionedCoreIff_anyHooks
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success h_bundle h_ok)

/--
Field any-hooks preconditioned↔core equivalence routed through the capstone
run-bundle path on arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedFieldAllHooksRunBundle_preconditionedCoreIff_anyHooks
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success h_bundle h_ok)

/--
Expression bundled-hook preconditioned↔core equivalence routed through the
capstone run-bundle path on arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedExprAllHooksRunBundle_preconditionedCoreIff
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success h_bundle h_ok)
    h_hooks

/--
Field bundled-hook preconditioned↔core equivalence routed through the capstone
run-bundle path on arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedFieldAllHooksRunBundle_preconditionedCoreIff
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success h_bundle h_ok)
    h_hooks

/--
Expression any-hooks preconditioned principality routed through the capstone
run-bundle path on successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_preconditioned_anyHooks
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success_noUnify
      h_bundle h_no h_ok)

/--
Field any-hooks preconditioned principality routed through the capstone
run-bundle path on successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_preconditioned_anyHooks
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success_noUnify
      h_bundle h_no h_ok)

/--
Expression bundled-hook preconditioned principality routed through the capstone
run-bundle path on successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExprAllHooksRunBundle_preconditioned
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success_noUnify
      h_bundle h_no h_ok)
    h_hooks

/--
Field bundled-hook preconditioned principality routed through the capstone
run-bundle path on successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedFieldAllHooksRunBundle_preconditioned
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success_noUnify
      h_bundle h_no h_ok)
    h_hooks

/--
Expression any-hooks preconditioned↔core equivalence routed through the
capstone run-bundle path on successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedExprAllHooksRunBundle_preconditionedCoreIff_anyHooks
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success_noUnify
      h_bundle h_no h_ok)

/--
Field any-hooks preconditioned↔core equivalence routed through the capstone
run-bundle path on successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedFieldAllHooksRunBundle_preconditionedCoreIff_anyHooks
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success_noUnify
      h_bundle h_no h_ok)

/--
Expression bundled-hook preconditioned↔core equivalence routed through the
capstone run-bundle path on successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedExprAllHooksRunBundle_preconditionedCoreIff
    (principalRowPolyBoundarySoundBundle_runBundleExpr_of_success_noUnify
      h_bundle h_no h_ok)
    h_hooks

/--
Field bundled-hook preconditioned↔core equivalence routed through the capstone
run-bundle path on successful no-unify runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_noUnify_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedFieldAllHooksRunBundle_preconditionedCoreIff
    (principalRowPolyBoundarySoundBundle_runBundleField_of_success_noUnify
      h_bundle h_no h_ok)
    h_hooks

/-- Bundled-seed aliases for arbitrary-success capstone `via_runBundle` wrappers. -/
theorem principalRowPolyBoundarySoundBundle_coreExpr_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalRowPolyBoundarySoundBundle_coreExpr_of_success_via_runBundle h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_coreField_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalRowPolyBoundarySoundBundle_coreField_of_success_via_runBundle h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_via_runBundle
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_via_runBundle
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_via_runBundle
    h_bundle h_hooks h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedField_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_preconditionedField_of_success_via_runBundle
    h_bundle h_hooks h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_via_runBundle
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_via_runBundle
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_via_runBundle
    h_bundle h_hooks h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_via_runBundle
    h_bundle h_hooks h_ok

theorem principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_via_runBundle
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_via_runBundle
    h_bundle h_ok

/-- Bundled-seed aliases for no-unify capstone `via_runBundle` wrappers. -/
theorem principalRowPolyBoundarySoundBundle_coreExpr_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalRowPolyBoundarySoundBundle_coreExpr_of_success_noUnify_via_runBundle
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_coreField_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalRowPolyBoundarySoundBundle_coreField_of_success_noUnify_via_runBundle
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_noUnify_via_runBundle
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_noUnify_via_runBundle
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_noUnify_via_runBundle
    h_bundle h_hooks h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedField_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_preconditionedField_of_success_noUnify_via_runBundle
    h_bundle h_hooks h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_runBundle
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_noUnify_via_runBundle
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_noUnify_via_runBundle
    h_bundle h_hooks h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_noUnify_via_runBundle
    h_bundle h_hooks h_no h_ok

theorem principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_noUnify_via_runBundle
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_noUnify_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_noUnify_via_runBundle
    h_bundle h_no h_ok

/--
Packaged expression consequences on the boundary+sound capstone run-bundle
route for arbitrary successful runs.
-/
structure PrincipalExprRunBundleConsequences
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  core : PrincipalTypingSliceCore env e ty
  preconditionedAny :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
  preconditioned :
    ∀ (h_hooks : UnifyHookPremises),
      PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty)
  preconditionedIffCore :
    ∀ (h_hooks : UnifyHookPremises),
      (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty)
  hookIrrelevant :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
        ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)

/--
Packaged field consequences on the boundary+sound capstone run-bundle route for
arbitrary successful runs.
-/
structure PrincipalFieldRunBundleConsequences
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  core : PrincipalFieldTypingSliceCore env fs rf
  preconditionedAny :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
  preconditioned :
    ∀ (h_hooks : UnifyHookPremises),
      PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf)
  preconditionedIffCore :
    ∀ (h_hooks : UnifyHookPremises),
      (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf)
  hookIrrelevant :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
        ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)

/--
Build packaged expression consequences from one successful run on the
boundary+sound capstone through the run-bundle route.
-/
theorem principalRowPolyBoundarySoundBundle_exprRunBundleConsequences_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalExprRunBundleConsequences st fuel env e st' ty := by
  refine {
    core := principalRowPolyBoundarySoundBundle_coreExpr_of_success_via_runBundle
      h_bundle h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app' h_proj'
    exact principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_via_runBundle
      h_bundle h_ok h_app' h_proj'
  · intro h_hooks
    exact principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_via_runBundle
      h_bundle h_hooks h_ok
  · intro h_app' h_proj'
    exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_via_runBundle
      h_bundle h_ok h_app' h_proj'
  · intro h_hooks
    exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_via_runBundle
      h_bundle h_hooks h_ok
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_via_runBundle
      h_bundle h_ok

/--
Build packaged field consequences from one successful run on the boundary+sound
capstone through the run-bundle route.
-/
theorem principalRowPolyBoundarySoundBundle_fieldRunBundleConsequences_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldRunBundleConsequences st fuel env fs st' rf := by
  refine {
    core := principalRowPolyBoundarySoundBundle_coreField_of_success_via_runBundle
      h_bundle h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app' h_proj'
    exact principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_via_runBundle
      h_bundle h_ok h_app' h_proj'
  · intro h_hooks
    exact principalRowPolyBoundarySoundBundle_preconditionedField_of_success_via_runBundle
      h_bundle h_hooks h_ok
  · intro h_app' h_proj'
    exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_via_runBundle
      h_bundle h_ok h_app' h_proj'
  · intro h_hooks
    exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_via_runBundle
      h_bundle h_hooks h_ok
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_via_runBundle
      h_bundle h_ok

/--
Bundled-seed alias for expression consequence bundles on the boundary+sound
run-bundle route.
-/
theorem principalRowPolyBoundarySoundBundle_exprRunBundleConsequences_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalExprRunBundleConsequences st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_exprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok

/--
Bundled-seed alias for field consequence bundles on the boundary+sound
run-bundle route.
-/
theorem principalRowPolyBoundarySoundBundle_fieldRunBundleConsequences_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldRunBundleConsequences st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_fieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok

/--
Expression core principality routed through packaged run-bundle consequences on
the boundary+sound capstone for arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_coreExpr_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  (principalRowPolyBoundarySoundBundle_exprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).core

/--
Field core principality routed through packaged run-bundle consequences on the
boundary+sound capstone for arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_coreField_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalRowPolyBoundarySoundBundle_fieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).core

/--
Expression any-hooks preconditioned principality routed through packaged
run-bundle consequences on the boundary+sound capstone for arbitrary successful
runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  (principalRowPolyBoundarySoundBundle_exprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).preconditionedAny

/--
Field any-hooks preconditioned principality routed through packaged run-bundle
consequences on the boundary+sound capstone for arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  (principalRowPolyBoundarySoundBundle_fieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).preconditionedAny

/--
Expression bundled-hook preconditioned principality routed through packaged
run-bundle consequences on the boundary+sound capstone for arbitrary successful
runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  (principalRowPolyBoundarySoundBundle_exprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).preconditioned h_hooks

/--
Field bundled-hook preconditioned principality routed through packaged
run-bundle consequences on the boundary+sound capstone for arbitrary successful
runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  (principalRowPolyBoundarySoundBundle_fieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).preconditioned h_hooks

/--
Expression any-hooks preconditioned↔core equivalence routed through packaged
run-bundle consequences on the boundary+sound capstone for arbitrary successful
runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  (principalRowPolyBoundarySoundBundle_exprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).preconditionedAnyIffCore

/--
Field any-hooks preconditioned↔core equivalence routed through packaged
run-bundle consequences on the boundary+sound capstone for arbitrary successful
runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalRowPolyBoundarySoundBundle_fieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).preconditionedAnyIffCore

/--
Expression bundled-hook preconditioned↔core equivalence routed through packaged
run-bundle consequences on the boundary+sound capstone for arbitrary successful
runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalRowPolyBoundarySoundBundle_exprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).preconditionedIffCore h_hooks

/--
Field bundled-hook preconditioned↔core equivalence routed through packaged
run-bundle consequences on the boundary+sound capstone for arbitrary successful
runs.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalRowPolyBoundarySoundBundle_fieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).preconditionedIffCore h_hooks

/--
Expression fixed-run hook-irrelevance routed through packaged run-bundle
consequences on the boundary+sound capstone for arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalRowPolyBoundarySoundBundle_exprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).hookIrrelevant

/--
Field fixed-run hook-irrelevance routed through packaged run-bundle
consequences on the boundary+sound capstone for arbitrary successful runs.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalRowPolyBoundarySoundBundle_fieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_ok).hookIrrelevant

/--
Build packaged no-unify expression consequence bundles from the boundary+sound
capstone through the run-bundle route.
-/
theorem principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleConsequences_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty := by
  refine {
    core := principalRowPolyBoundarySoundBundle_coreExpr_of_success_noUnify_via_runBundle
      h_bundle h_no h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app' h_proj'
    exact principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_noUnify_via_runBundle
      h_bundle h_no h_ok h_app' h_proj'
  · intro h_hooks
    exact principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_noUnify_via_runBundle
      h_bundle h_hooks h_no h_ok
  · intro h_app' h_proj'
    exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_runBundle
      h_bundle h_no h_ok h_app' h_proj'
  · intro h_hooks
    exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_noUnify_via_runBundle
      h_bundle h_hooks h_no h_ok
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_noUnify_via_runBundle
      h_bundle h_no h_ok

/--
Build packaged no-unify field consequence bundles from the boundary+sound
capstone through the run-bundle route.
-/
theorem principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleConsequences_of_success_via_runBundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf := by
  refine {
    core := principalRowPolyBoundarySoundBundle_coreField_of_success_noUnify_via_runBundle
      h_bundle h_no h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app' h_proj'
    exact principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_noUnify_via_runBundle
      h_bundle h_no h_ok h_app' h_proj'
  · intro h_hooks
    exact principalRowPolyBoundarySoundBundle_preconditionedField_of_success_noUnify_via_runBundle
      h_bundle h_hooks h_no h_ok
  · intro h_app' h_proj'
    exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_noUnify_via_runBundle
      h_bundle h_no h_ok h_app' h_proj'
  · intro h_hooks
    exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_noUnify_via_runBundle
      h_bundle h_hooks h_no h_ok
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_noUnify_via_runBundle
      h_bundle h_no h_ok

/--
Bundled-seed alias for no-unify expression consequence bundles on the
boundary+sound run-bundle route.
-/
theorem principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleConsequences_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok

/--
Bundled-seed alias for no-unify field consequence bundles on the boundary+sound
run-bundle route.
-/
theorem principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleConsequences_of_success_via_runBundle_from_bundle
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok

/--
No-unify expression core principality routed through packaged run-bundle
consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_coreExpr_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  (principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).core

/--
No-unify field core principality routed through packaged run-bundle
consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_coreField_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).core

/--
No-unify expression any-hooks preconditioned principality routed through
packaged run-bundle consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  (principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).preconditionedAny

/--
No-unify field any-hooks preconditioned principality routed through packaged
run-bundle consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  (principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).preconditionedAny

/--
No-unify expression bundled-hook preconditioned principality routed through
packaged run-bundle consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  (principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).preconditioned h_hooks

/--
No-unify field bundled-hook preconditioned principality routed through packaged
run-bundle consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedField_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  (principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).preconditioned h_hooks

/--
No-unify expression any-hooks preconditioned↔core equivalence routed through
packaged run-bundle consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  (principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).preconditionedAnyIffCore

/--
No-unify field any-hooks preconditioned↔core equivalence routed through
packaged run-bundle consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).preconditionedAnyIffCore

/--
No-unify expression bundled-hook preconditioned↔core equivalence routed through
packaged run-bundle consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).preconditionedIffCore h_hooks

/--
No-unify field bundled-hook preconditioned↔core equivalence routed through
packaged run-bundle consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).preconditionedIffCore h_hooks

/--
No-unify expression fixed-run hook-irrelevance routed through packaged
run-bundle consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).hookIrrelevant

/--
No-unify field fixed-run hook-irrelevance routed through packaged run-bundle
consequences on the boundary+sound capstone.
-/
theorem principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_noUnify_via_runBundleConsequences
    {h_app : AppUnifySoundHook}
    {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleConsequences_of_success_via_runBundle
    h_bundle h_no h_ok).hookIrrelevant

/-- Bundled-seed aliases for arbitrary-success capstone consequence-route wrappers. -/
theorem principalRowPolyBoundarySoundBundle_coreExpr_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalRowPolyBoundarySoundBundle_coreExpr_of_success_via_runBundleConsequences
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_coreField_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalRowPolyBoundarySoundBundle_coreField_of_success_via_runBundleConsequences
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_via_runBundleConsequences
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_via_runBundleConsequences
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_via_runBundleConsequences
    h_bundle h_hooks h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedField_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_preconditionedField_of_success_via_runBundleConsequences
    h_bundle h_hooks h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_via_runBundleConsequences
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_via_runBundleConsequences
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_via_runBundleConsequences
    h_bundle h_hooks h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_via_runBundleConsequences
    h_bundle h_hooks h_ok

theorem principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_via_runBundleConsequences
    h_bundle h_ok

theorem principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_via_runBundleConsequences
    h_bundle h_ok

/-- Bundled-seed aliases for no-unify capstone consequence-route wrappers. -/
theorem principalRowPolyBoundarySoundBundle_coreExpr_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalRowPolyBoundarySoundBundle_coreExpr_of_success_noUnify_via_runBundleConsequences
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_coreField_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalRowPolyBoundarySoundBundle_coreField_of_success_noUnify_via_runBundleConsequences
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_noUnify_via_runBundleConsequences
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_noUnify_via_runBundleConsequences
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_noUnify_via_runBundleConsequences
    h_bundle h_hooks h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedField_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_preconditionedField_of_success_noUnify_via_runBundleConsequences
    h_bundle h_hooks h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_runBundleConsequences
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_noUnify_via_runBundleConsequences
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_noUnify_via_runBundleConsequences
    h_bundle h_hooks h_no h_ok

theorem principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_noUnify_via_runBundleConsequences
    h_bundle h_hooks h_no h_ok

theorem principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_noUnify_via_runBundleConsequences
    h_bundle h_no h_ok

theorem principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_noUnify_via_runBundleConsequences_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_noUnify_via_runBundleConsequences
    h_bundle h_no h_ok

/--
Boundary+sound expression route pair: packaged all-hooks run-bundle witness and
its packaged consequence witness for an arbitrary successful run.
-/
structure PrincipalBoundarySoundExprRunBundleRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  runBundle : PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty
  consequences : PrincipalExprRunBundleConsequences st fuel env e st' ty

/--
Boundary+sound field route pair: packaged all-hooks run-bundle witness and its
packaged consequence witness for an arbitrary successful field run.
-/
structure PrincipalBoundarySoundFieldRunBundleRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  runBundle : PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf
  consequences : PrincipalFieldRunBundleConsequences st fuel env fs st' rf

/--
Boundary+sound no-unify expression route pair: packaged all-hooks run-bundle
witness and packaged no-unify consequence witness from one successful run.
-/
structure PrincipalBoundarySoundNoUnifyExprRunBundleRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  runBundle : PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty
  consequences : PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty

/--
Boundary+sound no-unify field route pair: packaged all-hooks run-bundle witness
and packaged no-unify consequence witness from one successful field run.
-/
structure PrincipalBoundarySoundNoUnifyFieldRunBundleRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  runBundle : PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf
  consequences : PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf

/--
Build the boundary+sound expression route pair from one arbitrary successful
expression run.
-/
theorem principalRowPolyBoundarySoundBundle_exprRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundExprRunBundleRoutes st fuel env e st' ty := by
  exact {
    runBundle := principalRowPolyBoundarySoundBundle_runBundleExpr_of_success h_bundle h_ok
    consequences := principalRowPolyBoundarySoundBundle_exprRunBundleConsequences_of_success_via_runBundle
      h_bundle h_ok
  }

/--
Build the boundary+sound field route pair from one arbitrary successful field
run.
-/
theorem principalRowPolyBoundarySoundBundle_fieldRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldRunBundleRoutes st fuel env fs st' rf := by
  exact {
    runBundle := principalRowPolyBoundarySoundBundle_runBundleField_of_success h_bundle h_ok
    consequences := principalRowPolyBoundarySoundBundle_fieldRunBundleConsequences_of_success_via_runBundle
      h_bundle h_ok
  }

/--
Build the boundary+sound no-unify expression route pair from one successful
no-unify expression run.
-/
theorem principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundNoUnifyExprRunBundleRoutes st fuel env e st' ty := by
  exact {
    runBundle := principalRowPolyBoundarySoundBundle_runBundleExpr_of_success_noUnify
      h_bundle h_no h_ok
    consequences := principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleConsequences_of_success_via_runBundle
      h_bundle h_no h_ok
  }

/--
Build the boundary+sound no-unify field route pair from one successful no-unify
field run.
-/
theorem principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldRunBundleRoutes st fuel env fs st' rf := by
  exact {
    runBundle := principalRowPolyBoundarySoundBundle_runBundleField_of_success_noUnify
      h_bundle h_no h_ok
    consequences := principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleConsequences_of_success_via_runBundle
      h_bundle h_no h_ok
  }

/--
Direct hook-seeded entrypoint for arbitrary-success expression route pairs on
the boundary+sound capstone surface.
-/
theorem principalBoundarySoundExprRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundExprRunBundleRoutes st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_exprRunBundleRoutes_of_success
    (principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj) h_ok

/--
Direct hook-seeded entrypoint for arbitrary-success field route pairs on the
boundary+sound capstone surface.
-/
theorem principalBoundarySoundFieldRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldRunBundleRoutes st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_fieldRunBundleRoutes_of_success
    (principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj) h_ok

/--
Direct hook-seeded entrypoint for no-unify expression route pairs on the
boundary+sound capstone surface.
-/
theorem principalBoundarySoundNoUnifyExprRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundNoUnifyExprRunBundleRoutes st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleRoutes_of_success
    (principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj) h_no h_ok

/--
Direct hook-seeded entrypoint for no-unify field route pairs on the
boundary+sound capstone surface.
-/
theorem principalBoundarySoundNoUnifyFieldRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldRunBundleRoutes st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleRoutes_of_success
    (principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj) h_no h_ok

/--
Bundled-hook entrypoint for arbitrary-success expression route pairs on the
boundary+sound capstone surface.
-/
theorem principalBoundarySoundExprRunBundleRoutes_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundExprRunBundleRoutes st fuel env e st' ty :=
  principalBoundarySoundExprRunBundleRoutes_of_success
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/--
Bundled-hook entrypoint for arbitrary-success field route pairs on the
boundary+sound capstone surface.
-/
theorem principalBoundarySoundFieldRunBundleRoutes_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldRunBundleRoutes st fuel env fs st' rf :=
  principalBoundarySoundFieldRunBundleRoutes_of_success
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/--
Bundled-hook entrypoint for no-unify expression route pairs on the
boundary+sound capstone surface.
-/
theorem principalBoundarySoundNoUnifyExprRunBundleRoutes_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundNoUnifyExprRunBundleRoutes st fuel env e st' ty :=
  principalBoundarySoundNoUnifyExprRunBundleRoutes_of_success
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/--
Bundled-hook entrypoint for no-unify field route pairs on the boundary+sound
capstone surface.
-/
theorem principalBoundarySoundNoUnifyFieldRunBundleRoutes_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldRunBundleRoutes st fuel env fs st' rf :=
  principalBoundarySoundNoUnifyFieldRunBundleRoutes_of_success
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- One-hop projection of the arbitrary-success expression run-bundle witness from a boundary+sound route pair. -/
theorem principalBoundarySoundExprRunBundleRoutes_runBundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_routes : PrincipalBoundarySoundExprRunBundleRoutes st fuel env e st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  h_routes.runBundle

/-- One-hop projection of the arbitrary-success expression consequence witness from a boundary+sound route pair. -/
theorem principalBoundarySoundExprRunBundleRoutes_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_routes : PrincipalBoundarySoundExprRunBundleRoutes st fuel env e st' ty) :
    PrincipalExprRunBundleConsequences st fuel env e st' ty :=
  h_routes.consequences

/-- One-hop projection of the arbitrary-success field run-bundle witness from a boundary+sound route pair. -/
theorem principalBoundarySoundFieldRunBundleRoutes_runBundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFieldRunBundleRoutes st fuel env fs st' rf) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  h_routes.runBundle

/-- One-hop projection of the arbitrary-success field consequence witness from a boundary+sound route pair. -/
theorem principalBoundarySoundFieldRunBundleRoutes_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFieldRunBundleRoutes st fuel env fs st' rf) :
    PrincipalFieldRunBundleConsequences st fuel env fs st' rf :=
  h_routes.consequences

/-- One-hop projection of the no-unify expression run-bundle witness from a boundary+sound route pair. -/
theorem principalBoundarySoundNoUnifyExprRunBundleRoutes_runBundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_routes : PrincipalBoundarySoundNoUnifyExprRunBundleRoutes st fuel env e st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  h_routes.runBundle

/-- One-hop projection of the no-unify expression consequence witness from a boundary+sound route pair. -/
theorem principalBoundarySoundNoUnifyExprRunBundleRoutes_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_routes : PrincipalBoundarySoundNoUnifyExprRunBundleRoutes st fuel env e st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  h_routes.consequences

/-- One-hop projection of the no-unify field run-bundle witness from a boundary+sound route pair. -/
theorem principalBoundarySoundNoUnifyFieldRunBundleRoutes_runBundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFieldRunBundleRoutes st fuel env fs st' rf) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  h_routes.runBundle

/-- One-hop projection of the no-unify field consequence witness from a boundary+sound route pair. -/
theorem principalBoundarySoundNoUnifyFieldRunBundleRoutes_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFieldRunBundleRoutes st fuel env fs st' rf) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  h_routes.consequences

/--
Boundary+sound expression typing route package for arbitrary successful runs:
recursive soundness (`HasType`/`HasTypeU`) plus the run-bundle route pair.
-/
structure PrincipalBoundarySoundExprTypingRunBundleRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  hasType : HasType env e ty
  hasTypeU : HasTypeU env e ty
  routes : PrincipalBoundarySoundExprRunBundleRoutes st fuel env e st' ty

/--
Boundary+sound field typing route package for arbitrary successful runs:
recursive soundness (`HasFieldsType`/`HasFieldsTypeU`) plus the run-bundle
route pair.
-/
structure PrincipalBoundarySoundFieldTypingRunBundleRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  hasType : HasFieldsType env fs rf
  hasTypeU : HasFieldsTypeU env fs rf
  routes : PrincipalBoundarySoundFieldRunBundleRoutes st fuel env fs st' rf

/--
Boundary+sound no-unify expression typing route package: recursive soundness
(`HasType`/`HasTypeU`) plus the no-unify run-bundle route pair.
-/
structure PrincipalBoundarySoundNoUnifyExprTypingRunBundleRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  hasType : HasType env e ty
  hasTypeU : HasTypeU env e ty
  routes : PrincipalBoundarySoundNoUnifyExprRunBundleRoutes st fuel env e st' ty

/--
Boundary+sound no-unify field typing route package: recursive soundness
(`HasFieldsType`/`HasFieldsTypeU`) plus the no-unify run-bundle route pair.
-/
structure PrincipalBoundarySoundNoUnifyFieldTypingRunBundleRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  hasType : HasFieldsType env fs rf
  hasTypeU : HasFieldsTypeU env fs rf
  routes : PrincipalBoundarySoundNoUnifyFieldRunBundleRoutes st fuel env fs st' rf

/--
Build the boundary+sound expression typing route package from one arbitrary
successful run.
-/
theorem principalRowPolyBoundarySoundBundle_exprTypingRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundExprTypingRunBundleRoutes st fuel env e st' ty := by
  exact {
    hasType := principalRowPolyBoundarySoundBundle_expr_hasType h_bundle h_ok
    hasTypeU := principalRowPolyBoundarySoundBundle_expr_hasTypeU h_bundle h_ok
    routes := principalRowPolyBoundarySoundBundle_exprRunBundleRoutes_of_success h_bundle h_ok
  }

/--
Build the boundary+sound field typing route package from one arbitrary
successful field run.
-/
theorem principalRowPolyBoundarySoundBundle_fieldTypingRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldTypingRunBundleRoutes st fuel env fs st' rf := by
  exact {
    hasType := principalRowPolyBoundarySoundBundle_field_hasType h_bundle h_ok
    hasTypeU := principalRowPolyBoundarySoundBundle_field_hasTypeU h_bundle h_ok
    routes := principalRowPolyBoundarySoundBundle_fieldRunBundleRoutes_of_success h_bundle h_ok
  }

/--
Build the boundary+sound no-unify expression typing route package from one
successful no-unify expression run.
-/
theorem principalRowPolyBoundarySoundBundle_noUnifyExprTypingRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundNoUnifyExprTypingRunBundleRoutes st fuel env e st' ty := by
  exact {
    hasType := principalRowPolyBoundarySoundBundle_expr_hasType h_bundle h_ok
    hasTypeU := principalRowPolyBoundarySoundBundle_expr_hasTypeU h_bundle h_ok
    routes := principalRowPolyBoundarySoundBundle_noUnifyExprRunBundleRoutes_of_success
      h_bundle h_no h_ok
  }

/--
Build the boundary+sound no-unify field typing route package from one
successful no-unify field run.
-/
theorem principalRowPolyBoundarySoundBundle_noUnifyFieldTypingRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldTypingRunBundleRoutes st fuel env fs st' rf := by
  exact {
    hasType := principalRowPolyBoundarySoundBundle_field_hasType h_bundle h_ok
    hasTypeU := principalRowPolyBoundarySoundBundle_field_hasTypeU h_bundle h_ok
    routes := principalRowPolyBoundarySoundBundle_noUnifyFieldRunBundleRoutes_of_success
      h_bundle h_no h_ok
  }

/--
Direct hook-seeded entrypoint for arbitrary-success expression typing+route
packages on the boundary+sound capstone surface.
-/
theorem principalBoundarySoundExprTypingRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundExprTypingRunBundleRoutes st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_exprTypingRunBundleRoutes_of_success
    (principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj) h_ok

/--
Direct hook-seeded entrypoint for arbitrary-success field typing+route packages
on the boundary+sound capstone surface.
-/
theorem principalBoundarySoundFieldTypingRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldTypingRunBundleRoutes st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_fieldTypingRunBundleRoutes_of_success
    (principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj) h_ok

/--
Direct hook-seeded entrypoint for no-unify expression typing+route packages on
the boundary+sound capstone surface.
-/
theorem principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundNoUnifyExprTypingRunBundleRoutes st fuel env e st' ty :=
  principalRowPolyBoundarySoundBundle_noUnifyExprTypingRunBundleRoutes_of_success
    (principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj) h_no h_ok

/--
Direct hook-seeded entrypoint for no-unify field typing+route packages on the
boundary+sound capstone surface.
-/
theorem principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldTypingRunBundleRoutes st fuel env fs st' rf :=
  principalRowPolyBoundarySoundBundle_noUnifyFieldTypingRunBundleRoutes_of_success
    (principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj) h_no h_ok

/--
Bundled-hook entrypoint for arbitrary-success expression typing+route packages
on the boundary+sound capstone surface.
-/
theorem principalBoundarySoundExprTypingRunBundleRoutes_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundExprTypingRunBundleRoutes st fuel env e st' ty :=
  principalBoundarySoundExprTypingRunBundleRoutes_of_success
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/--
Bundled-hook entrypoint for arbitrary-success field typing+route packages on
the boundary+sound capstone surface.
-/
theorem principalBoundarySoundFieldTypingRunBundleRoutes_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldTypingRunBundleRoutes st fuel env fs st' rf :=
  principalBoundarySoundFieldTypingRunBundleRoutes_of_success
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/--
Bundled-hook entrypoint for no-unify expression typing+route packages on the
boundary+sound capstone surface.
-/
theorem principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundNoUnifyExprTypingRunBundleRoutes st fuel env e st' ty :=
  principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_of_success
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/--
Bundled-hook entrypoint for no-unify field typing+route packages on the
boundary+sound capstone surface.
-/
theorem principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_of_success_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldTypingRunBundleRoutes st fuel env fs st' rf :=
  principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_of_success
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- One-hop projection of `HasType` from an arbitrary-success expression typing+route package. -/
theorem principalBoundarySoundExprTypingRunBundleRoutes_hasType
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_pkg : PrincipalBoundarySoundExprTypingRunBundleRoutes st fuel env e st' ty) :
    HasType env e ty :=
  h_pkg.hasType

/-- One-hop projection of `HasTypeU` from an arbitrary-success expression typing+route package. -/
theorem principalBoundarySoundExprTypingRunBundleRoutes_hasTypeU
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_pkg : PrincipalBoundarySoundExprTypingRunBundleRoutes st fuel env e st' ty) :
    HasTypeU env e ty :=
  h_pkg.hasTypeU

/-- One-hop projection of the route pair from an arbitrary-success expression typing+route package. -/
theorem principalBoundarySoundExprTypingRunBundleRoutes_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_pkg : PrincipalBoundarySoundExprTypingRunBundleRoutes st fuel env e st' ty) :
    PrincipalBoundarySoundExprRunBundleRoutes st fuel env e st' ty :=
  h_pkg.routes

/-- One-hop projection of `HasFieldsType` from an arbitrary-success field typing+route package. -/
theorem principalBoundarySoundFieldTypingRunBundleRoutes_hasType
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_pkg : PrincipalBoundarySoundFieldTypingRunBundleRoutes st fuel env fs st' rf) :
    HasFieldsType env fs rf :=
  h_pkg.hasType

/-- One-hop projection of `HasFieldsTypeU` from an arbitrary-success field typing+route package. -/
theorem principalBoundarySoundFieldTypingRunBundleRoutes_hasTypeU
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_pkg : PrincipalBoundarySoundFieldTypingRunBundleRoutes st fuel env fs st' rf) :
    HasFieldsTypeU env fs rf :=
  h_pkg.hasTypeU

/-- One-hop projection of the route pair from an arbitrary-success field typing+route package. -/
theorem principalBoundarySoundFieldTypingRunBundleRoutes_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_pkg : PrincipalBoundarySoundFieldTypingRunBundleRoutes st fuel env fs st' rf) :
    PrincipalBoundarySoundFieldRunBundleRoutes st fuel env fs st' rf :=
  h_pkg.routes

/-- One-hop projection of `HasType` from a no-unify expression typing+route package. -/
theorem principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_hasType
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_pkg : PrincipalBoundarySoundNoUnifyExprTypingRunBundleRoutes st fuel env e st' ty) :
    HasType env e ty :=
  h_pkg.hasType

/-- One-hop projection of `HasTypeU` from a no-unify expression typing+route package. -/
theorem principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_hasTypeU
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_pkg : PrincipalBoundarySoundNoUnifyExprTypingRunBundleRoutes st fuel env e st' ty) :
    HasTypeU env e ty :=
  h_pkg.hasTypeU

/-- One-hop projection of the route pair from a no-unify expression typing+route package. -/
theorem principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_pkg : PrincipalBoundarySoundNoUnifyExprTypingRunBundleRoutes st fuel env e st' ty) :
    PrincipalBoundarySoundNoUnifyExprRunBundleRoutes st fuel env e st' ty :=
  h_pkg.routes

/-- One-hop projection of `HasFieldsType` from a no-unify field typing+route package. -/
theorem principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_hasType
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_pkg : PrincipalBoundarySoundNoUnifyFieldTypingRunBundleRoutes st fuel env fs st' rf) :
    HasFieldsType env fs rf :=
  h_pkg.hasType

/-- One-hop projection of `HasFieldsTypeU` from a no-unify field typing+route package. -/
theorem principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_hasTypeU
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_pkg : PrincipalBoundarySoundNoUnifyFieldTypingRunBundleRoutes st fuel env fs st' rf) :
    HasFieldsTypeU env fs rf :=
  h_pkg.hasTypeU

/-- One-hop projection of the route pair from a no-unify field typing+route package. -/
theorem principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_pkg : PrincipalBoundarySoundNoUnifyFieldTypingRunBundleRoutes st fuel env fs st' rf) :
    PrincipalBoundarySoundNoUnifyFieldRunBundleRoutes st fuel env fs st' rf :=
  h_pkg.routes

/--
Hook-parameterized suite for the boundary+sound typing+run-bundle-route
surface, aggregating arbitrary-success and no-unify expression/field packages.
-/
structure PrincipalBoundarySoundTypingRunBundleSuite
    (h_app : AppUnifySoundHook) (h_proj : ProjUnifySoundHook) : Prop where
  expr :
    ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
      {st' : UnifyState} {ty : Ty},
      inferExprUnify st fuel env e = .ok st' ty →
      PrincipalBoundarySoundExprTypingRunBundleRoutes st fuel env e st' ty
  field :
    ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
      {st' : UnifyState} {rf : RowFields},
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      PrincipalBoundarySoundFieldTypingRunBundleRoutes st fuel env fs st' rf
  noUnifyExpr :
    ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
      {st' : UnifyState} {ty : Ty},
      NoUnifyBranchesExpr e →
      inferExprUnify st fuel env e = .ok st' ty →
      PrincipalBoundarySoundNoUnifyExprTypingRunBundleRoutes st fuel env e st' ty
  noUnifyField :
    ∀ {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
      {st' : UnifyState} {rf : RowFields},
      NoUnifyBranchesFields fs →
      inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)) →
      PrincipalBoundarySoundNoUnifyFieldTypingRunBundleRoutes st fuel env fs st' rf

/-- Explicit component alias for `PrincipalBoundarySoundTypingRunBundleSuite`. -/
abbrev PrincipalBoundarySoundTypingRunBundleSuiteComponents
    (h_app : AppUnifySoundHook) (h_proj : ProjUnifySoundHook) : Prop :=
  PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj

/-- `PrincipalBoundarySoundTypingRunBundleSuite` equals its components alias. -/
theorem principalBoundarySoundTypingRunBundleSuite_iff_components
    (h_app : AppUnifySoundHook) (h_proj : ProjUnifySoundHook) :
    PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj
      ↔ PrincipalBoundarySoundTypingRunBundleSuiteComponents h_app h_proj := by
  constructor <;> intro h <;>
    simpa [PrincipalBoundarySoundTypingRunBundleSuiteComponents] using h

/-- Build typing+run-bundle suite from components alias. -/
theorem principalBoundarySoundTypingRunBundleSuite_of_components
    (h_app : AppUnifySoundHook) (h_proj : ProjUnifySoundHook)
    (h_comp : PrincipalBoundarySoundTypingRunBundleSuiteComponents h_app h_proj) :
    PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj := by
  simpa [PrincipalBoundarySoundTypingRunBundleSuiteComponents] using h_comp

/-- Decompose typing+run-bundle suite into components alias. -/
theorem principalBoundarySoundTypingRunBundleSuite_as_components
    (h_app : AppUnifySoundHook) (h_proj : ProjUnifySoundHook)
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj) :
    PrincipalBoundarySoundTypingRunBundleSuiteComponents h_app h_proj := by
  simpa [PrincipalBoundarySoundTypingRunBundleSuiteComponents] using h_suite

/-- Direct components-route decomposition for typing+run-bundle suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_as_components_of_components
    (h_app : AppUnifySoundHook) (h_proj : ProjUnifySoundHook)
    (h_comp : PrincipalBoundarySoundTypingRunBundleSuiteComponents h_app h_proj) :
    PrincipalBoundarySoundTypingRunBundleSuiteComponents h_app h_proj := by
  simpa using h_comp

/--
Construct the boundary+sound typing+run-bundle-route suite directly from hook
premises.
-/
theorem principalBoundarySoundTypingRunBundleSuite_of_hooks
    (h_app : AppUnifySoundHook) (h_proj : ProjUnifySoundHook) :
    PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj := by
  refine {
    expr := ?_
    field := ?_
    noUnifyExpr := ?_
    noUnifyField := ?_
  }
  · intro st fuel env e st' ty h_ok
    exact principalBoundarySoundExprTypingRunBundleRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok
  · intro st fuel env fs st' rf h_ok
    exact principalBoundarySoundFieldTypingRunBundleRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok
  · intro st fuel env e st' ty h_no h_ok
    exact principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_no h_ok
  · intro st fuel env fs st' rf h_no h_ok
    exact principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_no h_ok

/-- Direct route decomposition from `of_hooks` into typing-run-bundle components. -/
theorem principalBoundarySoundTypingRunBundleSuite_as_components_of_hooks
    (h_app : AppUnifySoundHook) (h_proj : ProjUnifySoundHook) :
    PrincipalBoundarySoundTypingRunBundleSuiteComponents h_app h_proj :=
  principalBoundarySoundTypingRunBundleSuite_as_components h_app h_proj
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj)

/--
Bundled-hook constructor for the boundary+sound typing+run-bundle-route suite.
-/
theorem principalBoundarySoundTypingRunBundleSuite_of_hook_bundle
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundarySoundTypingRunBundleSuite h_hooks.1 h_hooks.2 :=
  principalBoundarySoundTypingRunBundleSuite_of_hooks h_hooks.1 h_hooks.2

/-- Direct route decomposition from bundled-hook typing-run-bundle constructor. -/
theorem principalBoundarySoundTypingRunBundleSuite_as_components_of_hook_bundle
    (h_hooks : UnifyHookPremises) :
    PrincipalBoundarySoundTypingRunBundleSuiteComponents h_hooks.1 h_hooks.2 :=
  principalBoundarySoundTypingRunBundleSuite_as_components h_hooks.1 h_hooks.2
    (principalBoundarySoundTypingRunBundleSuite_of_hook_bundle h_hooks)

/-- One-hop projection: arbitrary-success expression package from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_expr
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundExprTypingRunBundleRoutes st fuel env e st' ty :=
  h_suite.expr h_ok

/-- One-hop projection: arbitrary-success field package from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_field
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldTypingRunBundleRoutes st fuel env fs st' rf :=
  h_suite.field h_ok

/-- One-hop projection: no-unify expression package from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyExpr
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundNoUnifyExprTypingRunBundleRoutes st fuel env e st' ty :=
  h_suite.noUnifyExpr h_no h_ok

/-- One-hop projection: no-unify field package from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyField
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldTypingRunBundleRoutes st fuel env fs st' rf :=
  h_suite.noUnifyField h_no h_ok

/-- Suite wrapper: arbitrary-success expression `HasType` from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_expr_hasType
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasType env e ty :=
  principalBoundarySoundExprTypingRunBundleRoutes_hasType
    (principalBoundarySoundTypingRunBundleSuite_expr h_suite h_ok)

/-- Suite wrapper: arbitrary-success expression `HasTypeU` from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_expr_hasTypeU
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasTypeU env e ty :=
  principalBoundarySoundExprTypingRunBundleRoutes_hasTypeU
    (principalBoundarySoundTypingRunBundleSuite_expr h_suite h_ok)

/-- Suite wrapper: arbitrary-success field `HasFieldsType` from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_field_hasType
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsType env fs rf :=
  principalBoundarySoundFieldTypingRunBundleRoutes_hasType
    (principalBoundarySoundTypingRunBundleSuite_field h_suite h_ok)

/-- Suite wrapper: arbitrary-success field `HasFieldsTypeU` from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_field_hasTypeU
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsTypeU env fs rf :=
  principalBoundarySoundFieldTypingRunBundleRoutes_hasTypeU
    (principalBoundarySoundTypingRunBundleSuite_field h_suite h_ok)

/-- Suite wrapper: no-unify expression `HasType` from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_hasType
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasType env e ty :=
  principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_hasType
    (principalBoundarySoundTypingRunBundleSuite_noUnifyExpr h_suite h_no h_ok)

/-- Suite wrapper: no-unify expression `HasTypeU` from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_hasTypeU
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasTypeU env e ty :=
  principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_hasTypeU
    (principalBoundarySoundTypingRunBundleSuite_noUnifyExpr h_suite h_no h_ok)

/-- Suite wrapper: no-unify field `HasFieldsType` from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyField_hasType
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsType env fs rf :=
  principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_hasType
    (principalBoundarySoundTypingRunBundleSuite_noUnifyField h_suite h_no h_ok)

/-- Suite wrapper: no-unify field `HasFieldsTypeU` from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyField_hasTypeU
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsTypeU env fs rf :=
  principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_hasTypeU
    (principalBoundarySoundTypingRunBundleSuite_noUnifyField h_suite h_no h_ok)

/-- Suite wrapper: arbitrary-success expression core principality from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_expr_core_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  (principalBoundarySoundExprRunBundleRoutes_consequences
    (principalBoundarySoundExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_expr h_suite h_ok))).core

/-- Suite wrapper: arbitrary-success field core principality from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_field_core_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalBoundarySoundFieldRunBundleRoutes_consequences
    (principalBoundarySoundFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_field h_suite h_ok))).core

/-- Suite wrapper: no-unify expression core principality from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_core_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  (principalBoundarySoundNoUnifyExprRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyExpr h_suite h_no h_ok))).core

/-- Suite wrapper: no-unify field core principality from the typing-route suite. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyField_core_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  (principalBoundarySoundNoUnifyFieldRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyField h_suite h_no h_ok))).core

/-- Suite wrapper: arbitrary-success expression any-hooks preconditioned principality. -/
theorem principalBoundarySoundTypingRunBundleSuite_expr_preconditioned_anyHooks_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  (principalBoundarySoundExprRunBundleRoutes_consequences
    (principalBoundarySoundExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_expr h_suite h_ok))).preconditionedAny

/-- Suite wrapper: arbitrary-success field any-hooks preconditioned principality. -/
theorem principalBoundarySoundTypingRunBundleSuite_field_preconditioned_anyHooks_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  (principalBoundarySoundFieldRunBundleRoutes_consequences
    (principalBoundarySoundFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_field h_suite h_ok))).preconditionedAny

/-- Suite wrapper: no-unify expression any-hooks preconditioned principality. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_preconditioned_anyHooks_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  (principalBoundarySoundNoUnifyExprRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyExpr h_suite h_no h_ok))).preconditionedAny

/-- Suite wrapper: no-unify field any-hooks preconditioned principality. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyField_preconditioned_anyHooks_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  (principalBoundarySoundNoUnifyFieldRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyField h_suite h_no h_ok))).preconditionedAny

/-- Suite wrapper: arbitrary-success expression bundled-hook preconditioned principality. -/
theorem principalBoundarySoundTypingRunBundleSuite_expr_preconditioned_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  (principalBoundarySoundExprRunBundleRoutes_consequences
    (principalBoundarySoundExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_expr h_suite h_ok))).preconditioned h_hooks

/-- Suite wrapper: arbitrary-success field bundled-hook preconditioned principality. -/
theorem principalBoundarySoundTypingRunBundleSuite_field_preconditioned_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  (principalBoundarySoundFieldRunBundleRoutes_consequences
    (principalBoundarySoundFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_field h_suite h_ok))).preconditioned h_hooks

/-- Suite wrapper: no-unify expression bundled-hook preconditioned principality. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_preconditioned_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  (principalBoundarySoundNoUnifyExprRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyExpr h_suite h_no h_ok))).preconditioned h_hooks

/-- Suite wrapper: no-unify field bundled-hook preconditioned principality. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyField_preconditioned_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  (principalBoundarySoundNoUnifyFieldRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyField h_suite h_no h_ok))).preconditioned h_hooks

/-- Suite wrapper: arbitrary-success expression any-hooks `preconditioned ↔ core`. -/
theorem principalBoundarySoundTypingRunBundleSuite_expr_preconditionedCoreIff_anyHooks_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  (principalBoundarySoundExprRunBundleRoutes_consequences
    (principalBoundarySoundExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_expr h_suite h_ok))).preconditionedAnyIffCore

/-- Suite wrapper: arbitrary-success field any-hooks `preconditioned ↔ core`. -/
theorem principalBoundarySoundTypingRunBundleSuite_field_preconditionedCoreIff_anyHooks_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalBoundarySoundFieldRunBundleRoutes_consequences
    (principalBoundarySoundFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_field h_suite h_ok))).preconditionedAnyIffCore

/-- Suite wrapper: no-unify expression any-hooks `preconditioned ↔ core`. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_preconditionedCoreIff_anyHooks_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  (principalBoundarySoundNoUnifyExprRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyExpr h_suite h_no h_ok))).preconditionedAnyIffCore

/-- Suite wrapper: no-unify field any-hooks `preconditioned ↔ core`. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyField_preconditionedCoreIff_anyHooks_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalBoundarySoundNoUnifyFieldRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyField h_suite h_no h_ok))).preconditionedAnyIffCore

/-- Suite wrapper: arbitrary-success expression bundled-hook `preconditioned ↔ core`. -/
theorem principalBoundarySoundTypingRunBundleSuite_expr_preconditionedCoreIff_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalBoundarySoundExprRunBundleRoutes_consequences
    (principalBoundarySoundExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_expr h_suite h_ok))).preconditionedIffCore h_hooks

/-- Suite wrapper: arbitrary-success field bundled-hook `preconditioned ↔ core`. -/
theorem principalBoundarySoundTypingRunBundleSuite_field_preconditionedCoreIff_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalBoundarySoundFieldRunBundleRoutes_consequences
    (principalBoundarySoundFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_field h_suite h_ok))).preconditionedIffCore h_hooks

/-- Suite wrapper: no-unify expression bundled-hook `preconditioned ↔ core`. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_preconditionedCoreIff_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  (principalBoundarySoundNoUnifyExprRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyExpr h_suite h_no h_ok))).preconditionedIffCore h_hooks

/-- Suite wrapper: no-unify field bundled-hook `preconditioned ↔ core`. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyField_preconditionedCoreIff_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  (principalBoundarySoundNoUnifyFieldRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyField h_suite h_no h_ok))).preconditionedIffCore h_hooks

/-- Suite wrapper: arbitrary-success expression fixed-run hook-irrelevance. -/
theorem principalBoundarySoundTypingRunBundleSuite_expr_hookIrrelevant_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalBoundarySoundExprRunBundleRoutes_consequences
    (principalBoundarySoundExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_expr h_suite h_ok))).hookIrrelevant

/-- Suite wrapper: arbitrary-success field fixed-run hook-irrelevance. -/
theorem principalBoundarySoundTypingRunBundleSuite_field_hookIrrelevant_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalBoundarySoundFieldRunBundleRoutes_consequences
    (principalBoundarySoundFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_field h_suite h_ok))).hookIrrelevant

/-- Suite wrapper: no-unify expression fixed-run hook-irrelevance. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_hookIrrelevant_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  (principalBoundarySoundNoUnifyExprRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyExprTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyExpr h_suite h_no h_ok))).hookIrrelevant

/-- Suite wrapper: no-unify field fixed-run hook-irrelevance. -/
theorem principalBoundarySoundTypingRunBundleSuite_noUnifyField_hookIrrelevant_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_suite : PrincipalBoundarySoundTypingRunBundleSuite h_app h_proj)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  (principalBoundarySoundNoUnifyFieldRunBundleRoutes_consequences
    (principalBoundarySoundNoUnifyFieldTypingRunBundleRoutes_routes
      (principalBoundarySoundTypingRunBundleSuite_noUnifyField h_suite h_no h_ok))).hookIrrelevant

/-- Direct hook-seeded expression `HasType` wrapper via the typing-route suite. -/
theorem principalBoundarySoundExpr_hasType_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasType env e ty :=
  principalBoundarySoundTypingRunBundleSuite_expr_hasType
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded field `HasFieldsType` wrapper via the typing-route suite. -/
theorem principalBoundarySoundField_hasType_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsType env fs rf :=
  principalBoundarySoundTypingRunBundleSuite_field_hasType
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded expression `HasTypeU` wrapper via the typing-route suite. -/
theorem principalBoundarySoundExpr_hasTypeU_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasTypeU env e ty :=
  principalBoundarySoundTypingRunBundleSuite_expr_hasTypeU
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded field `HasFieldsTypeU` wrapper via the typing-route suite. -/
theorem principalBoundarySoundField_hasTypeU_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsTypeU env fs rf :=
  principalBoundarySoundTypingRunBundleSuite_field_hasTypeU
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded no-unify expression `HasType` wrapper via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_hasType_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasType env e ty :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_hasType
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Direct hook-seeded no-unify field `HasFieldsType` wrapper via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_hasType_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsType env fs rf :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyField_hasType
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Direct hook-seeded no-unify expression `HasTypeU` wrapper via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_hasTypeU_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasTypeU env e ty :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_hasTypeU
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Direct hook-seeded no-unify field `HasFieldsTypeU` wrapper via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_hasTypeU_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsTypeU env fs rf :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyField_hasTypeU
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Direct hook-seeded expression core principality wrapper via the typing-route suite. -/
theorem principalBoundarySoundExpr_core_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalBoundarySoundTypingRunBundleSuite_expr_core_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded field core principality wrapper via the typing-route suite. -/
theorem principalBoundarySoundField_core_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalBoundarySoundTypingRunBundleSuite_field_core_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded no-unify expression core principality wrapper via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_core_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_core_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Direct hook-seeded no-unify field core principality wrapper via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_core_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyField_core_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Bundled-hook alias for expression `HasType` via the typing-route suite. -/
theorem principalBoundarySoundExpr_hasType_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasType env e ty :=
  principalBoundarySoundExpr_hasType_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for field `HasFieldsType` via the typing-route suite. -/
theorem principalBoundarySoundField_hasType_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsType env fs rf :=
  principalBoundarySoundField_hasType_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for expression `HasTypeU` via the typing-route suite. -/
theorem principalBoundarySoundExpr_hasTypeU_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasTypeU env e ty :=
  principalBoundarySoundExpr_hasTypeU_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for field `HasFieldsTypeU` via the typing-route suite. -/
theorem principalBoundarySoundField_hasTypeU_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsTypeU env fs rf :=
  principalBoundarySoundField_hasTypeU_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for no-unify expression `HasType` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_hasType_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasType env e ty :=
  principalBoundarySoundNoUnifyExpr_hasType_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Bundled-hook alias for no-unify field `HasFieldsType` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_hasType_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsType env fs rf :=
  principalBoundarySoundNoUnifyField_hasType_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Bundled-hook alias for no-unify expression `HasTypeU` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_hasTypeU_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    HasTypeU env e ty :=
  principalBoundarySoundNoUnifyExpr_hasTypeU_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Bundled-hook alias for no-unify field `HasFieldsTypeU` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_hasTypeU_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    HasFieldsTypeU env fs rf :=
  principalBoundarySoundNoUnifyField_hasTypeU_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Bundled-hook alias for expression core principality via the typing-route suite. -/
theorem principalBoundarySoundExpr_core_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalBoundarySoundExpr_core_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for field core principality via the typing-route suite. -/
theorem principalBoundarySoundField_core_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalBoundarySoundField_core_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for no-unify expression core principality via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_core_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalBoundarySoundNoUnifyExpr_core_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Bundled-hook alias for no-unify field core principality via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_core_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalBoundarySoundNoUnifyField_core_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Direct hook-seeded expression any-hooks preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundExpr_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalBoundarySoundTypingRunBundleSuite_expr_preconditioned_anyHooks_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded field any-hooks preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundField_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalBoundarySoundTypingRunBundleSuite_field_preconditioned_anyHooks_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded no-unify expression any-hooks preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_preconditioned_anyHooks_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Direct hook-seeded no-unify field any-hooks preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyField_preconditioned_anyHooks_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Direct hook-seeded expression bundled-hook preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundExpr_preconditioned_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalBoundarySoundTypingRunBundleSuite_expr_preconditioned_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_hooks h_ok

/-- Direct hook-seeded field bundled-hook preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundField_preconditioned_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalBoundarySoundTypingRunBundleSuite_field_preconditioned_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_hooks h_ok

/-- Direct hook-seeded no-unify expression bundled-hook preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_preconditioned_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_preconditioned_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_hooks h_no h_ok

/-- Direct hook-seeded no-unify field bundled-hook preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_preconditioned_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyField_preconditioned_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_hooks h_no h_ok

/-- Direct hook-seeded expression any-hooks `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundExpr_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalBoundarySoundTypingRunBundleSuite_expr_preconditionedCoreIff_anyHooks_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded field any-hooks `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundField_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalBoundarySoundTypingRunBundleSuite_field_preconditionedCoreIff_anyHooks_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded no-unify expression any-hooks `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_preconditionedCoreIff_anyHooks_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Direct hook-seeded no-unify field any-hooks `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyField_preconditionedCoreIff_anyHooks_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Direct hook-seeded expression bundled-hook `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundExpr_preconditionedCoreIff_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalBoundarySoundTypingRunBundleSuite_expr_preconditionedCoreIff_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_hooks h_ok

/-- Direct hook-seeded field bundled-hook `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundField_preconditionedCoreIff_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalBoundarySoundTypingRunBundleSuite_field_preconditionedCoreIff_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_hooks h_ok

/-- Direct hook-seeded no-unify expression bundled-hook `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_preconditionedCoreIff_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_preconditionedCoreIff_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_hooks h_no h_ok

/-- Direct hook-seeded no-unify field bundled-hook `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_preconditionedCoreIff_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyField_preconditionedCoreIff_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_hooks h_no h_ok

/-- Direct hook-seeded expression fixed-run hook-irrelevance via the typing-route suite. -/
theorem principalBoundarySoundExpr_hookIrrelevant_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalBoundarySoundTypingRunBundleSuite_expr_hookIrrelevant_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded field fixed-run hook-irrelevance via the typing-route suite. -/
theorem principalBoundarySoundField_hookIrrelevant_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalBoundarySoundTypingRunBundleSuite_field_hookIrrelevant_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_ok

/-- Direct hook-seeded no-unify expression fixed-run hook-irrelevance via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_hookIrrelevant_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyExpr_hookIrrelevant_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Direct hook-seeded no-unify field fixed-run hook-irrelevance via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_hookIrrelevant_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalBoundarySoundTypingRunBundleSuite_noUnifyField_hookIrrelevant_of_success
    (principalBoundarySoundTypingRunBundleSuite_of_hooks h_app h_proj) h_no h_ok

/-- Bundled-hook alias for expression any-hooks preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundExpr_preconditioned_anyHooks_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalBoundarySoundExpr_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for field any-hooks preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundField_preconditioned_anyHooks_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalBoundarySoundField_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for no-unify expression any-hooks preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_preconditioned_anyHooks_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty :=
  principalBoundarySoundNoUnifyExpr_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Bundled-hook alias for no-unify field any-hooks preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_preconditioned_anyHooks_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf :=
  principalBoundarySoundNoUnifyField_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Bundled-hook alias for expression bundled-hook preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundExpr_preconditioned_of_success_via_typingRunBundleSuite_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalBoundarySoundExpr_preconditioned_of_success_via_typingRunBundleSuite
    (h_app := h_app) (h_proj := h_proj) h_hooks h_ok

/-- Bundled-hook alias for field bundled-hook preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundField_preconditioned_of_success_via_typingRunBundleSuite_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalBoundarySoundField_preconditioned_of_success_via_typingRunBundleSuite
    (h_app := h_app) (h_proj := h_proj) h_hooks h_ok

/-- Bundled-hook alias for no-unify expression bundled-hook preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_preconditioned_of_success_via_typingRunBundleSuite_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalBoundarySoundNoUnifyExpr_preconditioned_of_success_via_typingRunBundleSuite
    (h_app := h_app) (h_proj := h_proj) h_hooks h_no h_ok

/-- Bundled-hook alias for no-unify field bundled-hook preconditioned principality via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_preconditioned_of_success_via_typingRunBundleSuite_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalBoundarySoundNoUnifyField_preconditioned_of_success_via_typingRunBundleSuite
    (h_app := h_app) (h_proj := h_proj) h_hooks h_no h_ok

/-- Bundled-hook alias for expression any-hooks `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundExpr_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalBoundarySoundExpr_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for field any-hooks `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundField_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalBoundarySoundField_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for no-unify expression any-hooks `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app' h_proj',
      (PrincipalTypingSlicePreconditioned h_app' h_proj' st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalBoundarySoundNoUnifyExpr_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Bundled-hook alias for no-unify field any-hooks `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app' h_proj',
      (PrincipalFieldTypingSlicePreconditioned h_app' h_proj' st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalBoundarySoundNoUnifyField_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Bundled-hook alias for expression bundled-hook `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundExpr_preconditionedCoreIff_of_success_via_typingRunBundleSuite_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalBoundarySoundExpr_preconditionedCoreIff_of_success_via_typingRunBundleSuite
    (h_app := h_app) (h_proj := h_proj) h_hooks h_ok

/-- Bundled-hook alias for field bundled-hook `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundField_preconditionedCoreIff_of_success_via_typingRunBundleSuite_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalBoundarySoundField_preconditionedCoreIff_of_success_via_typingRunBundleSuite
    (h_app := h_app) (h_proj := h_proj) h_hooks h_ok

/-- Bundled-hook alias for no-unify expression bundled-hook `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_preconditionedCoreIff_of_success_via_typingRunBundleSuite_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalBoundarySoundNoUnifyExpr_preconditionedCoreIff_of_success_via_typingRunBundleSuite
    (h_app := h_app) (h_proj := h_proj) h_hooks h_no h_ok

/-- Bundled-hook alias for no-unify field bundled-hook `preconditioned ↔ core` via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_preconditionedCoreIff_of_success_via_typingRunBundleSuite_from_bundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_hooks : UnifyHookPremises)
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalBoundarySoundNoUnifyField_preconditionedCoreIff_of_success_via_typingRunBundleSuite
    (h_app := h_app) (h_proj := h_proj) h_hooks h_no h_ok

/-- Bundled-hook alias for expression fixed-run hook-irrelevance via the typing-route suite. -/
theorem principalBoundarySoundExpr_hookIrrelevant_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalBoundarySoundExpr_hookIrrelevant_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for field fixed-run hook-irrelevance via the typing-route suite. -/
theorem principalBoundarySoundField_hookIrrelevant_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalBoundarySoundField_hookIrrelevant_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for no-unify expression fixed-run hook-irrelevance via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyExpr_hookIrrelevant_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalBoundarySoundNoUnifyExpr_hookIrrelevant_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Bundled-hook alias for no-unify field fixed-run hook-irrelevance via the typing-route suite. -/
theorem principalBoundarySoundNoUnifyField_hookIrrelevant_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalBoundarySoundNoUnifyField_hookIrrelevant_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/--
Packaged arbitrary-success expression capstone on the direct boundary+sound
typing-suite surface.
-/
structure PrincipalBoundarySoundExprFull
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  hasType : HasType env e ty
  hasTypeU : HasTypeU env e ty
  core : PrincipalTypingSliceCore env e ty
  preconditionedAny :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
  preconditioned :
    ∀ (h_hooks : UnifyHookPremises),
      PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty)
  preconditionedIffCore :
    ∀ (h_hooks : UnifyHookPremises),
      (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty)
  hookIrrelevant :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
        ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)

/--
Packaged arbitrary-success field capstone on the direct boundary+sound
typing-suite surface.
-/
structure PrincipalBoundarySoundFieldFull
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  hasType : HasFieldsType env fs rf
  hasTypeU : HasFieldsTypeU env fs rf
  core : PrincipalFieldTypingSliceCore env fs rf
  preconditionedAny :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
  preconditioned :
    ∀ (h_hooks : UnifyHookPremises),
      PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf)
  preconditionedIffCore :
    ∀ (h_hooks : UnifyHookPremises),
      (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf)
  hookIrrelevant :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
        ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)

/--
Build the packaged arbitrary-success expression capstone from one successful run
via the direct boundary+sound typing-suite surface.
-/
theorem principalBoundarySoundExprFull_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundExprFull st fuel env e st' ty := by
  refine {
    hasType := principalBoundarySoundExpr_hasType_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok
    hasTypeU := principalBoundarySoundExpr_hasTypeU_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok
    core := principalBoundarySoundExpr_core_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app' h_proj'
    exact principalBoundarySoundExpr_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok h_app' h_proj'
  · intro h_hooks
    exact principalBoundarySoundExpr_preconditioned_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_hooks h_ok
  · intro h_app' h_proj'
    exact principalBoundarySoundExpr_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok h_app' h_proj'
  · intro h_hooks
    exact principalBoundarySoundExpr_preconditionedCoreIff_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_hooks h_ok
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalBoundarySoundExpr_hookIrrelevant_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok

/--
Build the packaged arbitrary-success field capstone from one successful field
run via the direct boundary+sound typing-suite surface.
-/
theorem principalBoundarySoundFieldFull_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldFull st fuel env fs st' rf := by
  refine {
    hasType := principalBoundarySoundField_hasType_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok
    hasTypeU := principalBoundarySoundField_hasTypeU_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok
    core := principalBoundarySoundField_core_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app' h_proj'
    exact principalBoundarySoundField_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok h_app' h_proj'
  · intro h_hooks
    exact principalBoundarySoundField_preconditioned_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_hooks h_ok
  · intro h_app' h_proj'
    exact principalBoundarySoundField_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok h_app' h_proj'
  · intro h_hooks
    exact principalBoundarySoundField_preconditionedCoreIff_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_hooks h_ok
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalBoundarySoundField_hookIrrelevant_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok

/-- Bundled-hook alias for the arbitrary-success expression full capstone on the direct typing-suite surface. -/
theorem principalBoundarySoundExprFull_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundExprFull st fuel env e st' ty :=
  principalBoundarySoundExprFull_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/-- Bundled-hook alias for the arbitrary-success field full capstone on the direct typing-suite surface. -/
theorem principalBoundarySoundFieldFull_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldFull st fuel env fs st' rf :=
  principalBoundarySoundFieldFull_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok

/--
Packaged no-unify expression capstone on the direct boundary+sound typing-suite
surface.
-/
structure PrincipalBoundarySoundNoUnifyExprFull
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty) : Prop where
  hasType : HasType env e ty
  hasTypeU : HasTypeU env e ty
  core : PrincipalTypingSliceCore env e ty
  preconditionedAny :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
  preconditioned :
    ∀ (h_hooks : UnifyHookPremises),
      PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty)
  preconditionedIffCore :
    ∀ (h_hooks : UnifyHookPremises),
      (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty)
  hookIrrelevant :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
        ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty)

/--
Packaged no-unify field capstone on the direct boundary+sound typing-suite
surface.
-/
structure PrincipalBoundarySoundNoUnifyFieldFull
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields) : Prop where
  hasType : HasFieldsType env fs rf
  hasTypeU : HasFieldsTypeU env fs rf
  core : PrincipalFieldTypingSliceCore env fs rf
  preconditionedAny :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
  preconditioned :
    ∀ (h_hooks : UnifyHookPremises),
      PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
  preconditionedAnyIffCore :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf)
  preconditionedIffCore :
    ∀ (h_hooks : UnifyHookPremises),
      (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf)
  hookIrrelevant :
    ∀ {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
      {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook},
      (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
        ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf)

/--
Build the packaged no-unify expression capstone from one successful no-unify
run via the direct boundary+sound typing-suite surface.
-/
theorem principalBoundarySoundNoUnifyExprFull_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e st' ty := by
  refine {
    hasType := principalBoundarySoundNoUnifyExpr_hasType_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok
    hasTypeU := principalBoundarySoundNoUnifyExpr_hasTypeU_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok
    core := principalBoundarySoundNoUnifyExpr_core_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app' h_proj'
    exact principalBoundarySoundNoUnifyExpr_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok h_app' h_proj'
  · intro h_hooks
    exact principalBoundarySoundNoUnifyExpr_preconditioned_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_hooks h_no h_ok
  · intro h_app' h_proj'
    exact principalBoundarySoundNoUnifyExpr_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok h_app' h_proj'
  · intro h_hooks
    exact principalBoundarySoundNoUnifyExpr_preconditionedCoreIff_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_hooks h_no h_ok
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalBoundarySoundNoUnifyExpr_hookIrrelevant_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok

/--
Build the packaged no-unify field capstone from one successful no-unify field
run via the direct boundary+sound typing-suite surface.
-/
theorem principalBoundarySoundNoUnifyFieldFull_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs st' rf := by
  refine {
    hasType := principalBoundarySoundNoUnifyField_hasType_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok
    hasTypeU := principalBoundarySoundNoUnifyField_hasTypeU_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok
    core := principalBoundarySoundNoUnifyField_core_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok
    preconditionedAny := ?_
    preconditioned := ?_
    preconditionedAnyIffCore := ?_
    preconditionedIffCore := ?_
    hookIrrelevant := ?_
  }
  · intro h_app' h_proj'
    exact principalBoundarySoundNoUnifyField_preconditioned_anyHooks_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok h_app' h_proj'
  · intro h_hooks
    exact principalBoundarySoundNoUnifyField_preconditioned_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_hooks h_no h_ok
  · intro h_app' h_proj'
    exact principalBoundarySoundNoUnifyField_preconditionedCoreIff_anyHooks_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok h_app' h_proj'
  · intro h_hooks
    exact principalBoundarySoundNoUnifyField_preconditionedCoreIff_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_hooks h_no h_ok
  · intro h_app₁ h_proj₁ h_app₂ h_proj₂
    exact principalBoundarySoundNoUnifyField_hookIrrelevant_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok

/-- Bundled-hook alias for the no-unify expression full capstone on the direct typing-suite surface. -/
theorem principalBoundarySoundNoUnifyExprFull_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e st' ty :=
  principalBoundarySoundNoUnifyExprFull_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/-- Bundled-hook alias for the no-unify field full capstone on the direct typing-suite surface. -/
theorem principalBoundarySoundNoUnifyFieldFull_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs st' rf :=
  principalBoundarySoundNoUnifyFieldFull_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_no h_ok

/--
Top-level full typing-suite capstone combining arbitrary-success and no-unify
full surfaces for expression and field runs.
-/
structure PrincipalBoundarySoundFullSuite
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  expr : PrincipalBoundarySoundExprFull st fuel env e stExpr ty
  field : PrincipalBoundarySoundFieldFull st fuel env fs stField rf
  noUnifyExpr :
    NoUnifyBranchesExpr e →
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
  noUnifyField :
    NoUnifyBranchesFields fs →
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf

/-- Explicit component alias for `PrincipalBoundarySoundFullSuite`. -/
abbrev PrincipalBoundarySoundFullSuiteComponents
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop :=
  PrincipalBoundarySoundExprFull st fuel env e stExpr ty
    ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
    ∧ (NoUnifyBranchesExpr e →
        PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
    ∧ (NoUnifyBranchesFields fs →
        PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)

/-- `PrincipalBoundarySoundFullSuite` is equivalent to explicit components. -/
theorem principalBoundarySoundFullSuite_iff_components
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf
      ↔ PrincipalBoundarySoundFullSuiteComponents
          st fuel env e fs stExpr ty stField rf := by
  constructor
  · intro h_suite
    exact ⟨h_suite.expr, h_suite.field, h_suite.noUnifyExpr, h_suite.noUnifyField⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2.1, h_comp.2.2.1, h_comp.2.2.2⟩

/-- Build `PrincipalBoundarySoundFullSuite` from explicit components. -/
theorem principalBoundarySoundFullSuite_of_components
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields)
    (h_comp :
      PrincipalBoundarySoundFullSuiteComponents
        st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundFullSuite_iff_components
    st fuel env e fs stExpr ty stField rf).2 h_comp

/-- Decompose `PrincipalBoundarySoundFullSuite` into explicit components. -/
theorem principalBoundarySoundFullSuite_as_components
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields)
    (h_suite : PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuiteComponents
      st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundFullSuite_iff_components
    st fuel env e fs stExpr ty stField rf).1 h_suite

/-- Direct components-route decomposition for `PrincipalBoundarySoundFullSuite`. -/
theorem principalBoundarySoundFullSuite_as_components_of_components
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields)
    (h_comp :
      PrincipalBoundarySoundFullSuiteComponents
        st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuiteComponents
      st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundFullSuite_iff_components
    st fuel env e fs stExpr ty stField rf).1
    (principalBoundarySoundFullSuite_of_components
      st fuel env e fs stExpr ty stField rf h_comp)

/--
Build the full typing-suite capstone from successful expression and field runs
on the direct boundary+sound typing-suite path.
-/
theorem principalBoundarySoundFullSuite_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf := by
  refine {
    expr := principalBoundarySoundExprFull_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok_expr
    field := principalBoundarySoundFieldFull_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok_field
    noUnifyExpr := ?_
    noUnifyField := ?_
  }
  · intro h_no
    exact principalBoundarySoundNoUnifyExprFull_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok_expr
  · intro h_no
    exact principalBoundarySoundNoUnifyFieldFull_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no h_ok_field

/-- Bundled-hook alias for the full typing-suite capstone constructor. -/
theorem principalBoundarySoundFullSuite_of_success_via_typingRunBundleSuite_from_bundle
    (h_hooks : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullSuite_of_success_via_typingRunBundleSuite
    (h_app := h_hooks.1) (h_proj := h_hooks.2) h_ok_expr h_ok_field

/-- One-hop projection: arbitrary-success expression full surface from the full suite. -/
theorem principalBoundarySoundFullSuite_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  h_suite.expr

/-- One-hop projection: arbitrary-success field full surface from the full suite. -/
theorem principalBoundarySoundFullSuite_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  h_suite.field

/-- One-hop projection: no-unify expression full surface from the full suite. -/
theorem principalBoundarySoundFullSuite_noUnifyExpr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesExpr e) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_suite.noUnifyExpr h_no

/-- One-hop projection: no-unify field full surface from the full suite. -/
theorem principalBoundarySoundFullSuite_noUnifyField
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_suite.noUnifyField h_no

/--
Construct the full typing-suite capstone via the boundary+sound bundle route,
so one `PrincipalRowPolyBoundarySoundBundle` witness yields the full direct
arbitrary-success/no-unify expr+field package.
-/
theorem principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf := by
  refine {
    expr := ?_
    field := ?_
    noUnifyExpr := ?_
    noUnifyField := ?_
  }
  · refine {
      hasType := principalRowPolyBoundarySoundBundle_expr_hasType h_bundle h_ok_expr
      hasTypeU := principalRowPolyBoundarySoundBundle_expr_hasTypeU h_bundle h_ok_expr
      core := principalRowPolyBoundarySoundBundle_coreExpr_of_success h_bundle h_ok_expr
      preconditionedAny := ?_
      preconditioned := ?_
      preconditionedAnyIffCore := ?_
      preconditionedIffCore := ?_
      hookIrrelevant := ?_
    }
    · intro h_app' h_proj'
      exact principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success
        h_bundle h_ok_expr h_app' h_proj'
    · intro h_hooks
      exact principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success
        h_bundle h_ok_expr h_hooks
    · intro h_app' h_proj'
      exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success
        h_bundle h_ok_expr h_app' h_proj'
    · intro h_hooks
      exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success
        h_bundle h_ok_expr h_hooks
    · intro h_app₁ h_proj₁ h_app₂ h_proj₂
      exact principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success
        h_bundle h_ok_expr
  · refine {
      hasType := principalRowPolyBoundarySoundBundle_field_hasType h_bundle h_ok_field
      hasTypeU := principalRowPolyBoundarySoundBundle_field_hasTypeU h_bundle h_ok_field
      core := principalRowPolyBoundarySoundBundle_coreField_of_success h_bundle h_ok_field
      preconditionedAny := ?_
      preconditioned := ?_
      preconditionedAnyIffCore := ?_
      preconditionedIffCore := ?_
      hookIrrelevant := ?_
    }
    · intro h_app' h_proj'
      exact principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success
        h_bundle h_ok_field h_app' h_proj'
    · intro h_hooks
      exact principalRowPolyBoundarySoundBundle_preconditionedField_of_success
        h_bundle h_ok_field h_hooks
    · intro h_app' h_proj'
      exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success
        h_bundle h_ok_field h_app' h_proj'
    · intro h_hooks
      exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success
        h_bundle h_ok_field h_hooks
    · intro h_app₁ h_proj₁ h_app₂ h_proj₂
      exact principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success
        h_bundle h_ok_field
  · intro h_no
    refine {
      hasType := principalRowPolyBoundarySoundBundle_expr_hasType h_bundle h_ok_expr
      hasTypeU := principalRowPolyBoundarySoundBundle_expr_hasTypeU h_bundle h_ok_expr
      core := principalRowPolyBoundarySoundBundle_coreExpr_of_success_noUnify h_bundle h_no h_ok_expr
      preconditionedAny := ?_
      preconditioned := ?_
      preconditionedAnyIffCore := ?_
      preconditionedIffCore := ?_
      hookIrrelevant := ?_
    }
    · intro h_app' h_proj'
      exact principalRowPolyBoundarySoundBundle_preconditionedExpr_anyHooks_of_success_noUnify
        h_bundle h_no h_ok_expr h_app' h_proj'
    · intro h_hooks
      exact principalRowPolyBoundarySoundBundle_preconditionedExpr_of_success_noUnify
        h_bundle h_no h_ok_expr h_hooks
    · intro h_app' h_proj'
      exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_anyHooks_of_success_noUnify
        h_bundle h_no h_ok_expr h_app' h_proj'
    · intro h_hooks
      exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffExpr_of_success_noUnify
        h_bundle h_no h_ok_expr h_hooks
    · intro h_app₁ h_proj₁ h_app₂ h_proj₂
      exact principalRowPolyBoundarySoundBundle_hookIrrelevantExpr_of_success_noUnify
        h_bundle h_no h_ok_expr
  · intro h_no
    refine {
      hasType := principalRowPolyBoundarySoundBundle_field_hasType h_bundle h_ok_field
      hasTypeU := principalRowPolyBoundarySoundBundle_field_hasTypeU h_bundle h_ok_field
      core := principalRowPolyBoundarySoundBundle_coreField_of_success_noUnify h_bundle h_no h_ok_field
      preconditionedAny := ?_
      preconditioned := ?_
      preconditionedAnyIffCore := ?_
      preconditionedIffCore := ?_
      hookIrrelevant := ?_
    }
    · intro h_app' h_proj'
      exact principalRowPolyBoundarySoundBundle_preconditionedField_anyHooks_of_success_noUnify
        h_bundle h_no h_ok_field h_app' h_proj'
    · intro h_hooks
      exact principalRowPolyBoundarySoundBundle_preconditionedField_of_success_noUnify
        h_bundle h_no h_ok_field h_hooks
    · intro h_app' h_proj'
      exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_anyHooks_of_success_noUnify
        h_bundle h_no h_ok_field h_app' h_proj'
    · intro h_hooks
      exact principalRowPolyBoundarySoundBundle_preconditionedCoreIffField_of_success_noUnify
        h_bundle h_no h_ok_field h_hooks
    · intro h_app₁ h_proj₁ h_app₂ h_proj₂
      exact principalRowPolyBoundarySoundBundle_hookIrrelevantField_of_success_noUnify
        h_bundle h_no h_ok_field

/-- Bundled-hook constructor alias for the row-poly-boundary full-suite route. -/
theorem principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle
    (h_bundle := principalRowPolyBoundarySoundBundle_of_hook_bundle h_seed)
    h_ok_expr h_ok_field

/--
Canonical hook-seeded constructor for the row-poly-boundary full-suite route.
-/
theorem principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle_proved
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle
    (h_bundle := principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj)
    h_ok_expr h_ok_field

/-- Bundled-hook alias for the canonical row-poly-boundary full-suite constructor. -/
theorem principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle_proved_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle_proved
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/--
Dual-routed hook-seeded constructor for the row-poly-boundary full-suite route.
-/
theorem principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle
    (h_bundle := principalRowPolyBoundarySoundBundle_of_hooks_via_dualConsequenceSlices h_app h_proj)
    h_ok_expr h_ok_field

/-- Bundled-hook alias for the dual-routed row-poly-boundary full-suite constructor. -/
theorem principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/--
Combined capstone packaging the direct full-suite theorem surface with the
row-poly hook-free vertical slice.
-/
structure PrincipalBoundarySoundFullVerticalSuite
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  full : PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf
  vertical : VerticalHookFreeUnifySlices

/-- Explicit component alias for `PrincipalBoundarySoundFullVerticalSuite`. -/
abbrev PrincipalBoundarySoundFullVerticalSuiteComponents
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop :=
  PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf
    ∧ VerticalHookFreeUnifySlices

/-- `PrincipalBoundarySoundFullVerticalSuite` is equivalent to explicit components. -/
theorem principalBoundarySoundFullVerticalSuite_iff_components
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf
      ↔ PrincipalBoundarySoundFullVerticalSuiteComponents
          st fuel env e fs stExpr ty stField rf := by
  constructor
  · intro h_suite
    exact ⟨h_suite.full, h_suite.vertical⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2⟩

/-- Build `PrincipalBoundarySoundFullVerticalSuite` from explicit components. -/
theorem principalBoundarySoundFullVerticalSuite_of_components
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields)
    (h_comp :
      PrincipalBoundarySoundFullVerticalSuiteComponents
        st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundFullVerticalSuite_iff_components
    st fuel env e fs stExpr ty stField rf).2 h_comp

/-- Decompose `PrincipalBoundarySoundFullVerticalSuite` into explicit components. -/
theorem principalBoundarySoundFullVerticalSuite_as_components
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields)
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalSuiteComponents
      st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundFullVerticalSuite_iff_components
    st fuel env e fs stExpr ty stField rf).1 h_suite

/-- Direct components-route decomposition for `PrincipalBoundarySoundFullVerticalSuite`. -/
theorem principalBoundarySoundFullVerticalSuite_as_components_of_components
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields)
    (h_comp :
      PrincipalBoundarySoundFullVerticalSuiteComponents
        st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalSuiteComponents
      st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundFullVerticalSuite_iff_components
    st fuel env e fs stExpr ty stField rf).1
    (principalBoundarySoundFullVerticalSuite_of_components
      st fuel env e fs stExpr ty stField rf h_comp)

/--
Build the full+vertical capstone from a row-poly boundary+sound bundle and
successful expression/field runs.
-/
theorem principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf := by
  refine {
    full := principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle
      h_bundle h_ok_expr h_ok_field
    vertical := principalRowPolyBoundaryBundle_vertical h_bundle.boundary
  }

/-- Bundled-hook alias for the row-poly full+vertical capstone constructor. -/
theorem principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
    (h_bundle := principalRowPolyBoundarySoundBundle_of_hook_bundle h_seed)
    h_ok_expr h_ok_field

/--
Canonical hook-seeded constructor for the row-poly full+vertical capstone.
-/
theorem principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_proved
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
    (h_bundle := principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj)
    h_ok_expr h_ok_field

/-- Bundled-hook alias for the canonical row-poly full+vertical constructor. -/
theorem principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_proved_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_proved
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/--
Dual-routed hook-seeded constructor for the row-poly full+vertical capstone.
-/
theorem principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
    (h_bundle := principalRowPolyBoundarySoundBundle_of_hooks_via_dualConsequenceSlices h_app h_proj)
    h_ok_expr h_ok_field

/-- Bundled-hook alias for the dual-routed row-poly full+vertical constructor. -/
theorem principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/--
Direct hook-seeded constructor for full+vertical packaging via the direct
typing-suite full surface.
-/
theorem principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf := by
  refine {
    full := principalBoundarySoundFullSuite_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field
    vertical := principalRowPolyBoundaryBundle_vertical principalRowPolyBoundaryBundle_proved
  }

/-- Bundled-hook alias for direct full+vertical construction via typing-suite. -/
theorem principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/--
Dual-routed direct hook-seeded constructor for full+vertical packaging via the
direct typing-suite full surface.
-/
theorem principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf := by
  refine {
    full := principalBoundarySoundFullSuite_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field
    vertical := principalRowPolyBoundaryBundle_vertical
      principalRowPolyBoundaryBundle_proved_via_dualConsequenceSlices
  }

/-- Bundled-hook alias for dual-routed direct full+vertical construction via typing-suite. -/
theorem principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/--
Route-pair packaging for `FullVertical`: one witness carries both the direct
typing-suite route and the row-poly-boundary route.
-/
structure PrincipalBoundarySoundFullVerticalRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  viaTypingSuite :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf
  viaRowPolyBundle :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf

/--
Construct `FullVertical` route-pair packaging from successful expression/field
runs and a row-poly boundary+sound bundle.
-/
theorem principalBoundarySoundFullVerticalRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf := by
  refine {
    viaTypingSuite := principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field
    viaRowPolyBundle := principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
      h_bundle h_ok_expr h_ok_field
  }

/-- Bundled-hook constructor alias for `FullVertical` route-pair packaging. -/
theorem principalBoundarySoundFullVerticalRoutes_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalRoutes_of_success
    (h_bundle := principalRowPolyBoundarySoundBundle_of_hook_bundle h_seed)
    h_ok_expr h_ok_field

/--
Dual-routed bundled-hook constructor alias for `FullVertical` route-pair
packaging.
-/
theorem principalBoundarySoundFullVerticalRoutes_of_success_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf := by
  refine {
    viaTypingSuite :=
      principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices_from_bundle
        h_seed h_ok_expr h_ok_field
    viaRowPolyBundle :=
      principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices_from_bundle
        h_seed h_ok_expr h_ok_field
  }

/-- Explicit row-poly route alias for `FullVerticalRoutes` construction. -/
theorem principalBoundarySoundFullVerticalRoutes_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalRoutes_of_success h_bundle h_ok_expr h_ok_field

/-- Bundled-hook alias for the explicit row-poly `FullVerticalRoutes` constructor. -/
theorem principalBoundarySoundFullVerticalRoutes_of_success_via_rowPolyBoundarySoundBundle_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalRoutes_of_success_from_bundle
    h_seed h_ok_expr h_ok_field

/-- Hook-seeded dual-routed constructor alias for `FullVerticalRoutes`. -/
theorem principalBoundarySoundFullVerticalRoutes_of_success_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf := by
  refine {
    viaTypingSuite :=
      principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices
        (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field
    viaRowPolyBundle :=
      principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices
        (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field
  }

/-- Explicit typing-suite route alias for `FullVerticalRoutes` construction. -/
theorem principalBoundarySoundFullVerticalRoutes_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf := by
  refine {
    viaTypingSuite :=
      principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite
        (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field
    viaRowPolyBundle :=
      principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
        (h_bundle := principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj)
        h_ok_expr h_ok_field
  }

/-- Bundled-hook alias for the explicit typing-suite `FullVerticalRoutes` constructor. -/
theorem principalBoundarySoundFullVerticalRoutes_of_success_via_typingRunBundleSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalRoutes_of_success_via_typingRunBundleSuite
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/-- Bundled-hook alias for the explicit dual-routed `FullVerticalRoutes` constructor. -/
theorem principalBoundarySoundFullVerticalRoutes_of_success_via_dualConsequenceSlices_alias_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalRoutes_of_success_via_dualConsequenceSlices_from_bundle
    h_seed h_ok_expr h_ok_field

/-- One-hop projection: typing-suite `FullVertical` route from the route pair. -/
theorem principalBoundarySoundFullVerticalRoutes_viaTypingSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_routes.viaTypingSuite

/-- One-hop projection: row-poly `FullVertical` route from the route pair. -/
theorem principalBoundarySoundFullVerticalRoutes_viaRowPolyBundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_routes.viaRowPolyBundle

/-- One-hop projection: full-suite surface via the typing-suite route pair branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaTypingSuite_full
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  h_routes.viaTypingSuite.full

/-- One-hop projection: vertical app/proj pair via the typing-suite route pair branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaTypingSuite_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices :=
  h_routes.viaTypingSuite.vertical

/-- One-hop projection: hook-free app vertical theorem via the typing-suite route pair branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaTypingSuite_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_routes.viaTypingSuite.vertical.1

/-- One-hop projection: hook-free projection vertical theorem via the typing-suite route pair branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaTypingSuite_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_routes.viaTypingSuite.vertical.2

/-- One-hop projection: full-suite surface via the row-poly-bundle route pair branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaRowPolyBundle_full
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  h_routes.viaRowPolyBundle.full

/-- One-hop projection: vertical app/proj pair via the row-poly-bundle route pair branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaRowPolyBundle_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices :=
  h_routes.viaRowPolyBundle.vertical

/-- One-hop projection: hook-free app vertical theorem via the row-poly-bundle route pair branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaRowPolyBundle_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_routes.viaRowPolyBundle.vertical.1

/-- One-hop projection: hook-free projection vertical theorem via the row-poly-bundle route pair branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaRowPolyBundle_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_routes.viaRowPolyBundle.vertical.2

/-- One-hop projection: arbitrary-success expression full surface via typing-suite route branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaTypingSuite_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  h_routes.viaTypingSuite.full.expr

/-- One-hop projection: arbitrary-success field full surface via typing-suite route branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaTypingSuite_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  h_routes.viaTypingSuite.full.field

/-- One-hop projection: no-unify expression full surface via typing-suite route branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaTypingSuite_noUnifyExpr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesExpr e) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_routes.viaTypingSuite.full.noUnifyExpr h_no

/-- One-hop projection: no-unify field full surface via typing-suite route branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaTypingSuite_noUnifyField
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_routes.viaTypingSuite.full.noUnifyField h_no

/-- One-hop local decomposition on the typing-suite route branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaTypingSuite_as_full_and_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf
      ∧ VerticalHookFreeUnifySlices :=
  ⟨h_routes.viaTypingSuite.full, h_routes.viaTypingSuite.vertical⟩

/-- One-hop projection: arbitrary-success expression full surface via row-poly route branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaRowPolyBundle_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  h_routes.viaRowPolyBundle.full.expr

/-- One-hop projection: arbitrary-success field full surface via row-poly route branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaRowPolyBundle_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  h_routes.viaRowPolyBundle.full.field

/-- One-hop projection: no-unify expression full surface via row-poly route branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaRowPolyBundle_noUnifyExpr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesExpr e) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_routes.viaRowPolyBundle.full.noUnifyExpr h_no

/-- One-hop projection: no-unify field full surface via row-poly route branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaRowPolyBundle_noUnifyField
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_routes.viaRowPolyBundle.full.noUnifyField h_no

/-- One-hop local decomposition on the row-poly route branch. -/
theorem principalBoundarySoundFullVerticalRoutes_viaRowPolyBundle_as_full_and_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf
      ∧ VerticalHookFreeUnifySlices :=
  ⟨h_routes.viaRowPolyBundle.full, h_routes.viaRowPolyBundle.vertical⟩

/--
Master route packaging for `FullVertical`: one witness carries both the regular
and dual consequence route pairs.
-/
structure PrincipalBoundarySoundFullVerticalMasterRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  regular : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf
  dual : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf

/-- Build `FullVertical` master routes from a bundled hook seed. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf := by
  refine {
    regular := principalBoundarySoundFullVerticalRoutes_of_success_from_bundle
      h_seed h_ok_expr h_ok_field
    dual := principalBoundarySoundFullVerticalRoutes_of_success_via_dualConsequenceSlices_from_bundle
      h_seed h_ok_expr h_ok_field
  }

/-- Build `FullVertical` master routes from split hook premises. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterRoutes_of_success_from_bundle
    (h_seed := ⟨h_app, h_proj⟩) h_ok_expr h_ok_field

/--
Build `FullVertical` master routes from an explicit row-poly boundary+sound
bundle witness.
-/
theorem principalBoundarySoundFullVerticalMasterRoutes_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf := by
  refine {
    regular := principalBoundarySoundFullVerticalRoutes_of_success
      (h_bundle := h_bundle) h_ok_expr h_ok_field
    dual := principalBoundarySoundFullVerticalRoutes_of_success_via_dualConsequenceSlices
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field
  }

/-- One-hop projection: regular route pair from master `FullVertical` routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  h_master.regular

/-- One-hop projection: dual route pair from master `FullVertical` routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  h_master.dual

/-- One-hop projection: regular typing-suite branch from master `FullVertical` routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular_viaTypingSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_master.regular.viaTypingSuite

/-- One-hop projection: regular row-poly branch from master `FullVertical` routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular_viaRowPolyBundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_master.regular.viaRowPolyBundle

/-- One-hop projection: dual typing-suite branch from master `FullVertical` routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual_viaTypingSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_master.dual.viaTypingSuite

/-- One-hop projection: dual row-poly branch from master `FullVertical` routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual_viaRowPolyBundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_master.dual.viaRowPolyBundle

/--
`FullVertical` master routes are equivalent to a pair of route witnesses:
regular and dual.
-/
theorem principalBoundarySoundFullVerticalMasterRoutes_iff_regular_and_dual
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ↔ (PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf
          ∧ PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) := by
  constructor
  · intro h_master
    exact ⟨h_master.regular, h_master.dual⟩
  · intro h_pair
    exact ⟨h_pair.1, h_pair.2⟩

/-- Constructor from an explicit regular/dual route pair. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_of_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_pair : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundFullVerticalMasterRoutes_iff_regular_and_dual).2 h_pair

/-- One-hop extraction of the regular/dual route pair from a master witness. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_as_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundFullVerticalMasterRoutes_iff_regular_and_dual).1 h_master

/-- One-hop projection: regular route full-suite consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular_full
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  h_master.regular.viaTypingSuite.full

/-- One-hop projection: regular route vertical consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices :=
  h_master.regular.viaTypingSuite.vertical

/-- One-hop projection: regular route app vertical consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_master.regular.viaTypingSuite.vertical.1

/-- One-hop projection: regular route projection vertical consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_master.regular.viaTypingSuite.vertical.2

/-- One-hop projection: dual route full-suite consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual_full
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  h_master.dual.viaTypingSuite.full

/-- One-hop projection: dual route vertical consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices :=
  h_master.dual.viaTypingSuite.vertical

/-- One-hop projection: dual route app vertical consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_master.dual.viaTypingSuite.vertical.1

/-- One-hop projection: dual route projection vertical consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_master.dual.viaTypingSuite.vertical.2

/-- One-hop projection: regular route arbitrary-success expression full consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  h_master.regular.viaTypingSuite.full.expr

/-- One-hop projection: regular route arbitrary-success field full consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  h_master.regular.viaTypingSuite.full.field

/-- One-hop projection: regular route no-unify expression full consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular_noUnifyExpr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesExpr e) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_master.regular.viaTypingSuite.full.noUnifyExpr h_no

/-- One-hop projection: regular route no-unify field full consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular_noUnifyField
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_master.regular.viaTypingSuite.full.noUnifyField h_no

/-- One-hop projection: dual route arbitrary-success expression full consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  h_master.dual.viaTypingSuite.full.expr

/-- One-hop projection: dual route arbitrary-success field full consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  h_master.dual.viaTypingSuite.full.field

/-- One-hop projection: dual route no-unify expression full consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual_noUnifyExpr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesExpr e) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_master.dual.viaTypingSuite.full.noUnifyExpr h_no

/-- One-hop projection: dual route no-unify field full consequence from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual_noUnifyField
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_master.dual.viaTypingSuite.full.noUnifyField h_no

/-- One-hop paired extraction: regular+dual full-suite consequences from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_full_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  ⟨h_master.regular.viaTypingSuite.full, h_master.dual.viaTypingSuite.full⟩

/-- One-hop paired extraction: regular+dual vertical consequences from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_vertical_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices ∧ VerticalHookFreeUnifySlices :=
  ⟨h_master.regular.viaTypingSuite.vertical, h_master.dual.viaTypingSuite.vertical⟩

/-- One-hop paired extraction: regular+dual expression full consequences from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_expr_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  ⟨h_master.regular.viaTypingSuite.full.expr, h_master.dual.viaTypingSuite.full.expr⟩

/-- One-hop paired extraction: regular+dual field full consequences from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_field_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf
      ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  ⟨h_master.regular.viaTypingSuite.full.field, h_master.dual.viaTypingSuite.full.field⟩

/-- One-hop paired extraction: regular+dual no-unify expression full consequences from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_noUnifyExpr_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesExpr e) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  ⟨h_master.regular.viaTypingSuite.full.noUnifyExpr h_no,
    h_master.dual.viaTypingSuite.full.noUnifyExpr h_no⟩

/-- One-hop paired extraction: regular+dual no-unify field full consequences from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_noUnifyField_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  ⟨h_master.regular.viaTypingSuite.full.noUnifyField h_no,
    h_master.dual.viaTypingSuite.full.noUnifyField h_no⟩

/-- One-hop paired extraction: regular+dual `(full ∧ vertical)` decompositions from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_full_and_vertical_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    (PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf
      ∧ VerticalHookFreeUnifySlices)
      ∧
      (PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf
        ∧ VerticalHookFreeUnifySlices) :=
  ⟨⟨h_master.regular.viaTypingSuite.full, h_master.regular.viaTypingSuite.vertical⟩,
    ⟨h_master.dual.viaTypingSuite.full, h_master.dual.viaTypingSuite.vertical⟩⟩

/-- One-hop decomposition: regular route branch from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_regular_as_full_and_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf
      ∧ VerticalHookFreeUnifySlices :=
  ⟨h_master.regular.viaTypingSuite.full, h_master.regular.viaTypingSuite.vertical⟩

/-- One-hop decomposition: dual route branch from master routes. -/
theorem principalBoundarySoundFullVerticalMasterRoutes_dual_as_full_and_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf
      ∧ VerticalHookFreeUnifySlices :=
  ⟨h_master.dual.viaTypingSuite.full, h_master.dual.viaTypingSuite.vertical⟩

/-- Direct expression full consequence wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySoundExprFull_of_success_via_fullVerticalMasterRoutes
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  (principalBoundarySoundFullVerticalMasterRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field).regular.viaTypingSuite.full.expr

/-- Direct field full consequence wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySoundFieldFull_of_success_via_fullVerticalMasterRoutes
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  (principalBoundarySoundFullVerticalMasterRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field).regular.viaTypingSuite.full.field

/-- Direct no-unify expression full consequence wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySoundNoUnifyExprFull_of_success_via_fullVerticalMasterRoutes
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  (principalBoundarySoundFullVerticalMasterRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field).regular.viaTypingSuite.full.noUnifyExpr h_no

/-- Direct no-unify field full consequence wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySoundNoUnifyFieldFull_of_success_via_fullVerticalMasterRoutes
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  (principalBoundarySoundFullVerticalMasterRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field).regular.viaTypingSuite.full.noUnifyField h_no

/-- Direct hook-free app vertical consequence wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySound_verticalApp_of_success_via_fullVerticalMasterRoutes
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeAppSlice :=
  (principalBoundarySoundFullVerticalMasterRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field).regular.viaTypingSuite.vertical.1

/-- Direct hook-free projection vertical consequence wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySound_verticalProj_of_success_via_fullVerticalMasterRoutes
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeProjSlice :=
  (principalBoundarySoundFullVerticalMasterRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field).regular.viaTypingSuite.vertical.2

/-- Bundled-hook alias for the direct expression full wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySoundExprFull_of_success_via_fullVerticalMasterRoutes_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  principalBoundarySoundExprFull_of_success_via_fullVerticalMasterRoutes
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/-- Bundled-hook alias for the direct field full wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySoundFieldFull_of_success_via_fullVerticalMasterRoutes_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  principalBoundarySoundFieldFull_of_success_via_fullVerticalMasterRoutes
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/-- Bundled-hook alias for the direct no-unify expression full wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySoundNoUnifyExprFull_of_success_via_fullVerticalMasterRoutes_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  principalBoundarySoundNoUnifyExprFull_of_success_via_fullVerticalMasterRoutes
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no h_ok_expr h_ok_field

/-- Bundled-hook alias for the direct no-unify field full wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySoundNoUnifyFieldFull_of_success_via_fullVerticalMasterRoutes_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  principalBoundarySoundNoUnifyFieldFull_of_success_via_fullVerticalMasterRoutes
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no h_ok_expr h_ok_field

/-- Bundled-hook alias for direct hook-free app vertical wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySound_verticalApp_of_success_via_fullVerticalMasterRoutes_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeAppSlice :=
  principalBoundarySound_verticalApp_of_success_via_fullVerticalMasterRoutes
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/-- Bundled-hook alias for direct hook-free projection vertical wrapper via `FullVerticalMasterRoutes`. -/
theorem principalBoundarySound_verticalProj_of_success_via_fullVerticalMasterRoutes_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeProjSlice :=
  principalBoundarySound_verticalProj_of_success_via_fullVerticalMasterRoutes
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/--
Packaged direct consequence surface from the `FullVerticalMasterRoutes` layer.
This bundles principal full surfaces and hook-free vertical consequences under
one successful-run witness.
-/
structure PrincipalBoundarySoundFullVerticalMasterCapstone
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  expr : PrincipalBoundarySoundExprFull st fuel env e stExpr ty
  field : PrincipalBoundarySoundFieldFull st fuel env fs stField rf
  noUnifyExpr :
    NoUnifyBranchesExpr e →
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
  noUnifyField :
    NoUnifyBranchesFields fs →
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
  verticalApp : VerticalHookFreeAppSlice
  verticalProj : VerticalHookFreeProjSlice

/-- Build the packaged `FullVerticalMasterCapstone` from an explicit master-routes witness. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_of_masterRoutes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  refine {
    expr := principalBoundarySoundFullVerticalMasterRoutes_regular_expr h_master
    field := principalBoundarySoundFullVerticalMasterRoutes_regular_field h_master
    noUnifyExpr := ?_
    noUnifyField := ?_
    verticalApp := principalBoundarySoundFullVerticalMasterRoutes_regular_vertical_app h_master
    verticalProj := principalBoundarySoundFullVerticalMasterRoutes_regular_vertical_proj h_master
  }
  · intro h_no
    exact principalBoundarySoundFullVerticalMasterRoutes_regular_noUnifyExpr h_master h_no
  · intro h_no
    exact principalBoundarySoundFullVerticalMasterRoutes_regular_noUnifyField h_master h_no

/-- Hook-seeded constructor for the packaged `FullVerticalMasterCapstone`. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterCapstone_of_masterRoutes
    (principalBoundarySoundFullVerticalMasterRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)

/-- Bundled-hook constructor for the packaged `FullVerticalMasterCapstone`. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterCapstone_of_success
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/--
Build the packaged `FullVerticalMasterCapstone` directly from an explicit
row-poly boundary+sound bundle witness.
-/
theorem principalBoundarySoundFullVerticalMasterCapstone_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterCapstone_of_masterRoutes
    (principalBoundarySoundFullVerticalMasterRoutes_of_success_via_rowPolyBoundarySoundBundle
      (h_bundle := h_bundle) h_ok_expr h_ok_field)

/--
`FullVerticalMasterCapstone` is equivalent to an explicit conjunction of its
principal/vertical component consequences.
-/
theorem principalBoundarySoundFullVerticalMasterCapstone_iff_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf
      ↔ (PrincipalBoundarySoundExprFull st fuel env e stExpr ty
          ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
          ∧ (NoUnifyBranchesExpr e →
              PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
          ∧ (NoUnifyBranchesFields fs →
              PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
          ∧ VerticalHookFreeAppSlice
          ∧ VerticalHookFreeProjSlice) := by
  constructor
  · intro h_cap
    exact ⟨h_cap.expr, h_cap.field, h_cap.noUnifyExpr, h_cap.noUnifyField,
      h_cap.verticalApp, h_cap.verticalProj⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2.1, h_comp.2.2.1, h_comp.2.2.2.1,
      h_comp.2.2.2.2.1, h_comp.2.2.2.2.2⟩

/-- Constructor helper from explicit component conjunction for `FullVerticalMasterCapstone`. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_of_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_comp :
      PrincipalBoundarySoundExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
        ∧ (NoUnifyBranchesExpr e →
            PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
        ∧ (NoUnifyBranchesFields fs →
            PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
        ∧ VerticalHookFreeAppSlice
        ∧ VerticalHookFreeProjSlice) :
    PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundFullVerticalMasterCapstone_iff_components).2 h_comp

/-- Direct component-route decomposition for `FullVerticalMasterCapstone`. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_as_components_of_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_comp :
      PrincipalBoundarySoundExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
        ∧ (NoUnifyBranchesExpr e →
            PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
        ∧ (NoUnifyBranchesFields fs →
            PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
        ∧ VerticalHookFreeAppSlice
        ∧ VerticalHookFreeProjSlice) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
      ∧ (NoUnifyBranchesExpr e →
          PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
      ∧ (NoUnifyBranchesFields fs →
          PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  simpa using h_comp

/-- One-hop decomposition of `FullVerticalMasterCapstone` into explicit components. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_as_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
      ∧ (NoUnifyBranchesExpr e →
          PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
      ∧ (NoUnifyBranchesFields fs →
          PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice :=
  (principalBoundarySoundFullVerticalMasterCapstone_iff_components).1 h_cap

/-- Direct route decomposition from `of_masterRoutes` into explicit components. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_as_components_of_masterRoutes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
      ∧ (NoUnifyBranchesExpr e →
          PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
      ∧ (NoUnifyBranchesFields fs →
          PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundFullVerticalMasterCapstone_as_components
    (principalBoundarySoundFullVerticalMasterCapstone_of_masterRoutes h_master)

/-- Direct route decomposition from `of_success` into explicit components. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_as_components_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
      ∧ (NoUnifyBranchesExpr e →
          PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
      ∧ (NoUnifyBranchesFields fs →
          PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundFullVerticalMasterCapstone_as_components
    (principalBoundarySoundFullVerticalMasterCapstone_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_from_bundle` into explicit components. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_as_components_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
      ∧ (NoUnifyBranchesExpr e →
          PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
      ∧ (NoUnifyBranchesFields fs →
          PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundFullVerticalMasterCapstone_as_components
    (principalBoundarySoundFullVerticalMasterCapstone_of_success_from_bundle
      h_seed h_ok_expr h_ok_field)

/-- Direct route decomposition from row-poly bundle success into explicit components. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_as_components_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
      ∧ (NoUnifyBranchesExpr e →
          PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
      ∧ (NoUnifyBranchesFields fs →
          PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundFullVerticalMasterCapstone_as_components
    (principalBoundarySoundFullVerticalMasterCapstone_of_success_via_rowPolyBoundarySoundBundle
      (h_bundle := h_bundle) h_ok_expr h_ok_field)

/-- Convert a master-capstone witness into the `FullVerticalSuite` surface. -/
theorem principalBoundarySoundFullVerticalSuite_of_masterCapstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf := by
  refine {
    full := ?_
    vertical := ?_
  }
  · refine {
      expr := h_cap.expr
      field := h_cap.field
      noUnifyExpr := h_cap.noUnifyExpr
      noUnifyField := h_cap.noUnifyField
    }
  · exact ⟨h_cap.verticalApp, h_cap.verticalProj⟩

/-- Convert a `FullVerticalSuite` witness into the master-capstone surface. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_of_fullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  refine {
    expr := h_suite.full.expr
    field := h_suite.full.field
    noUnifyExpr := h_suite.full.noUnifyExpr
    noUnifyField := h_suite.full.noUnifyField
    verticalApp := h_suite.vertical.1
    verticalProj := h_suite.vertical.2
  }

/-- Direct route decomposition from `of_fullVerticalSuite` into explicit components. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_as_components_of_fullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
      ∧ (NoUnifyBranchesExpr e →
          PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
      ∧ (NoUnifyBranchesFields fs →
          PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundFullVerticalMasterCapstone_as_components
    (principalBoundarySoundFullVerticalMasterCapstone_of_fullVerticalSuite h_suite)

/-- Equivalence between master-capstone and `FullVerticalSuite` surfaces. -/
theorem principalBoundarySoundFullVerticalMasterCapstone_iff_fullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf
      ↔ PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf := by
  constructor
  · intro h_cap
    exact principalBoundarySoundFullVerticalSuite_of_masterCapstone h_cap
  · intro h_suite
    exact principalBoundarySoundFullVerticalMasterCapstone_of_fullVerticalSuite h_suite

/--
Unified full master surface:
one witness carries both full master routes and full master capstone.
-/
structure PrincipalBoundarySoundFullVerticalMasterSurface
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  routes : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
  capstone : PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf

/-- Build unified full master surface directly from full master routes. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf := by
  refine {
    routes := h_routes
    capstone := principalBoundarySoundFullVerticalMasterCapstone_of_masterRoutes h_routes
  }

/-- Build unified full master surface directly from full master capstone. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_capstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf := by
  let h_suite :
      PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
    principalBoundarySoundFullVerticalSuite_of_masterCapstone h_cap
  let h_route :
      PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
    { viaTypingSuite := h_suite, viaRowPolyBundle := h_suite }
  refine {
    routes := { regular := h_route, dual := h_route }
    capstone := h_cap
  }

/-- Build unified full master surface from successful runs (split hooks). -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_routes
    (principalBoundarySoundFullVerticalMasterRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)

/-- Bundled-hook constructor for unified full master surface from successful runs. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_success
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/-- Alias: build unified full master surface via full master routes from successful runs. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success_via_fullVerticalMasterRoutes
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_success
    (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field

/-- Bundled alias for unified full master surface via full master routes. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success_via_fullVerticalMasterRoutes_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_success_from_bundle
    h_seed h_ok_expr h_ok_field

/-- Alias: build unified full master surface via full master capstone from successful runs. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success_via_fullVerticalMasterCapstone
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_capstone
    (principalBoundarySoundFullVerticalMasterCapstone_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)

/-- Bundled alias for unified full master surface via full master capstone. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success_via_fullVerticalMasterCapstone_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_success_via_fullVerticalMasterCapstone
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/-- Explicit row-poly alias for unified full master surface construction. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    (h_bundle : PrincipalRowPolyBoundarySoundBundle h_app h_proj)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_routes
    (principalBoundarySoundFullVerticalMasterRoutes_of_success_via_rowPolyBoundarySoundBundle
      (h_bundle := h_bundle) h_ok_expr h_ok_field)

/-- Bundled alias for explicit row-poly unified full master surface construction. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success_via_rowPolyBoundarySoundBundle_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_success_from_bundle
    h_seed h_ok_expr h_ok_field

/-- Explicit typing-route alias for unified full master surface construction. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_success
    (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field

/-- Bundled typing-route alias for unified full master surface construction. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success_via_typingRunBundleSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_success_from_bundle
    h_seed h_ok_expr h_ok_field

/-- Explicit dual-route alias for unified full master surface construction. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_success
    (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field

/-- Bundled dual-route alias for unified full master surface construction. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_success_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_of_success_from_bundle
    h_seed h_ok_expr h_ok_field

/-- One-hop projection: full master routes from unified full master surface. -/
theorem principalBoundarySoundFullVerticalMasterSurface_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  h_surface.routes

/-- One-hop projection: full master capstone from unified full master surface. -/
theorem principalBoundarySoundFullVerticalMasterSurface_capstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  h_surface.capstone

/-- One-hop projection: expression full consequence from unified full master surface. -/
theorem principalBoundarySoundFullVerticalMasterSurface_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  h_surface.capstone.expr

/-- One-hop projection: field full consequence from unified full master surface. -/
theorem principalBoundarySoundFullVerticalMasterSurface_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  h_surface.capstone.field

/-- One-hop projection: no-unify expression full consequence from unified full master surface. -/
theorem principalBoundarySoundFullVerticalMasterSurface_noUnifyExpr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesExpr e) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_surface.capstone.noUnifyExpr h_no

/-- One-hop projection: no-unify field full consequence from unified full master surface. -/
theorem principalBoundarySoundFullVerticalMasterSurface_noUnifyField
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_surface.capstone.noUnifyField h_no

/-- One-hop projection: hook-free app vertical consequence from unified full master surface. -/
theorem principalBoundarySoundFullVerticalMasterSurface_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_surface.capstone.verticalApp

/-- One-hop projection: hook-free projection vertical consequence from unified full master surface. -/
theorem principalBoundarySoundFullVerticalMasterSurface_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_surface.capstone.verticalProj

/--
Unified full master surface is equivalent to an explicit full master-routes witness.
-/
theorem principalBoundarySoundFullVerticalMasterSurface_iff_masterRoutes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf
      ↔ PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf := by
  constructor
  · intro h_surface
    exact h_surface.routes
  · intro h_routes
    exact principalBoundarySoundFullVerticalMasterSurface_of_routes h_routes

/--
Unified full master surface is equivalent to an explicit full master-capstone witness.
-/
theorem principalBoundarySoundFullVerticalMasterSurface_iff_masterCapstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf
      ↔ PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  constructor
  · intro h_surface
    exact h_surface.capstone
  · intro h_cap
    exact principalBoundarySoundFullVerticalMasterSurface_of_capstone h_cap

/-- Decompose unified full master surface into direct consequence components. -/
theorem principalBoundarySoundFullVerticalMasterSurface_iff_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf
      ↔ (PrincipalBoundarySoundExprFull st fuel env e stExpr ty
          ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
          ∧ (NoUnifyBranchesExpr e →
              PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
          ∧ (NoUnifyBranchesFields fs →
              PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
          ∧ VerticalHookFreeAppSlice
          ∧ VerticalHookFreeProjSlice) := by
  constructor
  · intro h_surface
    exact principalBoundarySoundFullVerticalMasterCapstone_as_components h_surface.capstone
  · intro h_conseq
    exact principalBoundarySoundFullVerticalMasterSurface_of_capstone
      (principalBoundarySoundFullVerticalMasterCapstone_of_components h_conseq)

/-- Constructor helper from explicit consequence decomposition for unified full master surface. -/
theorem principalBoundarySoundFullVerticalMasterSurface_of_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_conseq :
      PrincipalBoundarySoundExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
        ∧ (NoUnifyBranchesExpr e →
            PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
        ∧ (NoUnifyBranchesFields fs →
            PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
        ∧ VerticalHookFreeAppSlice
        ∧ VerticalHookFreeProjSlice) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundFullVerticalMasterSurface_iff_consequences).2 h_conseq

/-- One-hop decomposition of unified full master surface into direct consequence components. -/
theorem principalBoundarySoundFullVerticalMasterSurface_as_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
      ∧ (NoUnifyBranchesExpr e →
          PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty)
      ∧ (NoUnifyBranchesFields fs →
          PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf)
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice :=
  (principalBoundarySoundFullVerticalMasterSurface_iff_consequences).1 h_surface

/-- Direct successful-run expression full wrapper via unified full master surface. -/
theorem principalBoundarySoundExprFull_of_success_via_fullVerticalMasterSurface
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  principalBoundarySoundFullVerticalMasterSurface_expr
    (principalBoundarySoundFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)

/-- Direct successful-run field full wrapper via unified full master surface. -/
theorem principalBoundarySoundFieldFull_of_success_via_fullVerticalMasterSurface
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_field
    (principalBoundarySoundFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)

/-- Direct successful-run no-unify expression full wrapper via unified full master surface. -/
theorem principalBoundarySoundNoUnifyExprFull_of_success_via_fullVerticalMasterSurface
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  principalBoundarySoundFullVerticalMasterSurface_noUnifyExpr
    (principalBoundarySoundFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)
    h_no_expr

/-- Direct successful-run no-unify field full wrapper via unified full master surface. -/
theorem principalBoundarySoundNoUnifyFieldFull_of_success_via_fullVerticalMasterSurface
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_noUnifyField
    (principalBoundarySoundFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)
    h_no_field

/-- Direct successful-run app vertical wrapper via unified full master surface. -/
theorem principalBoundarySound_verticalApp_of_success_via_fullVerticalMasterSurface
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeAppSlice :=
  principalBoundarySoundFullVerticalMasterSurface_vertical_app
    (principalBoundarySoundFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)

/-- Direct successful-run projection vertical wrapper via unified full master surface. -/
theorem principalBoundarySound_verticalProj_of_success_via_fullVerticalMasterSurface
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeProjSlice :=
  principalBoundarySoundFullVerticalMasterSurface_vertical_proj
    (principalBoundarySoundFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)

/-- Bundled-hook expression full wrapper via unified full master surface. -/
theorem principalBoundarySoundExprFull_of_success_via_fullVerticalMasterSurface_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  principalBoundarySoundExprFull_of_success_via_fullVerticalMasterSurface
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/-- Bundled-hook field full wrapper via unified full master surface. -/
theorem principalBoundarySoundFieldFull_of_success_via_fullVerticalMasterSurface_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  principalBoundarySoundFieldFull_of_success_via_fullVerticalMasterSurface
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/-- Bundled-hook no-unify expression full wrapper via unified full master surface. -/
theorem principalBoundarySoundNoUnifyExprFull_of_success_via_fullVerticalMasterSurface_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  principalBoundarySoundNoUnifyExprFull_of_success_via_fullVerticalMasterSurface
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_ok_expr h_ok_field

/-- Bundled-hook no-unify field full wrapper via unified full master surface. -/
theorem principalBoundarySoundNoUnifyFieldFull_of_success_via_fullVerticalMasterSurface_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  principalBoundarySoundNoUnifyFieldFull_of_success_via_fullVerticalMasterSurface
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_field h_ok_expr h_ok_field

/-- Bundled-hook app vertical wrapper via unified full master surface. -/
theorem principalBoundarySound_verticalApp_of_success_via_fullVerticalMasterSurface_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeAppSlice :=
  principalBoundarySound_verticalApp_of_success_via_fullVerticalMasterSurface
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/-- Bundled-hook projection vertical wrapper via unified full master surface. -/
theorem principalBoundarySound_verticalProj_of_success_via_fullVerticalMasterSurface_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeProjSlice :=
  principalBoundarySound_verticalProj_of_success_via_fullVerticalMasterSurface
    (h_app := h_seed.1) (h_proj := h_seed.2) h_ok_expr h_ok_field

/--
No-unify-specialized packaged consequence surface from
`FullVerticalMasterCapstone`.
-/
structure PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  exprNoUnify : PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
  fieldNoUnify : PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
  verticalApp : VerticalHookFreeAppSlice
  verticalProj : VerticalHookFreeProjSlice

/-- Build the no-unify-specialized packaged capstone from a master-capstone witness. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_masterCapstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  refine {
    exprNoUnify := h_cap.noUnifyExpr h_no_expr
    fieldNoUnify := h_cap.noUnifyField h_no_field
    verticalApp := h_cap.verticalApp
    verticalProj := h_cap.verticalProj
  }

/-- Hook-seeded constructor for the no-unify-specialized packaged capstone. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_masterCapstone
    (principalBoundarySoundFullVerticalMasterCapstone_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)
    h_no_expr h_no_field

/-- Bundled-hook constructor for the no-unify-specialized packaged capstone. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_success
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/--
No-unify master capstone is equivalent to an explicit conjunction of its
no-unify and vertical components.
-/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_iff_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf
      ↔ (PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
          ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
          ∧ VerticalHookFreeAppSlice
          ∧ VerticalHookFreeProjSlice) := by
  constructor
  · intro h_cap
    exact ⟨h_cap.exprNoUnify, h_cap.fieldNoUnify, h_cap.verticalApp, h_cap.verticalProj⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2.1, h_comp.2.2.1, h_comp.2.2.2⟩

/-- Constructor helper from explicit components for the no-unify master capstone. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_comp :
      PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
        ∧ VerticalHookFreeAppSlice
        ∧ VerticalHookFreeProjSlice) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_iff_components).2 h_comp

/-- Direct component-route decomposition for the no-unify master capstone. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components_of_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_comp :
      PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
        ∧ VerticalHookFreeAppSlice
        ∧ VerticalHookFreeProjSlice) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  simpa using h_comp

/-- One-hop decomposition of the no-unify master capstone into explicit components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice :=
  (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_iff_components).1 h_cap

/-- Direct route decomposition from `of_masterCapstone` into no-unify components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components_of_masterCapstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_masterCapstone
      h_cap h_no_expr h_no_field)

/-- Direct route decomposition from `of_success` into no-unify components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_success
      (h_app := h_app) (h_proj := h_proj)
      h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_from_bundle` into no-unify components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_success_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/--
No-unify-specialized full+vertical suite surface.
-/
structure PrincipalBoundarySoundNoUnifyFullVerticalSuite
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  exprNoUnify : PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
  fieldNoUnify : PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
  vertical : VerticalHookFreeUnifySlices

/-- Explicit component alias for `PrincipalBoundarySoundNoUnifyFullVerticalSuite`. -/
abbrev PrincipalBoundarySoundNoUnifyFullVerticalSuiteComponents
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop :=
  PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
    ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
    ∧ VerticalHookFreeUnifySlices

/-- Convert the no-unify master capstone into the no-unify full+vertical suite surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_masterCapstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf := by
  refine {
    exprNoUnify := h_cap.exprNoUnify
    fieldNoUnify := h_cap.fieldNoUnify
    vertical := ⟨h_cap.verticalApp, h_cap.verticalProj⟩
  }

/-- Convert the no-unify full+vertical suite surface into the no-unify master capstone. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_fullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  refine {
    exprNoUnify := h_suite.exprNoUnify
    fieldNoUnify := h_suite.fieldNoUnify
    verticalApp := h_suite.vertical.1
    verticalProj := h_suite.vertical.2
  }

/-- Direct route decomposition from `of_fullVerticalSuite` into no-unify components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components_of_fullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_fullVerticalSuite h_suite)

/-- Equivalence between no-unify master-capstone and no-unify full+vertical suite surfaces. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_iff_fullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf
      ↔ PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf := by
  constructor
  · intro h_cap
    exact principalBoundarySoundNoUnifyFullVerticalSuite_of_masterCapstone h_cap
  · intro h_suite
    exact principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_fullVerticalSuite h_suite

/-- Hook-seeded constructor for the no-unify full+vertical suite surface from successful runs. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_masterCapstone
    (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Bundled-hook constructor for the no-unify full+vertical suite surface from successful runs. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_success
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/--
Convert a full+vertical suite witness into the no-unify-specialized full+vertical suite
using explicit no-unify branch premises.
-/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_fullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf := by
  refine {
    exprNoUnify := h_suite.full.noUnifyExpr h_no_expr
    fieldNoUnify := h_suite.full.noUnifyField h_no_field
    vertical := h_suite.vertical
  }

/-- Row-poly bundle route constructor for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_fullVerticalSuite
    (principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
      (h_bundle := principalRowPolyBoundarySoundBundle_of_hooks h_app h_proj)
      h_ok_expr h_ok_field)
    h_no_expr h_no_field

/-- Bundled row-poly bundle route constructor for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Proved row-poly bundle route constructor for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_proved
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
    (h_app := h_app) (h_proj := h_proj)
    h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled proved row-poly bundle route constructor for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_proved_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_proved
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Dual-route row-poly bundle constructor for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_fullVerticalSuite
    (principalBoundarySoundFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)
    h_no_expr h_no_field

/-- Bundled dual-route row-poly bundle constructor for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Typing-suite route constructor for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_fullVerticalSuite
    (principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)
    h_no_expr h_no_field

/-- Bundled typing-suite route constructor for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Dual-route typing-suite constructor for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_fullVerticalSuite
    (principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)
    h_no_expr h_no_field

/-- Bundled dual-route typing-suite constructor for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- One-hop projection: no-unify expression full consequence from no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_suite.exprNoUnify

/-- One-hop projection: no-unify field full consequence from no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_suite.fieldNoUnify

/-- One-hop projection: hook-free vertical pair from no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices :=
  h_suite.vertical

/-- One-hop projection: hook-free app vertical consequence from no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_suite.vertical.1

/-- One-hop projection: hook-free projection vertical consequence from no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_suite.vertical.2

/-- No-unify full+vertical suite decomposes to explicit no-unify + vertical components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_iff_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf
      ↔ (PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
          ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
          ∧ VerticalHookFreeUnifySlices) := by
  constructor
  · intro h_suite
    exact ⟨h_suite.exprNoUnify, h_suite.fieldNoUnify, h_suite.vertical⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2.1, h_comp.2.2⟩

/-- Constructor helper from explicit components for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_comp :
      PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
        ∧ VerticalHookFreeUnifySlices) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundNoUnifyFullVerticalSuite_iff_components).2 h_comp

/-- One-hop decomposition of no-unify full+vertical suite into explicit components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices :=
  (principalBoundarySoundNoUnifyFullVerticalSuite_iff_components).1 h_suite

/-- Direct component-route decomposition for no-unify full+vertical suite. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_comp :
      PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
        ∧ VerticalHookFreeUnifySlices) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  simpa using h_comp

/-- Direct route decomposition from `of_masterCapstone` into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_masterCapstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_masterCapstone h_cap)

/-- Direct route decomposition from `of_success` into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success
      (h_app := h_app) (h_proj := h_proj)
      h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_from_bundle` into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_fullVerticalSuite` into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_fullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_fullVerticalSuite
      h_suite h_no_expr h_no_field)

/-- Direct route decomposition from row-poly-bundle success into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from bundled row-poly-bundle success into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success_via_rowPolyBoundarySoundBundle_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from proved row-poly-bundle success into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success_via_rowPolyBoundarySoundBundle_proved
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_proved
      (h_app := h_app) (h_proj := h_proj)
      h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from bundled proved row-poly-bundle success into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success_via_rowPolyBoundarySoundBundle_proved_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_proved_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from dual-routed row-poly-bundle success into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices
      (h_app := h_app) (h_proj := h_proj)
      h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from bundled dual-routed row-poly-bundle success into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from typing-run-bundle success into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from bundled typing-run-bundle success into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success_via_typingRunBundleSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from dual-routed typing-run-bundle success into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices
      (h_app := h_app) (h_proj := h_proj)
      h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from bundled dual-routed typing-run-bundle success into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/--
Route-pair packaging for no-unify full+vertical suites:
one witness carries both the typing-suite route and the row-poly-bundle route.
-/
structure PrincipalBoundarySoundNoUnifyFullVerticalRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  viaTypingSuite :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf
  viaRowPolyBundle :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf

/-- Build no-unify full+vertical route-pair packaging from successful runs. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf := by
  refine {
    viaTypingSuite :=
      principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite
        (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field
    viaRowPolyBundle :=
      principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle
        (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field
  }

/-- Bundled-hook constructor alias for no-unify full+vertical route-pair packaging. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalRoutes_of_success
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Build no-unify full+vertical route-pair packaging through dual route constructors. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_of_success_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf := by
  refine {
    viaTypingSuite :=
      principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_typingRunBundleSuite_via_dualConsequenceSlices
        (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field
    viaRowPolyBundle :=
      principalBoundarySoundNoUnifyFullVerticalSuite_of_success_via_rowPolyBoundarySoundBundle_via_dualConsequenceSlices
        (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field
  }

/-- Bundled-hook dual constructor alias for no-unify full+vertical route-pair packaging. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_of_success_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalRoutes_of_success_via_dualConsequenceSlices
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- One-hop projection: typing-suite no-unify full+vertical route from the route pair. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaTypingSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_routes.viaTypingSuite

/-- One-hop projection: row-poly-bundle no-unify full+vertical route from the route pair. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaRowPolyBundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_routes.viaRowPolyBundle

/-- One-hop projection: no-unify expr full consequence via typing-suite route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaTypingSuite_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_routes.viaTypingSuite.exprNoUnify

/-- One-hop projection: no-unify field full consequence via typing-suite route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaTypingSuite_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_routes.viaTypingSuite.fieldNoUnify

/-- One-hop projection: hook-free vertical pair via typing-suite route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaTypingSuite_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices :=
  h_routes.viaTypingSuite.vertical

/-- One-hop projection: hook-free app vertical theorem via typing-suite route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaTypingSuite_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_routes.viaTypingSuite.vertical.1

/-- One-hop projection: hook-free projection vertical theorem via typing-suite route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaTypingSuite_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_routes.viaTypingSuite.vertical.2

/-- One-hop projection: no-unify expr full consequence via row-poly route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaRowPolyBundle_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_routes.viaRowPolyBundle.exprNoUnify

/-- One-hop projection: no-unify field full consequence via row-poly route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaRowPolyBundle_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_routes.viaRowPolyBundle.fieldNoUnify

/-- One-hop projection: hook-free vertical pair via row-poly route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaRowPolyBundle_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices :=
  h_routes.viaRowPolyBundle.vertical

/-- One-hop projection: hook-free app vertical theorem via row-poly route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaRowPolyBundle_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_routes.viaRowPolyBundle.vertical.1

/-- One-hop projection: hook-free projection vertical theorem via row-poly route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaRowPolyBundle_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_routes.viaRowPolyBundle.vertical.2

/-- One-hop local decomposition on the typing-suite no-unify route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaTypingSuite_as_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices :=
  ⟨h_routes.viaTypingSuite.exprNoUnify, h_routes.viaTypingSuite.fieldNoUnify, h_routes.viaTypingSuite.vertical⟩

/-- One-hop local decomposition on the row-poly no-unify route branch. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_viaRowPolyBundle_as_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices :=
  ⟨h_routes.viaRowPolyBundle.exprNoUnify, h_routes.viaRowPolyBundle.fieldNoUnify, h_routes.viaRowPolyBundle.vertical⟩

/-- Lift a full-vertical route-pair witness into the no-unify route-pair layer under no-unify premises. -/
theorem principalBoundarySoundNoUnifyFullVerticalRoutes_of_fullVerticalRoutes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundFullVerticalRoutes st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf := by
  refine {
    viaTypingSuite :=
      principalBoundarySoundNoUnifyFullVerticalSuite_of_fullVerticalSuite
        h_routes.viaTypingSuite h_no_expr h_no_field
    viaRowPolyBundle :=
      principalBoundarySoundNoUnifyFullVerticalSuite_of_fullVerticalSuite
        h_routes.viaRowPolyBundle h_no_expr h_no_field
  }

/--
Master route packaging for no-unify full+vertical surfaces:
one witness carries both regular and dual no-unify route pairs.
-/
structure PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  regular :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf
  dual :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf

/-- Build no-unify full+vertical master routes from a bundled hook seed. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf := by
  refine {
    regular := principalBoundarySoundNoUnifyFullVerticalRoutes_of_success_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field
    dual := principalBoundarySoundNoUnifyFullVerticalRoutes_of_success_via_dualConsequenceSlices_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field
  }

/-- Build no-unify full+vertical master routes from split hook premises. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success_from_bundle
    (h_seed := ⟨h_app, h_proj⟩) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Lift full-vertical master routes into no-unify master routes under no-unify premises. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_fullVerticalMasterRoutes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf := by
  refine {
    regular :=
      principalBoundarySoundNoUnifyFullVerticalRoutes_of_fullVerticalRoutes
        h_master.regular h_no_expr h_no_field
    dual :=
      principalBoundarySoundNoUnifyFullVerticalRoutes_of_fullVerticalRoutes
        h_master.dual h_no_expr h_no_field
  }

/-- Explicit row-poly route alias for no-unify full-vertical master-route construction. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success
    (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled-hook alias for explicit row-poly no-unify full-vertical master-route construction. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success_via_rowPolyBoundarySoundBundle_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success_from_bundle
    h_seed h_no_expr h_no_field h_ok_expr h_ok_field

/-- Explicit typing-route alias for no-unify full-vertical master-route construction. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success
    (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled-hook alias for explicit typing-route no-unify master-route construction. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success_via_typingRunBundleSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success_from_bundle
    h_seed h_no_expr h_no_field h_ok_expr h_ok_field

/-- Explicit dual-route constructor for no-unify full-vertical master-route packaging. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success
    (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled-hook alias for explicit dual-route no-unify master-route construction. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success_from_bundle
    h_seed h_no_expr h_no_field h_ok_expr h_ok_field

/-- One-hop projection: regular no-unify route pair from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_regular
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  h_master.regular

/-- One-hop projection: dual no-unify route pair from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_dual
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  h_master.dual

/-- One-hop projection: regular typing-suite branch from no-unify master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_regular_viaTypingSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_master.regular.viaTypingSuite

/-- One-hop projection: regular row-poly branch from no-unify master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_regular_viaRowPolyBundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_master.regular.viaRowPolyBundle

/-- One-hop projection: dual typing-suite branch from no-unify master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_dual_viaTypingSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_master.dual.viaTypingSuite

/-- One-hop projection: dual row-poly branch from no-unify master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_dual_viaRowPolyBundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  h_master.dual.viaRowPolyBundle

/-- Build the no-unify master capstone from the regular branch of no-unify master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_noUnifyMasterRoutes_regular
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_fullVerticalSuite
    h_master.regular.viaTypingSuite

/-- Build the no-unify master capstone from the dual branch of no-unify master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_noUnifyMasterRoutes_dual
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_fullVerticalSuite
    h_master.dual.viaTypingSuite

/-- Canonical capstone projection from no-unify master routes (via regular branch). -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_noUnifyMasterRoutes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_noUnifyMasterRoutes_regular h_master

/-- Direct route decomposition from regular no-unify master-routes projection. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components_of_noUnifyMasterRoutes_regular
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_noUnifyMasterRoutes_regular h_master)

/-- Direct route decomposition from dual no-unify master-routes projection. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components_of_noUnifyMasterRoutes_dual
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_noUnifyMasterRoutes_dual h_master)

/-- Direct route decomposition from canonical no-unify master-routes projection. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components_of_noUnifyMasterRoutes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_noUnifyMasterRoutes h_master)

/-- Master no-unify routes decompose to explicit regular and dual route-pair witnesses. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_iff_regular_and_dual
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ↔ (PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf
          ∧ PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) := by
  constructor
  · intro h_master
    exact ⟨h_master.regular, h_master.dual⟩
  · intro h_pair
    exact ⟨h_pair.1, h_pair.2⟩

/-- Constructor helper from explicit regular/dual no-unify route-pair witnesses. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_pair :
      PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf
        ∧ PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundNoUnifyFullVerticalMasterRoutes_iff_regular_and_dual).2 h_pair

/-- One-hop decomposition of master no-unify routes into regular and dual route pairs. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_as_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundNoUnifyFullVerticalMasterRoutes_iff_regular_and_dual).1 h_master

/-- One-hop projection: regular no-unify expr full consequence from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_regular_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_master.regular.viaTypingSuite.exprNoUnify

/-- One-hop projection: regular no-unify field full consequence from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_regular_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_master.regular.viaTypingSuite.fieldNoUnify

/-- One-hop projection: regular hook-free app vertical consequence from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_regular_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_master.regular.viaTypingSuite.vertical.1

/-- One-hop projection: regular hook-free projection vertical consequence from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_regular_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_master.regular.viaTypingSuite.vertical.2

/-- One-hop projection: regular hook-free vertical pair from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_regular_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices :=
  h_master.regular.viaTypingSuite.vertical

/-- One-hop projection: dual no-unify expr full consequence from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_dual_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_master.dual.viaTypingSuite.exprNoUnify

/-- One-hop projection: dual no-unify field full consequence from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_dual_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_master.dual.viaTypingSuite.fieldNoUnify

/-- One-hop projection: dual hook-free app vertical consequence from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_dual_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_master.dual.viaTypingSuite.vertical.1

/-- One-hop projection: dual hook-free projection vertical consequence from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_dual_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_master.dual.viaTypingSuite.vertical.2

/-- One-hop projection: dual hook-free vertical pair from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_dual_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices :=
  h_master.dual.viaTypingSuite.vertical

/-- One-hop paired extraction: regular+dual no-unify expr full consequences from master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_expr_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  ⟨h_master.regular.viaTypingSuite.exprNoUnify, h_master.dual.viaTypingSuite.exprNoUnify⟩

/-- One-hop paired extraction: regular+dual no-unify field full consequences from master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_field_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  ⟨h_master.regular.viaTypingSuite.fieldNoUnify, h_master.dual.viaTypingSuite.fieldNoUnify⟩

/-- One-hop paired extraction: regular+dual vertical pairs from master no-unify routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_vertical_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices ∧ VerticalHookFreeUnifySlices :=
  ⟨h_master.regular.viaTypingSuite.vertical, h_master.dual.viaTypingSuite.vertical⟩

/-- One-hop paired extraction: regular+dual no-unify component decompositions from master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_components_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    (PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices)
      ∧
      (PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
        ∧ VerticalHookFreeUnifySlices) :=
  ⟨⟨h_master.regular.viaTypingSuite.exprNoUnify, h_master.regular.viaTypingSuite.fieldNoUnify,
      h_master.regular.viaTypingSuite.vertical⟩,
    ⟨h_master.dual.viaTypingSuite.exprNoUnify, h_master.dual.viaTypingSuite.fieldNoUnify,
      h_master.dual.viaTypingSuite.vertical⟩⟩

/-- One-hop decomposition: regular branch from no-unify master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_regular_as_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices :=
  ⟨h_master.regular.viaTypingSuite.exprNoUnify, h_master.regular.viaTypingSuite.fieldNoUnify,
    h_master.regular.viaTypingSuite.vertical⟩

/-- One-hop decomposition: dual branch from no-unify master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterRoutes_dual_as_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices :=
  ⟨h_master.dual.viaTypingSuite.exprNoUnify, h_master.dual.viaTypingSuite.fieldNoUnify,
    h_master.dual.viaTypingSuite.vertical⟩

/--
Unified no-unify master surface:
one witness carries both no-unify master routes and no-unify master capstone.
-/
structure PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  routes : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
  capstone : PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf

/-- Build unified no-unify master surface directly from no-unify master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf := by
  refine {
    routes := h_routes
    capstone := principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_noUnifyMasterRoutes h_routes
  }

/-- Build unified no-unify master surface directly from no-unify master capstone. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_capstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf := by
  let h_suite :
      PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
    principalBoundarySoundNoUnifyFullVerticalSuite_of_masterCapstone h_cap
  let h_route :
      PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
    { viaTypingSuite := h_suite, viaRowPolyBundle := h_suite }
  refine {
    routes := { regular := h_route, dual := h_route }
    capstone := h_cap
  }

/-- Build unified no-unify master surface from successful runs (split hooks). -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_routes
    (principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Bundled-hook constructor for unified no-unify master surface from successful runs. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Lift full-vertical master routes into unified no-unify master surface under no-unify premises. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_fullVerticalMasterRoutes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_routes
    (principalBoundarySoundNoUnifyFullVerticalMasterRoutes_of_fullVerticalMasterRoutes
      h_master h_no_expr h_no_field)

/-- Lift unified full master surface into unified no-unify master surface under no-unify premises. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_fullVerticalMasterSurface
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_fullVerticalMasterRoutes
    h_surface.routes h_no_expr h_no_field

/--
Combined full/no-unify master-surface package:
one witness carries the general full master surface and its no-unify specialization.
-/
structure PrincipalBoundarySoundFullNoUnifyMasterSurfacePair
    (st : UnifyState) (fuel : Nat) (env : TermEnv)
    (e : CoreExpr) (fs : CoreFields)
    (stExpr : UnifyState) (ty : Ty)
    (stField : UnifyState) (rf : RowFields) : Prop where
  full : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf
  noUnify : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf

/-- Build the combined full/no-unify package from explicit surface witnesses. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_of_surfaces
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_full : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf)
    (h_no : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf := by
  exact ⟨h_full, h_no⟩

/-- Build the combined full/no-unify package from successful runs (split hooks). -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf := by
  let h_full :
      PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
    principalBoundarySoundFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field
  refine {
    full := h_full
    noUnify :=
      principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_fullVerticalMasterSurface
        h_full h_no_expr h_no_field
  }

/-- Bundled-hook constructor for the combined full/no-unify package from successful runs. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundFullNoUnifyMasterSurfacePair_of_success
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- One-hop projection: general full master surface from the combined package. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_full
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_pair : PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  h_pair.full

/-- One-hop projection: no-unify master surface from the combined package. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_noUnify
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_pair : PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  h_pair.noUnify

/-- Combined package is equivalent to explicit full/no-unify surface conjunction. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_iff_surfaces
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf
      ↔ (PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf
          ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) := by
  constructor
  · intro h_pair
    exact ⟨h_pair.full, h_pair.noUnify⟩
  · intro h_surfaces
    exact ⟨h_surfaces.1, h_surfaces.2⟩

/-- One-hop full expression consequence from the combined package. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_pair : PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  principalBoundarySoundFullVerticalMasterSurface_expr h_pair.full

/-- One-hop full field consequence from the combined package. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_pair : PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  principalBoundarySoundFullVerticalMasterSurface_field h_pair.full

/-- One-hop no-unify expression consequence from the combined package. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_noUnifyExpr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_pair : PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_pair.noUnify.capstone.exprNoUnify

/-- One-hop no-unify field consequence from the combined package. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_noUnifyField
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_pair : PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_pair.noUnify.capstone.fieldNoUnify

/-- One-hop app vertical consequence from the combined package. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_pair : PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  principalBoundarySoundFullVerticalMasterSurface_vertical_app h_pair.full

/-- One-hop projection vertical consequence from the combined package. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_pair : PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  principalBoundarySoundFullVerticalMasterSurface_vertical_proj h_pair.full

/-- Decompose the combined package into direct consequence components. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_iff_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf
      ↔ (PrincipalBoundarySoundExprFull st fuel env e stExpr ty
          ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
          ∧ PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
          ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
          ∧ VerticalHookFreeAppSlice
          ∧ VerticalHookFreeProjSlice) := by
  constructor
  · intro h_pair
    exact ⟨h_pair.full.capstone.expr,
      h_pair.full.capstone.field,
      h_pair.noUnify.capstone.exprNoUnify,
      h_pair.noUnify.capstone.fieldNoUnify,
      h_pair.full.capstone.verticalApp,
      h_pair.full.capstone.verticalProj⟩
  · intro h_conseq
    let h_full :
        PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
      principalBoundarySoundFullVerticalMasterSurface_of_consequences
        ⟨h_conseq.1,
          h_conseq.2.1,
          (fun _ => h_conseq.2.2.1),
          (fun _ => h_conseq.2.2.2.1),
          h_conseq.2.2.2.2.1,
          h_conseq.2.2.2.2.2⟩
    let h_no_cap :
        PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
      principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_components
        ⟨h_conseq.2.2.1, h_conseq.2.2.2.1, h_conseq.2.2.2.2.1, h_conseq.2.2.2.2.2⟩
    let h_no :
        PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
      principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_capstone h_no_cap
    exact ⟨h_full, h_no⟩

/-- Constructor helper from explicit consequence decomposition for the combined package. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_of_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_conseq :
      PrincipalBoundarySoundExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
        ∧ PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
        ∧ VerticalHookFreeAppSlice
        ∧ VerticalHookFreeProjSlice) :
    PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundFullNoUnifyMasterSurfacePair_iff_consequences).2 h_conseq

/-- One-hop decomposition of the combined package into direct consequence components. -/
theorem principalBoundarySoundFullNoUnifyMasterSurfacePair_as_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_pair : PrincipalBoundarySoundFullNoUnifyMasterSurfacePair st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundFieldFull st fuel env fs stField rf
      ∧ PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice :=
  (principalBoundarySoundFullNoUnifyMasterSurfacePair_iff_consequences).1 h_pair

/-- Direct successful-run expression full wrapper via combined full/no-unify package. -/
theorem principalBoundarySoundExprFull_of_success_via_fullNoUnifyMasterSurfacePair
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  principalBoundarySoundFullNoUnifyMasterSurfacePair_expr
    (principalBoundarySoundFullNoUnifyMasterSurfacePair_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct successful-run field full wrapper via combined full/no-unify package. -/
theorem principalBoundarySoundFieldFull_of_success_via_fullNoUnifyMasterSurfacePair
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  principalBoundarySoundFullNoUnifyMasterSurfacePair_field
    (principalBoundarySoundFullNoUnifyMasterSurfacePair_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct successful-run no-unify expression full wrapper via combined package. -/
theorem principalBoundarySoundNoUnifyExprFull_of_success_via_fullNoUnifyMasterSurfacePair
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  principalBoundarySoundFullNoUnifyMasterSurfacePair_noUnifyExpr
    (principalBoundarySoundFullNoUnifyMasterSurfacePair_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct successful-run no-unify field full wrapper via combined package. -/
theorem principalBoundarySoundNoUnifyFieldFull_of_success_via_fullNoUnifyMasterSurfacePair
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  principalBoundarySoundFullNoUnifyMasterSurfacePair_noUnifyField
    (principalBoundarySoundFullNoUnifyMasterSurfacePair_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct successful-run app vertical wrapper via combined full/no-unify package. -/
theorem principalBoundarySound_verticalApp_of_success_via_fullNoUnifyMasterSurfacePair
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeAppSlice :=
  principalBoundarySoundFullNoUnifyMasterSurfacePair_vertical_app
    (principalBoundarySoundFullNoUnifyMasterSurfacePair_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct successful-run projection vertical wrapper via combined full/no-unify package. -/
theorem principalBoundarySound_verticalProj_of_success_via_fullNoUnifyMasterSurfacePair
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeProjSlice :=
  principalBoundarySoundFullNoUnifyMasterSurfacePair_vertical_proj
    (principalBoundarySoundFullNoUnifyMasterSurfacePair_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Bundled-hook expression full wrapper via combined full/no-unify package. -/
theorem principalBoundarySoundExprFull_of_success_via_fullNoUnifyMasterSurfacePair_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  principalBoundarySoundExprFull_of_success_via_fullNoUnifyMasterSurfacePair
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled-hook field full wrapper via combined full/no-unify package. -/
theorem principalBoundarySoundFieldFull_of_success_via_fullNoUnifyMasterSurfacePair_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  principalBoundarySoundFieldFull_of_success_via_fullNoUnifyMasterSurfacePair
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled-hook no-unify expression full wrapper via combined package. -/
theorem principalBoundarySoundNoUnifyExprFull_of_success_via_fullNoUnifyMasterSurfacePair_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  principalBoundarySoundNoUnifyExprFull_of_success_via_fullNoUnifyMasterSurfacePair
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled-hook no-unify field full wrapper via combined package. -/
theorem principalBoundarySoundNoUnifyFieldFull_of_success_via_fullNoUnifyMasterSurfacePair_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  principalBoundarySoundNoUnifyFieldFull_of_success_via_fullNoUnifyMasterSurfacePair
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled-hook app vertical wrapper via combined full/no-unify package. -/
theorem principalBoundarySound_verticalApp_of_success_via_fullNoUnifyMasterSurfacePair_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeAppSlice :=
  principalBoundarySound_verticalApp_of_success_via_fullNoUnifyMasterSurfacePair
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled-hook projection vertical wrapper via combined full/no-unify package. -/
theorem principalBoundarySound_verticalProj_of_success_via_fullNoUnifyMasterSurfacePair_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeProjSlice :=
  principalBoundarySound_verticalProj_of_success_via_fullNoUnifyMasterSurfacePair
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Alias: build unified no-unify master surface via no-unify master routes from successful runs. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_noUnifyMasterRoutes
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
    (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled alias for unified no-unify master surface via no-unify master routes. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_noUnifyMasterRoutes_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_from_bundle
    h_seed h_no_expr h_no_field h_ok_expr h_ok_field

/-- Alias: build unified no-unify master surface via row-poly route from successful runs. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
    (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled alias: unified no-unify master surface via row-poly route. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_rowPolyBoundarySoundBundle_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_from_bundle
    h_seed h_no_expr h_no_field h_ok_expr h_ok_field

/-- Alias: build unified no-unify master surface via typing-route from successful runs. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
    (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled alias: unified no-unify master surface via typing-route. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_typingRunBundleSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_from_bundle
    h_seed h_no_expr h_no_field h_ok_expr h_ok_field

/-- Alias: build unified no-unify master surface via dual-routed entry from successful runs. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
    (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled alias: unified no-unify master surface via dual-routed entry. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_from_bundle
    h_seed h_no_expr h_no_field h_ok_expr h_ok_field

/--
Build unified no-unify master surface from the general full master capstone,
using explicit no-unify branch premises.
-/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_masterCapstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_capstone
    (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_masterCapstone
      h_cap h_no_expr h_no_field)

/-- Build unified no-unify master surface from the full+vertical suite surface and no-unify premises. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_fullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_masterCapstone
    (principalBoundarySoundFullVerticalMasterCapstone_of_fullVerticalSuite h_suite)
    h_no_expr h_no_field

/-- Hook-seeded full-master-capstone route constructor for the unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_fullVerticalMasterCapstone
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_masterCapstone
    (principalBoundarySoundFullVerticalMasterCapstone_of_success
      (h_app := h_app) (h_proj := h_proj) h_ok_expr h_ok_field)
    h_no_expr h_no_field

/-- Bundled full-master-capstone route constructor for the unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_fullVerticalMasterCapstone_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_fullVerticalMasterCapstone
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Build unified no-unify master surface via no-unify master capstone from successful runs. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_noUnifyMasterCapstone
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_capstone
    (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Bundled constructor for unified no-unify master surface via no-unify master capstone. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_noUnifyMasterCapstone_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_noUnifyMasterCapstone
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Alias: build unified no-unify master surface via full-vertical master-routes route. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_fullVerticalMasterRoutes
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
    (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled alias: unified no-unify master surface via full-vertical master-routes route. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_fullVerticalMasterRoutes_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_from_bundle
    h_seed h_no_expr h_no_field h_ok_expr h_ok_field

/-- One-hop projection: no-unify master routes from unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf :=
  h_surface.routes

/-- One-hop projection: no-unify master capstone from unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_capstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  h_surface.capstone

/-- One-hop projection: no-unify expr full consequence from unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  h_surface.capstone.exprNoUnify

/-- One-hop projection: no-unify field full consequence from unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  h_surface.capstone.fieldNoUnify

/-- One-hop projection: hook-free app vertical consequence from unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_surface.capstone.verticalApp

/-- One-hop projection: hook-free projection vertical consequence from unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_surface.capstone.verticalProj

/-- Unified no-unify master surface is equivalent to no-unify master-routes surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_iff_masterRoutes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf
      ↔ PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf := by
  constructor
  · intro h_surface
    exact h_surface.routes
  · intro h_routes
    exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_routes h_routes

/-- Unified no-unify master surface is equivalent to no-unify master-capstone surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_iff_masterCapstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf
      ↔ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  constructor
  · intro h_surface
    exact h_surface.capstone
  · intro h_cap
    exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_capstone h_cap

/-- One-hop projection: regular no-unify route pair from unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_regular_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  h_surface.routes.regular

/-- One-hop projection: dual no-unify route pair from unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_dual_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  h_surface.routes.dual

/-- One-hop paired extraction: regular+dual no-unify route pairs from unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_routes_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalRoutes st fuel env e fs stExpr ty stField rf :=
  ⟨h_surface.routes.regular, h_surface.routes.dual⟩

/-- One-hop paired extraction: regular+dual no-unify expr full consequences from unified surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_expr_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  principalBoundarySoundNoUnifyFullVerticalMasterRoutes_expr_pair h_surface.routes

/-- One-hop paired extraction: regular+dual no-unify field full consequences from unified surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_field_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterRoutes_field_pair h_surface.routes

/-- One-hop paired extraction: regular+dual vertical pairs from unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_vertical_pair
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices ∧ VerticalHookFreeUnifySlices :=
  principalBoundarySoundNoUnifyFullVerticalMasterRoutes_vertical_pair h_surface.routes

/-- Direct no-unify expr full consequence wrapper via unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyExprFull_of_success_via_noUnifyMasterSurface
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field).capstone.exprNoUnify

/-- Direct no-unify field full consequence wrapper via unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFieldFull_of_success_via_noUnifyMasterSurface
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field).capstone.fieldNoUnify

/-- Direct hook-free app vertical wrapper via unified no-unify master surface. -/
theorem principalBoundarySoundNoUnify_verticalApp_of_success_via_noUnifyMasterSurface
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeAppSlice :=
  (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field).capstone.verticalApp

/-- Direct hook-free projection vertical wrapper via unified no-unify master surface. -/
theorem principalBoundarySoundNoUnify_verticalProj_of_success_via_noUnifyMasterSurface
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeProjSlice :=
  (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field).capstone.verticalProj

/-- Bundled alias for direct no-unify expr wrapper via unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyExprFull_of_success_via_noUnifyMasterSurface_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  principalBoundarySoundNoUnifyExprFull_of_success_via_noUnifyMasterSurface
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled alias for direct no-unify field wrapper via unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFieldFull_of_success_via_noUnifyMasterSurface_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  principalBoundarySoundNoUnifyFieldFull_of_success_via_noUnifyMasterSurface
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled alias for direct no-unify app vertical wrapper via unified no-unify master surface. -/
theorem principalBoundarySoundNoUnify_verticalApp_of_success_via_noUnifyMasterSurface_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeAppSlice :=
  principalBoundarySoundNoUnify_verticalApp_of_success_via_noUnifyMasterSurface
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Bundled alias for direct no-unify projection vertical wrapper via unified no-unify master surface. -/
theorem principalBoundarySoundNoUnify_verticalProj_of_success_via_noUnifyMasterSurface_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    VerticalHookFreeProjSlice :=
  principalBoundarySoundNoUnify_verticalProj_of_success_via_noUnifyMasterSurface
    (h_app := h_seed.1) (h_proj := h_seed.2) h_no_expr h_no_field h_ok_expr h_ok_field

/-- Unified no-unify master surface is equivalent to explicit no-unify consequence conjunction. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_iff_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf
      ↔ (PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
          ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
          ∧ VerticalHookFreeAppSlice
          ∧ VerticalHookFreeProjSlice) := by
  constructor
  · intro h_surface
    exact principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components h_surface.capstone
  · intro h_conseq
    exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_capstone
      (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_components h_conseq)

/-- Constructor helper from explicit no-unify consequences for unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_conseq :
      PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
        ∧ VerticalHookFreeAppSlice
        ∧ VerticalHookFreeProjSlice) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundNoUnifyFullVerticalMasterSurface_iff_consequences).2 h_conseq

/-- One-hop decomposition from unified no-unify master surface into explicit no-unify consequences. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeAppSlice
      ∧ VerticalHookFreeProjSlice :=
  (principalBoundarySoundNoUnifyFullVerticalMasterSurface_iff_consequences).1 h_surface

/-- Unified no-unify master surface decomposes to explicit routes + capstone components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_iff_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf
      ↔ (PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
          ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf) := by
  constructor
  · intro h_surface
    exact ⟨h_surface.routes, h_surface.capstone⟩
  · intro h_comp
    exact ⟨h_comp.1, h_comp.2⟩

/-- Constructor helper from explicit components for unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_comp :
      PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
        ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundNoUnifyFullVerticalMasterSurface_iff_components).2 h_comp

/-- One-hop decomposition of unified no-unify master surface into explicit components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf :=
  (principalBoundarySoundNoUnifyFullVerticalMasterSurface_iff_components).1 h_surface

/-- Direct component-route decomposition for unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_components
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_comp :
      PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
        ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  simpa using h_comp

/-- Direct route decomposition from `of_routes` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_routes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_routes : PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_routes h_routes)

/-- Direct route decomposition from `of_capstone` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_capstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_capstone h_cap)

/-- Direct route decomposition from `of_success` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success
      (h_app := h_app) (h_proj := h_proj)
      h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_from_bundle` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_dualConsequenceSlices` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_dualConsequenceSlices
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_dualConsequenceSlices
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_dualConsequenceSlices_from_bundle` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_dualConsequenceSlices_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_fullVerticalMasterCapstone` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_fullVerticalMasterCapstone
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_fullVerticalMasterCapstone
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_fullVerticalMasterCapstone_from_bundle` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_fullVerticalMasterCapstone_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_fullVerticalMasterCapstone_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_fullVerticalMasterRoutes` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_fullVerticalMasterRoutes
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_fullVerticalMasterRoutes
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_fullVerticalMasterRoutes_from_bundle` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_fullVerticalMasterRoutes_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_fullVerticalMasterRoutes_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_noUnifyMasterCapstone` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_noUnifyMasterCapstone
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_noUnifyMasterCapstone
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_noUnifyMasterCapstone_from_bundle` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_noUnifyMasterCapstone_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_noUnifyMasterCapstone_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_noUnifyMasterRoutes` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_noUnifyMasterRoutes
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_noUnifyMasterRoutes
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_noUnifyMasterRoutes_from_bundle` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_noUnifyMasterRoutes_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_noUnifyMasterRoutes_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_rowPolyBoundarySoundBundle` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_rowPolyBoundarySoundBundle
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_rowPolyBoundarySoundBundle
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_rowPolyBoundarySoundBundle_from_bundle` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_rowPolyBoundarySoundBundle_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_rowPolyBoundarySoundBundle_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_typingRunBundleSuite` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_typingRunBundleSuite
    {h_app : AppUnifySoundHook} {h_proj : ProjUnifySoundHook}
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_typingRunBundleSuite
      (h_app := h_app) (h_proj := h_proj) h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_success_via_typingRunBundleSuite_from_bundle` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_success_via_typingRunBundleSuite_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs)
    (h_ok_expr : inferExprUnify st fuel env e = .ok stExpr ty)
    (h_ok_field : inferFieldsUnify st fuel env fs = .ok stField (.row (.mk rf none))) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_success_via_typingRunBundleSuite_from_bundle
      h_seed h_no_expr h_no_field h_ok_expr h_ok_field)

/-- Direct route decomposition from `of_fullVerticalMasterRoutes` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_fullVerticalMasterRoutes
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_master : PrincipalBoundarySoundFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_fullVerticalMasterRoutes
      h_master h_no_expr h_no_field)

/-- Direct route decomposition from `of_fullVerticalMasterSurface` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_fullVerticalMasterSurface
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_fullVerticalMasterSurface
      h_surface h_no_expr h_no_field)

/-- Direct route decomposition from `of_masterCapstone` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_masterCapstone
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_cap : PrincipalBoundarySoundFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_masterCapstone
      h_cap h_no_expr h_no_field)

/-- Direct route decomposition from `of_fullVerticalSuite` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_fullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf)
    (h_no_expr : NoUnifyBranchesExpr e)
    (h_no_field : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_fullVerticalSuite
      h_suite h_no_expr h_no_field)

/-- Direct route decomposition from `of_consequences` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_consequences
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_conseq :
      PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
        ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
        ∧ VerticalHookFreeAppSlice
        ∧ VerticalHookFreeProjSlice) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_consequences h_conseq)

/-- Project a no-unify full+vertical suite witness from the unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_of_noUnifyMasterSurface
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalSuite_of_masterCapstone h_surface.capstone

/-- Direct route decomposition from `of_noUnifyMasterSurface` into suite components. -/
theorem principalBoundarySoundNoUnifyFullVerticalSuite_as_components_of_noUnifyMasterSurface
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_surface : PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty
      ∧ PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf
      ∧ VerticalHookFreeUnifySlices := by
  exact principalBoundarySoundNoUnifyFullVerticalSuite_as_components
    (principalBoundarySoundNoUnifyFullVerticalSuite_of_noUnifyMasterSurface h_surface)

/-- Lift a no-unify full+vertical suite witness into the unified no-unify master surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_noUnifyFullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf :=
  principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_capstone
    (principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_fullVerticalSuite h_suite)

/-- Direct route decomposition from `of_noUnifyFullVerticalSuite` into master-surface components. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components_of_noUnifyFullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes st fuel env e fs stExpr ty stField rf
      ∧ PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone st fuel env e fs stExpr ty stField rf := by
  exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_as_components
    (principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_noUnifyFullVerticalSuite h_suite)

/-- Unified no-unify master surface is equivalent to no-unify full+vertical suite surface. -/
theorem principalBoundarySoundNoUnifyFullVerticalMasterSurface_iff_fullVerticalSuite
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface st fuel env e fs stExpr ty stField rf
      ↔ PrincipalBoundarySoundNoUnifyFullVerticalSuite st fuel env e fs stExpr ty stField rf := by
  constructor
  · intro h_surface
    exact principalBoundarySoundNoUnifyFullVerticalSuite_of_noUnifyMasterSurface h_surface
  · intro h_suite
    exact principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_noUnifyFullVerticalSuite h_suite

/--
The row-poly full+vertical capstone is equivalent to providing:
- a full principal boundary soundness suite witness, and
- a hook-free vertical app/projection slice witness.
-/
theorem principalBoundarySoundFullVerticalSuite_iff_full_and_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields} :
    PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf
      ↔ (PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf
          ∧ VerticalHookFreeUnifySlices) := by
  constructor
  · intro h_suite
    exact ⟨h_suite.full, h_suite.vertical⟩
  · intro h_pair
    exact ⟨h_pair.1, h_pair.2⟩

/-- One-hop projection: full-suite surface from the full+vertical capstone. -/
theorem principalBoundarySoundFullVerticalSuite_full
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFullSuite st fuel env e fs stExpr ty stField rf :=
  h_suite.full

/-- One-hop projection: hook-free vertical slice from the full+vertical capstone. -/
theorem principalBoundarySoundFullVerticalSuite_vertical
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeUnifySlices :=
  h_suite.vertical

/-- One-hop projection: hook-free app vertical theorem from the full+vertical capstone. -/
theorem principalBoundarySoundFullVerticalSuite_vertical_app
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeAppSlice :=
  h_suite.vertical.1

/-- One-hop projection: hook-free projection vertical theorem from the full+vertical capstone. -/
theorem principalBoundarySoundFullVerticalSuite_vertical_proj
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    VerticalHookFreeProjSlice :=
  h_suite.vertical.2

/-- One-hop projection: arbitrary-success expression full surface from the full+vertical capstone. -/
theorem principalBoundarySoundFullVerticalSuite_expr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundExprFull st fuel env e stExpr ty :=
  principalBoundarySoundFullSuite_expr h_suite.full

/-- One-hop projection: arbitrary-success field full surface from the full+vertical capstone. -/
theorem principalBoundarySoundFullVerticalSuite_field
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf) :
    PrincipalBoundarySoundFieldFull st fuel env fs stField rf :=
  principalBoundarySoundFullSuite_field h_suite.full

/-- One-hop projection: no-unify expression full surface from the full+vertical capstone. -/
theorem principalBoundarySoundFullVerticalSuite_noUnifyExpr
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesExpr e) :
    PrincipalBoundarySoundNoUnifyExprFull st fuel env e stExpr ty :=
  principalBoundarySoundFullSuite_noUnifyExpr h_suite.full h_no

/-- One-hop projection: no-unify field full surface from the full+vertical capstone. -/
theorem principalBoundarySoundFullVerticalSuite_noUnifyField
    {st : UnifyState} {fuel : Nat} {env : TermEnv}
    {e : CoreExpr} {fs : CoreFields}
    {stExpr : UnifyState} {ty : Ty}
    {stField : UnifyState} {rf : RowFields}
    (h_suite : PrincipalBoundarySoundFullVerticalSuite st fuel env e fs stExpr ty stField rf)
    (h_no : NoUnifyBranchesFields fs) :
    PrincipalBoundarySoundNoUnifyFieldFull st fuel env fs stField rf :=
  principalBoundarySoundFullSuite_noUnifyField h_suite.full h_no

/--
Expression preconditioned↔core wrapper on the dual-routed proved master suite.
-/
theorem principalBoundaryMasterSuite_preconditionedCoreIff_expr_via_dualConsequenceSlices
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalBoundaryMasterSuite_preconditionedCoreIff_expr
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices
    h_hooks st fuel env e st' ty h_ok

/--
Field preconditioned↔core wrapper on the dual-routed proved master suite.
-/
theorem principalBoundaryMasterSuite_preconditionedCoreIff_field_via_dualConsequenceSlices
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalBoundaryMasterSuite_preconditionedCoreIff_field
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices
    h_hooks st fuel env fs st' rf h_ok

/--
Dual-routed variant of `principalNoUnifyCoreExpr_of_success_via_suite`.
-/
theorem principalNoUnifyCoreExpr_of_success_via_suite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty := by
  exact (principalBoundaryBridgeSuite_noUnify_expr
      principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks).core

/--
Dual-routed variant of `principalNoUnifyPreconditionedExpr_of_success_via_suite`.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_suite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  exact (principalBoundaryBridgeSuite_noUnify_expr
      principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks).preconditioned

/--
Dual-routed variant of `principalNoUnifyCoreField_of_success_via_suite`.
-/
theorem principalNoUnifyCoreField_of_success_via_suite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf := by
  exact (principalBoundaryBridgeSuite_noUnify_field
      principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks).core

/--
Dual-routed variant of `principalNoUnifyPreconditionedField_of_success_via_suite`.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_suite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  exact (principalBoundaryBridgeSuite_noUnify_field
      principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks).preconditioned

/-- Bundled-seed alias for dual-routed no-unify core expression via suite. -/
theorem principalNoUnifyCoreExpr_of_success_via_suite_via_dualConsequenceSlices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_suite_via_dualConsequenceSlices h_no h_ok h_seed

/-- Bundled-seed alias for dual-routed no-unify preconditioned expression via suite. -/
theorem principalNoUnifyPreconditionedExpr_of_success_via_suite_via_dualConsequenceSlices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_seed : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_suite_via_dualConsequenceSlices
    h_no h_ok h_seed

/-- Bundled-seed alias for dual-routed no-unify core field via suite. -/
theorem principalNoUnifyCoreField_of_success_via_suite_via_dualConsequenceSlices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_suite_via_dualConsequenceSlices h_no h_ok h_seed

/-- Bundled-seed alias for dual-routed no-unify preconditioned field via suite. -/
theorem principalNoUnifyPreconditionedField_of_success_via_suite_via_dualConsequenceSlices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_suite_via_dualConsequenceSlices
    h_no h_ok h_seed

/--
Dual-routed variant of `principalCoreExpr_of_preconditioned_success_via_suite`.
-/
theorem principalCoreExpr_of_preconditioned_success_via_suite_via_dualConsequenceSlices
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_pre : PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty) :
    PrincipalTypingSliceCore env e ty := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_expr
      principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices
      h_hooks st fuel env e st' ty h_ok).1 h_pre

/--
Dual-routed variant of `principalPreconditionedExpr_of_core_success_via_suite`.
-/
theorem principalPreconditionedExpr_of_core_success_via_suite_via_dualConsequenceSlices
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_core : PrincipalTypingSliceCore env e ty) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_expr
      principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices
      h_hooks st fuel env e st' ty h_ok).2 h_core

/--
Dual-routed variant of `principalCoreField_of_preconditioned_success_via_suite`.
-/
theorem principalCoreField_of_preconditioned_success_via_suite_via_dualConsequenceSlices
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_pre : PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf) :
    PrincipalFieldTypingSliceCore env fs rf := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_field
      principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices
      h_hooks st fuel env fs st' rf h_ok).1 h_pre

/--
Dual-routed variant of `principalPreconditionedField_of_core_success_via_suite`.
-/
theorem principalPreconditionedField_of_core_success_via_suite_via_dualConsequenceSlices
    (h_hooks : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_core : PrincipalFieldTypingSliceCore env fs rf) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf := by
  exact (principalBoundaryBridgeSuite_preconditionedCoreIff_field
      principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices
      h_hooks st fuel env fs st' rf h_ok).2 h_core

/-- Bundled-seed alias for dual-routed suite preconditioned->core expression conversion. -/
theorem principalCoreExpr_of_preconditioned_success_via_suite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_pre : PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_preconditioned_success_via_suite_via_dualConsequenceSlices
    h_seed st fuel env e st' ty h_ok h_pre

/-- Bundled-seed alias for dual-routed suite core->preconditioned expression conversion. -/
theorem principalPreconditionedExpr_of_core_success_via_suite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (e : CoreExpr)
    (st' : UnifyState) (ty : Ty)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_core : PrincipalTypingSliceCore env e ty) :
    PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_core_success_via_suite_via_dualConsequenceSlices
    h_seed st fuel env e st' ty h_ok h_core

/-- Bundled-seed alias for dual-routed suite preconditioned->core field conversion. -/
theorem principalCoreField_of_preconditioned_success_via_suite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_pre : PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_preconditioned_success_via_suite_via_dualConsequenceSlices
    h_seed st fuel env fs st' rf h_ok h_pre

/-- Bundled-seed alias for dual-routed suite core->preconditioned field conversion. -/
theorem principalPreconditionedField_of_core_success_via_suite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    (st : UnifyState) (fuel : Nat) (env : TermEnv) (fs : CoreFields)
    (st' : UnifyState) (rf : RowFields)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_core : PrincipalFieldTypingSliceCore env fs rf) :
    PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_core_success_via_suite_via_dualConsequenceSlices
    h_seed st fuel env fs st' rf h_ok h_core

/--
Master-suite dual-routed convenience wrapper: derive core expression
principality from an arbitrary successful run.
-/
theorem principalCoreExpr_of_success_via_masterSuite_via_dualConsequenceSlices
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_app0 h_proj0 h_ok

/--
Master-suite dual-routed convenience wrapper: derive preconditioned expression
principality for any hook witnesses from an arbitrary successful run.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_app0 h_proj0 h_ok

/--
Master-suite dual-routed convenience wrapper: derive preconditioned expression
principality for a bundled hook witness from an arbitrary successful run.
-/
theorem principalPreconditionedExpr_of_success_via_masterSuite_via_dualConsequenceSlices
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_app0 h_proj0 h_ok h_hooks

/--
Master-suite dual-routed convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_app0 h_proj0 h_ok

/--
Master-suite dual-routed convenience wrapper: derive fixed-run expression
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalPreconditionedCoreIffExpr_of_success_via_masterSuite_via_dualConsequenceSlices
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_app0 h_proj0 h_ok h_hooks

/--
Master-suite dual-routed convenience wrapper: derive core field principality
from an arbitrary successful field run.
-/
theorem principalCoreField_of_success_via_masterSuite_via_dualConsequenceSlices
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_app0 h_proj0 h_ok

/--
Master-suite dual-routed convenience wrapper: derive preconditioned field
principality for any hook witnesses from an arbitrary successful field run.
-/
theorem principalPreconditionedField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_app0 h_proj0 h_ok

/--
Master-suite dual-routed convenience wrapper: derive preconditioned field
principality for a bundled hook witness from an arbitrary successful field run.
-/
theorem principalPreconditionedField_of_success_via_masterSuite_via_dualConsequenceSlices
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_app0 h_proj0 h_ok h_hooks

/--
Master-suite dual-routed convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_app0 h_proj0 h_ok

/--
Master-suite dual-routed convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalPreconditionedCoreIffField_of_success_via_masterSuite_via_dualConsequenceSlices
    (h_app0 : AppUnifySoundHook)
    (h_proj0 : ProjUnifySoundHook)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_app0 h_proj0 h_ok h_hooks

/--
Master-suite dual-routed no-unify convenience wrapper: derive core expression
principality from a successful no-unify expression run.
-/
theorem principalNoUnifyCoreExpr_of_success_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify convenience wrapper: derive preconditioned
expression principality for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify convenience wrapper: derive preconditioned
expression principality for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks

/--
Master-suite dual-routed no-unify convenience wrapper: derive fixed-run
expression preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify convenience wrapper: derive fixed-run
expression preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks

/--
Master-suite dual-routed no-unify convenience wrapper: derive core field
principality from a successful no-unify field run.
-/
theorem principalNoUnifyCoreField_of_success_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify convenience wrapper: derive preconditioned
field principality for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify convenience wrapper: derive preconditioned
field principality for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedField_of_success_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks

/--
Master-suite dual-routed no-unify convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify convenience wrapper: derive fixed-run field
preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks

/--
Master-suite dual-routed no-unify-to-general convenience wrapper: derive core
expression principality from a successful no-unify run.
-/
theorem principalCoreExpr_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify-to-general convenience wrapper: derive
preconditioned expression principality for any hook witnesses.
-/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify-to-general convenience wrapper: derive
preconditioned expression principality for a bundled hook witness.
-/
theorem principalPreconditionedExpr_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_noUnify_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks

/--
Master-suite dual-routed no-unify-to-general convenience wrapper: derive
fixed-run expression preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify-to-general convenience wrapper: derive
fixed-run expression preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks

/--
Master-suite dual-routed no-unify-to-general convenience wrapper: derive core
field principality from a successful no-unify field run.
-/
theorem principalCoreField_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify-to-general convenience wrapper: derive
preconditioned field principality for any hook witnesses.
-/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify-to-general convenience wrapper: derive
preconditioned field principality for a bundled hook witness.
-/
theorem principalPreconditionedField_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_noUnify_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks

/--
Master-suite dual-routed no-unify-to-general convenience wrapper: derive
fixed-run field preconditioned↔core equivalence for any hook witnesses.
-/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok

/--
Master-suite dual-routed no-unify-to-general convenience wrapper: derive
fixed-run field preconditioned↔core equivalence for a bundled hook witness.
-/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_noUnify_via_masterSuite
    principalBoundaryMasterSuite_proved_via_dualConsequenceSlices h_no h_ok h_hooks

/-- Bundled-seed alias for dual-routed arbitrary-success core expression wrapper. -/
theorem principalCoreExpr_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_via_masterSuite_via_dualConsequenceSlices
    h_seed.1 h_seed.2 h_ok

/-- Bundled-seed alias for dual-routed arbitrary-success any-hooks expression wrapper. -/
theorem principalPreconditionedExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    h_seed.1 h_seed.2 h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed arbitrary-success bundled expression wrapper. -/
theorem principalPreconditionedExpr_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_via_masterSuite_via_dualConsequenceSlices
    h_seed.1 h_seed.2 h_ok h_seed

/-- Bundled-seed alias for dual-routed arbitrary-success any-hooks `↔` expression wrapper. -/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    h_seed.1 h_seed.2 h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed arbitrary-success bundled `↔` expression wrapper. -/
theorem principalPreconditionedCoreIffExpr_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_via_masterSuite_via_dualConsequenceSlices
    h_seed.1 h_seed.2 h_ok h_seed

/-- Bundled-seed alias for dual-routed arbitrary-success core field wrapper. -/
theorem principalCoreField_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_via_masterSuite_via_dualConsequenceSlices
    h_seed.1 h_seed.2 h_ok

/-- Bundled-seed alias for dual-routed arbitrary-success any-hooks field wrapper. -/
theorem principalPreconditionedField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    h_seed.1 h_seed.2 h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed arbitrary-success bundled field wrapper. -/
theorem principalPreconditionedField_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_via_masterSuite_via_dualConsequenceSlices
    h_seed.1 h_seed.2 h_ok h_seed

/-- Bundled-seed alias for dual-routed arbitrary-success any-hooks `↔` field wrapper. -/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    h_seed.1 h_seed.2 h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed arbitrary-success bundled `↔` field wrapper. -/
theorem principalPreconditionedCoreIffField_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_via_masterSuite_via_dualConsequenceSlices
    h_seed.1 h_seed.2 h_ok h_seed

/-- Bundled-seed alias for dual-routed no-unify core expression wrapper. -/
theorem principalNoUnifyCoreExpr_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (_h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterSuite_via_dualConsequenceSlices h_no h_ok

/-- Bundled-seed alias for dual-routed no-unify any-hooks expression wrapper. -/
theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed no-unify bundled expression wrapper. -/
theorem principalNoUnifyPreconditionedExpr_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed

/-- Bundled-seed alias for dual-routed no-unify any-hooks `↔` expression wrapper. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed no-unify bundled `↔` expression wrapper. -/
theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed

/-- Bundled-seed alias for dual-routed no-unify core field wrapper. -/
theorem principalNoUnifyCoreField_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (_h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterSuite_via_dualConsequenceSlices h_no h_ok

/-- Bundled-seed alias for dual-routed no-unify any-hooks field wrapper. -/
theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed no-unify bundled field wrapper. -/
theorem principalNoUnifyPreconditionedField_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed

/-- Bundled-seed alias for dual-routed no-unify any-hooks `↔` field wrapper. -/
theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed no-unify bundled `↔` field wrapper. -/
theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed

/-- Bundled-seed alias for dual-routed no-unify-to-general core expression wrapper. -/
theorem principalCoreExpr_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (_h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices h_no h_ok

/-- Bundled-seed alias for dual-routed no-unify-to-general any-hooks expression wrapper. -/
theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed no-unify-to-general bundled expression wrapper. -/
theorem principalPreconditionedExpr_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty :=
  principalPreconditionedExpr_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed

/-- Bundled-seed alias for dual-routed no-unify-to-general any-hooks `↔` expression wrapper. -/
theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed no-unify-to-general bundled `↔` expression wrapper. -/
theorem principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed

/-- Bundled-seed alias for dual-routed no-unify-to-general core field wrapper. -/
theorem principalCoreField_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (_h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices h_no h_ok

/-- Bundled-seed alias for dual-routed no-unify-to-general any-hooks field wrapper. -/
theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed no-unify-to-general bundled field wrapper. -/
theorem principalPreconditionedField_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf :=
  principalPreconditionedField_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed

/-- Bundled-seed alias for dual-routed no-unify-to-general any-hooks `↔` field wrapper. -/
theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed.1 h_seed.2

/-- Bundled-seed alias for dual-routed no-unify-to-general bundled `↔` field wrapper. -/
theorem principalPreconditionedCoreIffField_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle
    (h_seed : UnifyHookPremises)
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_seed.1 h_seed.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices
    h_no h_ok h_seed

/--
Surface-layer naming-parity wrappers for no-unify cross-route success APIs.
These mirror the existing `...from_cross_route_slices` families under
explicit `...from_cross_route_surface_slices` theorem names.
-/
theorem principalNoUnifyCoreExpr_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyCoreExpr_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyCoreExpr_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyCoreExpr_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyCoreField_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyCoreField_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyCoreField_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyCoreField_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyExprAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksCapstone st fuel env e st' ty :=
  principalNoUnifyExprAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyExprRunBundleConsequences st fuel env e st' ty :=
  principalNoUnifyExprRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyFieldAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksCapstone st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksCapstone_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyFieldRunBundleConsequences st fuel env fs st' rf :=
  principalNoUnifyFieldRunBundleConsequences_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty
      ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf
      ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedExpr_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedExpr_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (h_hooks : UnifyHookPremises) :
    PrincipalTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyPreconditionedField_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedField_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedField_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyPreconditionedField_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (h_hooks : UnifyHookPremises) :
    PrincipalFieldTypingSlicePreconditioned h_hooks.1 h_hooks.2 st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok h_hooks

theorem principalNoUnifyRunBundleExpr_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyRunBundleExpr_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedExprAllHooksRunBundle st fuel env e st' ty :=
  principalNoUnifyRunBundleExpr_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyRunBundleField_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyRunBundleField_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalNoUnifyRunBundleField_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalNoUnifyRunBundleField_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalPreconditionedFieldAllHooksRunBundle st fuel env fs st' rf :=
  principalNoUnifyRunBundleField_of_success_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok


/--
Surface-layer naming-parity wrappers for long-form no-unify cross-route success APIs.
These mirror the existing `...of_success_noUnify_via_*_from_cross_route_slices`
families under explicit `...from_cross_route_surface_slices` theorem names.
-/
theorem principalCoreExpr_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalCoreExpr_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalTypingSliceCore env e ty :=
  principalNoUnifyCoreExpr_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalTypingSliceCore env e ty :=
  principalCoreExpr_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalCoreField_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalCoreField_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalCoreField_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalNoUnifyCoreField_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalCoreField_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalFieldTypingSliceCore env fs rf :=
  principalCoreField_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalNoUnifyPreconditionedCoreIffExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty
        ↔ PrincipalTypingSliceCore env e ty) :=
  principalPreconditionedCoreIffExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalNoUnifyPreconditionedCoreIffField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      (PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf
        ↔ PrincipalFieldTypingSliceCore env fs rf) :=
  principalPreconditionedCoreIffField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalNoUnifyPreconditionedExpr_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalTypingSlicePreconditioned h_app h_proj st fuel env e st' ty :=
  principalPreconditionedExpr_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalNoUnifyPreconditionedExpr_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    (PrincipalTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env e st' ty
      ↔ PrincipalTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env e st' ty) :=
  principalPreconditionedExpr_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalNoUnifyPreconditionedField_anyHooks_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    ∀ h_app h_proj,
      PrincipalFieldTypingSlicePreconditioned h_app h_proj st fuel env fs st' rf :=
  principalPreconditionedField_anyHooks_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterConsequenceCapstone_from_cross_route_slices
    h_no h_ok

theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalNoUnifyPreconditionedField_hookIrrelevant_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

theorem principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    {h_app₁ : AppUnifySoundHook} {h_proj₁ : ProjUnifySoundHook}
    {h_app₂ : AppUnifySoundHook} {h_proj₂ : ProjUnifySoundHook}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    (PrincipalFieldTypingSlicePreconditioned h_app₁ h_proj₁ st fuel env fs st' rf
      ↔ PrincipalFieldTypingSlicePreconditioned h_app₂ h_proj₂ st fuel env fs st' rf) :=
  principalPreconditionedField_hookIrrelevant_of_success_noUnify_via_masterRunBundleConsequence_from_cross_route_slices
    h_no h_ok


/--
Success-wrapper alias for expression all-hooks route surface on the
master-consequence-capstone cross-route surface layer.
-/
theorem principalNoUnifyExprAllHooksRouteSurface_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty :=
  principalNoUnifyExprAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Success-wrapper alias for field all-hooks route surface on the
master-consequence-capstone cross-route surface layer.
-/
theorem principalNoUnifyFieldAllHooksRouteSurface_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksRouteSurface_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/--
Success-wrapper alias for expression all-hooks route surface on the
master-run-bundle-consequence cross-route surface layer.
-/
theorem principalNoUnifyExprAllHooksRouteSurface_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty) :
    PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty :=
  principalNoUnifyExprAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/--
Success-wrapper alias for field all-hooks route surface on the
master-run-bundle-consequence cross-route surface layer.
-/
theorem principalNoUnifyFieldAllHooksRouteSurface_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none))) :
    PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksRouteSurface_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route expression all-hooks route surface. -/
theorem principalNoUnifyExprAllHooksRouteSurface_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty :=
  principalNoUnifyExprAllHooksRouteSurface_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for capstone-route field all-hooks route surface. -/
theorem principalNoUnifyFieldAllHooksRouteSurface_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksRouteSurface_of_success_via_masterConsequenceCapstone_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route expression all-hooks route surface. -/
theorem principalNoUnifyExprAllHooksRouteSurface_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {e : CoreExpr}
    {st' : UnifyState} {ty : Ty}
    (h_no : NoUnifyBranchesExpr e)
    (h_ok : inferExprUnify st fuel env e = .ok st' ty)
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyExprAllHooksRouteSurface st fuel env e st' ty :=
  principalNoUnifyExprAllHooksRouteSurface_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok

/-- Bundled-seed alias for run-bundle-route field all-hooks route surface. -/
theorem principalNoUnifyFieldAllHooksRouteSurface_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices_from_bundle
    {st : UnifyState} {fuel : Nat} {env : TermEnv} {fs : CoreFields}
    {st' : UnifyState} {rf : RowFields}
    (h_no : NoUnifyBranchesFields fs)
    (h_ok : inferFieldsUnify st fuel env fs = .ok st' (.row (.mk rf none)))
    (_h_seed : UnifyHookPremises) :
    PrincipalNoUnifyFieldAllHooksRouteSurface st fuel env fs st' rf :=
  principalNoUnifyFieldAllHooksRouteSurface_of_success_via_masterRunBundleConsequence_from_cross_route_surface_slices
    h_no h_ok
