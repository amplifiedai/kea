# Formalization Bridge Roadmap

Concrete milestone checklist for moving from the current fuel model to an implementation-aligned well-founded substitution model, then lifting that bridge into full language-level metatheory.

## M0. Baseline and Guardrails

- [x] Zero `sorry` in `formal/Rill`.
- [x] Keep a proved preconditioned extension theorem (`unifyRows_extends_rowMap_preconditioned`) as the current contract.
- [x] Keep Rust<->Lean mapping current in `FORMAL.md`.

## M1. Substitution Bridge (In Progress)

- [x] Define acyclicity witness from idempotence (`Subst.acyclicOfIdempotent`).
- [x] Define bounded WF substitution family:
  - `applySubstBounded`
  - `applySubstRowBounded`
  - `applySubstTyListBounded`
  - `applySubstRowFieldsBounded`
- [x] Define top-level WF APIs:
  - `applySubstWF`
  - `applySubstRowWF`
  - `applySubstTyListWF`
  - `applySubstRowFieldsWF`
- [x] Prove key WF lookup/no-op lemmas (`applySubstWF_var_lookup`, `applySubstWF_var_unbound`, row-open variants).
- [x] Prove bind consistency under idempotence for WF (`applySubstWF_bindType_consistent_of_idempotent`, row-tail analogues).
- [x] Add first compat equivalence lemmas on branch-critical shapes:
  - `applySubstCompat_var_eq_applySubstWF_of_idempotent`
  - `applySubstRowCompat_empty_open_eq_applySubstRowWF_of_idempotent`
- [x] Add compat lemmas for non-var/non-open-row constructors (`list`, `map`, `record`, `tuple`) under idempotence/no-domain-vars assumptions.
- [x] Add a single theorem schema for "fuel and WF agree on all values reachable from successful unify branches under idempotence".

## M2. Unify-Level Bridge

- [x] Refactor `Unify` proofs to consume compat lemmas first, fuel details second.
  Completed via `unifyRows_preconditioned_contract_compat_first`, with `unifyRows_extends_rowMap_preconditioned_wf_split` now routed through this compat-first layer.
- [x] Introduce branch-local substitution equivalence lemmas:
  - no-subst-update branches
  - single-bind branches
  - open-open fresh-row branch
- [x] Prove a bridge theorem: successful `unifyRows` branch updates are invariant under swapping `applySubstCompat` for WF substitution, given current preconditions.

## M3. Contract Strengthening

- [x] Re-prove preconditioned global extension theorem with WF substitution phrasing.
- [x] Isolate exactly which assumptions can be weakened from `Idempotent` to `Acyclic`.
- [x] Keep theorem names and statement intent aligned with Rust proptest mapping.

## M4. Typing-System Expansion (Post-Bridge)

- [x] Kickoff slice: add minimal declarative typing + algorithmic soundness for literals, vars, closed anonymous records, and projection (`Rill/Typing.lean`).
- [x] Extend kickoff to monomorphic `let` + typed lambda/application in `Rill/Typing.lean` (syntax-directed app on lambda heads).
- [x] Generalize monomorphic app soundness from lambda-head-only to function-valued expressions in `Rill/Typing.lean`.
- [x] Prove algorithmic/declarative equivalence on the current core slice (`inferExpr_sound`, `inferExpr_complete`, `inferExpr_iff_hasType`).
- [x] Add environment-congruence transport lemmas for core typing (`hasType_lookup_congr`, `inferExpr_lookup_congr`).
- [x] Add unification-threaded algorithmic typing (`inferExprUnify`, `inferFieldsUnify`) with explicit app/proj soundness-hook interfaces.
- [x] Add branch-local soundness wrappers for unification-backed app/proj steps (`inferExprUnify_app_step_sound`, `inferExprUnify_proj_step_sound`).
- [x] Prove recursive soundness on the non-app/proj fragment (`inferExprUnify_sound_no_unify_branches`, `inferFieldsUnify_sound_no_unify_branches`) as scaffolding for full vertical theorem.
- [x] Add structural size measures (`exprSize`, `fieldsSize`) to support well-founded mutual recursion for the full preconditioned theorem.
- [x] Lift unification-threaded inference to a full preconditioned soundness theorem (`inferExprUnify_sound_preconditioned`, `inferFieldsUnify_sound_preconditioned`) with explicit app/proj hooks.
- [x] Document principal-typing boundary for the vertical slice via uniqueness theorems (`inferExprUnify_deterministic`, `inferExprUnify_type_unique_preconditioned`).
- [x] Refine app-branch boundary with a derivable weaker hook (`AppUnifySoundHookWeak`, `appUnifySoundHookWeak_proved`).
- [x] Refine projection-branch boundary with a derivable weaker hook (`ProjUnifySoundHookWeak`, `projUnifySoundHookWeak_proved`) and bundled weak premise package (`UnifyHookPremisesWeak`, `unifyHookPremisesWeak_proved`), including strong→weak adapters (`appUnifySoundHookWeak_of_appUnifySoundHook`, `projUnifySoundHookWeak_of_projUnifySoundHook`, `unifyHookPremisesWeak_of_unifyHookPremises`).
- [x] Add one-step weak-boundary app/projection soundness lemmas (`inferExprUnify_app_step_sound_weak`, `inferExprUnify_proj_step_sound_weak`) plus strong-hook lifted variants (`inferExprUnify_app_step_sound_weak_of_strong`, `inferExprUnify_proj_step_sound_weak_of_strong`) and bundle entrypoints (`inferExprUnify_*_step_sound_weak_from_bundle`, `inferExprUnify_*_step_sound_weak_from_strong_bundle`) to make weak-hook consumption explicit at the branch-step API.
- [x] Add a canonical weak local-step bundle surface (`UnifyStepSoundWeak`) with constructors from weak and strong hook packages (`unifyStepSoundWeak_of_hookPremisesWeak`, `unifyStepSoundWeak_of_unifyHookPremises`) and step-bundle entrypoints (`inferExprUnify_*_step_sound_weak_from_stepBundle`).
- [x] Add direct proved/strong-package weak-step entrypoints (`inferExprUnify_*_step_sound_weak_proved`, `inferExprUnify_*_step_sound_weak_from_unifyHookPremises`) so call sites can consume weak branch-step APIs without manual bundle threading.
- [x] Add all-hooks no-unify naming-parity wrappers for fixed-run `preconditioned ↔ core` transport (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_allHooksSuite`, `principalPreconditionedCoreIff*_of_success_noUnify_via_allHooksSuite`) routed through canonical all-hooks no-unify wrappers.
- [x] Add master/all-hooks no-unify naming-parity wrappers for core/preconditioned/hook-irrelevance surfaces (`principalCore*`, `principalPreconditioned*_*`, `principalPreconditioned*hookIrrelevant*_of_success_noUnify_via_*Suite`) routed through canonical `principalNoUnify*` paths.
- [x] Add arbitrary-success all-hooks capstone entry wrappers across general/master suite layers (`principalPreconditionedExpr/FieldAllHooksCapstone_of_success_via_generalAllHooksSuite`, bundled `..._from_bundle` forms, and matching `..._via_masterSuite` forms) so successful-run principal boundary consequences are available as one packaged theorem output.
- [x] Add bundled-baseline arbitrary-success convenience wrappers across general/master suite layers (`principalCore*`, `principalPreconditioned*AnyHooks*`, `principalPreconditionedCoreIff*AnyHooks*_of_success_via_*Suite_from_bundle`) so one `UnifyHookPremises` seed drives the non-no-unify principal API without split baseline-hook arguments.
- [x] Complete bundled-baseline arbitrary-success parity for bundled target-hook outputs (`principalPreconditioned*_*_of_success_via_*Suite_from_bundle`, including `preconditioned ↔ core` forms) so single-seed entry now covers both any-hooks and bundled-target theorem consumption.
- [x] Add run-level arbitrary-success all-hooks bundle contracts (`PrincipalPreconditionedExpr/FieldAllHooksRunBundle`) with capstone/success constructors and general/master suite entry wrappers so one theorem output now carries both capstone consequences and fixed-run hook-irrelevance.
- [x] Add direct run-bundle projection helpers for expression/field core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance surfaces (`principalPreconditioned*AllHooksRunBundle_*`) so run-bundle consumers can project principal consequences without manual capstone-field destructuring.
- [x] Add combined arbitrary-success run-bundle slice packaging (`PrincipalPreconditionedAllHooksRunBundleExpr/FieldSlice`, `PrincipalPreconditionedAllHooksRunBundleSlices`, proved + projections) to keep run-bundle consumption aligned with existing expression/field slice APIs.
- [x] Integrate arbitrary-success run-bundle slices into `PrincipalPreconditionedAllHooksSuite` (`runBundles`) with suite-level run-bundle projections so one general-all-hooks suite witness now exports capstones, irrelevance, and run-bundle packaging together.
- [x] Add parameterized arbitrary-success run-bundle convenience wrappers (`principalGeneralAllHooksRunBundleExpr/Field_of_success`) and route both general/master run-bundle entry wrappers through that general-all-hooks layer.
- [x] Add master-suite one-hop projections for arbitrary-success all-hooks run bundles (`principalBoundaryMasterSuite_allHooks_runBundle_expr/field`) to keep top-level master consumption symmetric with capstone and irrelevance surfaces.
- [x] Extend no-unify-to-general all-hooks packaging with run-bundle slices/projections (`PrincipalNoUnifyToGeneralAllHooks*RunBundle*`, suite `runBundles`, suite/master one-hop run-bundle projections) and keep no-unify-all-hooks compatibility constructors aligned with the expanded suite shape.
- [x] Extend no-unify all-hooks packaging with run-bundle slices/projections (`PrincipalBoundaryNoUnifyAllHooks*RunBundle*`, suite `runBundles`, suite/master one-hop run-bundle projections) and keep no-unify-to-general compatibility constructors aligned with the expanded suite shape.
- [x] Add explicit run-bundle compatibility theorems between no-unify and no-unify-to-general suite layers (both directions + canonical proved variants) so cross-suite equivalence is also exposed at the run-bundle slice boundary.
- [x] Add direct no-unify run-bundle convenience wrappers across general/master/all-hooks entrypoints (`principalPreconditioned*AllHooksRunBundle_of_success_noUnify_via_*`) so no-unify successful runs reach the run-bundle API without manual suite/capstone reconstruction.
- [x] Add a top-level master run-bundle aggregate surface (`PrincipalBoundaryMasterRunBundleSuite`, constructor + proved theorem) and no-unify-as-general run-bundle projections so all-hooks/no-unify/no-unify-to-general run-bundle entrypoints are consumable from one master-derived API.
- [x] Add one-hop projection/coherence helpers for `PrincipalBoundaryMasterRunBundleSuite` (`..._allHooks_*`, `..._noUnifyAllHooks_*`, `..._noUnifyToGeneral_*`, `..._noUnify_*_as_general`) so master run-bundle consumers can stay on projection APIs instead of record-field destructuring.
- [x] Add direct convenience wrappers over `principalBoundaryMasterRunBundleSuite_proved` (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterRunBundleSuite*`, plus no-unify variants) so run-bundle call sites can avoid explicit suite threading.
- [x] Add naming-parity no-unify run-bundle wrappers on the master-run-bundle-suite path (`principalNoUnifyRunBundle*_*_via_masterRunBundleSuite`) and route long-form no-unify wrappers through them.
- [x] Add master-run-bundle no-unify consequence wrappers for core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance (`principalNoUnifyCore*`, `principalNoUnifyPreconditioned*_*`, `principalNoUnifyPreconditionedCoreIff*_*`, `principalNoUnifyPreconditioned*hookIrrelevant*_*_via_masterRunBundleSuite`) via run-bundle projection helpers.
- [x] Add master-run-bundle long-form no-unify-to-general naming-parity wrappers (`principalCore*`, `principalPreconditioned*_*`, `principalPreconditionedCoreIff*_*`, `principalPreconditioned*hookIrrelevant*_*_of_success_noUnify_via_masterRunBundleSuite`) to mirror master/all-hooks no-unify naming surfaces.
- [x] Add packaged per-run no-unify consequence bundles on the master-run-bundle-suite path (`PrincipalNoUnifyExpr/FieldRunBundleConsequences`, plus `..._of_success_via_masterRunBundleSuite`) bundling core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance.
- [x] Lift master-run-bundle no-unify consequence bundles to slice-level packaging (`PrincipalNoUnifyExpr/FieldRunBundleConsequenceSlice`, combined `PrincipalNoUnifyRunBundleConsequenceSlices`, proved + one-hop projections) for reusable expression/field consequence consumption.
- [x] Add a top-level master run-bundle consequence suite (`PrincipalBoundaryMasterRunBundleConsequenceSuite`, constructors from master/master-run-bundle suites, proved theorem, and no-unify expr/field one-hop consequence projections) so run-bundle and no-unify consequence surfaces share one aggregate API.
- [x] Add master-suite one-hop projections into the consequence-suite layer (`principalBoundaryMasterSuite_runBundleConsequenceSuite`, `principalBoundaryMasterSuite_noUnifyRunBundleConsequences_{expr,field}`) for direct top-level access to no-unify consequence bundles.
- [x] Add run-bundle projection helpers from the master run-bundle consequence suite (`principalBoundaryMasterRunBundleConsequenceSuite_{allHooks,noUnifyAllHooks,noUnifyToGeneral}_{expr,field}`) for direct inherited run-bundle access from the consequence-suite aggregate.
- [x] Route master-suite no-unify consequence wrappers (core, preconditioned, preconditioned↔core, hook-irrelevance for expr+field) through `principalBoundaryMasterSuite_noUnifyRunBundleConsequences_{expr,field}` and consequence-suite run-bundle projections so top-level no-unify theorem consumption stays on the canonical consequence path.
- [x] Add top-level master run-bundle projection wrappers via the consequence-suite aggregate (`principalBoundaryMasterSuite_{allHooks,noUnifyAllHooks,noUnifyToGeneral}AllHooks_runBundle_{expr,field}_via_consequenceSuite`) and route master no-unify run-bundle convenience wrappers through that projection layer.
- [x] Add bundled-hook no-unify `_from_bundle` wrappers on master-run-bundle-consequence/master no-unify-to-general paths (`..._of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle`, `..._of_success_noUnify_via_masterSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), completing no-unify bundled-hook naming parity with arbitrary-success wrappers.
- [x] Add `principalNoUnify*..._from_bundle` alias wrappers on the same master paths (`..._via_masterRunBundleConsequenceSuite_from_bundle`, `..._via_masterSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), completing bundled-hook parity for both long-form and no-unify naming families.
- [x] Add matching all-hooks no-unify bundled-hook `_from_bundle` wrappers for both long-form and `principalNoUnify*` naming families (`..._of_success_noUnify_via_allHooksSuite_from_bundle`, `..._via_allHooksSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), closing bundled-hook parity across all-hooks/master/master-consequence entry layers.
- [x] Add consequence-bundle-to-capstone projections (`principalNoUnifyExpr/FieldRunBundleConsequences_capstone`) and top-level master `..._via_consequenceSuite` capstone/irrelevance wrappers (`principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_{expr,field,irrelevance_*}_via_consequenceSuite`) so the consequence-path API covers capstone + irrelevance, not only run-bundles.
- [x] Add consequence-path no-unify-as-general aliases on top-level master projections (`principalBoundaryMasterSuite_noUnifyAllHooks_{expr,field,runBundle_*}_as_general_via_consequenceSuite`) to preserve no-unify-as-general coherence on the new consequence routing layer.
- [x] Add no-unify capstone convenience wrappers on both master paths (`principalPreconditioned*AllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite`, `principalPreconditioned*AllHooksCapstone_of_success_noUnify_via_masterSuite`) so capstone-level no-unify entrypoints match run-bundle/consequence coverage.
- [x] Add no-unify capstone alias wrappers (`principalNoUnify*AllHooksCapstone_of_success_via_*Suite`) across all-hooks/master/master-consequence entry layers to complete capstone naming parity with existing run-bundle/consequence alias families.
- [x] Add bundled-hook no-unify capstone wrappers/aliases (`...AllHooksCapstone_of_success_noUnify_via_*Suite_from_bundle`, `principalNoUnify*AllHooksCapstone_of_success_via_*Suite_from_bundle`) across all-hooks/master/master-consequence entry layers, completing `_from_bundle` parity for capstone no-unify surfaces.
- [x] Add arbitrary-success capstone wrappers on the consequence path (`principalBoundaryMasterSuite_allHooks_{expr,field}_via_consequenceSuite`, `principalPreconditioned*AllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite*`) so consequence-path coverage includes capstone surfaces for arbitrary-success slices as well as no-unify slices.
- [x] Add arbitrary-success hook-irrelevance wrappers on the consequence route (`principalBoundaryMasterSuite_allHooks_irrelevance_{expr,field}_via_consequenceSuite`, `principalPreconditioned*hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite*`, `principalPreconditioned*hookIrrelevant_of_success_via_masterSuite*`) so non-no-unify fixed-run irrelevance also routes through the consequence-path layer.
- [x] Add bundled-hook no-unify hook-irrelevance wrappers/aliases (`...hookIrrelevant_of_success_noUnify_via_*Suite_from_bundle`, `principalNoUnifyPreconditioned*hookIrrelevant_of_success_via_*Suite_from_bundle`) across all-hooks/master/master-consequence entry layers, completing `_from_bundle` parity for no-unify irrelevance theorem surfaces.
- [x] Add bundled-hook arbitrary-success irrelevance wrappers on the general-all-hooks path (`principalPreconditioned*hookIrrelevant_of_success_via_generalAllHooksSuite_from_bundle`), completing `_from_bundle` parity for non-no-unify irrelevance entrypoints.
- [x] Add a master consequence capstone aggregate (`PrincipalBoundaryMasterConsequenceCapstoneSuite`, constructor/proved/master one-hop, and expression/field capstone+irrelevance projections) so consequence-path capstone/irrelevance surfaces are consumable from one packaged theorem API.
- [x] Add direct convenience wrappers over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (arbitrary-success + no-unify capstone families, `principalNoUnify*` aliases, and `_from_bundle` variants) so the new aggregate suite can be consumed in one step.
- [x] Add full hook-irrelevance convenience/alias parity over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalPreconditioned*hookIrrelevant*_of_success_via_masterConsequenceCapstoneSuite*`, `..._of_success_noUnify_via_masterConsequenceCapstoneSuite*`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_masterConsequenceCapstoneSuite*`, plus `_from_bundle` variants) so consequence-capstone aggregate entrypoints now cover irrelevance surfaces with the same one-step API as capstone wrappers.
- [x] Add direct core/preconditioned/preconditioned↔core convenience wrappers over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalCore*`, `principalPreconditioned*{,_anyHooks}*`, `principalPreconditionedCoreIff*{,_anyHooks}*` on `..._via_masterConsequenceCapstoneSuite*`, including bundled-baseline variants) so consequence-capstone aggregate entrypoints now expose the full principal-boundary theorem surface in one step, not only capstone/irrelevance APIs.
- [x] Add full no-unify principal-surface parity over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalNoUnifyCore*`, `principalNoUnifyPreconditioned*{,_anyHooks}*`, `principalNoUnifyPreconditionedCoreIff*{,_anyHooks}*` plus long-form `..._of_success_noUnify_via_masterConsequenceCapstoneSuite*` aliases and bundled variants) so no-unify consequence-capstone entrypoints match arbitrary-success coverage for core/preconditioned/`↔` theorem APIs.
- [x] Add missing bundled-baseline `_from_bundle` aliases for core/any-hooks consequence-capstone surfaces (`principal{NoUnify,}Core*`, `principal{NoUnify,}Preconditioned*AnyHooks*`, `principal{NoUnify,}PreconditionedCoreIff*AnyHooks*`, plus long-form no-unify-to-general counterparts on `..._via_masterConsequenceCapstoneSuite*`) to complete bundled-seed naming parity across the full consequence-capstone principal API.
- [x] Add direct run-bundle convenience wrappers on `..._via_masterConsequenceCapstoneSuite*` (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterConsequenceCapstoneSuite*`, no-unify variants, and `principalNoUnifyRunBundle*` aliases) so the consequence-capstone route also exports packaged `capstone + hook-irrelevance` bundles in one step.
- [x] Add direct packaged no-unify consequence constructors on `..._via_masterConsequenceCapstoneSuite*` (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite`) so consequence-capstone entrypoints can emit the full no-unify bundle surface (core/preconditioned/`↔`/irrelevance) in one theorem output.
- [x] Add bundled-hook `_from_bundle` aliases for those consequence-capstone no-unify consequence constructors (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite_from_bundle`), completing naming parity for packaged no-unify consequence entrypoints on this route.
- [x] Add a packaged no-unify consequence slice layer for the consequence-capstone route (`PrincipalNoUnifyExpr/FieldRunBundleConsequenceSliceViaMasterConsequenceCapstoneSuite`, combined `PrincipalNoUnifyRunBundleConsequenceSlicesViaMasterConsequenceCapstoneSuite`, proved theorem, expression/field one-hop projections) so this route has a reusable all-runs bundle API shape parallel to the master-run-bundle consequence path.
- [x] Add explicit cross-route no-unify consequence coherence constructors (`PrincipalNoUnifyExpr/FieldRunBundleConsequencesBothMasterConsequenceRoutes` plus `principalNoUnify*RunBundleConsequences_on_both_master_consequence_routes`) so one theorem output can carry witnesses from both `masterConsequenceCapstone` and `masterRunBundleConsequence` entry layers.
- [x] Lift that cross-route coherence into reusable all-runs slice packaging (`PrincipalNoUnify*RunBundleConsequencesBothMasterConsequenceRoutesSlice`, combined `...RoutesSlices`, proved theorem, expression/field one-hop projections) so route-coherence consumption follows the same slice API pattern used elsewhere in M4.
- [x] Add route-specific one-hop/canonical projections from those cross-route slices (`...RoutesSlices_{expr,field}_via_{masterConsequenceCapstone,masterRunBundleConsequence}` and `principalNoUnify*RunBundleConsequences_via_*_from_cross_route_slices`) so each route’s consequence bundle is directly consumable from one shared coherence proof surface.
- [x] Add canonical no-unify all-hooks capstone projections from that cross-route coherence surface (`principalNoUnify*AllHooksCapstone_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) so both routes can reach capstone consequences through one shared coherence entrypoint.
- [x] Add explicit cross-route all-hooks capstone coherence packaging (`PrincipalNoUnifyExpr/FieldAllHooksCapstonesBothMasterConsequenceRoutes`, combined capstone slices, and per-route one-hop projections) so capstone-level route coherence is consumable from one shared theorem API, parallel to consequence-bundle coherence.
- [x] Add explicit cross-route all-hooks run-bundle coherence packaging (`PrincipalNoUnifyExpr/FieldAllHooksRunBundlesBothMasterConsequenceRoutes`, combined run-bundle slices, and per-route one-hop projections), and route `principalNoUnifyRunBundle*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` through that canonical layer.
- [x] Add explicit cross-route fixed-run hook-irrelevance coherence packaging (`PrincipalNoUnifyExpr/FieldHookIrrelevanceBothMasterConsequenceRoutes`, combined irrelevance slices, and per-route one-hop projections), and route `principalNoUnifyPreconditioned*hookIrrelevant...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` through that canonical layer.
- [x] Add a higher-level cross-route all-hooks route-surface bundle (`PrincipalNoUnifyExpr/FieldAllHooksRouteSurfaceBothMasterConsequenceRoutes`, combined slices, and per-route canonical projections) so each master consequence route exports capstone + run-bundle + fixed-run irrelevance as one packaged per-run theorem surface.
- [x] Route top-level cross-route all-hooks capstone aliases (`principalNoUnify*AllHooksCapstone_of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through the new all-hooks route-surface canonical projections so capstone call sites consume the unified route-surface layer.
- [x] Route top-level cross-route all-hooks run-bundle and fixed-run irrelevance aliases (`principalNoUnifyRunBundle*...` and `principalNoUnifyPreconditioned*hookIrrelevant...` on both master consequence routes) through the same all-hooks route-surface canonical projections, completing unified all-hooks-facet consumption (capstone/run-bundle/irrelevance) from one cross-route entry layer.
- [x] Add canonical cross-route projections for core, any-hooks preconditioned, any-hooks `preconditioned ↔ core`, and fixed-run hook-irrelevance on both routes (`principalNoUnify{Core,Preconditioned*,PreconditionedCoreIff*,Preconditioned*hookIrrelevant}_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) so downstream theorem consumption can remain on one shared cross-route slice surface across all principal consequence facets.
- [x] Add bundled-target hook projections on top of those cross-route any-hooks surfaces (`principalNoUnifyPreconditioned*` and `principalNoUnifyPreconditionedCoreIff*` via both routes from cross-route slices) to avoid manual hook-pair projection when consuming the shared coherence API.
- [x] Add `_from_bundle` alias wrappers for those bundled-target cross-route projections (`principalNoUnifyPreconditioned*...from_cross_route_slices_from_bundle`, `principalNoUnifyPreconditionedCoreIff*...from_cross_route_slices_from_bundle` on both routes) to complete naming parity with existing no-unify wrapper families.
- [x] Add long-form no-unify-to-general aliases on the same cross-route route surfaces (`principalCore*`, `principalPreconditioned*AnyHooks*`, `principalPreconditionedCoreIff*AnyHooks*`, `principalPreconditioned*hookIrrelevant*_of_success_noUnify_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) so downstream call sites can use familiar naming families while routing through the shared coherence path.
- [x] Add matching `_from_bundle` aliases for those long-form cross-route no-unify-to-general wrappers (core/any-hooks/`preconditioned ↔ core`/hook-irrelevance on both routes) to complete bundled-hook naming parity for the new cross-route theorem family.
- [x] Add full `principalNoUnify*...of_success_via_masterRunBundleConsequence_from_cross_route_slices` naming-parity aliases (core, preconditioned, preconditioned↔core, hook-irrelevance, run-bundle consequences, and capstone, including `_from_bundle` variants) so the master-run-bundle-consequence cross-route surface has complete no-unify naming parity with the established long-form wrappers.
- [x] Mirror that same `principalNoUnify*...of_success_via_masterConsequenceCapstone_from_cross_route_slices` alias family (core, preconditioned, preconditioned↔core, hook-irrelevance, run-bundle consequences, and capstone, including `_from_bundle` variants) so both master consequence routes now expose a 62/62 no-unify theorem-surface parity match.
- [x] Add the remaining bundled-seed `_from_bundle` aliases for no-unify cross-route wrappers on both master consequence routes (core, any-hooks preconditioned, any-hooks `preconditioned ↔ core`, run-bundle, and packaged consequence surfaces) so every `principalNoUnify*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` theorem has a bundled-seed counterpart.
- [x] Add the missing bundled-seed `_from_bundle` aliases on `masterRunBundleConsequenceSuite` for no-unify core/any-hooks/run-bundle/consequence wrappers (`principalNoUnify{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,RunBundle*,Expr/FieldRunBundleConsequences}...`) so this suite has complete bundled-seed parity across all no-unify theorem surfaces.
- [x] Add full bundled-seed `_from_bundle` parity on `masterRunBundleSuite` for all no-unify wrappers (run-bundle, core, any-hooks preconditioned, bundled preconditioned, any-hooks/bundled `preconditioned ↔ core`, hook-irrelevance, and packaged consequences) so every `principalNoUnify*...of_success_via_masterRunBundleSuite` theorem has a bundled-seed companion.
- [x] Add the remaining bundled-seed `_from_bundle` aliases on `allHooksSuite` and `masterSuite` for no-unify core/any-hooks/run-bundle wrappers, closing the last suite-level parity gaps; parity checks now report `missing_from_bundle = 0` across all seven no-unify route families (`allHooks`, `master`, `masterRunBundle`, `masterRunBundleConsequence`, `masterConsequenceCapstone`, and both cross-route surfaces).
- [x] Add the final bundled-seed aliases on the proved-boundary `...via_suite` wrappers (`principalNoUnify{Core,Preconditioned}{Expr,Field}_of_success_via_suite_from_bundle`), closing the remaining global gap so every `principalNoUnify*...of_success_via_*` theorem now has a `_from_bundle` companion (`missing_count = 0` on full theorem-name parity scan).
- [x] Add bundled-seed `_from_bundle` parity for the long-form no-unify-to-general `masterRunBundleConsequenceSuite` wrappers (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*AllHooksRunBundle}_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle`), closing that route’s long-form parity gap (`missing = 0` for `..._of_success_noUnify_via_masterRunBundleConsequenceSuite`).
- [x] Add the same long-form bundled-seed parity layer on `allHooksSuite` and `masterSuite` (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*AllHooksRunBundle}_of_success_noUnify_via_{allHooksSuite,masterSuite}_from_bundle`), reducing long-form no-unify parity gaps to the two remaining routes: `generalAllHooks` and `masterRunBundleSuite`.
- [x] Close the remaining long-form no-unify bundled-seed gaps on `masterRunBundleSuite` and `generalAllHooks` with the matching `_from_bundle` alias families (including fixed-run preconditioned, fixed-run `preconditioned ↔ core`, and hook-irrelevance variants where applicable), bringing long-form parity to full closure (`global_longform_missing = 0` for all `..._of_success_noUnify_via_*` theorem names).
- [x] Add the last four bundled-seed aliases surfaced by the broad `..._of_success_via_*` scan (`principalBoundaryNoUnify{ExprCapstone,FieldCapstone}_of_success_via_suite_from_bundle`, `principalBoundaryNoUnifyRunBundle{Expr,Field}_of_success_via_allHooksSuite_from_bundle`), bringing global bundle-name parity to full closure (`missing_bundle = 0` across all `..._of_success_via_*` theorem names).
- [x] Add direct convenience wrappers over `principalBoundaryMasterRunBundleConsequenceSuite_proved` (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite` plus core/any-hooks projections) for one-step no-unify consequence-bundle consumption.
- [x] Extend the master-run-bundle-consequence-suite convenience layer to full no-unify parity (`principalPreconditioned*_*`, `principalPreconditionedCoreIff*_*`, `principalPreconditioned*hookIrrelevant*_*_of_success_noUnify_via_masterRunBundleConsequenceSuite`) so bundled/any-hooks and `↔`/irrelevance surfaces are all one-step from the aggregate consequence suite.
- [x] Add matching run-bundle convenience wrappers over `principalBoundaryMasterRunBundleConsequenceSuite_proved` (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterRunBundleConsequenceSuite*` plus no-unify variants) so arbitrary-success and no-unify run-bundle access can route through the consequence-suite aggregate entrypoint.
- [x] Add full `principalNoUnify*` naming-parity aliases on the master-run-bundle-consequence-suite path (core, preconditioned, preconditioned↔core, hook-irrelevance for expr+field) routed through long-form no-unify-to-general wrappers.
- [x] Add canonical no-unify run-bundle convenience wrappers on the no-unify suite layers (`principalBoundaryNoUnifyRunBundle*_*_via_allHooksSuite`, `principalNoUnifyToGeneralRunBundle*_*_of_success`) to stabilize per-suite run-bundle entry naming before higher-layer routing.
- [x] Add naming-parity no-unify run-bundle wrappers on all-hooks/master entrypoints (`principalNoUnifyRunBundle*_*_via_allHooksSuite`, `principalNoUnifyRunBundle*_*_via_masterSuite`) and route no-unify run-bundle convenience wrappers through canonical per-suite run-bundle APIs (`principalNoUnifyToGeneralRunBundle*_*_of_success`).
- [x] Route master-suite no-unify consequence wrappers (core, preconditioned, preconditioned↔core, hook-irrelevance) through no-unify run-bundle projection helpers so the master no-unify API stays on the run-bundle canonical path.
- [x] Introduce two-judgment architecture scaffold (`HasType` + `HasTypeU`) with explicit substitution admissibility and lift lemmas.
- [x] Show counterexample recovery in `HasTypeU` (`app_counterexample_hasTypeU`), validating the architecture shift.
- [x] Discharge a unification-aware app hook from substitution admissibility alone (`AppUnifySoundHookUResolved`, `appUnifySoundHookUResolved_proved`) once a resolved function-shape equation is available.
- [x] Add successor-fuel app hook variant (`AppUnifySoundHookUResolvedSucc`, `appUnifySoundHookUResolvedSucc_proved`) aligned with current bindTypeVar/idempotence bridge equalities.
- [x] Add one-step app bridge theorem in the unification-aware judgment (`inferExprUnify_app_step_sound_hasTypeU_resolved`) parameterized by explicit resolved function-shape equality.
- [x] Prove global resolved-shape assumptions are not derivable in the current fuel model (`not_AppResolvedShapeFromUnify`, `not_ProjResolvedShapeFromUnify`, `not_UnifyResolvedShapePremises`), tightening the vertical-slice boundary.
- [x] Land a hook-free app vertical theorem on a concrete true fragment (`inferExprUnify_app_vertical_closed_fresh_empty_subst`) using no-unify child inference + closed/fresh empty-subst app bridge.
- [x] Land a hook-free projection vertical theorem on a concrete true fragment (`inferExprUnify_proj_vertical_resolved`) using no-unify receiver inference + explicit resolved closed-row witness.
- [x] Add top-level projection inference corollary for the resolved vertical slice (`inferExprUnify_proj_vertical_resolved_of_infer`).
- [x] Compose app+projection vertical slices into a single packaged theorem surface (`VerticalHookFreeUnifySlices`, `verticalHookFreeUnifySlices_proved`).
- [x] Timebox an evaluator-side generalizability spike (`Rill/Eval.lean`): minimal semantics + determinism + initial progress/composition lemmas (`eval_progress_lit`, `eval_progress_var_of_envCovers`, `eval_let_of_eval_steps`, `eval_progress_record_of_evalFields`), literal-preservation lemmas (`eval_preserves_int_lit`, `eval_preserves_bool_lit`, `eval_preserves_string_lit`), variable-preservation under typed runtime environments (`eval_preserves_var_of_envTyped`), executable fragment predicates (`EvalFragmentExpr`, `EvalFragmentFields`), and initial executable soundness slices (`eval_sound_atomic`, `inferEval_sound_atomic`).
- [x] Extend evaluator spike to a non-atomic executable soundness slice over the full evaluator fragment (`eval_sound_evalFragment`, `evalFields_sound_evalFragment`, `inferEval_sound_evalFragment`) with record runtime typing transport (`ValueFieldsHasType`, `valueFieldsHasType_get`) and let-environment extension (`envWellTyped_cons`).
- [x] Add reduced lam/app vertical slice via beta-style direct app-lam execution (`.app (.lam ...) arg`) with no first-class function values in the fragment (`EvalFragmentFull`, `EvalFragmentFullFields`, `eval_app_lam_of_eval_arg`, `eval_sound_evalFragmentFull`, `evalFields_sound_evalFragmentFull`, `inferEval_sound_evalFragmentFull`).
- [x] Bridge from app unification success to weak-hook equality premise (`applySubstCompat stAfter.subst fuel (.var resVar) = retTy`) under explicit substitution assumptions.
  Completed via the app-equality bridge/theorem family in `Kea/Typing.lean` (`app_unify_result_eq_of_bindTypeVar_idempotent`, `app_unify_result_eq_of_unify_function_shape_idempotent`, shifted contract wrappers `app_unify_result_eq_of_unify_success_contract_succ` and closed/fresh specializations), with explicit no-op-domain contracts (`AppUnifyNoopDomain`) and resolved-shape/`HasTypeU` hook packaging (`AppResolvedShapeFromUnifyClosedFreshSucc`, `AppUnifySoundHookUClosedFreshSucc`).
- [ ] Prove full principal types for the row-polymorphic inference fragment beyond the current preconditioned vertical boundary.
  Progress: added packaged preconditioned principal-typing slice in `Kea/Typing.lean` (`PrincipalTypingSlicePreconditioned`, `principalTypingSlicePreconditioned_of_success`), strengthened the hook-free no-unify fragment with expression+field completeness/equivalence packaging (`inferExprUnify_complete_no_unify_branches`, `inferFieldsUnify_complete_no_unify_branches`, `inferExprUnify_ok_iff_inferExpr_no_unify_branches`, `inferFieldsUnify_ok_iff_inferFields_no_unify_branches`, `PrincipalTypingNoUnifySlices`), added a no-unify-to-preconditioned bridge (`principalTypingSlicePreconditioned_of_success_no_unify`), added bundled-hook principal entrypoints (`UnifyHookPremises`, `principalTypingSlicePreconditioned_of_success_from_bundle`, `principalTypingSlicePreconditioned_of_success_no_unify_from_bundle`), added core declarative principality packaging for syntax-directed inference (`hasType_unique`, `inferExpr_principal`, `PrincipalTypingSliceCore`, `principalTypingSliceCore_of_infer`), added no-unify unify-success bridges into those core principal packages (`principalTypingSliceCore_of_unify_success_no_unify`, `principalFieldTypingSliceCore_of_unify_success_no_unify`), added a general core-principal-to-preconditioned bridge (`principalTypingSlicePreconditioned_of_success_of_core_principal`), added the converse preconditioned-to-core bridge (`principalTypingSliceCore_of_preconditioned_success`, bundle variant), added packaged no-unify bridge exports (`PrincipalNoUnifyBridgeBundle`, `principalNoUnifyBridgeBundle_of_success`, hook-bundle variant), added field-side preconditioned principal parity (`inferFieldsUnify_deterministic`, `inferFieldsUnify_row_unique_preconditioned`, `PrincipalFieldTypingSlicePreconditioned` + direct/bundle/no-unify/core-bridge variants), added packaged no-unify field bridge exports (`PrincipalFieldNoUnifyBridgeBundle`, direct and hook-bundle constructors), added the converse preconditioned-to-core field bridge (`principalFieldTypingSliceCore_of_preconditioned_success`, bundle variant), added a combined expression+field no-unify bridge capstone (`PrincipalNoUnifyBridgeSlices`, `principalNoUnifyBridgeSlices_proved`), added successful-run equivalence bridges (`principalTypingSlicePreconditioned_iff_core_of_success`, `principalFieldTypingSlicePreconditioned_iff_core_of_success`, plus bundle variants), added a combined successful-run equivalence capstone (`PrincipalPreconditionedCoreIffSlices`, `principalPreconditionedCoreIffSlices_proved`), added one-hop projection helpers for both combined capstones (`principalNoUnifyBridgeSlices_expr/field`, `principalPreconditionedCoreIffSlices_expr/field`), added top-level suite packaging/projections (`PrincipalBoundaryBridgeSuite`, `principalBoundaryBridgeSuite_proved`, `principalBoundaryBridgeSuite_*`), added suite-based no-unify convenience entrypoints for direct core/preconditioned extraction (`principalNoUnifyCoreExpr/Field_of_success_via_suite`, `principalNoUnifyPreconditionedExpr/Field_of_success_via_suite`), added suite-based generic successful-run conversion wrappers in both directions (`principalCoreExpr/Field_of_preconditioned_success_via_suite`, `principalPreconditionedExpr/Field_of_core_success_via_suite`), added suite coherence lemmas tying no-unify bundle witnesses to preconditioned↔core witnesses (`principalBoundaryBridgeSuite_noUnify_*_coherent_*`), added no-unify capstone packaging with suite-derived constructors/projections (`PrincipalBoundaryNoUnifyExprCapstone`, `PrincipalBoundaryNoUnifyFieldCapstone`, `PrincipalBoundaryNoUnifyCapstoneSlices`, `principalBoundaryNoUnifyCapstoneSlices_proved`), added one-hop extraction helpers from capstone slices for core/preconditioned/`↔` witnesses (`principalBoundaryNoUnifyCapstoneSlices_expr_*`, `principalBoundaryNoUnifyCapstoneSlices_field_*`), added hook-passing parity entrypoints for capstone construction (`principalBoundaryNoUnifyExpr/FieldCapstone_of_success`, `principalBoundaryNoUnifyExpr/FieldCapstone_of_success_from_hook_bundle`), added fixed-run hook-transport/irrelevance theorems (`principalTypingSlicePreconditioned_transport_hooks_of_success`, `principalTypingSlicePreconditioned_hook_irrelevant_of_success`, field analogues), packaged that hook-irrelevance surface as a combined expression+field capstone (`PrincipalPreconditionedHookIrrelevanceSlices`, `principalPreconditionedHookIrrelevanceSlices_proved`, `principalPreconditionedHookIrrelevanceSlices_expr/field`), added a top-level vacuity suite that combines no-unify capstones with hook-irrelevance slices (`PrincipalBoundaryVacuitySuite`, `principalBoundaryVacuitySuite_proved`, `principalBoundaryVacuitySuite_*`), added no-unify all-hooks capstone surfaces (`PrincipalBoundaryNoUnifyExpr/FieldAllHooksCapstone`, `PrincipalBoundaryNoUnifyAllHooksCapstoneSlices`, projections) so one no-unify success exports core + all-hook preconditioned + per-hook equivalence in hook-free form, added all-hooks-derived irrelevance packaging (`PrincipalBoundaryNoUnifyAllHooksIrrelevanceSlices`, `principalBoundaryNoUnifyAllHooksIrrelevanceSlices_proved`, expression/field projections) to make hook-independence directly derivable from all-hooks capstones on no-unify successes, packaged both under a top-level all-hooks suite (`PrincipalBoundaryNoUnifyAllHooksSuite`, `principalBoundaryNoUnifyAllHooksSuite_proved`, `principalBoundaryNoUnifyAllHooksSuite_*`), added compatibility bridges back to the hook-specific capstone API (`principalBoundaryNoUnifyExpr/FieldCapstone_of_allHooks`, `principalBoundaryNoUnifyCapstoneSlices_of_allHooksCapstones`, `principalBoundaryNoUnifyCapstoneSlices_of_allHooksSuite`), added a top-level principal boundary master suite (`PrincipalBoundaryMasterSuite`, `principalBoundaryMasterSuite_proved`, `principalBoundaryMasterSuite_*`) aggregating bridge/vacuity/general-all-hooks/no-unify-all-hooks surfaces plus all-hooks→hooked compatibility projections, added all-hooks-suite no-unify convenience wrappers (`principalNoUnifyCore*` / `principalNoUnifyPreconditioned*_*_via_allHooksSuite`, including any-hooks forms) for direct downstream consumption without capstone destructuring, added general successful-run all-hooks capstone packaging (`PrincipalPreconditionedExpr/FieldAllHooksCapstone`, `PrincipalPreconditionedAllHooksCapstoneSlices`, with one-hop projections) so arbitrary successful runs export core + any-hooks preconditioned consequences from one hook witness pair, packaged that layer as a top-level suite with capstone-derived irrelevance (`PrincipalPreconditionedAllHooksSuite`, `principalPreconditionedAllHooksSuite_proved`, `principalPreconditionedHookIrrelevanceSlices_of_allHooksCapstones`, `principalPreconditionedAllHooksSuite_*`), added general-all-hooks-suite convenience wrappers (`principalCore*` / `principalPreconditioned*_*_via_generalAllHooksSuite`, including any-hooks forms) for direct successful-run consumption without capstone destructuring, added master-suite convenience wrappers (`principalCore*` / `principalPreconditioned*_*_via_masterSuite`, including any-hooks forms) so arbitrary successful-run consequences can be consumed directly from the master aggregate surface, added master-suite no-unify convenience wrappers (`principalNoUnifyCore*` / `principalNoUnifyPreconditioned*_*_via_masterSuite`, including any-hooks forms) so no-unify consequences are equally consumable from that same master surface, added explicit no-unify-to-general all-hooks projections (`principalPreconditionedExpr/FieldAllHooksCapstone_of_noUnifyAllHooks`, `principalBoundaryNoUnifyAllHooksSuite_capstone_*_as_general`, `principalBoundaryMasterSuite_noUnifyAllHooks_*_as_general`) to unify successful no-unify and arbitrary-success all-hooks call surfaces, added success-level no-unify-to-general wrappers (`principalPreconditionedExpr/FieldAllHooksCapstone_of_success_noUnify`, `principalCore*` / `principalPreconditioned*AnyHooks*_of_success_noUnify_via_generalAllHooks`) for direct no-hook-witness consumption on no-unify runs, added bundled-hook and irrelevance parity wrappers on that same path (`principalPreconditionedExpr/Field_of_success_noUnify_via_generalAllHooks`, `principalPreconditionedExpr/Field_hookIrrelevant_of_success_noUnify_via_generalAllHooks`), packaged that bridge as a dedicated suite (`PrincipalNoUnifyToGeneralAllHooksSuite`, `principalNoUnifyToGeneralAllHooks*` capstone/irrelevance slices and one-hop projections), lifted it into the master surface (`PrincipalBoundaryMasterSuite.noUnifyToGeneralAllHooks`, `principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_*`) as the canonical no-unify-as-general projection path, added hook-irrelevance convenience wrappers across the suite entrypoints (`principalPreconditioned*hookIrrelevant*_via_generalAllHooksSuite`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_masterSuite`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_allHooksSuite`), routed master-suite no-unify core/preconditioned convenience wrappers through that same canonical projection family (`principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_*`), routed all-hooks-suite no-unify convenience wrappers (including hook-irrelevance variants) through `PrincipalNoUnifyToGeneralAllHooksSuite_proved`, added bidirectional suite compatibility with derived forms (`principalNoUnifyToGeneralAllHooksSuite_of_noUnifyAllHooksSuite`, `principalBoundaryNoUnifyAllHooksSuite_of_noUnifyToGeneralAllHooksSuite`, `principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks`, `principalBoundaryNoUnifyAllHooksSuite_proved_via_noUnifyToGeneral`) to make the canonical relation explicit, added parameterized no-unify-to-general convenience wrappers (`principalNoUnifyToGeneralCore*`, `principalNoUnifyToGeneralPreconditioned*_*`) that now underpin both master and all-hooks no-unify convenience entrypoints, completed no-unify convenience parity with explicit bundled-hook `preconditioned ↔ core` wrappers (`principalNoUnifyToGeneralPreconditionedCoreIff*` with `principalNoUnifyPreconditionedCoreIff*_of_success_via_masterSuite` / `...via_allHooksSuite`), added matching arbitrary-success bundled-hook `preconditioned ↔ core` wrappers for general/master paths (`principalPreconditionedCoreIff*_of_success_via_generalAllHooksSuite`, `principalPreconditionedCoreIff*_of_success_via_masterSuite`), added matching any-hooks no-unify `preconditioned ↔ core` wrappers across canonical/master/all-hooks entrypoints (`principalNoUnifyToGeneralPreconditionedCoreIff*AnyHooks*`, `principalNoUnifyPreconditionedCoreIff*AnyHooks*_of_success_via_*Suite`) with bundled forms routed through these any-hooks APIs, added matching any-hooks arbitrary-success `preconditioned ↔ core` wrappers for general/master paths (`principalPreconditionedCoreIff*AnyHooks*_of_success_via_generalAllHooksSuite`, `principalPreconditionedCoreIff*AnyHooks*_of_success_via_masterSuite`) with bundled forms routed through them, added a parameterized arbitrary-success convenience layer over `PrincipalPreconditionedAllHooksSuite` (`principalGeneralAllHooks*`) that now underpins both `via_generalAllHooksSuite` and `via_masterSuite` wrappers, added direct no-unify-to-general `preconditioned ↔ core` wrappers on the proved general-all-hooks path (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_generalAllHooks`, `principalPreconditionedCoreIff*_of_success_noUnify_via_generalAllHooks`), and added master no-unify-to-general naming-parity wrappers for that same fixed-run `↔` surface (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_masterSuite`, `principalPreconditionedCoreIff*_of_success_noUnify_via_masterSuite`); remaining work is lifting this from the current hook/precondition boundary to the full row-polymorphic fragment.
- [x] Extend to DataFrame verb typing judgments once core typing soundness is stable.
  N/A for Kea scope: DataFrame/column verb formalization remains in the archived Rill track and is not part of Kea language formalization.
- [x] Add supertrait/evidence bridge kickoff model (`Rill/Traits.lean`): trait graph closure (`TraitGraph`) + closure-aware satisfaction/bound-checking surfaces (`satisfiesWithGraph`, `checkTraitBoundsWithGraph`) for MCP-observed evidence behavior.
- [x] Add concrete supertrait-gap boundary witness theorems (`satisfies_direct_ord_only`, `requiredTraits_ord_requires_eq`, `satisfiesWithGraph_ord_only_false`, `supertrait_gap_witness`) matching MCP-observed direct-impl vs closure-aware divergence.
- [x] Add bound-checking gap witness trio (`checkTraitBoundsWithGraph_ord_only_reports_missing_super`, `checkTraitBounds_direct_ord_only_accepts`, `checkTraitBoundsWithGraph_ord_and_eq_accepts`) to make the direct-vs-closure discrepancy executable at the trait-bound checker surface.
- [x] Package the trait-closure boundary into a single citation surface (`TraitClosureGapSlice`, `traitClosureGapSlice_proved`) for downstream paper and bridge theorem references.
- [x] Add no-impl witness theorems (`checkTraitBounds_direct_no_impl_reports_ord`, `checkTraitBoundsWithGraph_no_impl_reports_ord_and_eq`) to pin expected trait-bound failures when neither direct nor supertrait impls exist.
- [x] Add call-site gate model + bundle (`callSiteAcceptsDirect`, `callSiteAcceptsWithGraph`, `TraitCallSiteEnforcementSlice`) to make direct-vs-closure enforcement outcomes explicit at the acceptance boundary.
- [x] Add gate/checker normalization lemmas (`callSiteAcceptsDirect_eq_true_iff`, `callSiteAcceptsWithGraph_eq_true_iff`) so downstream theorems can switch between boolean gates and checker outputs.
- [x] Add witness-level refinement bundle (`TraitCallSiteRefinementWitnessSlice`) showing closure-aware acceptance implies direct acceptance on the fully-implemented witness state, while direct-only acceptance remains strictly weaker.
- [x] Add reusable refinement bridge surface (`TraitBoundRefinementPremise`, `callSiteAcceptsWithGraph_implies_direct_of_premise`) so future language-level checker changes can discharge one premise and inherit gate-level refinement.
- [x] Add witness-specialized premise instantiation path (`TraitBoundRefinementPremise_ord_and_eq_witness`, `callSiteAcceptsWithGraph_ord_and_eq_implies_direct_via_premise`) to connect the reusable bridge surface to a concrete fully-implemented state.
- [x] Add explicit site-level trait call boundary packaging (`TraitCallBoundarySite`, `callSiteAcceptsDirectAtSite`, `callSiteAcceptsWithGraphAtSite`, `trait_call_boundary_surface_slice`) to pin direct-vs-closure witness outcomes at boundary-sensitive sites.

## M5. Post-`61bd3a1` Language-Shift Delta Checklist

- [x] Re-audit unification-critical Rust surfaces after `feat: align function-only syntax, imports, prelude, and actor docs/tests` and confirm no structural `unify`/`unifyRows` algorithm rewrite in `rill-infer` (formal row-unification core remains aligned).
- [x] Re-probe MCP actor surface for message-form semantics (`impl Actor for T where Message = ...`, `send(actor, Msg)`, `call(actor, Msg)`) and log outcomes.
- [x] Re-probe MCP interactive prelude boundary for the new extended-prelude policy (confirm allowed bare names remain available and non-extended names reject without import).
- [x] Re-probe trait-closure boundary witness after syntax/runtime shift (confirm direct-only/supertrait-unsatisfied divergence behavior still reproduces).
- [x] Lift the actor message-style shift into an explicit Lean-facing contract surface in `Rill/Traits.lean` (`ActorDispatchModel`, `ActorMessageDispatchBoundarySlice`) so post-migration actor call-site boundaries are explicit and citable.
- [x] Add site-level actor dispatch boundary packaging (`ActorDispatchBoundarySite`, `actorDispatchAccepts*AtSite`, `actor_dispatch_boundary_surface_slice`) so message-style vs legacy dispatch outcomes are explicit at boundary-sensitive sites.
- [x] Decide whether to formalize strict-module-prelude semantics as a runtime/typing bridge artifact or keep it as implementation-only policy evidence in MCP logs.
  Decision: keep strict-module-prelude behavior as implementation-policy evidence in MCP logs for now; do not add a Lean artifact in this phase.

## M6. Kea Effect/Handler Contract Track (Complete)

- [x] WP6.1 handler core + normalization.
  Progress: `Kea/Properties/HandlerEffectRemoval.lean` landed with `EffectRow.handleRemove` and capstones (`handle_removes_effect`, `handle_preserves_other_effects`, row-tail/WF preservation, idempotence), then moved to spec-normalized composition via `EffectRow.handleComposeNormalized` plus nested same-target consequences (`nested_same_target_outer_removal_noop_of_inner_absent`, `nested_same_target_remains_absent_of_outer_absent`). MCP now confirms overlap-idempotence closure (`[Trace] ∪ [Trace] = [Trace]`) on tracked probes.
- [x] WP6.2 absent-effect closed-row no-op + clause-level closed-aware contracts.
  Progress: `Kea/Properties/HandlerAbsentEffectNoop.lean` added closed-row no-op model (`handleComposeClosedAware`, `handle_absent_effect_noop`, present/open fallback theorem). `Kea/Properties/HandlerClosedAwareContracts.lean` lifted this into clause APIs (`resultEffectsCoreClosedAware`, `resultEffectsClosedAware`) with normalized/closed bridge theorems, branch reduction/classification (`resultEffectsClosedAware_absent_closed_reduces_to_applyThen`, `resultEffectsCoreClosedAware_branch_classification`), bundle packaging (`ClosedAwareCoreBundle`, `closedAwareCoreBundle_of_classification`), and typing-facing consequences (`resultEffectsClosedAware_preserves_row_tail`, `wellTypedSlice_implies_handled_removed_closedAware`).
- [x] WP6.3 resume-linearity + clause typing integration.
  Progress: `Kea/Properties/ResumeLinearity.lean` landed (`ResumeUse`, saturating composition, `resume_at_most_once`) and was strengthened with exact combine/exclusivity theorems (`resume_combine_atMostOnce_iff`, `resume_combine_atMostOnce_implies_one_side_zero`, `resume_combine_one_one_not_atMostOnce`). `Kea/Properties/HandlerTypingContracts.lean` then integrated effect-removal + linearity into `wellTypedSlice` with explicit `resultEffectsCore`/`applyThenEffects`/`resultEffects`, handled-label non-reintroduction, resume provenance, branch exclusivity, and loop legality. MCP aligns with `E0012` double-resume rejection behavior.
- [x] WP6.4 operation typing + tail capability + nested composition packages.
  Progress: `Kea/Properties/EffectOperationTyping.lean` added declaration/operation contracts (`EffectDecl`, `operationCallTyping`, `performOperationEffects`) with WF transport and named bundles (`OperationCallBundle`). `Kea/Properties/TailResumptiveClassification.lean` and `Kea/Properties/TailCapabilityComposition.lean` added direct-call eligibility/classification plus named bundles (`TailResumptiveBundle`, `TailCapabilityBundle`), and now include closed-aware direct-call/capability surfaces (`tail_resumptive_direct_call_sound_closedAware`, `TailResumptiveClosedAwareBundle`, `TailCapabilityClosedAwareBundle`, `tail_resumptive_eligible_capability_direct_call_sound_closedAware`). `Kea/Properties/NestedHandlerCompositionContracts.lean` added nested same-target capstones + bundle (`NestedHandlerBundle`). MCP probes are aligned across capability residual effects and nested same-target control.
- [x] WP6.5 fail/result lowering and catch bridge stack.
  Progress: `Kea/Properties/FailResultContracts.lean`, `FailResultEquivalence.lean`, `EffectPolymorphismSoundness.lean`, `CatchTypingBridge.lean`, and `HigherOrderCatchContracts.lean` now provide the full admissible-catch theorem stack: Fail-as-zero-resume, function-type lowering/equivalence (including closed-aware clause-output capstone `failResultContract_sound_closedAware`), admissibility partition (`catchAdmissible` vs `catchUnnecessary`), named admissible bundles (`AdmissibleEffectPoly*Bundle`), judgment/raw-premise adapters, combined capstone classifiers, and higher-order specialization/bundles/classifiers. Runtime divergences on fail-absent and higher-order catch are closed on current MCP: fail-absent `catch` rejects with `E0012`; fail-present higher-order catch preserves residual non-Fail effects.
- [x] WP6.6 unify entry API across Phase-2 capstones.
  Completed by adding shared closed-aware entry packaging (`ClosedAwareResultBundle`, `closedAwareResultBundle_of_wellTyped`, `wellTypedSlice_implies_handled_removed_legacy_via_closedAware`) and routing fail/catch bridge surfaces through it (`FailResultContracts`, `EffectPolymorphismSoundness`, plus direct catch/higher-order adapters `catchTypingJudgment_clauseFailRemoved_via_closedAware`, `higherOrderCatchTypingJudgment_clauseFailRemoved_via_closedAware`, `catchTypingJudgment_clauseRowTailStable_closedAware`, `higherOrderCatchTypingJudgment_clauseRowTailStable_closedAware`), alongside closed-aware nested-handler capstones (`nestedComposeClosedAware`, `nested_handlers_compose_closedAware`, `NestedHandlerClosedAwareBundle`) and closed-aware tail-capability surfaces (`wellTyped_capability_direct_call_sound_closedAware`, `TailCapabilityClosedAwareBundle`).

## M7. Type Universe Parity (In Progress)

- [x] Add a cross-family boundary-surface package theorem (`boundary_surface_suite`) that composes per-family boundary slices and the dynamic/wrapper/grouped-tagged typing bridges (at explicit boundary sites) into one reusable citation contract.
- [x] Add an expression-level ascription bridge slice (`BoundaryAscriptionSyntax`) and wire it into the cross-family boundary surface suite.
- [x] Add a minimal algorithmic Dynamic-ascription checker (`inferDynamicAscriptionAtSite`) with soundness and variable boundary witnesses.
- [x] Package algorithmic Dynamic-ascription outcomes (`DynamicAscriptionAlgorithmicSliceAtSite`) and lift them into the cross-family boundary surface suite.
- [x] Add algorithmic↔declarative Dynamic-ascription alignment witnesses (`dynamicAscriptionAlgorithmicDeclarativeVarAlignmentAtSite`) for the core `x : Dynamic` boundary probe.
- [x] Add wrapper/grouped algorithmic ascription checkers (`inferWrapperAscriptionAtSite`, `inferGroupedTaggedAscriptionAtSite`) with site-level witness slices and lift them into the cross-family boundary surface suite.
- [x] Add wrapper/grouped algorithmic↔declarative alignment witnesses (`wrapperAscriptionAlgorithmicDeclarativeTaskAlignmentAtSite`, `groupedAscriptionAlgorithmicDeclarativeAlignmentAtSite`).
- [x] Package cross-family ascription algorithmic↔declarative alignment (`AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites`) and lift it into the cross-family boundary surface suite.
- [x] Package a unified ascription bridge suite (`BoundaryAscriptionBridgeSuiteAtSites`) and consume it from `boundary_surface_suite`.
- [x] Add expression-level `inferExpr` integration adapters/slice for ascription surfaces (`infer*ExprWithAscriptionAtSite`, `AscriptionInferExprBridgeSliceAtSites`) and fold into `BoundaryAscriptionBridgeSuiteAtSites`.
- [x] Lift `AscriptionInferExprBridgeSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Add expression-level ascription completeness slice (`AscriptionInferExprCompletenessSliceAtSites`) and fold into `BoundaryAscriptionBridgeSuiteAtSites`.
- [x] Lift `AscriptionInferExprCompletenessSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Lift `AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Add `.base` embedding slice (`AscriptionBaseEmbeddingSliceAtSites`) and fold into `BoundaryAscriptionBridgeSuiteAtSites`.
- [x] Lift `AscriptionBaseEmbeddingSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Move generic ascription primitives into `Rill/Typing.lean` (`HasTypeAtCoreBoundary`, `CoreExprWithAscription`, `HasTypeWithAscription`, `inferExprWithAscription` + soundness/completeness/iff) and rewire boundary modules to consume the core definitions.
- [x] Add Typing-level `.base` conservativity lemmas for ascription inference (`inferExprWithAscription_base_eq`, `inferExprWithAscription_base_iff`) as preparation for eventual base-`CoreExpr` `ascribe` integration.
- [x] Add Typing-level `.ascribe` boundary-equivalence lemma (`inferExprWithAscription_ascribe_iff_boundary`) to bridge algorithmic inference directly to `HasTypeAtCoreBoundary`.
- [x] Route wrapper/grouped ascription algorithmic checkers through Typing core `inferExprWithAscription` and revalidate mismatch/identity MCP controls.
- [x] Add expression-level core-infer routing slice (`AscriptionCoreInferRoutingSliceAtSites`) and lift it into both `BoundaryAscriptionBridgeSuiteAtSites` and `boundary_surface_suite`.
- [x] Relax wrapper/grouped boundary-gate semantics from strict empty-substitution success to existential unifier success (`∃ st', unify ... = .ok st'`), then restore fully quantified expression-level infer surfaces (`inferWrapperExprWithAscriptionAtSite_sound`/`_complete`/`_iff`, `inferGroupedTaggedExprWithAscriptionAtSite_sound`/`_complete`/`_iff`) and lift `AscriptionInferExprBridgeSliceAtSites` to a fully quantified cross-family soundness slice.
- [x] Add explicit ascription-node equivalence theorems for wrapper/grouped adapters (`inferWrapperAscriptionAtSite_iff`, `inferGroupedTaggedAscriptionAtSite_iff`) to close the local algorithmic↔declarative bridge at `.ascribe`.
- [x] Route wrapper/grouped ascription-node equivalence through Typing-core boundary bridges (`inferWrapperAscriptionAtSite_iff_boundary`, `inferGroupedTaggedAscriptionAtSite_iff_boundary`) and derive local `HasTypeWith*Ascription` iff theorems from those boundary-level contracts.
- [x] Generalize `AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites` from witness probes to fully quantified ascription-level equivalence across Dynamic/wrapper/grouped adapters (using `inferDynamicAscriptionAtSite_iff`, `inferWrapperAscriptionAtSite_iff`, `inferGroupedTaggedAscriptionAtSite_iff`).
- [x] Add derivation theorems from the packaged `infer`↔`HasType` slice (`ascriptionInferExprIffSliceAtSites_implies_bridge`, `..._implies_completeness`) to make slice-strength relationships explicit.
- [x] Add nominal ADT language-level typing bridge and nominal algorithmic ascription slice (`HasTypeAtNominalAdtBoundaryAtSite`, `NominalAdtTypingBridgeSliceAtSites`, `inferNominalAscriptionAtSite`, `NominalAdtAscriptionAlgorithmicSliceAtSite`) and lift them into `boundary_surface_suite`.
- [x] WP7.1 low-risk leaf parity (`Html`/`Markdown`/`Atom`/`Date`/`DateTime`) with vertical theorem slice (`TemporalLeafParity`), explicit site-level leaf boundary-policy package (`leaf_boundary_surface_slice`), and MCP validation.
- [ ] WP7.2 precision numerics + dimension kernel (`IntN`/`FloatN`/`Dim`/`DimVar`).
  Progress: `IntN`/`FloatN` landed in `Ty.lean` and propagated through substitution/free-vars/occurs/generalize/typing/unification proof surfaces; added explicit theorem slice `PrecisionLeafParity`, now including precision unification decision/iff contracts (`intN_unify_decision`, `intN_unify_ok_iff_constructor_beq_true`, `floatN_unify_decision`, `floatN_unify_ok_iff_constructor_beq_true`) and an explicit site-level precision boundary-policy layer (`PrecisionBoundarySite`, `precisionBoundaryAllowsAtSite`) with packaged closure theorem `precision_boundary_surface_slice` for width-mismatch and non-precision rejection surfaces. Added standalone `Dim`/`DimVar` kernel module (`Rill/Dimensions.lean`) with proved substitution/idempotence/unification lemmas, now including explicit decision/characterization contracts (`unifyDim_of_beq_true`, `unifyDim_const_decision`, `unifyDim_const_some_iff_eq`, `unifyDim_const_none_iff_ne`, `unifyDim_const_some_implies_empty`), explicit var/const binding contracts (`unifyDim_const_var_binds`, `unifyDimList_single_var_const_binds`, `unifyDimList_single_const_var_binds`, `unifyDimList_pair_var_const_binds_distinct`, `unifyDimList_pair_const_var_binds_distinct`, `unifyDimList_pair_same_var_const_binds_of_eq`, `unifyDimList_pair_same_var_const_none_of_ne`, `unifyDimList_pair_same_var_const_decision`, `unifyDimList_pair_const_same_var_binds_of_eq`, `unifyDimList_pair_const_same_var_none_of_ne`, `unifyDimList_pair_const_same_var_decision`, `unifyDimList_pair_var_const_some_iff_var_distinct_or_consts_eq`, `unifyDimList_pair_var_const_none_iff_var_eq_and_consts_ne`, `unifyDimList_pair_const_var_some_iff_var_distinct_or_consts_eq`, `unifyDimList_pair_const_var_none_iff_var_eq_and_consts_ne`), plus pointwise dim-list kernel contracts (`unifyDimList_reflexive`, `unifyDimList_consts_some_iff_eq`, `unifyDimList_consts_some_implies_empty`, `unifyDimList_consts_none_iff_ne`, `unifyDimList_consts_decision`, `unifyDimList_head_const_mismatch_none`, `unifyDimList_consts_length_mismatch_none`, `unifyDimList_consts_none_implies_beq_false`). MCP revalidation confirms precision boundary diagnostics (`Int32`→`Int64`, `Float32`→`Float64`, `Int`→`Int32`) and decimal checks remain aligned (`Decimal(10, 2)` accepted; scale mismatch rejects with dimension mismatch). Remaining scope is deeper dim-aware theorem families (beyond constructor-local parity slices).
- [ ] WP7.3 decimal constructor parity.
  Progress: added `Ty.decimal` and proof slice `Rill/Properties/DecimalParity.lean` (substitution leaf, reflexive unification, constructor-BEq success/failure decision lemmas, exact decision equation + success-iff-BEq characterization, precision/scale mismatch witnesses, free-var lemmas, and bidirectional constant-dimension dim-kernel bridges: success `decimal_unify_consts_of_dim_kernel_success`, kernel-failure rejection `decimal_unify_consts_reject_of_prec_dim_kernel_none` / `decimal_unify_consts_reject_of_scale_dim_kernel_none` / `decimal_unify_consts_reject_of_dim_kernel_none`, plus success characterization `decimal_unify_consts_ok_iff_dim_kernel_success`); `DecimalParity` now also includes an explicit site-level decimal boundary-policy layer (`DecimalBoundarySite`, `decimalBoundaryAllowsAtSite`) with packaged closure theorem `decimal_boundary_surface_slice` for scale/precision mismatch and non-decimal rejection surfaces. MCP loop confirms runtime decimal annotation strictness after the implementation fix, including scale-mismatch and non-decimal boundary diagnostics on this surface path. Remaining scope is full dim-aware decomposition in the main unifier.
- [ ] WP7.4 shape-carrying constructors (`FixedSizeList`/`Tensor`).
  Progress: constructors landed in `Ty.lean` and now propagate through substitution/free-vars/occurs/generalize plus typing-proof exhaustiveness; main unifier now has constructor branches for fixed-size-list/tensor; added vertical theorem slice `Rill/Properties/ShapeConstructorParity.lean` (substitution-step decomposition, reflexive unification, size/rank mismatch witnesses, element-type mismatch witnesses under matching metadata, normalized reduction/rejection contracts under explicit non-short-circuit preconditions, explicit any-fuel inner-branch propagation lemmas `fixedSizeList_inner_error_propagates_any_fuel`/`fixedSizeList_inner_success_propagates_any_fuel`/`tensor_inner_error_propagates_any_fuel`/`tensor_inner_success_propagates_any_fuel`, generalized successor-fuel mismatch contracts `fixedSizeList_dim_mismatch_any_fuel`/`tensor_rank_mismatch_any_fuel` plus arbitrary-inner mismatch generalizations `fixedSizeList_dim_mismatch_any_elem_any_fuel`/`tensor_shape_mismatch_any_elem_any_fuel`, explicit mixed var/const metadata rejection witnesses (`fixedSizeList_var_const_dim_mismatch_any_elem_any_fuel`, `fixedSizeList_const_var_dim_mismatch_any_elem_any_fuel`, `tensor_rank1_var_const_shape_mismatch_any_elem_any_fuel`, `tensor_rank1_const_var_shape_mismatch_any_elem_any_fuel`), explicit kernel-vs-constructor witnesses for mixed fixed-size-list/rank-1/rank-2 tensor metadata (`fixedSizeList_var_const_dim_kernel_success`, `fixedSizeList_const_var_dim_kernel_success`, `fixedSizeList_var_const_kernel_success_but_unify_rejects`, `fixedSizeList_const_var_kernel_success_but_unify_rejects`, `tensor_rank1_var_const_dim_kernel_success`, `tensor_rank1_const_var_dim_kernel_success`, `tensor_rank1_var_const_kernel_success_but_unify_rejects`, `tensor_rank1_const_var_kernel_success_but_unify_rejects`, `tensor_rank2_var_const_dim_kernel_success_distinct`, `tensor_rank2_var_const_kernel_success_but_unify_rejects_distinct`, `tensor_rank2_const_var_dim_kernel_success_distinct`, `tensor_rank2_const_var_kernel_success_but_unify_rejects_distinct`, `tensor_rank2_var_const_dim_kernel_some_iff_var_distinct_or_consts_eq`, `tensor_rank2_var_const_dim_kernel_none_iff_var_eq_and_consts_ne`, `tensor_rank2_const_var_dim_kernel_some_iff_var_distinct_or_consts_eq`, `tensor_rank2_const_var_dim_kernel_none_iff_var_eq_and_consts_ne`, `tensor_rank2_mixed_dim_kernel_pair_decomposition_slice`, `tensor_rank2_same_var_const_dim_kernel_success_of_eq`, `tensor_rank2_same_var_const_dim_kernel_none_of_ne`, `tensor_rank2_same_var_const_dim_kernel_some_iff_eq`, `tensor_rank2_same_var_const_unify_rejects_any`, `tensor_rank2_same_var_const_ok_iff_dim_kernel_success_iff_ne`, `tensor_rank2_same_var_const_ok_iff_dim_kernel_success_of_ne`, `tensor_rank2_same_var_const_kernel_success_but_unify_rejects_of_eq`, `tensor_rank2_const_same_var_dim_kernel_success_of_eq`, `tensor_rank2_const_same_var_dim_kernel_none_of_ne`, `tensor_rank2_const_same_var_dim_kernel_some_iff_eq`, `tensor_rank2_const_same_var_unify_rejects_any`, `tensor_rank2_const_same_var_ok_iff_dim_kernel_success_iff_ne`, `tensor_rank2_const_same_var_ok_iff_dim_kernel_success_of_ne`, `tensor_rank2_const_same_var_kernel_success_but_unify_rejects_of_eq`, `tensor_rank2_same_var_ok_iff_dim_kernel_success_split`, `tensor_rank2_same_var_const_non_generalization_iff_eq`, `tensor_rank2_const_same_var_non_generalization_iff_eq`, `tensor_rank2_same_var_non_generalization_split_iff_eq`, `tensor_rank2_var_const_non_generalization_by_var_equality`, `tensor_rank2_const_var_non_generalization_by_var_equality`, `tensor_rank2_mixed_non_generalization_by_var_equality_slice`, `tensor_rank2_var_const_ok_iff_dim_kernel_success_iff_var_eq_and_const_ne`, `tensor_rank2_const_var_ok_iff_dim_kernel_success_iff_var_eq_and_const_ne`, `tensor_rank2_mixed_ok_iff_dim_kernel_success_iff_var_eq_and_const_ne_slice`, `tensor_rank2_var_const_non_generalization_iff_not_var_eq_and_const_ne`, `tensor_rank2_const_var_non_generalization_iff_not_var_eq_and_const_ne`, `tensor_rank2_mixed_non_generalization_iff_not_var_eq_and_const_ne_slice`, `tensor_rank2_var_const_kernel_success_but_unify_rejects_iff_var_distinct_or_consts_eq`, `tensor_rank2_const_var_kernel_success_but_unify_rejects_iff_var_distinct_or_consts_eq`, `tensor_rank2_mixed_kernel_success_but_unify_rejects_iff_var_distinct_or_consts_eq_slice`, `tensor_rank2_var_const_divergence_iff_not_naive_contract`, `tensor_rank2_const_var_divergence_iff_not_naive_contract`, `tensor_rank2_mixed_divergence_iff_not_naive_contract_slice`, `fixedSizeList_var_const_divergence_iff_not_naive_contract`, `fixedSizeList_const_var_divergence_iff_not_naive_contract`, `tensor_rank1_var_const_divergence_iff_not_naive_contract`, `tensor_rank1_const_var_divergence_iff_not_naive_contract`, `mixed_shape_rank1_divergence_iff_not_naive_contract_slice`, `mixed_shape_divergence_iff_not_naive_contract_slice`, `tensor_rank2_same_var_const_divergence_iff_not_naive_contract_of_eq`, `tensor_rank2_const_same_var_divergence_iff_not_naive_contract_of_eq`, `tensor_rank2_same_var_divergence_iff_not_naive_contract_slice_of_eq`), plus packaged mixed-shape boundary citation theorem `mixed_shape_kernel_boundary_slice`, packaged repeated-var rank-2 boundary theorem `tensor_rank2_same_var_kernel_boundary_slice_of_eq`, explicit non-generalization counterexamples in both directions (including repeated-var/equal-constants rank-2 cases), and packaged non-generalization boundary theorems `mixed_shape_non_generalization_slice` and `tensor_rank2_same_var_non_generalization_slice_of_eq`, constant-dimension bridge lemmas `fixedSizeList_unify_consts_of_dim_kernel_success`/`tensor_rank1_unify_consts_of_dim_kernel_success` with explicit eq/ne acceptance/rejection corollaries, explicit dim-kernel match-decision contracts `fixedSizeList_unify_consts_match_decision` and `tensor_rank1_unify_consts_match_decision`, and generalized pointwise dim-list bridge contracts including arbitrary-inner generalizations (`tensor_unify_const_shapes_of_dim_list_kernel_success_any_elem`, `tensor_unify_const_shapes_accept_of_eq_any_elem`, `tensor_unify_const_shapes_reject_of_dim_list_kernel_none_any_elem`, `tensor_unify_const_shapes_reject_of_ne_any_elem`, `tensor_unify_const_shapes_ok_iff_dim_list_kernel_success_any_elem`, `tensor_unify_const_shapes_match_decision_any_elem`, plus `Int` wrappers `tensor_unify_const_shapes_of_dim_list_kernel_success`, `tensor_unify_const_shapes_accept_of_eq`, `tensor_unify_const_shapes_reject_of_dim_list_kernel_none`, `tensor_unify_const_shapes_reject_of_ne`, and extended mismatch/decision contracts `tensor_unify_const_shapes_reject_of_length_mismatch`, `tensor_unify_const_shapes_reject_of_head_mismatch`, `tensor_unify_const_shapes_ok_iff_dim_list_kernel_success`, `tensor_unify_const_shapes_match_decision`), kernel-failure rejection companions `fixedSizeList_unify_consts_reject_of_dim_kernel_none`/`tensor_rank1_unify_consts_reject_of_dim_kernel_none`, and success-iff-kernel-success characterizations `fixedSizeList_unify_consts_ok_iff_dim_kernel_success`/`tensor_rank1_unify_consts_ok_iff_dim_kernel_success`). Post-restart MCP re-check still confirms shape constructor annotation syntax/docs divergence on this surface path.
- [ ] WP7.5 nominal ADT parity (`Sum`/`Opaque`).
  Progress: `Sum`/`Opaque` constructors landed in `Ty.lean`, propagated through substitution/free-vars/occurs/generalize/unify plus typing-proof exhaustiveness, and are covered by `Rill/Properties/NominalAdtParity.lean` (substitution-step decomposition, reflexive unification, packaged structural slices `nominal_adt_subst_step_slice`/`nominal_adt_unifies_with_self_slice`/`nominal_adt_free_vars_slice`, nominal-name mismatch witnesses including successor-fuel contracts `sum_name_mismatch_any_fuel`/`opaque_name_mismatch_any_fuel` plus arbitrary-list generalizations `sum_name_mismatch_any_args_any_fuel`/`opaque_name_mismatch_any_params_any_fuel`, constructor-arity mismatch witnesses plus successor+1 fuel contracts `sum_arity_mismatch_any_fuel`/`opaque_arity_mismatch_any_fuel` and arbitrary-list generalizations for both directions `sum_arity_mismatch_any_nonempty_args_any_fuel`/`opaque_arity_mismatch_any_nonempty_params_any_fuel` and `sum_arity_mismatch_empty_vs_nonempty_any_fuel`/`opaque_arity_mismatch_empty_vs_nonempty_any_fuel`, normalized branch-decision equations `sum_unify_branch_decision_of_normalized`/`opaque_unify_branch_decision_of_normalized` plus packaged cross-constructor decision slice `nominal_adt_unify_branch_decision_slice_of_normalized`, normalized reduction/rejection contracts under explicit non-short-circuit preconditions, branch corollaries `sum_unify_accepts_of_normalized_args_ok`/`opaque_unify_accepts_of_normalized_params_ok` plus generic error-propagation corollaries `sum_unify_rejects_args_err_of_normalized`/`opaque_unify_rejects_params_err_of_normalized`, normalized-name-inequality convenience slices `sum_unify_rejects_of_normalized_name_ne`/`opaque_unify_rejects_of_normalized_name_ne` plus packaged cross-constructor slice `nominal_adt_unify_rejects_of_normalized_name_ne_slice`, explicit any-fuel outer-branch propagation lemmas (`sum_args_error_propagates_any_fuel`, `sum_args_success_propagates_any_fuel`, `sum_args_arity_mismatch_propagates_any_fuel`, `opaque_params_error_propagates_any_fuel`, `opaque_params_success_propagates_any_fuel`, `opaque_params_arity_mismatch_propagates_any_fuel`), and arity-rejection specializations `sum_unify_rejects_arity_mismatch_of_normalized`/`opaque_unify_rejects_arity_mismatch_of_normalized`, packaged mismatch slices `nominal_adt_name_mismatch_slice_any_lists_any_fuel`/`nominal_adt_arity_mismatch_slice_any_fuel`/`nominal_adt_mismatch_suite_any_fuel`, free-var lemmas). `NominalAdtParity` now also includes an explicit site-level boundary-policy layer (`NominalAdtBoundarySite`, `nominalAdtBoundaryAllowsAtSite`) with packaged closure theorem `nominal_adt_boundary_surface_slice` for nominal-name mismatch and non-nominal rejection surfaces. `RecordStructuralProjection` now includes both the unifier-symmetry witness `anonRecordUnifiesWithNamedRecord` and policy-closure witnesses (`record_nominal_boundary_closes_unifier_symmetry`, `record_boundary_policy_site_invariant`, `record_boundary_rejects_structural_to_named_all_sites`, `record_boundary_allows_named_to_structural_all_sites`, `record_boundary_directional_policy_all_sites`, `record_nominal_boundary_closes_unifier_symmetry_all_sites`), explicitly modeling that directional nominal-boundary checks must sit above unification at all boundary-sensitive sites. New module `Rill/Properties/NominalAdtTypingBridge.lean` now lifts nominal boundary policy into modeled typing gates (`HasTypeAtNominalAdtBoundaryAtSite`) with packaged ascription/all-sites bridge theorems (`nominal_adt_typing_bridge_ascription`, `nominal_adt_typing_bridge_all_sites`, `NominalAdtTypingBridgeSliceAtSites`), plus a minimal algorithmic nominal ascription checker/equivalence slice (`nominalAscriptionAllowsBoolAtSite`, `inferNominalAscriptionAtSite`, `inferNominalAscriptionAtSite_iff`, `NominalAdtAscriptionAlgorithmicSliceAtSite`), and `boundary_surface_suite` now includes both the nominal typing-bridge and nominal ascription-algorithmic slices explicitly. MCP validation confirms reflexive annotation behavior, nominal mismatch diagnostics (`Alpha` vs `Gamma`, `UserId` vs `OrderId`/`Int`), ADT constructor arity diagnostics (`Circle` expected 1 argument, got 2), structural-to-nominal rejection diagnostics across all four boundary-sensitive sites (`let`/call/return/ascription), named->structural projection control acceptance (`let get_name = r -> r.name; get_name(User { ... })`), normalized nominal mismatch behavior across ADT/opaque decision paths (`A` vs `B`, `Int` vs `UserId`), and non-nominal call-boundary rejection (`expected A, got Int`). Remaining scope is language-level branch-refinement theorem coverage; this is blocked on extending `Typing.CoreExpr` with ADT constructor/case forms.
- [ ] WP7.6 higher-order constructor internals (`Forall`/`App`/`Constructor`/`Existential`).
  Progress: `Forall`/`App`/`Constructor`/`Existential` landed in `Ty.lean`, propagated through substitution/free-vars/occurs/generalize/unify plus typing-proof exhaustiveness, and are covered by `Rill/Properties/HigherOrderConstructorParity.lean` + `Rill/Properties/ForallParity.lean` + `Rill/Properties/ExistentialParity.lean` (substitution-step decomposition, reflexive unification, constructor mismatch witnesses, free-var lemmas, and packaged constructor-app structural slices `constructor_app_subst_step_slice`/`constructor_app_unifies_with_self_slice`/`constructor_app_free_vars_slice`). `ForallParity` now includes generalized alpha-insensitive compatibility, constructor-level alpha-invariance, explicit canonical-equivalence closure lemmas (`forallCanonicalEq_refl/symm/trans`) with unification lifts (`forallCanonicalEq_unifies`, `forallCanonicalEq_unifies_symm`, `forallCanonicalEq_unifies_trans`) and packaged closure witness `forall_canonical_equivalence_slice`, a normalized non-short-circuit branch reduction lemma (`forall_unify_reduces_to_body_unify_of_normalized_foralls`) with accept/reject corollaries (`forall_unify_accepts_of_normalized_body_ok`, `forall_unify_rejects_of_normalized_body_err`) plus arbitrary-state success lifting (`forall_unify_accepts_of_normalized_body_ok_any`), generic body-error propagation (`forall_unify_rejects_of_normalized_body_err_any`), successor-fuel quantified-body mismatch rejection (`forall_body_mismatch_any_fuel`), explicit any-fuel body-error propagation (`forall_body_error_propagates_any_fuel`), explicit any-fuel body-success propagation (`forall_body_success_propagates_any_fuel`), concrete alpha-renaming/vacuous-binder witnesses, packaged structural slice `forall_structural_slice`, packaged concrete surface witness `forall_surface_boundary_slice`, and an explicit site-level boundary-policy layer (`ForallBoundarySite`, `forallBoundaryAllowsAtSite`) with packaged closure theorem `forall_boundary_surface_slice`. `ExistentialParity` now includes normalized reduction/rejection contracts under explicit non-short-circuit preconditions (`existential_unify_reduces_to_assoc_of_normalized`, `existential_unify_rejects_of_normalized`) plus equal-bounds associated-type-list outcome propagation corollaries (`existential_unify_accepts_of_normalized_assoc_ok`, `existential_unify_rejects_assoc_err_of_normalized_bounds_eq`), explicit any-fuel outer-branch propagation lemmas (`existential_assoc_error_propagates_any_fuel`, `existential_assoc_success_propagates_any_fuel`), successor-fuel mismatch rejection witnesses for bounds in both concrete (`existential_bounds_mismatch_any_fuel`) and arbitrary-assoc generalized form (`existential_bounds_mismatch_any_assoc_any_fuel`), associated-type arity in both concrete (`existential_assoc_length_mismatch_any_fuel`) and directional generalized forms (`existential_assoc_length_mismatch_any_nonempty_assoc_any_fuel`, `existential_assoc_length_mismatch_empty_vs_nonempty_any_fuel`), and an explicit site-level existential boundary-policy layer (`ExistentialBoundarySite`, `existentialBoundaryAllowsAtSite`) with packaged closure theorem `existential_boundary_surface_slice`. `HigherOrderConstructorParity` now includes normalized app/constructor branch contracts (`app_unify_branch_of_normalized`, `constructor_unify_reduces_to_fixed_args_of_normalized`, `constructor_unify_rejects_of_normalized_guard_false`), app-branch outcome propagation corollaries (`app_unify_rejects_ctor_err_of_normalized`, `app_unify_accepts_of_normalized_ctor_ok_args_ok`, `app_unify_rejects_args_err_of_normalized_ctor_ok`, `app_unify_rejects_args_arity_mismatch_of_normalized_ctor_ok`, `app_unify_rejects_ctor_guard_false_of_normalized_succ`), explicit any-fuel app propagation lemmas (`app_ctor_error_propagates_any_fuel`, `app_ctor_args_success_propagates_any_fuel`, `app_args_error_propagates_any_fuel`, `app_args_arity_mismatch_propagates_any_fuel`), direct constructor-headed app guard-failure rejection across fuel (`app_constructor_name_mismatch_any_fuel`, `app_constructor_arity_mismatch_any_fuel`, `app_constructor_guard_mismatch_any_fuel`), normalized fixed-argument branch success/error propagation corollaries (`constructor_unify_accepts_of_normalized_fixed_args_ok`, `constructor_unify_rejects_fixed_args_err_of_normalized`, `constructor_unify_rejects_fixed_args_arity_mismatch_of_normalized`), explicit any-fuel fixed-arg propagation lemmas (`constructor_fixed_args_error_propagates_any_fuel`, `constructor_fixed_args_success_propagates_any_fuel`), explicit any-fuel constructor-guard mismatch theorem (`constructor_guard_mismatch_any_fixed_any_fuel`), packaged guard-mismatch suite `constructor_guard_mismatch_suite_any_fuel`, packaged concrete constructor-guard witness `constructor_guard_surface_slice`, plus an explicit site-level constructor-head boundary-policy layer (`ConstructorGuardBoundarySite`, `constructorGuardBoundaryAllowsAtSite`) with packaged closure theorem `constructor_guard_boundary_surface_slice`, and successor-fuel generalized constructor mismatch contracts for arbitrary fixed-argument lists (`constructor_name_mismatch_any_fixed_any_fuel`, `constructor_arity_mismatch_any_fixed_any_fuel`). MCP validation now confirms constructor-parameter arity mismatch diagnostics for `List`/`Map` after the runtime fix (including name/arity mismatch surfaces), alongside existential boundary behavior (`any` accepted; `any Show -> Int`, `any Show -> any Eq`, and `Int -> any Show` rejected), rank-2 annotation parsing/type-checking with the correct `forall a. fn(a) -> a` syntax, acceptance of alpha-renamed/vacuous-binder-compatible quantified arguments, rejection of non-equivalent quantified body shapes at call sites (`argument 1 is not polymorphic enough: expected \`forall a. (a) -> a\``), rejection of non-`forall` arguments at the same boundary, combined List/Map surface guard mismatch diagnostics, and non-constructor-to-constructor call-boundary rejection (`expected List(Int), got Int`). Lean mirrors observed constructor-level `forall` binder canonicalization behavior. Remaining scope is language-level higher-rank theorem/runtime parity (alpha-equivalence/subsumption/evidence interactions).
- [ ] WP7.7 runtime wrappers and boundaries (`Dynamic`/`GroupedFrame`/`Task`/`Actor`/`Arc`/`Tagged`).
  Progress: `Dynamic`/`GroupedFrame`/`Task`/`Actor`/`Arc`/`Tagged` landed in `Ty.lean`, propagated through substitution/free-vars/occurs/generalize/unify plus typing-proof exhaustiveness, and are covered by `Rill/Properties/RuntimeWrapperParity.lean` + `Rill/Properties/GroupedTaggedParity.lean` (substitution-step decomposition, reflexive unification, mismatch witnesses, free-var lemmas). `RuntimeWrapperParity` includes normalized reduction contracts for wrapper constructors, explicit any-fuel wrapper-inner propagation lemmas (`task_inner_error_propagates_any_fuel`, `task_inner_success_propagates_any_fuel`, `actor_inner_error_propagates_any_fuel`, `actor_inner_success_propagates_any_fuel`, `arc_inner_error_propagates_any_fuel`, `arc_inner_success_propagates_any_fuel`), dynamic-var path contracts, successor-fuel dynamic boundary contracts, and function-return absorption witnesses from the earlier permissive slice; it now also includes an explicit Dynamic boundary-policy layer (`DynamicBoundarySite`, `dynamicBoundaryAllowsAtSite`) with site-invariance theorem (`dynamic_boundary_policy_site_invariant`), site-level narrowing/widening witnesses, a general widening law (`dynamic_boundary_allows_dynamic_from_any_all_sites`), a general non-Dynamic narrowing law (`dynamic_boundary_rejects_from_dynamic_all_sites`), closure/widening-alignment theorems (`dynamic_return_boundary_closes_unifier_absorption`, `dynamic_boundary_closes_unifier_absorption_all_sites`, `dynamic_boundary_closes_unifier_absorption_task_all_sites`, `dynamic_boundary_closes_unifier_absorption_bool_all_sites`, `dynamic_boundary_allows_unifier_widening_int_all_sites`, `dynamic_boundary_allows_unifier_widening_task_all_sites`), packaged surface theorem `dynamic_boundary_surface_slice`, and an explicit Task/Actor/Arc wrapper boundary-policy layer (`WrapperBoundarySite`, `wrapperBoundaryAllowsAtSite`) with packaged closure theorem `wrapper_boundary_surface_slice`. `BoundaryAssignability` now provides shared language-level boundary modeling (`HasTypeAtBoundary`, `allowsByBool`, `allowsByBoolAndUnify`) plus relation transport (`hasTypeAtBoundary_congr`) used by all typing-bridge modules; `allowsByBoolAndUnify` now records existential unifier success (`∃ st', unify ... = .ok st'`) rather than strict empty-substitution success. `DynamicBoundaryTypingBridge` now adds modeled ascription and site-generalized Dynamic typing bridges (`HasTypeAtAscriptionBoundaryAtSite`, `HasTypeAtAscriptionBoundary`, `hasTypeAtAscriptionBoundaryAtSite_iff_ascription`, `dynamic_boundary_typing_bridge_ascription`, `dynamic_boundary_typing_bridge_ascription_all_sites`) on top of variable/call-argument/let/return alignment, tying Dynamic boundary rejection to declarative core typing outcomes across boundary-sensitive sites. `WrapperBoundaryTypingBridge` now adds modeled ascription and site-generalized typing bridges for Task/Actor/Arc (`HasTypeAtWrapperBoundaryAtSite`, `HasTypeAtWrapperBoundary`, `hasTypeAtWrapperBoundaryAtSite_iff_ascription`, `wrapper_typing_bridge_ascription`, `wrapper_typing_bridge_all_sites`) plus wrapper uniqueness/mismatch controls, aligning wrapper boundary policy with declarative typing across boundary-sensitive sites. `GroupedTaggedParity` includes explicit inner-type mismatch witnesses, generalized successor-fuel key/metadata mismatch contracts (`groupedFrame_keys_mismatch_any_fuel`, `tagged_metadata_mismatch_any_fuel`) plus arbitrary-inner generalizations (`groupedFrame_keys_mismatch_any_inner_any_fuel`, `tagged_metadata_mismatch_any_inner_any_fuel`), normalized reduction/rejection contracts, explicit any-fuel inner-branch propagation lemmas (`groupedFrame_inner_error_propagates_any_fuel`, `groupedFrame_inner_success_propagates_any_fuel`, `tagged_inner_error_propagates_any_fuel`, `tagged_inner_success_propagates_any_fuel`), and now an explicit site-level grouped/tagged boundary-policy layer (`GroupedTaggedBoundarySite`, `groupedTaggedBoundaryAllowsAtSite`) with packaged closure theorem `grouped_tagged_boundary_surface_slice`. `GroupedTaggedTypingBridge` now adds modeled ascription and site-generalized typing bridges (`HasTypeAtGroupedTaggedBoundaryAtSite`, `HasTypeAtGroupedTaggedBoundary`, `hasTypeAtGroupedTaggedBoundaryAtSite_iff_ascription`, `grouped_tagged_typing_bridge_ascription`, `grouped_tagged_typing_bridge_all_sites`) plus grouped/tagged uniqueness/mismatch controls, aligning grouped/tagged boundary policy with declarative typing across boundary-sensitive sites. `BoundaryAscriptionSyntax` now adds an explicit expression/judgment bridge layer (`CoreExprWithAscription`, `HasTypeWithAscription`, `BoundaryAscriptionSyntaxSliceAtSites`) plus expression-level site-invariance lemmas (`hasTypeWithDynamicAscription_ascribe_iff_ascription`, `hasTypeWithWrapperAscription_ascribe_iff_ascription`, `hasTypeWithGroupedTaggedAscription_ascribe_iff_ascription`), algorithmic Dynamic/wrapper/grouped ascription checkers (`inferDynamicAscriptionAtSite`, `inferWrapperAscriptionAtSite`, `inferGroupedTaggedAscriptionAtSite`) now routed through Typing core `inferExprWithAscription`, site-level algorithmic witness slices (`DynamicAscriptionAlgorithmicSliceAtSite`, `WrapperAscriptionAlgorithmicSliceAtSite`, `GroupedTaggedAscriptionAlgorithmicSliceAtSite`), and packaged algorithmic↔declarative alignment slices (`dynamicAscriptionAlgorithmicDeclarativeVarAlignmentAtSite`, `wrapperAscriptionAlgorithmicDeclarativeTaskAlignmentAtSite`, `groupedAscriptionAlgorithmicDeclarativeAlignmentAtSite`, `AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites`), plus an expression-level `inferExpr` integration slice (`inferDynamicExprWithAscriptionAtSite`, `inferWrapperExprWithAscriptionAtSite`, `inferGroupedTaggedExprWithAscriptionAtSite`, `AscriptionInferExprBridgeSliceAtSites`, `AscriptionInferExprCompletenessSliceAtSites`, `AscriptionInferExprIffSliceAtSites`, `AscriptionCoreInferRoutingSliceAtSites`, `AscriptionBaseEmbeddingSliceAtSites`). Wrapper/grouped expression-level soundness is now fully quantified (`inferWrapperExprWithAscriptionAtSite_sound`, `inferGroupedTaggedExprWithAscriptionAtSite_sound`) with corresponding `iff` surfaces, local `.ascribe`-node equivalence surfaces are explicit (`inferWrapperAscriptionAtSite_iff`, `inferGroupedTaggedAscriptionAtSite_iff`), and both `AscriptionInferExprBridgeSliceAtSites` and `AscriptionInferExprIffSliceAtSites` now carry fully quantified cross-family contracts. `boundary_surface_suite` now includes the packaged ascription bridge suite (`BoundaryAscriptionBridgeSuiteAtSites`) and explicit inferExpr integration/completeness/equivalence slices (`AscriptionInferExprBridgeSliceAtSites`, `AscriptionInferExprCompletenessSliceAtSites`, `AscriptionInferExprIffSliceAtSites`, `AscriptionCoreInferRoutingSliceAtSites`, `AscriptionBaseEmbeddingSliceAtSites`). Rebuilt MCP confirms explicit Dynamic narrowing in implementation (`Dynamic -> concrete` rejected with `expect_type` guidance), confirms Task/Actor/Arc wrapper mismatch plus non-wrapper rejection (`Task(Int)`/`Actor(Int)`/`Arc(Int)` vs `Bool` inner mismatch and `Int` -> wrapper rejection), confirms grouped/tagged wrapper mismatch plus non-wrapper rejection on exposed paths (`GroupedFrame(Bool)` vs `GroupedFrame(Int)`, `Tagged(Bool)` vs `Tagged(Int)`, and `Int` -> grouped/tagged rejection), and confirms Dynamic return/app/let/ascription boundary behavior, while controls remain accepted; parser support for parameterized grouped key/metadata annotation syntax (`keys: [...]`) is still absent in this surface path, so metadata/key mismatch behavior there remains a Lean-level parity contract pending fuller surface syntax exposure. Bare `GroupedFrame`/`Tagged` collapse remains, but is currently treated as expected behavior for parameterless forms in this annotation path. Typing core now owns the generic ascription artifacts (`HasTypeAtCoreBoundary`, `CoreExprWithAscription`, `HasTypeWithAscription`, `inferExprWithAscription` plus soundness/completeness/iff). Remaining scope is deciding whether `ascribe` should be merged into the base `CoreExpr`/`inferExprUnify` surface.

## Operating Checklist (every milestone)

- [ ] `cd formal && lake build` passes.
- [ ] `FORMAL.md` table updated for every new theorem.
- [ ] If MCP is used for validation, append session details to `formal/mcp-log.md`.
- [ ] Keep changes formal-only unless explicitly requested otherwise.
