# Formalization Bridge Roadmap

Concrete milestone checklist for moving from the current fuel model to an implementation-aligned well-founded substitution model, then lifting that bridge into full language-level metatheory.

## M0. Baseline and Guardrails

- [x] Zero `sorry` in `formal/Rill`.
- [x] Keep a proved preconditioned extension theorem (`unifyRows_extends_rowMap_preconditioned`) as the current contract.
- [x] Keep Rust<->Lean mapping current in `FORMAL.md`.

## M1. Substitution Bridge (In Progress)

- [x] Define acyclicity witness from idempotence (`Subst.acyclicOfIdempotent`).
- [x] Define bounded WF substitution family:
  - `applySubstBounded`
  - `applySubstRowBounded`
  - `applySubstTyListBounded`
  - `applySubstRowFieldsBounded`
- [x] Define top-level WF APIs:
  - `applySubstWF`
  - `applySubstRowWF`
  - `applySubstTyListWF`
  - `applySubstRowFieldsWF`
- [x] Prove key WF lookup/no-op lemmas (`applySubstWF_var_lookup`, `applySubstWF_var_unbound`, row-open variants).
- [x] Prove bind consistency under idempotence for WF (`applySubstWF_bindType_consistent_of_idempotent`, row-tail analogues).
- [x] Add first compat equivalence lemmas on branch-critical shapes:
  - `applySubstCompat_var_eq_applySubstWF_of_idempotent`
  - `applySubstRowCompat_empty_open_eq_applySubstRowWF_of_idempotent`
- [x] Add compat lemmas for non-var/non-open-row constructors (`list`, `map`, `record`, `tuple`) under idempotence/no-domain-vars assumptions.
- [x] Add a single theorem schema for "fuel and WF agree on all values reachable from successful unify branches under idempotence".

## M2. Unify-Level Bridge

- [x] Refactor `Unify` proofs to consume compat lemmas first, fuel details second.
  Completed via `unifyRows_preconditioned_contract_compat_first`, with `unifyRows_extends_rowMap_preconditioned_wf_split` now routed through this compat-first layer.
- [x] Introduce branch-local substitution equivalence lemmas:
  - no-subst-update branches
  - single-bind branches
  - open-open fresh-row branch
- [x] Prove a bridge theorem: successful `unifyRows` branch updates are invariant under swapping `applySubstCompat` for WF substitution, given current preconditions.

## M3. Contract Strengthening

- [x] Re-prove preconditioned global extension theorem with WF substitution phrasing.
- [x] Isolate exactly which assumptions can be weakened from `Idempotent` to `Acyclic`.
- [x] Keep theorem names and statement intent aligned with Rust proptest mapping.

## M4. Typing-System Expansion (Post-Bridge)

- [x] Kickoff slice: add minimal declarative typing + algorithmic soundness for literals, vars, closed anonymous records, and projection (`Rill/Typing.lean`).
- [x] Extend kickoff to monomorphic `let` + typed lambda/application in `Rill/Typing.lean` (syntax-directed app on lambda heads).
- [x] Generalize monomorphic app soundness from lambda-head-only to function-valued expressions in `Rill/Typing.lean`.
- [x] Prove algorithmic/declarative equivalence on the current core slice (`inferExpr_sound`, `inferExpr_complete`, `inferExpr_iff_hasType`).
- [x] Add environment-congruence transport lemmas for core typing (`hasType_lookup_congr`, `inferExpr_lookup_congr`).
- [x] Add unification-threaded algorithmic typing (`inferExprUnify`, `inferFieldsUnify`) with explicit app/proj soundness-hook interfaces.
- [x] Add branch-local soundness wrappers for unification-backed app/proj steps (`inferExprUnify_app_step_sound`, `inferExprUnify_proj_step_sound`).
- [x] Prove recursive soundness on the non-app/proj fragment (`inferExprUnify_sound_no_unify_branches`, `inferFieldsUnify_sound_no_unify_branches`) as scaffolding for full vertical theorem.
- [x] Add structural size measures (`exprSize`, `fieldsSize`) to support well-founded mutual recursion for the full preconditioned theorem.
- [x] Lift unification-threaded inference to a full preconditioned soundness theorem (`inferExprUnify_sound_preconditioned`, `inferFieldsUnify_sound_preconditioned`) with explicit app/proj hooks.
- [x] Document principal-typing boundary for the vertical slice via uniqueness theorems (`inferExprUnify_deterministic`, `inferExprUnify_type_unique_preconditioned`).
- [x] Refine app-branch boundary with a derivable weaker hook (`AppUnifySoundHookWeak`, `appUnifySoundHookWeak_proved`).
- [x] Refine projection-branch boundary with a derivable weaker hook (`ProjUnifySoundHookWeak`, `projUnifySoundHookWeak_proved`) and bundled weak premise package (`UnifyHookPremisesWeak`, `unifyHookPremisesWeak_proved`), including strong→weak adapters (`appUnifySoundHookWeak_of_appUnifySoundHook`, `projUnifySoundHookWeak_of_projUnifySoundHook`, `unifyHookPremisesWeak_of_unifyHookPremises`).
- [x] Add one-step weak-boundary app/projection soundness lemmas (`inferExprUnify_app_step_sound_weak`, `inferExprUnify_proj_step_sound_weak`) plus strong-hook lifted variants (`inferExprUnify_app_step_sound_weak_of_strong`, `inferExprUnify_proj_step_sound_weak_of_strong`) and bundle entrypoints (`inferExprUnify_*_step_sound_weak_from_bundle`, `inferExprUnify_*_step_sound_weak_from_strong_bundle`) to make weak-hook consumption explicit at the branch-step API.
- [x] Add a canonical weak local-step bundle surface (`UnifyStepSoundWeak`) with constructors from weak and strong hook packages (`unifyStepSoundWeak_of_hookPremisesWeak`, `unifyStepSoundWeak_of_unifyHookPremises`) and step-bundle entrypoints (`inferExprUnify_*_step_sound_weak_from_stepBundle`).
- [x] Add direct proved/strong-package weak-step entrypoints (`inferExprUnify_*_step_sound_weak_proved`, `inferExprUnify_*_step_sound_weak_from_unifyHookPremises`) so call sites can consume weak branch-step APIs without manual bundle threading.
- [x] Add all-hooks no-unify naming-parity wrappers for fixed-run `preconditioned ↔ core` transport (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_allHooksSuite`, `principalPreconditionedCoreIff*_of_success_noUnify_via_allHooksSuite`) routed through canonical all-hooks no-unify wrappers.
- [x] Add master/all-hooks no-unify naming-parity wrappers for core/preconditioned/hook-irrelevance surfaces (`principalCore*`, `principalPreconditioned*_*`, `principalPreconditioned*hookIrrelevant*_of_success_noUnify_via_*Suite`) routed through canonical `principalNoUnify*` paths.
- [x] Add arbitrary-success all-hooks capstone entry wrappers across general/master suite layers (`principalPreconditionedExpr/FieldAllHooksCapstone_of_success_via_generalAllHooksSuite`, bundled `..._from_bundle` forms, and matching `..._via_masterSuite` forms) so successful-run principal boundary consequences are available as one packaged theorem output.
- [x] Add bundled-baseline arbitrary-success convenience wrappers across general/master suite layers (`principalCore*`, `principalPreconditioned*AnyHooks*`, `principalPreconditionedCoreIff*AnyHooks*_of_success_via_*Suite_from_bundle`) so one `UnifyHookPremises` seed drives the non-no-unify principal API without split baseline-hook arguments.
- [x] Complete bundled-baseline arbitrary-success parity for bundled target-hook outputs (`principalPreconditioned*_*_of_success_via_*Suite_from_bundle`, including `preconditioned ↔ core` forms) so single-seed entry now covers both any-hooks and bundled-target theorem consumption.
- [x] Add run-level arbitrary-success all-hooks bundle contracts (`PrincipalPreconditionedExpr/FieldAllHooksRunBundle`) with capstone/success constructors and general/master suite entry wrappers so one theorem output now carries both capstone consequences and fixed-run hook-irrelevance.
- [x] Add direct run-bundle projection helpers for expression/field core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance surfaces (`principalPreconditioned*AllHooksRunBundle_*`) so run-bundle consumers can project principal consequences without manual capstone-field destructuring.
- [x] Add combined arbitrary-success run-bundle slice packaging (`PrincipalPreconditionedAllHooksRunBundleExpr/FieldSlice`, `PrincipalPreconditionedAllHooksRunBundleSlices`, proved + projections) to keep run-bundle consumption aligned with existing expression/field slice APIs.
- [x] Integrate arbitrary-success run-bundle slices into `PrincipalPreconditionedAllHooksSuite` (`runBundles`) with suite-level run-bundle projections so one general-all-hooks suite witness now exports capstones, irrelevance, and run-bundle packaging together.
- [x] Add parameterized arbitrary-success run-bundle convenience wrappers (`principalGeneralAllHooksRunBundleExpr/Field_of_success`) and route both general/master run-bundle entry wrappers through that general-all-hooks layer.
- [x] Add master-suite one-hop projections for arbitrary-success all-hooks run bundles (`principalBoundaryMasterSuite_allHooks_runBundle_expr/field`) to keep top-level master consumption symmetric with capstone and irrelevance surfaces.
- [x] Extend no-unify-to-general all-hooks packaging with run-bundle slices/projections (`PrincipalNoUnifyToGeneralAllHooks*RunBundle*`, suite `runBundles`, suite/master one-hop run-bundle projections) and keep no-unify-all-hooks compatibility constructors aligned with the expanded suite shape.
- [x] Extend no-unify all-hooks packaging with run-bundle slices/projections (`PrincipalBoundaryNoUnifyAllHooks*RunBundle*`, suite `runBundles`, suite/master one-hop run-bundle projections) and keep no-unify-to-general compatibility constructors aligned with the expanded suite shape.
- [x] Add explicit run-bundle compatibility theorems between no-unify and no-unify-to-general suite layers (both directions + canonical proved variants) so cross-suite equivalence is also exposed at the run-bundle slice boundary.
- [x] Add direct no-unify run-bundle convenience wrappers across general/master/all-hooks entrypoints (`principalPreconditioned*AllHooksRunBundle_of_success_noUnify_via_*`) so no-unify successful runs reach the run-bundle API without manual suite/capstone reconstruction.
- [x] Add a top-level master run-bundle aggregate surface (`PrincipalBoundaryMasterRunBundleSuite`, constructor + proved theorem) and no-unify-as-general run-bundle projections so all-hooks/no-unify/no-unify-to-general run-bundle entrypoints are consumable from one master-derived API.
- [x] Add one-hop projection/coherence helpers for `PrincipalBoundaryMasterRunBundleSuite` (`..._allHooks_*`, `..._noUnifyAllHooks_*`, `..._noUnifyToGeneral_*`, `..._noUnify_*_as_general`) so master run-bundle consumers can stay on projection APIs instead of record-field destructuring.
- [x] Add direct convenience wrappers over `principalBoundaryMasterRunBundleSuite_proved` (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterRunBundleSuite*`, plus no-unify variants) so run-bundle call sites can avoid explicit suite threading.
- [x] Add naming-parity no-unify run-bundle wrappers on the master-run-bundle-suite path (`principalNoUnifyRunBundle*_*_via_masterRunBundleSuite`) and route long-form no-unify wrappers through them.
- [x] Add master-run-bundle no-unify consequence wrappers for core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance (`principalNoUnifyCore*`, `principalNoUnifyPreconditioned*_*`, `principalNoUnifyPreconditionedCoreIff*_*`, `principalNoUnifyPreconditioned*hookIrrelevant*_*_via_masterRunBundleSuite`) via run-bundle projection helpers.
- [x] Add master-run-bundle long-form no-unify-to-general naming-parity wrappers (`principalCore*`, `principalPreconditioned*_*`, `principalPreconditionedCoreIff*_*`, `principalPreconditioned*hookIrrelevant*_*_of_success_noUnify_via_masterRunBundleSuite`) to mirror master/all-hooks no-unify naming surfaces.
- [x] Add packaged per-run no-unify consequence bundles on the master-run-bundle-suite path (`PrincipalNoUnifyExpr/FieldRunBundleConsequences`, plus `..._of_success_via_masterRunBundleSuite`) bundling core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance.
- [x] Lift master-run-bundle no-unify consequence bundles to slice-level packaging (`PrincipalNoUnifyExpr/FieldRunBundleConsequenceSlice`, combined `PrincipalNoUnifyRunBundleConsequenceSlices`, proved + one-hop projections) for reusable expression/field consequence consumption.
- [x] Add a top-level master run-bundle consequence suite (`PrincipalBoundaryMasterRunBundleConsequenceSuite`, constructors from master/master-run-bundle suites, proved theorem, and no-unify expr/field one-hop consequence projections) so run-bundle and no-unify consequence surfaces share one aggregate API.
- [x] Add master-suite one-hop projections into the consequence-suite layer (`principalBoundaryMasterSuite_runBundleConsequenceSuite`, `principalBoundaryMasterSuite_noUnifyRunBundleConsequences_{expr,field}`) for direct top-level access to no-unify consequence bundles.
- [x] Add run-bundle projection helpers from the master run-bundle consequence suite (`principalBoundaryMasterRunBundleConsequenceSuite_{allHooks,noUnifyAllHooks,noUnifyToGeneral}_{expr,field}`) for direct inherited run-bundle access from the consequence-suite aggregate.
- [x] Route master-suite no-unify consequence wrappers (core, preconditioned, preconditioned↔core, hook-irrelevance for expr+field) through `principalBoundaryMasterSuite_noUnifyRunBundleConsequences_{expr,field}` and consequence-suite run-bundle projections so top-level no-unify theorem consumption stays on the canonical consequence path.
- [x] Add top-level master run-bundle projection wrappers via the consequence-suite aggregate (`principalBoundaryMasterSuite_{allHooks,noUnifyAllHooks,noUnifyToGeneral}AllHooks_runBundle_{expr,field}_via_consequenceSuite`) and route master no-unify run-bundle convenience wrappers through that projection layer.
- [x] Add bundled-hook no-unify `_from_bundle` wrappers on master-run-bundle-consequence/master no-unify-to-general paths (`..._of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle`, `..._of_success_noUnify_via_masterSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), completing no-unify bundled-hook naming parity with arbitrary-success wrappers.
- [x] Add `principalNoUnify*..._from_bundle` alias wrappers on the same master paths (`..._via_masterRunBundleConsequenceSuite_from_bundle`, `..._via_masterSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), completing bundled-hook parity for both long-form and no-unify naming families.
- [x] Add matching all-hooks no-unify bundled-hook `_from_bundle` wrappers for both long-form and `principalNoUnify*` naming families (`..._of_success_noUnify_via_allHooksSuite_from_bundle`, `..._via_allHooksSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), closing bundled-hook parity across all-hooks/master/master-consequence entry layers.
- [x] Add consequence-bundle-to-capstone projections (`principalNoUnifyExpr/FieldRunBundleConsequences_capstone`) and top-level master `..._via_consequenceSuite` capstone/irrelevance wrappers (`principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_{expr,field,irrelevance_*}_via_consequenceSuite`) so the consequence-path API covers capstone + irrelevance, not only run-bundles.
- [x] Add consequence-path no-unify-as-general aliases on top-level master projections (`principalBoundaryMasterSuite_noUnifyAllHooks_{expr,field,runBundle_*}_as_general_via_consequenceSuite`) to preserve no-unify-as-general coherence on the new consequence routing layer.
- [x] Add no-unify capstone convenience wrappers on both master paths (`principalPreconditioned*AllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite`, `principalPreconditioned*AllHooksCapstone_of_success_noUnify_via_masterSuite`) so capstone-level no-unify entrypoints match run-bundle/consequence coverage.
- [x] Add no-unify capstone alias wrappers (`principalNoUnify*AllHooksCapstone_of_success_via_*Suite`) across all-hooks/master/master-consequence entry layers to complete capstone naming parity with existing run-bundle/consequence alias families.
- [x] Add bundled-hook no-unify capstone wrappers/aliases (`...AllHooksCapstone_of_success_noUnify_via_*Suite_from_bundle`, `principalNoUnify*AllHooksCapstone_of_success_via_*Suite_from_bundle`) across all-hooks/master/master-consequence entry layers, completing `_from_bundle` parity for capstone no-unify surfaces.
- [x] Add arbitrary-success capstone wrappers on the consequence path (`principalBoundaryMasterSuite_allHooks_{expr,field}_via_consequenceSuite`, `principalPreconditioned*AllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite*`) so consequence-path coverage includes capstone surfaces for arbitrary-success slices as well as no-unify slices.
- [x] Add arbitrary-success hook-irrelevance wrappers on the consequence route (`principalBoundaryMasterSuite_allHooks_irrelevance_{expr,field}_via_consequenceSuite`, `principalPreconditioned*hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite*`, `principalPreconditioned*hookIrrelevant_of_success_via_masterSuite*`) so non-no-unify fixed-run irrelevance also routes through the consequence-path layer.
- [x] Add bundled-hook no-unify hook-irrelevance wrappers/aliases (`...hookIrrelevant_of_success_noUnify_via_*Suite_from_bundle`, `principalNoUnifyPreconditioned*hookIrrelevant_of_success_via_*Suite_from_bundle`) across all-hooks/master/master-consequence entry layers, completing `_from_bundle` parity for no-unify irrelevance theorem surfaces.
- [x] Add bundled-hook arbitrary-success irrelevance wrappers on the general-all-hooks path (`principalPreconditioned*hookIrrelevant_of_success_via_generalAllHooksSuite_from_bundle`), completing `_from_bundle` parity for non-no-unify irrelevance entrypoints.
- [x] Add a master consequence capstone aggregate (`PrincipalBoundaryMasterConsequenceCapstoneSuite`, constructor/proved/master one-hop, and expression/field capstone+irrelevance projections) so consequence-path capstone/irrelevance surfaces are consumable from one packaged theorem API.
- [x] Add direct convenience wrappers over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (arbitrary-success + no-unify capstone families, `principalNoUnify*` aliases, and `_from_bundle` variants) so the new aggregate suite can be consumed in one step.
- [x] Add full hook-irrelevance convenience/alias parity over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalPreconditioned*hookIrrelevant*_of_success_via_masterConsequenceCapstoneSuite*`, `..._of_success_noUnify_via_masterConsequenceCapstoneSuite*`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_masterConsequenceCapstoneSuite*`, plus `_from_bundle` variants) so consequence-capstone aggregate entrypoints now cover irrelevance surfaces with the same one-step API as capstone wrappers.
- [x] Add direct core/preconditioned/preconditioned↔core convenience wrappers over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalCore*`, `principalPreconditioned*{,_anyHooks}*`, `principalPreconditionedCoreIff*{,_anyHooks}*` on `..._via_masterConsequenceCapstoneSuite*`, including bundled-baseline variants) so consequence-capstone aggregate entrypoints now expose the full principal-boundary theorem surface in one step, not only capstone/irrelevance APIs.
- [x] Add full no-unify principal-surface parity over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalNoUnifyCore*`, `principalNoUnifyPreconditioned*{,_anyHooks}*`, `principalNoUnifyPreconditionedCoreIff*{,_anyHooks}*` plus long-form `..._of_success_noUnify_via_masterConsequenceCapstoneSuite*` aliases and bundled variants) so no-unify consequence-capstone entrypoints match arbitrary-success coverage for core/preconditioned/`↔` theorem APIs.
- [x] Add missing bundled-baseline `_from_bundle` aliases for core/any-hooks consequence-capstone surfaces (`principal{NoUnify,}Core*`, `principal{NoUnify,}Preconditioned*AnyHooks*`, `principal{NoUnify,}PreconditionedCoreIff*AnyHooks*`, plus long-form no-unify-to-general counterparts on `..._via_masterConsequenceCapstoneSuite*`) to complete bundled-seed naming parity across the full consequence-capstone principal API.
- [x] Add direct run-bundle convenience wrappers on `..._via_masterConsequenceCapstoneSuite*` (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterConsequenceCapstoneSuite*`, no-unify variants, and `principalNoUnifyRunBundle*` aliases) so the consequence-capstone route also exports packaged `capstone + hook-irrelevance` bundles in one step.
- [x] Add direct packaged no-unify consequence constructors on `..._via_masterConsequenceCapstoneSuite*` (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite`) so consequence-capstone entrypoints can emit the full no-unify bundle surface (core/preconditioned/`↔`/irrelevance) in one theorem output.
- [x] Add bundled-hook `_from_bundle` aliases for those consequence-capstone no-unify consequence constructors (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite_from_bundle`), completing naming parity for packaged no-unify consequence entrypoints on this route.
- [x] Add a packaged no-unify consequence slice layer for the consequence-capstone route (`PrincipalNoUnifyExpr/FieldRunBundleConsequenceSliceViaMasterConsequenceCapstoneSuite`, combined `PrincipalNoUnifyRunBundleConsequenceSlicesViaMasterConsequenceCapstoneSuite`, proved theorem, expression/field one-hop projections) so this route has a reusable all-runs bundle API shape parallel to the master-run-bundle consequence path.
- [x] Add explicit cross-route no-unify consequence coherence constructors (`PrincipalNoUnifyExpr/FieldRunBundleConsequencesBothMasterConsequenceRoutes` plus `principalNoUnify*RunBundleConsequences_on_both_master_consequence_routes`) so one theorem output can carry witnesses from both `masterConsequenceCapstone` and `masterRunBundleConsequence` entry layers.
- [x] Lift that cross-route coherence into reusable all-runs slice packaging (`PrincipalNoUnify*RunBundleConsequencesBothMasterConsequenceRoutesSlice`, combined `...RoutesSlices`, proved theorem, expression/field one-hop projections) so route-coherence consumption follows the same slice API pattern used elsewhere in M4.
- [x] Add route-specific one-hop/canonical projections from those cross-route slices (`...RoutesSlices_{expr,field}_via_{masterConsequenceCapstone,masterRunBundleConsequence}` and `principalNoUnify*RunBundleConsequences_via_*_from_cross_route_slices`) so each route’s consequence bundle is directly consumable from one shared coherence proof surface.
- [x] Add canonical no-unify all-hooks capstone projections from that cross-route coherence surface (`principalNoUnify*AllHooksCapstone_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) so both routes can reach capstone consequences through one shared coherence entrypoint.
- [x] Add explicit cross-route all-hooks capstone coherence packaging (`PrincipalNoUnifyExpr/FieldAllHooksCapstonesBothMasterConsequenceRoutes`, combined capstone slices, and per-route one-hop projections) so capstone-level route coherence is consumable from one shared theorem API, parallel to consequence-bundle coherence.
- [x] Add explicit cross-route all-hooks run-bundle coherence packaging (`PrincipalNoUnifyExpr/FieldAllHooksRunBundlesBothMasterConsequenceRoutes`, combined run-bundle slices, and per-route one-hop projections), and route `principalNoUnifyRunBundle*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` through that canonical layer.
- [x] Add explicit cross-route fixed-run hook-irrelevance coherence packaging (`PrincipalNoUnifyExpr/FieldHookIrrelevanceBothMasterConsequenceRoutes`, combined irrelevance slices, and per-route one-hop projections), and route `principalNoUnifyPreconditioned*hookIrrelevant...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` through that canonical layer.
- [x] Add a higher-level cross-route all-hooks route-surface bundle (`PrincipalNoUnifyExpr/FieldAllHooksRouteSurfaceBothMasterConsequenceRoutes`, combined slices, and per-route canonical projections) so each master consequence route exports capstone + run-bundle + fixed-run irrelevance as one packaged per-run theorem surface.
- [x] Route top-level cross-route all-hooks capstone aliases (`principalNoUnify*AllHooksCapstone_of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through the new all-hooks route-surface canonical projections so capstone call sites consume the unified route-surface layer.
- [x] Route top-level cross-route all-hooks run-bundle and fixed-run irrelevance aliases (`principalNoUnifyRunBundle*...` and `principalNoUnifyPreconditioned*hookIrrelevant...` on both master consequence routes) through the same all-hooks route-surface canonical projections, completing unified all-hooks-facet consumption (capstone/run-bundle/irrelevance) from one cross-route entry layer.
- [x] Extend that all-hooks route-surface bundle with packaged consequence outputs (`PrincipalNoUnifyExpr/FieldRunBundleConsequences`) and route cross-route consequence aliases through it (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) so all major no-unify facets consume one shared route-surface layer.
- [x] Add one-hop and canonical route-surface projections for core, any-hooks preconditioned, and any-hooks `preconditioned ↔ core` (`principalNoUnify*AllHooksRouteSurface_{core,preconditioned_anyHooks,preconditionedCoreIff_anyHooks}` plus `..._via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`) so the unified surface layer is directly consumable for core/any-hooks theorem facets.
- [x] Route the canonical cross-route core/any-hooks/any-hooks-`↔`/fixed-run-irrelevance projections (`principalNoUnify{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*hookIrrelevant}_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through those route-surface canonical APIs, consolidating canonical theorem families on one coherence layer.
- [x] Add bundled-target one-hop/canonical route-surface projections (`principalNoUnify*AllHooksRouteSurface_{preconditioned,preconditionedCoreIff}` plus per-route `..._via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`) and route canonical bundled-target cross-route projections (`principalNoUnifyPreconditioned*` / `principalNoUnifyPreconditionedCoreIff* ... from_cross_route_slices`) through those APIs.
- [x] Add facet-level canonical `_from_cross_route_surface_slices` wrappers for capstone/run-bundle/consequence/fixed-run-irrelevance on both routes and route top no-unify alias entrypoints (`principalNoUnify*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through those named surface wrappers for explicit surface-layer consumption.
- [x] Route long-form no-unify-to-general cross-route aliases (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*hookIrrelevant}_of_success_noUnify_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through `_from_cross_route_surface_slices` canonical wrappers, extending explicit surface-layer consumption to long-form entrypoints.
- [x] Add bundled-seed `_from_bundle` convenience aliases for canonical cross-route surface projections on both routes (core, any-hooks preconditioned, any-hooks `preconditioned ↔ core`, run-bundle, consequence bundle, and capstone) so one `UnifyHookPremises` seed directly feeds `...from_cross_route_surface_slices` entrypoints.
- [x] Close the remaining canonical surface bundled-seed parity gaps (all-hooks route-surface, bundled-target preconditioned, bundled-target `preconditioned ↔ core`, and fixed-run hook-irrelevance on both routes), bringing `...from_cross_route_surface_slices` bundle parity to full closure (`missing_from_bundle = 0` across all 40 theorem names).
- [x] Add full no-unify success-name parity wrappers on that same surface layer (`principalNoUnify*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`, including `_from_bundle` variants), bringing `of_success_via_*` surface naming parity to 72/72.
- [x] Add long-form no-unify-to-general surface-name parity wrappers on that same layer (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*hookIrrelevant}_of_success_noUnify_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`, including `_from_bundle` variants), bringing long-form `of_success_noUnify_via_*` surface naming parity to 32/32.
- [x] Add direct all-hooks route-surface success wrappers on that same layer (`principalNoUnify{Expr,Field}AllHooksRouteSurface_of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`, with `_from_bundle` variants) so route-surface bundle consumption has explicit success-name entrypoints on both routes.
- [x] Add canonical cross-route projections for core, any-hooks preconditioned, any-hooks `preconditioned ↔ core`, and fixed-run hook-irrelevance on both routes (`principalNoUnify{Core,Preconditioned*,PreconditionedCoreIff*,Preconditioned*hookIrrelevant}_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) so downstream theorem consumption can remain on one shared cross-route slice surface across all principal consequence facets.
- [x] Add bundled-target hook projections on top of those cross-route any-hooks surfaces (`principalNoUnifyPreconditioned*` and `principalNoUnifyPreconditionedCoreIff*` via both routes from cross-route slices) to avoid manual hook-pair projection when consuming the shared coherence API.
- [x] Add `_from_bundle` alias wrappers for those bundled-target cross-route projections (`principalNoUnifyPreconditioned*...from_cross_route_slices_from_bundle`, `principalNoUnifyPreconditionedCoreIff*...from_cross_route_slices_from_bundle` on both routes) to complete naming parity with existing no-unify wrapper families.
- [x] Add long-form no-unify-to-general aliases on the same cross-route route surfaces (`principalCore*`, `principalPreconditioned*AnyHooks*`, `principalPreconditionedCoreIff*AnyHooks*`, `principalPreconditioned*hookIrrelevant*_of_success_noUnify_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) so downstream call sites can use familiar naming families while routing through the shared coherence path.
- [x] Add matching `_from_bundle` aliases for those long-form cross-route no-unify-to-general wrappers (core/any-hooks/`preconditioned ↔ core`/hook-irrelevance on both routes) to complete bundled-hook naming parity for the new cross-route theorem family.
- [x] Add full `principalNoUnify*...of_success_via_masterRunBundleConsequence_from_cross_route_slices` naming-parity aliases (core, preconditioned, preconditioned↔core, hook-irrelevance, run-bundle consequences, and capstone, including `_from_bundle` variants) so the master-run-bundle-consequence cross-route surface has complete no-unify naming parity with the established long-form wrappers.
- [x] Mirror that same `principalNoUnify*...of_success_via_masterConsequenceCapstone_from_cross_route_slices` alias family (core, preconditioned, preconditioned↔core, hook-irrelevance, run-bundle consequences, and capstone, including `_from_bundle` variants) so both master consequence routes now expose a 62/62 no-unify theorem-surface parity match.
- [x] Add the remaining bundled-seed `_from_bundle` aliases for no-unify cross-route wrappers on both master consequence routes (core, any-hooks preconditioned, any-hooks `preconditioned ↔ core`, run-bundle, and packaged consequence surfaces) so every `principalNoUnify*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` theorem has a bundled-seed counterpart.
- [x] Add the missing bundled-seed `_from_bundle` aliases on `masterRunBundleConsequenceSuite` for no-unify core/any-hooks/run-bundle/consequence wrappers (`principalNoUnify{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,RunBundle*,Expr/FieldRunBundleConsequences}...`) so this suite has complete bundled-seed parity across all no-unify theorem surfaces.
- [x] Add full bundled-seed `_from_bundle` parity on `masterRunBundleSuite` for all no-unify wrappers (run-bundle, core, any-hooks preconditioned, bundled preconditioned, any-hooks/bundled `preconditioned ↔ core`, hook-irrelevance, and packaged consequences) so every `principalNoUnify*...of_success_via_masterRunBundleSuite` theorem has a bundled-seed companion.
- [x] Add the remaining bundled-seed `_from_bundle` aliases on `allHooksSuite` and `masterSuite` for no-unify core/any-hooks/run-bundle wrappers, closing the last suite-level parity gaps; parity checks now report `missing_from_bundle = 0` across all seven no-unify route families (`allHooks`, `master`, `masterRunBundle`, `masterRunBundleConsequence`, `masterConsequenceCapstone`, and both cross-route surfaces).
- [x] Add the final bundled-seed aliases on the proved-boundary `...via_suite` wrappers (`principalNoUnify{Core,Preconditioned}{Expr,Field}_of_success_via_suite_from_bundle`), closing the remaining global gap so every `principalNoUnify*...of_success_via_*` theorem now has a `_from_bundle` companion (`missing_count = 0` on full theorem-name parity scan).
- [x] Add bundled-seed `_from_bundle` parity for the long-form no-unify-to-general `masterRunBundleConsequenceSuite` wrappers (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*AllHooksRunBundle}_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle`), closing that route’s long-form parity gap (`missing = 0` for `..._of_success_noUnify_via_masterRunBundleConsequenceSuite`).
- [x] Add the same long-form bundled-seed parity layer on `allHooksSuite` and `masterSuite` (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*AllHooksRunBundle}_of_success_noUnify_via_{allHooksSuite,masterSuite}_from_bundle`), reducing long-form no-unify parity gaps to the two remaining routes: `generalAllHooks` and `masterRunBundleSuite`.
- [x] Close the remaining long-form no-unify bundled-seed gaps on `masterRunBundleSuite` and `generalAllHooks` with the matching `_from_bundle` alias families (including fixed-run preconditioned, fixed-run `preconditioned ↔ core`, and hook-irrelevance variants where applicable), bringing long-form parity to full closure (`global_longform_missing = 0` for all `..._of_success_noUnify_via_*` theorem names).
- [x] Add the last four bundled-seed aliases surfaced by the broad `..._of_success_via_*` scan (`principalBoundaryNoUnify{ExprCapstone,FieldCapstone}_of_success_via_suite_from_bundle`, `principalBoundaryNoUnifyRunBundle{Expr,Field}_of_success_via_allHooksSuite_from_bundle`), bringing global bundle-name parity to full closure (`missing_bundle = 0` across all `..._of_success_via_*` theorem names).
- [x] Add direct convenience wrappers over `principalBoundaryMasterRunBundleConsequenceSuite_proved` (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite` plus core/any-hooks projections) for one-step no-unify consequence-bundle consumption.
- [x] Extend the master-run-bundle-consequence-suite convenience layer to full no-unify parity (`principalPreconditioned*_*`, `principalPreconditionedCoreIff*_*`, `principalPreconditioned*hookIrrelevant*_*_of_success_noUnify_via_masterRunBundleConsequenceSuite`) so bundled/any-hooks and `↔`/irrelevance surfaces are all one-step from the aggregate consequence suite.
- [x] Add matching run-bundle convenience wrappers over `principalBoundaryMasterRunBundleConsequenceSuite_proved` (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterRunBundleConsequenceSuite*` plus no-unify variants) so arbitrary-success and no-unify run-bundle access can route through the consequence-suite aggregate entrypoint.
- [x] Add full `principalNoUnify*` naming-parity aliases on the master-run-bundle-consequence-suite path (core, preconditioned, preconditioned↔core, hook-irrelevance for expr+field) routed through long-form no-unify-to-general wrappers.
- [x] Add canonical no-unify run-bundle convenience wrappers on the no-unify suite layers (`principalBoundaryNoUnifyRunBundle*_*_via_allHooksSuite`, `principalNoUnifyToGeneralRunBundle*_*_of_success`) to stabilize per-suite run-bundle entry naming before higher-layer routing.
- [x] Add naming-parity no-unify run-bundle wrappers on all-hooks/master entrypoints (`principalNoUnifyRunBundle*_*_via_allHooksSuite`, `principalNoUnifyRunBundle*_*_via_masterSuite`) and route no-unify run-bundle convenience wrappers through canonical per-suite run-bundle APIs (`principalNoUnifyToGeneralRunBundle*_*_of_success`).
- [x] Route master-suite no-unify consequence wrappers (core, preconditioned, preconditioned↔core, hook-irrelevance) through no-unify run-bundle projection helpers so the master no-unify API stays on the run-bundle canonical path.
- [x] Introduce two-judgment architecture scaffold (`HasType` + `HasTypeU`) with explicit substitution admissibility and lift lemmas.
- [x] Show counterexample recovery in `HasTypeU` (`app_counterexample_hasTypeU`), validating the architecture shift.
- [x] Add a packaged unification-aware recursive soundness bundle (`InferUnifyHasTypeUSoundBundle` in `Kea/Typing.lean`) with constructors from weak hooks/bundled weak hooks/resolved-shape premises and one-hop expr/field projections, so `HasTypeU` recursive soundness is consumable from one theorem surface.
- [x] Extend that recursive `HasTypeU` bundle with strong-hook constructors (`inferUnifyHasTypeUSoundBundle_of_{strong_hooks,strong_hook_bundle}`), so strong, weak, bundled, and resolved premise paths all feed one packaged soundness API.
- [x] Add direct weak-/strong-bundle recursive `HasTypeU` entry wrappers (`infer{Expr,Fields}Unify_sound_preconditioned_hasTypeU_from_{hook_bundle,strong_hook_bundle}`), so expr/field one-step entrypoint coverage now matches all premise-package forms (weak, strong, resolved) before bundle packaging.
- [x] Add canonical `via_sound_bundle` wrappers (`infer{Expr,Fields}Unify_sound_preconditioned_hasTypeU_{via_sound_bundle,from_*_via_sound_bundle}`) so generic/weak/strong/resolved bundle entrypoints all consume a single packaged API path.
- [x] Add one-hop constructor projections (`inferUnifyHasTypeUSoundBundle_{expr,field}_of_{hook_bundle,strong_hook_bundle,resolved}`) so weak/strong/resolved constructors each expose direct expr/field theorem entrypoints.
- [x] Add a dual recursive-soundness package (`InferUnifySoundDualBundle`) with hook-pair/hook-bundle constructors and direct `HasType`+`HasTypeU` expr/field projections (`inferUnifySoundDualBundle_{expr,field}_{hasType,hasTypeU}`), so one unification-success witness can drive both judgment surfaces through a single theorem API.
- [x] Add canonical `via_dual_bundle` entry wrappers for both judgments (`infer{Expr,Fields}Unify_sound_preconditioned_via_dual_bundle`, `infer{Expr,Fields}Unify_sound_preconditioned_hasTypeU_via_dual_bundle`) plus bundled-hook adapters (`..._from_hook_bundle_via_dual_bundle`) so dual-bundle consumers have one-step theorem entrypoints parallel to existing `via_sound_bundle` APIs.
- [x] Add one-hop bundled-hook constructor projections for each dual-bundle facet (`inferUnifySoundDualBundle_{expr,field}_{hasType,hasTypeU}_of_hook_bundle`), so `UnifyHookPremises` can feed all four dual consequences directly without manual bundle assembly/destructuring.
- [x] Add dual-to-`HasTypeU` bundle bridge theorems (`inferUnifyHasTypeUSoundBundle_of_dual_bundle`, `inferUnifyHasTypeUSoundBundle_of_dual_hook_bundle`) so the dual package composes directly with existing `InferUnifyHasTypeUSoundBundle` theorem consumers.
- [x] Add dual-bundle principal-slice wrappers and one-step agreement extractors (`principal{,Field}TypingSlicePreconditioned_of_success{_from_hook_bundle}_via_dual_bundle`, `infer{Expr,Fields}Unify_infer{Expr,Fields}_agrees_of_success{_from_hook_bundle}_via_dual_bundle`) so successful-run principal consequences and `infer` agreement facts are directly consumable from the dual theorem surface.
- [x] Add dual-bundle wrappers for the principal core-bridge surfaces (`principal{,Field}TypingSliceCore_of_preconditioned_success{_from_hook_bundle}_via_dual_bundle`, `principal{,Field}TypingSlicePreconditioned_iff_core_of_success{_from_hook_bundle}_via_dual_bundle`) so dual-bundle consumers can stay on the same API while extracting preconditioned→core and preconditioned↔core consequences.
- [x] Add packaged per-run dual principal consequence bundles (`Principal{,Field}TypingDualConsequence`) with constructors from successful runs (`..._of_success_via_dual_bundle`, bundled-hook variants), so preconditioned/core/`↔`/algorithmic-agreement consequences are consumable from one theorem output.
- [x] Add one-hop projections for those per-run dual consequence bundles (`principal{,Field}TypingDualConsequence_{preconditioned,core,iff_core,inferExpr_agrees/inferFields_agrees}`), so all consequence facets are directly consumable without record destructuring.
- [x] Add combined successful-run dual consequence slices (`PrincipalDual{Expr,Field}ConsequenceSlice`, `PrincipalDualConsequenceSlices`, `principalDualConsequenceSlices_proved`) plus one-hop expression/field projections, so dual principal bundles are consumable through the same slice-level API style as the existing capstone layers.
- [x] Add canonical proved-slice dual entrypoints (`principal{,Field}TypingDualConsequence_of_success_via_proved_slice`) and one-step agreement extractors (`infer{Expr,Fields}Unify_infer{Expr,Fields}_agrees_of_success_via_dual_proved_slice`) so callers can consume the combined dual slice without explicitly threading slice witnesses.
- [x] Add compatibility/equivalence bridges between dual consequence slices and the existing preconditioned↔core slice surface (`principalPreconditionedCoreIffSlices_of_dualConsequenceSlices`, `principalDualConsequenceSlices_of_principalPreconditionedCoreIffSlices`, `principalDualConsequenceSlices_iff_principalPreconditionedCoreIffSlices`) plus canonical proved-surface adapters in both directions.
- [x] Add compatibility/equivalence adapters between dual consequence bundles and existing no-unify bridge bundles (`principal{,Field}NoUnifyBridgeBundle_of_dualConsequence`, `principal{,Field}TypingDualConsequence_of_noUnifyBridgeBundle`, `principal{,Field}TypingDualConsequence_iff_noUnifyBridgeBundle_of_success`) so both surfaces can be consumed interchangeably on successful runs.
- [x] Add suite-level adapters from dual consequence slices into the established boundary stack (`principalNoUnifyBridgeSlices_of_dualConsequenceSlices`, `principalBoundaryBridgeSuite_of_dualConsequenceSlices`, `principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices`) so the dual API now feeds the existing principal bridge suite entry surface directly.
- [x] Add reverse boundary-suite adapters and equivalence (`principalDualConsequenceSlices_of_principalBoundaryBridgeSuite`, `principalBoundaryBridgeSuite_iff_dualConsequenceSlices`) plus canonical dual-slice recovery from the existing proved suite (`principalDualConsequenceSlices_proved_via_principalBoundaryBridgeSuite`) to close bidirectional interoperability between boundary-suite and dual-slice APIs.
- [x] Lift the dual-routed bridge path into the top-level master suite (`principalBoundaryMasterSuite_proved_via_dualConsequenceSlices`) and add direct preconditioned↔core wrappers on that route (`principalBoundaryMasterSuite_preconditionedCoreIff_{expr,field}_via_dualConsequenceSlices`) so dual interoperability now reaches the master-suite entry layer.
- [x] Add dual-routed suite convenience wrappers for no-unify/core/preconditioned and preconditioned↔core conversions (`principalNoUnify*...via_suite_via_dualConsequenceSlices`, `principal{Core,Preconditioned}*...via_suite_via_dualConsequenceSlices`, expression+field), so suite-level convenience APIs can remain on one explicit dual route end-to-end.
- [x] Add dual-routed master-suite convenience wrappers for arbitrary successful runs (`principal{Core,Preconditioned*,PreconditionedCoreIff*}{Expr,Field}_of_success_via_masterSuite_via_dualConsequenceSlices`, including any-hooks and bundled-hook forms), so master entrypoint consumers can stay on one explicit dual route without manually threading `PrincipalBoundaryMasterSuite`.
- [x] Add dual-routed master-suite no-unify convenience wrappers (`principalNoUnify{Core,Preconditioned*,PreconditionedCoreIff*}{Expr,Field}_of_success_via_masterSuite_via_dualConsequenceSlices`, including any-hooks and bundled-hook forms), so both arbitrary-success and no-unify master entrypoint families now have explicit dual-route counterparts.
- [x] Generalize top-level master↔dual interoperability (`principalBoundaryMasterSuite_of_dualConsequenceSlices`, `principalDualConsequenceSlices_of_principalBoundaryMasterSuite`, `principalBoundaryMasterSuite_iff_dualConsequenceSlices`) and route `principalBoundaryMasterSuite_proved_via_dualConsequenceSlices` through that generalized bridge.
- [x] Add dual-routed no-unify-to-general master-suite convenience wrappers (`principal{Core,Preconditioned*,PreconditionedCoreIff*}{Expr,Field}_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices`, including any-hooks and bundled-hook forms), closing naming/entrypoint parity between arbitrary-success and no-unify-to-general master APIs on the dual route.
- [x] Add bundled-seed `_from_bundle` aliases for all dual-routed master-suite convenience families (`..._of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle`, `principalNoUnify*..._of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle`, and `..._of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle`, expression+field), so one `UnifyHookPremises` seed now covers the full dual-routed master convenience surface.
- [x] Add bundled-seed aliases for the dual-routed suite no-unify convenience wrappers (`principalNoUnify{Core,Preconditioned}{Expr,Field}_of_success_via_suite_via_dualConsequenceSlices_from_bundle`), completing `_from_bundle` parity on the dual `via_suite` no-unify route.
- [x] Add bundled-seed aliases for the dual-routed suite preconditioned↔core conversion wrappers (`principal{Core,Preconditioned}{Expr,Field}_of_{preconditioned,core}_success_via_suite_via_dualConsequenceSlices_from_bundle`), completing bundle-entry parity across the full dual `via_suite` convenience layer.
- [x] Add a packaged current row-polymorphic boundary capstone (`PrincipalRowPolyBoundaryBundle`) that combines `PrincipalBoundaryMasterSuite` with `VerticalHookFreeUnifySlices`, with canonical constructors (`..._proved`, `..._proved_via_dualConsequenceSlices`) and one-hop principal/vertical/dual projections.
- [x] Add an explicit decomposition bridge for that capstone (`principalRowPolyBoundaryBundle_of_dual_and_vertical`, `principalRowPolyBoundaryBundle_iff_dual_and_vertical`), exposing the current boundary as `dual principal slice ∧ hook-free vertical slice`.
- [x] Add one-hop boundary-bundle consumption wrappers (`principalRowPolyBoundaryBundle_preconditionedCoreIff_{expr,field}`, `principalRowPolyBoundaryBundle_vertical_{app,proj}`) so principal equivalence and hook-free vertical facets are directly consumable from one packaged boundary witness.
- [x] Add a higher capstone package that combines boundary + recursive soundness (`PrincipalRowPolyBoundarySoundBundle`) with direct/dual/bundled constructors and one-hop dual-soundness wrappers (`..._expr_hasTypeU`, `..._field_hasTypeU`), so boundary and dual-judgment recursive soundness can be consumed from one theorem witness.
- [x] Extend that capstone with explicit decomposition + full judgment symmetry (`principalRowPolyBoundarySoundBundle_iff_boundary_and_soundDual`, plus one-hop `..._expr/field_hasType` wrappers) so both `HasType` and `HasTypeU` recursive soundness facets are directly consumable from the combined package.
- [x] Add direct principal-success one-hop wrappers from that same capstone (`principalRowPolyBoundarySoundBundle_{core,preconditioned,preconditionedCoreIff}{Expr,Field}_of_success`) so core/preconditioned/`↔` theorem facets are consumable from one combined boundary+soundness witness.
- [x] Add matching no-unify principal-success one-hop wrappers on that same capstone (`principalRowPolyBoundarySoundBundle_{core,preconditioned,preconditionedCoreIff}{Expr,Field}_of_success_noUnify`) so no-unify core/preconditioned/`↔` theorem facets are also consumable from one combined boundary+soundness witness.
- [x] Add any-hooks one-hop wrappers on that capstone for both arbitrary-success and no-unify runs (`principalRowPolyBoundarySoundBundle_preconditioned{,CoreIff}{Expr,Field}_anyHooks_of_success{_noUnify}`), completing direct capstone consumption across bundled + any-hooks principal theorem families.
- [x] Add run-bundle + hook-irrelevance one-hop wrappers on that capstone for both arbitrary-success and no-unify runs (`principalRowPolyBoundarySoundBundle_{runBundle,hookIrrelevant}{Expr,Field}_of_success{_noUnify}`) so capstone/principal/run-bundle/irrelevance facets are all directly consumable from one combined boundary+soundness witness.
- [x] Add explicit run-bundle-route coherence wrappers on that capstone (`principalRowPolyBoundarySoundBundle_{core,hookIrrelevant}{Expr,Field}_of_success{_noUnify}_via_runBundle`) so direct core/irrelevance APIs are explicitly connected to the packaged run-bundle projection route.
- [x] Extend that run-bundle-route coherence layer to preconditioned + `preconditioned ↔ core` theorem families (`principalRowPolyBoundarySoundBundle_preconditioned{,CoreIff}{Expr,Field}{,_anyHooks}_of_success{_noUnify}_via_runBundle`), so core/preconditioned/`↔`/irrelevance capstone APIs all route explicitly through the packaged run-bundle projections.
- [x] Add bundled-seed `_from_bundle` aliases across that full `..._via_runBundle` wrapper family (`principalRowPolyBoundarySoundBundle_{core,preconditioned{,_anyHooks},preconditionedCoreIff{,_anyHooks},hookIrrelevant}{Expr,Field}_of_success{_noUnify}_via_runBundle_from_bundle`), closing bundle-entry naming parity on the direct run-bundle route.
- [x] Add no-unify packaged consequence-bundle wrappers on that run-bundle route (`principalRowPolyBoundarySoundBundle_noUnify{Expr,Field}RunBundleConsequences_of_success_via_runBundle` with `_from_bundle` aliases), so one boundary+sound capstone witness can export full no-unify consequence records (core/preconditioned/`↔`/irrelevance) through the same route.
- [x] Add no-unify one-hop theorem wrappers through those capstone consequence bundles (`principalRowPolyBoundarySoundBundle_{core,preconditioned,preconditionedCoreIff,hookIrrelevant}{Expr,Field}_of_success_noUnify_via_runBundleConsequences`, including any-hooks forms), so all no-unify principal facets are explicitly consumable from the packaged consequence route.
- [x] Add arbitrary-success packaged consequence-bundle wrappers on that same route (`Principal{,Field}RunBundleConsequences` with `principalRowPolyBoundarySoundBundle_{expr,field}RunBundleConsequences_of_success_via_runBundle` and `_from_bundle` aliases), so boundary+sound capstone witnesses now emit full consequence records on both arbitrary-success and no-unify run-bundle paths.
- [x] Add arbitrary-success one-hop theorem wrappers through those packaged consequence bundles (`principalRowPolyBoundarySoundBundle_{core,preconditioned,preconditionedCoreIff,hookIrrelevant}{Expr,Field}_of_success_via_runBundleConsequences`, including any-hooks forms), completing consequence-route one-hop symmetry between arbitrary-success and no-unify principal facets.
- [x] Add bundled-seed `_from_bundle` aliases for the full capstone consequence-route wrapper family (`..._of_success{_noUnify}_via_runBundleConsequences_from_bundle` across core/preconditioned/`↔`/irrelevance for expr+field, including any-hooks forms), closing bundle-entry naming parity on this boundary+sound run-bundle consequence surface.
- [x] Add boundary+sound run-bundle route-pair packaging (`PrincipalBoundarySound{,NoUnify}{Expr,Field}RunBundleRoutes` plus `principalRowPolyBoundarySoundBundle_{,noUnify}{Expr,Field}RunBundleRoutes_of_success`), so a single capstone witness now jointly yields both run-bundle and packaged-consequence outputs for arbitrary-success and no-unify runs.
- [x] Add one-hop projection APIs for those route-pair surfaces (`principalBoundarySound{,NoUnify}{Expr,Field}RunBundleRoutes_{runBundle,consequences}`), so route-pair consumers can extract either witness branch through named theorem entrypoints.
- [x] Add direct hook-seeded and bundled-hook entrypoints for route-pair consumption (`principalBoundarySound{,NoUnify}{Expr,Field}RunBundleRoutes_of_success{_from_bundle}`), so downstream APIs can enter route-pair surfaces from hook premises without manually assembling the boundary+sound bundle.
- [x] Add combined typing+route packages (`PrincipalBoundarySound{,NoUnify}{Expr,Field}TypingRunBundleRoutes` with `principalRowPolyBoundarySoundBundle_{,noUnify}{Expr,Field}TypingRunBundleRoutes_of_success`), so one capstone-success witness now exports recursive soundness and run-bundle route-pair evidence together.
- [x] Add direct hook-seeded/bundled entrypoints and one-hop projections for typing+route packages (`principalBoundarySound{,NoUnify}{Expr,Field}TypingRunBundleRoutes_of_success{_from_bundle}` and `..._{hasType,hasTypeU,routes}`), so combined soundness+route APIs are directly consumable from hook premises without record-field destructuring.
- [x] Add hook-parameterized typing-route suite packaging (`PrincipalBoundarySoundTypingRunBundleSuite` with `..._of_hooks`, `..._of_hook_bundle`, and `..._{expr,field,noUnifyExpr,noUnifyField}`), so one witness now aggregates arbitrary-success and no-unify expression/field typing-route surfaces.
- [x] Add suite-level recursive-soundness wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_{hasType,hasTypeU}`), so `HasType`/`HasTypeU` consequences are directly consumable from the typing-route suite without intermediate package destructuring.
- [x] Add suite-level principal-core wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_core_of_success`), so core principality is directly consumable from the typing-route suite on arbitrary-success and no-unify expression/field paths.
- [x] Add suite-level any-hooks preconditioned wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_preconditioned_anyHooks_of_success`), so per-hook preconditioned principality is directly consumable from the typing-route suite on arbitrary-success and no-unify expression/field paths.
- [x] Add suite-level bundled-hook preconditioned wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_preconditioned_of_success`), so bundled-hook preconditioned principality is directly consumable from the typing-route suite on arbitrary-success and no-unify expression/field paths.
- [x] Add suite-level any-hooks `preconditioned ↔ core` wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_preconditionedCoreIff_anyHooks_of_success`), so per-hook equivalence between preconditioned and core principality is directly consumable from the typing-route suite on arbitrary-success and no-unify expression/field paths.
- [x] Add suite-level bundled-hook `preconditioned ↔ core` and fixed-run hook-irrelevance wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_{preconditionedCoreIff,hookIrrelevant}_of_success`), completing direct suite-level consumption of the principal theorem matrix across arbitrary-success and no-unify expression/field paths.
- [x] Add direct hook-seeded convenience wrappers over that suite for recursive soundness/core surfaces (`principalBoundarySound{,NoUnify}{Expr,Field}_{hasType,hasTypeU,core}_of_success_via_typingRunBundleSuite`), so these outcomes are directly consumable from hook premises without explicit suite construction at call sites.
- [x] Add bundled-hook `_from_bundle` aliases for those direct typing-suite convenience wrappers (`principalBoundarySound{,NoUnify}{Expr,Field}_{hasType,hasTypeU,core}_of_success_via_typingRunBundleSuite_from_bundle`), completing bundle-entry naming parity on that direct consumption layer.
- [x] Close the no-unify recursive-soundness gap on that direct layer (`principalBoundarySoundNoUnify{Expr,Field}_{hasType,hasTypeU}_of_success_via_typingRunBundleSuite` plus `_from_bundle` aliases), so no-unify `HasType`/`HasTypeU` are directly consumable with full bundle-entry parity.
- [x] Add direct hook-seeded preconditioned principality wrappers over that suite (`principalBoundarySound{,NoUnify}{Expr,Field}_preconditioned{,_anyHooks}_of_success_via_typingRunBundleSuite`), so any-hooks and bundled-hook preconditioned surfaces are directly consumable from hook premises on arbitrary-success and no-unify expression/field paths.
- [x] Add direct hook-seeded `preconditioned ↔ core` wrappers over that suite (`principalBoundarySound{,NoUnify}{Expr,Field}_preconditionedCoreIff{,_anyHooks}_of_success_via_typingRunBundleSuite`), so any-hooks and bundled-hook equivalence surfaces are directly consumable from hook premises on arbitrary-success and no-unify expression/field paths.
- [x] Add direct hook-seeded fixed-run hook-irrelevance wrappers over that suite (`principalBoundarySound{,NoUnify}{Expr,Field}_hookIrrelevant_of_success_via_typingRunBundleSuite`), so fixed-run hook-independence is directly consumable from hook premises on arbitrary-success and no-unify expression/field paths.
- [x] Add bundled-hook `_from_bundle` aliases for direct typing-suite principality/equivalence/irrelevance wrappers (`principalBoundarySound{,NoUnify}{Expr,Field}_{preconditioned,preconditionedCoreIff{,_anyHooks},hookIrrelevant}_of_success_via_typingRunBundleSuite_from_bundle`), closing bundle-entry naming parity on this direct suite-consumption layer.
- [x] Add packaged arbitrary-success full capstones on that direct typing-suite surface (`PrincipalBoundarySound{Expr,Field}Full` with constructors `principalBoundarySound{Expr,Field}Full_of_success_via_typingRunBundleSuite` and bundled aliases), so recursive soundness + full principal matrix is consumable from one theorem witness per successful expression/field run.
- [x] Add packaged no-unify full capstones on that direct typing-suite surface (`PrincipalBoundarySoundNoUnify{Expr,Field}Full` with constructors `principalBoundarySoundNoUnify{Expr,Field}Full_of_success_via_typingRunBundleSuite` and bundled aliases), so no-unify recursive soundness + full principal matrix is consumable from one theorem witness per successful expression/field run.
- [x] Add a top-level direct typing-suite full package (`PrincipalBoundarySoundFullSuite`) with direct/bundled constructors and one-hop expr/field/no-unify projections, so arbitrary-success and no-unify full surfaces are jointly consumable from one theorem API.
- [x] Route that full package through the boundary+sound capstone path (`principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle` with bundled alias), so one `PrincipalRowPolyBoundarySoundBundle` witness exports the full direct arbitrary-success/no-unify expr+field theorem surface.
- [x] Add canonical and dual-routed entrypoint wrappers for that row-poly full-suite path (`..._via_rowPolyBoundarySoundBundle_{proved,via_dualConsequenceSlices}` plus bundled aliases), so hook-seeded/bundled call sites can consume the full-suite route without manually constructing intermediate boundary+sound bundles.
- [x] Add a combined full+vertical capstone package (`PrincipalBoundarySoundFullVerticalSuite`) with row-poly route constructor, bundled alias, and one-hop full/vertical/app/proj projections, so direct full principal surfaces and hook-free vertical guarantees are consumable together from one theorem witness.
- [x] Expand `PrincipalBoundarySoundFullVerticalSuite` with canonical+dual entrypoint wrappers, decomposition equivalence (`..._iff_full_and_vertical`), and direct expr/field/no-unify projections, completing one-hop API parity on the joint full-principal+vertical route.
- [x] Add direct typing-suite entrypoints for `PrincipalBoundarySoundFullVerticalSuite` (`..._via_typingRunBundleSuite` with bundled/dual aliases), so call sites can consume the combined full-principal+vertical surface without explicit row-poly bundle routing.
- [x] Add `PrincipalBoundarySoundFullVerticalRoutes` with direct/bundled/dual constructors and one-hop route projections, so typing-suite and row-poly-bundle `FullVertical` routes are packaged behind one theorem API.
- [x] Extend `PrincipalBoundarySoundFullVerticalRoutes` with one-hop full/vertical/app/proj projections on each branch (`viaTypingSuite_*`, `viaRowPolyBundle_*`) using direct field projections, keeping the route-pair surface order-independent and build-stable.
- [x] Add branch-level consequence projections on `PrincipalBoundarySoundFullVerticalRoutes` for expr/field/no-unify plus local `full ∧ vertical` decomposition (`..._as_full_and_vertical`), completing one-hop per-branch consumption of principal and vertical facets.
- [x] Add constructor naming parity on `PrincipalBoundarySoundFullVerticalRoutes` (`..._via_rowPolyBoundarySoundBundle`, `..._via_typingRunBundleSuite`, `..._via_dualConsequenceSlices`, with bundled aliases), so route entrypoints align with existing capstone naming conventions.
- [x] Add `PrincipalBoundarySoundFullVerticalMasterRoutes` with bundled/split-hook constructors and one-hop regular/dual branch projections, so regular and dual consequence-route witnesses are consumable from one `FullVertical` theorem surface.
- [x] Extend `PrincipalBoundarySoundFullVerticalMasterRoutes` with direct regular/dual full+vertical/app/proj wrappers (`..._{regular,dual}_{full,vertical,vertical_app,vertical_proj}`), completing one-hop master-level access to vertical consequences.
- [x] Extend `PrincipalBoundarySoundFullVerticalMasterRoutes` with regular/dual expr/field/no-unify full projections (`..._{regular,dual}_{expr,field,noUnifyExpr,noUnifyField}`), completing one-hop master-level access to principal-full consequences.
- [x] Add paired regular+dual extraction wrappers on `PrincipalBoundarySoundFullVerticalMasterRoutes` (`..._{full,vertical,expr,field,noUnifyExpr,noUnifyField}_pair`), so both route consequences are consumable together from one master witness.
- [x] Add explicit master-route decomposition/equivalence (`principalBoundarySoundFullVerticalMasterRoutes_iff_regular_and_dual`) with pair constructor/projection helpers (`..._of_pair`, `..._as_pair`) to make regular+dual route packaging structurally explicit.
- [x] Add regular/dual branch decomposition wrappers (`..._{regular,dual}_as_full_and_vertical`) and paired decomposition extraction (`..._full_and_vertical_pair`) on `PrincipalBoundarySoundFullVerticalMasterRoutes`, completing one-hop branch-level `full ∧ vertical` access.
- [x] Add direct success-entry convenience wrappers via `FullVerticalMasterRoutes` (`..._via_fullVerticalMasterRoutes` with bundled aliases) for expr/field/no-unify full surfaces and vertical app/proj consequences, enabling one-step consumption from successful runs.
- [x] Add packaged `PrincipalBoundarySoundFullVerticalMasterCapstone` with constructors from explicit master routes and successful runs (hook-seeded + bundled), bundling expr/field/no-unify full consequences with hook-free vertical app/proj guarantees under one witness.
- [x] Add explicit component decomposition for `PrincipalBoundarySoundFullVerticalMasterCapstone` (`..._iff_components`) with constructor/projection helpers (`..._of_components`, `..._as_components`) to keep the packaged capstone structurally transparent.
- [x] Add bidirectional bridge/equivalence between `PrincipalBoundarySoundFullVerticalMasterCapstone` and `PrincipalBoundarySoundFullVerticalSuite` (`..._of_masterCapstone`, `..._of_fullVerticalSuite`, `..._iff_fullVerticalSuite`) to align master-route packaging with the existing full-suite surface.
- [x] Add explicit row-poly bundle entry constructors for `FullVerticalMasterRoutes`/`FullVerticalMasterCapstone` (`..._of_success_via_rowPolyBoundarySoundBundle`) so these master surfaces can start directly from `PrincipalRowPolyBoundarySoundBundle`.
- [x] Add no-unify-specialized packaged master surface (`PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone`) with constructors from master-capstone and successful runs (hook-seeded + bundled), isolating no-unify expr/field full consequences with vertical app/proj guarantees.
- [x] Add explicit component decomposition for `PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone` (`..._iff_components`) with constructor/projection helpers (`..._of_components`, `..._as_components`) to keep the no-unify packaged surface structurally transparent.
- [x] Add `PrincipalBoundarySoundNoUnifyFullVerticalSuite` and prove bidirectional bridge/equivalence with `PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone` (`..._of_masterCapstone`, `..._of_fullVerticalSuite`, `..._iff_fullVerticalSuite`) to align no-unify package shapes.
- [x] Extend `PrincipalBoundarySoundNoUnifyFullVerticalSuite` with direct success constructors (`..._of_success`, `..._of_success_from_bundle`), one-hop expr/field/vertical/app/proj projections, and explicit decomposition equivalence (`..._iff_components`) so no-unify full-vertical suite usage is one-step from successful runs.
- [x] Add route-complete no-unify suite entry wrappers from canonical full-vertical paths (`..._of_fullVerticalSuite` plus `..._of_success_via_{rowPolyBoundarySoundBundle,typingRunBundleSuite}` with bundled/dual/proved variants), keeping no-unify full-vertical construction aligned with the row-poly and typing-route entry APIs.
- [x] Add `PrincipalBoundarySoundNoUnifyFullVerticalRoutes` with success/bundled/dual constructors plus one-hop branch projections/decompositions, so typing-route and row-poly-route no-unify full-vertical witnesses are packaged behind one route-pair theorem surface.
- [x] Add `PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes` with regular/dual route-pair constructors, decomposition equivalence (`..._iff_regular_and_dual`), and one-hop regular/dual consequence projections, so both no-unify consequence routes are packaged behind one master theorem surface.
- [x] Add naming-parity constructor aliases on `PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes` (`..._via_rowPolyBoundarySoundBundle`, `..._via_typingRunBundleSuite`, `..._via_dualConsequenceSlices`, with bundled variants) and capstone bridge projections (`principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_noUnifyMasterRoutes_{regular,dual}`), tying route-pair and capstone layers together.
- [x] Add no-unify master-route parity convenience/projection APIs (`..._{regular,dual}_via{TypingSuite,RowPolyBundle}`, paired extractions `..._{expr,field,vertical,components}_pair`, and branch decompositions `..._{regular,dual}_as_components`) to match one-hop consumption coverage on the full-route master layer.
- [x] Add a unified no-unify master surface package (`PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface`) with constructors from routes/capstone/success (split+bundled hooks), one-hop routes/capstone projections, and explicit decomposition equivalence (`..._iff_components`), so route-pair and capstone witnesses are consumable from one packaged theorem layer.
- [x] Extend `PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface` with direct bridges from full master-capstone/full-vertical suite surfaces under no-unify premises (`..._of_masterCapstone`, `..._of_fullVerticalSuite`, `..._of_success_via_fullVerticalMasterCapstone*`) and direct one-hop expr/field/vertical app-proj projections.
- [x] Add bidirectional bridge/equivalence between `PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface` and `PrincipalBoundarySoundNoUnifyFullVerticalSuite` (`..._of_noUnifyFullVerticalSuite`, `..._of_noUnifyMasterSurface`, `..._iff_fullVerticalSuite`) to connect the new packaged top layer back to the existing no-unify suite surface.
- [x] Add success-entry naming parity and interchange contracts for `PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface` (`..._of_success_via_noUnifyMaster{Routes,Capstone}` with bundled variants, plus `..._iff_master{Routes,Capstone}`) so the top no-unify package is directly interchangeable with underlying route/capstone layers.
- [x] Add direct successful-run consequence wrappers over `PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface` (`principalBoundarySoundNoUnify{Expr,Field}Full_of_success_via_noUnifyMasterSurface`, `principalBoundarySoundNoUnify_vertical{App,Proj}_of_success_via_noUnifyMasterSurface`, plus bundled aliases), so top no-unify package consumption is one-hop at call sites.
- [x] Extend `PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface` with paired regular/dual route consequence wrappers and explicit consequence-level decomposition contracts (`..._routes_pair`, `..._{expr,field,vertical}_pair`, `..._iff_consequences`, `..._of_consequences`, `..._as_consequences`) for both route-level and direct consequence-level one-hop consumption.
- [x] Add route-named success wrapper parity on `PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface` (`..._of_success_via_{rowPolyBoundarySoundBundle,typingRunBundleSuite,dualConsequenceSlices,fullVerticalMasterRoutes}` with bundled variants), so all canonical route names map directly to the same top no-unify package entry surface.
- [x] Add explicit lifts from full-vertical route/master-route surfaces into no-unify packaged layers under no-unify premises (`principalBoundarySoundNoUnifyFullVerticalRoutes_of_fullVerticalRoutes`, `...MasterRoutes_of_fullVerticalMasterRoutes`, `...MasterSurface_of_fullVerticalMasterRoutes`) to connect the general and no-unify tracks directly.
- [x] Discharge a unification-aware app hook from substitution admissibility alone (`AppUnifySoundHookUResolved`, `appUnifySoundHookUResolved_proved`) once a resolved function-shape equation is available.
- [x] Add successor-fuel app hook variant (`AppUnifySoundHookUResolvedSucc`, `appUnifySoundHookUResolvedSucc_proved`) aligned with current bindTypeVar/idempotence bridge equalities.
- [x] Add one-step app bridge theorem in the unification-aware judgment (`inferExprUnify_app_step_sound_hasTypeU_resolved`) parameterized by explicit resolved function-shape equality.
- [x] Prove global resolved-shape assumptions are not derivable in the current fuel model (`not_AppResolvedShapeFromUnify`, `not_ProjResolvedShapeFromUnify`, `not_UnifyResolvedShapePremises`), tightening the vertical-slice boundary.
- [x] Land a hook-free app vertical theorem on a concrete true fragment (`inferExprUnify_app_vertical_closed_fresh_empty_subst`) using no-unify child inference + closed/fresh empty-subst app bridge.
- [x] Land a hook-free projection vertical theorem on a concrete true fragment (`inferExprUnify_proj_vertical_resolved`) using no-unify receiver inference + explicit resolved closed-row witness.
- [x] Add top-level projection inference corollary for the resolved vertical slice (`inferExprUnify_proj_vertical_resolved_of_infer`).
- [x] Compose app+projection vertical slices into a single packaged theorem surface (`VerticalHookFreeUnifySlices`, `verticalHookFreeUnifySlices_proved`).
- [x] Timebox an evaluator-side generalizability spike (`Rill/Eval.lean`): minimal semantics + determinism + initial progress/composition lemmas (`eval_progress_lit`, `eval_progress_var_of_envCovers`, `eval_let_of_eval_steps`, `eval_progress_record_of_evalFields`), literal-preservation lemmas (`eval_preserves_int_lit`, `eval_preserves_bool_lit`, `eval_preserves_string_lit`), variable-preservation under typed runtime environments (`eval_preserves_var_of_envTyped`), executable fragment predicates (`EvalFragmentExpr`, `EvalFragmentFields`), and initial executable soundness slices (`eval_sound_atomic`, `inferEval_sound_atomic`).
- [x] Extend evaluator spike to a non-atomic executable soundness slice over the full evaluator fragment (`eval_sound_evalFragment`, `evalFields_sound_evalFragment`, `inferEval_sound_evalFragment`) with record runtime typing transport (`ValueFieldsHasType`, `valueFieldsHasType_get`) and let-environment extension (`envWellTyped_cons`).
- [x] Add reduced lam/app vertical slice via beta-style direct app-lam execution (`.app (.lam ...) arg`) with no first-class function values in the fragment (`EvalFragmentFull`, `EvalFragmentFullFields`, `eval_app_lam_of_eval_arg`, `eval_sound_evalFragmentFull`, `evalFields_sound_evalFragmentFull`, `inferEval_sound_evalFragmentFull`).
- [x] Bridge from app unification success to weak-hook equality premise (`applySubstCompat stAfter.subst fuel (.var resVar) = retTy`) under explicit substitution assumptions.
  Completed via the app-equality bridge/theorem family in `Kea/Typing.lean` (`app_unify_result_eq_of_bindTypeVar_idempotent`, `app_unify_result_eq_of_unify_function_shape_idempotent`, shifted contract wrappers `app_unify_result_eq_of_unify_success_contract_succ` and closed/fresh specializations), with explicit no-op-domain contracts (`AppUnifyNoopDomain`) and resolved-shape/`HasTypeU` hook packaging (`AppResolvedShapeFromUnifyClosedFreshSucc`, `AppUnifySoundHookUClosedFreshSucc`).
- [x] Prove full principal types for the row-polymorphic inference fragment beyond the current preconditioned vertical boundary.
  Progress: added packaged preconditioned principal-typing slice in `Kea/Typing.lean` (`PrincipalTypingSlicePreconditioned`, `principalTypingSlicePreconditioned_of_success`), strengthened the hook-free no-unify fragment with expression+field completeness/equivalence packaging (`inferExprUnify_complete_no_unify_branches`, `inferFieldsUnify_complete_no_unify_branches`, `inferExprUnify_ok_iff_inferExpr_no_unify_branches`, `inferFieldsUnify_ok_iff_inferFields_no_unify_branches`, `PrincipalTypingNoUnifySlices`), added a no-unify-to-preconditioned bridge (`principalTypingSlicePreconditioned_of_success_no_unify`), added bundled-hook principal entrypoints (`UnifyHookPremises`, `principalTypingSlicePreconditioned_of_success_from_bundle`, `principalTypingSlicePreconditioned_of_success_no_unify_from_bundle`), added core declarative principality packaging for syntax-directed inference (`hasType_unique`, `inferExpr_principal`, `PrincipalTypingSliceCore`, `principalTypingSliceCore_of_infer`), added no-unify unify-success bridges into those core principal packages (`principalTypingSliceCore_of_unify_success_no_unify`, `principalFieldTypingSliceCore_of_unify_success_no_unify`), added a general core-principal-to-preconditioned bridge (`principalTypingSlicePreconditioned_of_success_of_core_principal`), added the converse preconditioned-to-core bridge (`principalTypingSliceCore_of_preconditioned_success`, bundle variant), added packaged no-unify bridge exports (`PrincipalNoUnifyBridgeBundle`, `principalNoUnifyBridgeBundle_of_success`, hook-bundle variant), added field-side preconditioned principal parity (`inferFieldsUnify_deterministic`, `inferFieldsUnify_row_unique_preconditioned`, `PrincipalFieldTypingSlicePreconditioned` + direct/bundle/no-unify/core-bridge variants), added packaged no-unify field bridge exports (`PrincipalFieldNoUnifyBridgeBundle`, direct and hook-bundle constructors), added the converse preconditioned-to-core field bridge (`principalFieldTypingSliceCore_of_preconditioned_success`, bundle variant), added a combined expression+field no-unify bridge capstone (`PrincipalNoUnifyBridgeSlices`, `principalNoUnifyBridgeSlices_proved`), added successful-run equivalence bridges (`principalTypingSlicePreconditioned_iff_core_of_success`, `principalFieldTypingSlicePreconditioned_iff_core_of_success`, plus bundle variants), added a combined successful-run equivalence capstone (`PrincipalPreconditionedCoreIffSlices`, `principalPreconditionedCoreIffSlices_proved`), added one-hop projection helpers for both combined capstones (`principalNoUnifyBridgeSlices_expr/field`, `principalPreconditionedCoreIffSlices_expr/field`), added top-level suite packaging/projections (`PrincipalBoundaryBridgeSuite`, `principalBoundaryBridgeSuite_proved`, `principalBoundaryBridgeSuite_*`), added suite-based no-unify convenience entrypoints for direct core/preconditioned extraction (`principalNoUnifyCoreExpr/Field_of_success_via_suite`, `principalNoUnifyPreconditionedExpr/Field_of_success_via_suite`), added suite-based generic successful-run conversion wrappers in both directions (`principalCoreExpr/Field_of_preconditioned_success_via_suite`, `principalPreconditionedExpr/Field_of_core_success_via_suite`), added suite coherence lemmas tying no-unify bundle witnesses to preconditioned↔core witnesses (`principalBoundaryBridgeSuite_noUnify_*_coherent_*`), added no-unify capstone packaging with suite-derived constructors/projections (`PrincipalBoundaryNoUnifyExprCapstone`, `PrincipalBoundaryNoUnifyFieldCapstone`, `PrincipalBoundaryNoUnifyCapstoneSlices`, `principalBoundaryNoUnifyCapstoneSlices_proved`), added one-hop extraction helpers from capstone slices for core/preconditioned/`↔` witnesses (`principalBoundaryNoUnifyCapstoneSlices_expr_*`, `principalBoundaryNoUnifyCapstoneSlices_field_*`), added hook-passing parity entrypoints for capstone construction (`principalBoundaryNoUnifyExpr/FieldCapstone_of_success`, `principalBoundaryNoUnifyExpr/FieldCapstone_of_success_from_hook_bundle`), added fixed-run hook-transport/irrelevance theorems (`principalTypingSlicePreconditioned_transport_hooks_of_success`, `principalTypingSlicePreconditioned_hook_irrelevant_of_success`, field analogues), packaged that hook-irrelevance surface as a combined expression+field capstone (`PrincipalPreconditionedHookIrrelevanceSlices`, `principalPreconditionedHookIrrelevanceSlices_proved`, `principalPreconditionedHookIrrelevanceSlices_expr/field`), added a top-level vacuity suite that combines no-unify capstones with hook-irrelevance slices (`PrincipalBoundaryVacuitySuite`, `principalBoundaryVacuitySuite_proved`, `principalBoundaryVacuitySuite_*`), added no-unify all-hooks capstone surfaces (`PrincipalBoundaryNoUnifyExpr/FieldAllHooksCapstone`, `PrincipalBoundaryNoUnifyAllHooksCapstoneSlices`, projections) so one no-unify success exports core + all-hook preconditioned + per-hook equivalence in hook-free form, added all-hooks-derived irrelevance packaging (`PrincipalBoundaryNoUnifyAllHooksIrrelevanceSlices`, `principalBoundaryNoUnifyAllHooksIrrelevanceSlices_proved`, expression/field projections) to make hook-independence directly derivable from all-hooks capstones on no-unify successes, packaged both under a top-level all-hooks suite (`PrincipalBoundaryNoUnifyAllHooksSuite`, `principalBoundaryNoUnifyAllHooksSuite_proved`, `principalBoundaryNoUnifyAllHooksSuite_*`), added compatibility bridges back to the hook-specific capstone API (`principalBoundaryNoUnifyExpr/FieldCapstone_of_allHooks`, `principalBoundaryNoUnifyCapstoneSlices_of_allHooksCapstones`, `principalBoundaryNoUnifyCapstoneSlices_of_allHooksSuite`), added a top-level principal boundary master suite (`PrincipalBoundaryMasterSuite`, `principalBoundaryMasterSuite_proved`, `principalBoundaryMasterSuite_*`) aggregating bridge/vacuity/general-all-hooks/no-unify-all-hooks surfaces plus all-hooks→hooked compatibility projections, added all-hooks-suite no-unify convenience wrappers (`principalNoUnifyCore*` / `principalNoUnifyPreconditioned*_*_via_allHooksSuite`, including any-hooks forms) for direct downstream consumption without capstone destructuring, added general successful-run all-hooks capstone packaging (`PrincipalPreconditionedExpr/FieldAllHooksCapstone`, `PrincipalPreconditionedAllHooksCapstoneSlices`, with one-hop projections) so arbitrary successful runs export core + any-hooks preconditioned consequences from one hook witness pair, packaged that layer as a top-level suite with capstone-derived irrelevance (`PrincipalPreconditionedAllHooksSuite`, `principalPreconditionedAllHooksSuite_proved`, `principalPreconditionedHookIrrelevanceSlices_of_allHooksCapstones`, `principalPreconditionedAllHooksSuite_*`), added general-all-hooks-suite convenience wrappers (`principalCore*` / `principalPreconditioned*_*_via_generalAllHooksSuite`, including any-hooks forms) for direct successful-run consumption without capstone destructuring, added master-suite convenience wrappers (`principalCore*` / `principalPreconditioned*_*_via_masterSuite`, including any-hooks forms) so arbitrary successful-run consequences can be consumed directly from the master aggregate surface, added master-suite no-unify convenience wrappers (`principalNoUnifyCore*` / `principalNoUnifyPreconditioned*_*_via_masterSuite`, including any-hooks forms) so no-unify consequences are equally consumable from that same master surface, added explicit no-unify-to-general all-hooks projections (`principalPreconditionedExpr/FieldAllHooksCapstone_of_noUnifyAllHooks`, `principalBoundaryNoUnifyAllHooksSuite_capstone_*_as_general`, `principalBoundaryMasterSuite_noUnifyAllHooks_*_as_general`) to unify successful no-unify and arbitrary-success all-hooks call surfaces, added success-level no-unify-to-general wrappers (`principalPreconditionedExpr/FieldAllHooksCapstone_of_success_noUnify`, `principalCore*` / `principalPreconditioned*AnyHooks*_of_success_noUnify_via_generalAllHooks`) for direct no-hook-witness consumption on no-unify runs, added bundled-hook and irrelevance parity wrappers on that same path (`principalPreconditionedExpr/Field_of_success_noUnify_via_generalAllHooks`, `principalPreconditionedExpr/Field_hookIrrelevant_of_success_noUnify_via_generalAllHooks`), packaged that bridge as a dedicated suite (`PrincipalNoUnifyToGeneralAllHooksSuite`, `principalNoUnifyToGeneralAllHooks*` capstone/irrelevance slices and one-hop projections), lifted it into the master surface (`PrincipalBoundaryMasterSuite.noUnifyToGeneralAllHooks`, `principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_*`) as the canonical no-unify-as-general projection path, added hook-irrelevance convenience wrappers across the suite entrypoints (`principalPreconditioned*hookIrrelevant*_via_generalAllHooksSuite`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_masterSuite`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_allHooksSuite`), routed master-suite no-unify core/preconditioned convenience wrappers through that same canonical projection family (`principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_*`), routed all-hooks-suite no-unify convenience wrappers (including hook-irrelevance variants) through `PrincipalNoUnifyToGeneralAllHooksSuite_proved`, added bidirectional suite compatibility with derived forms (`principalNoUnifyToGeneralAllHooksSuite_of_noUnifyAllHooksSuite`, `principalBoundaryNoUnifyAllHooksSuite_of_noUnifyToGeneralAllHooksSuite`, `principalNoUnifyToGeneralAllHooksSuite_proved_via_noUnifyAllHooks`, `principalBoundaryNoUnifyAllHooksSuite_proved_via_noUnifyToGeneral`) to make the canonical relation explicit, added parameterized no-unify-to-general convenience wrappers (`principalNoUnifyToGeneralCore*`, `principalNoUnifyToGeneralPreconditioned*_*`) that now underpin both master and all-hooks no-unify convenience entrypoints, completed no-unify convenience parity with explicit bundled-hook `preconditioned ↔ core` wrappers (`principalNoUnifyToGeneralPreconditionedCoreIff*` with `principalNoUnifyPreconditionedCoreIff*_of_success_via_masterSuite` / `...via_allHooksSuite`), added matching arbitrary-success bundled-hook `preconditioned ↔ core` wrappers for general/master paths (`principalPreconditionedCoreIff*_of_success_via_generalAllHooksSuite`, `principalPreconditionedCoreIff*_of_success_via_masterSuite`), added matching any-hooks no-unify `preconditioned ↔ core` wrappers across canonical/master/all-hooks entrypoints (`principalNoUnifyToGeneralPreconditionedCoreIff*AnyHooks*`, `principalNoUnifyPreconditionedCoreIff*AnyHooks*_of_success_via_*Suite`) with bundled forms routed through these any-hooks APIs, added matching any-hooks arbitrary-success `preconditioned ↔ core` wrappers for general/master paths (`principalPreconditionedCoreIff*AnyHooks*_of_success_via_generalAllHooksSuite`, `principalPreconditionedCoreIff*AnyHooks*_of_success_via_masterSuite`) with bundled forms routed through them, added a parameterized arbitrary-success convenience layer over `PrincipalPreconditionedAllHooksSuite` (`principalGeneralAllHooks*`) that now underpins both `via_generalAllHooksSuite` and `via_masterSuite` wrappers, added direct no-unify-to-general `preconditioned ↔ core` wrappers on the proved general-all-hooks path (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_generalAllHooks`, `principalPreconditionedCoreIff*_of_success_noUnify_via_generalAllHooks`), and added master no-unify-to-general naming-parity wrappers for that same fixed-run `↔` surface (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_masterSuite`, `principalPreconditionedCoreIff*_of_success_noUnify_via_masterSuite`); this is now lifted to a unified full master-surface capstone (`PrincipalBoundarySoundFullVerticalMasterSurface`) with consequence decomposition/equivalence, route/capstone interchange, direct successful-run wrappers (`..._via_fullVerticalMasterSurface`), and a direct bridge into the no-unify master surface (`principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_fullVerticalMasterSurface`) under no-unify premises.
- [x] Add combined full/no-unify top-layer packaging over the master-surface route (`PrincipalBoundarySoundFullNoUnifyMasterSurfacePair` with success/bundled constructors, surface-equivalence decomposition, and one-hop full/no-unify/vertical projections), so one successful run now yields both general and no-unify top-level principal surfaces from the same witness.
- [x] Extend that combined top-layer package with consequence-equivalence decomposition (`principalBoundarySoundFullNoUnifyMasterSurfacePair_iff_consequences` + `..._of/as_consequences`) and direct successful-run wrappers (`..._of_success_via_fullNoUnifyMasterSurfacePair`, bundled variants), so full/no-unify/vertical outcomes are one-hop from the shared pair route.
- [x] Extend to DataFrame verb typing judgments once core typing soundness is stable.
  N/A for Kea scope: DataFrame/column verb formalization remains in the archived Rill track and is not part of Kea language formalization.
- [x] Add supertrait/evidence bridge kickoff model (`Rill/Traits.lean`): trait graph closure (`TraitGraph`) + closure-aware satisfaction/bound-checking surfaces (`satisfiesWithGraph`, `checkTraitBoundsWithGraph`) for MCP-observed evidence behavior.
- [x] Add concrete supertrait-gap boundary witness theorems (`satisfies_direct_ord_only`, `requiredTraits_ord_requires_eq`, `satisfiesWithGraph_ord_only_false`, `supertrait_gap_witness`) matching MCP-observed direct-impl vs closure-aware divergence.
- [x] Add bound-checking gap witness trio (`checkTraitBoundsWithGraph_ord_only_reports_missing_super`, `checkTraitBounds_direct_ord_only_accepts`, `checkTraitBoundsWithGraph_ord_and_eq_accepts`) to make the direct-vs-closure discrepancy executable at the trait-bound checker surface.
- [x] Package the trait-closure boundary into a single citation surface (`TraitClosureGapSlice`, `traitClosureGapSlice_proved`) for downstream paper and bridge theorem references.
- [x] Add no-impl witness theorems (`checkTraitBounds_direct_no_impl_reports_ord`, `checkTraitBoundsWithGraph_no_impl_reports_ord_and_eq`) to pin expected trait-bound failures when neither direct nor supertrait impls exist.
- [x] Add call-site gate model + bundle (`callSiteAcceptsDirect`, `callSiteAcceptsWithGraph`, `TraitCallSiteEnforcementSlice`) to make direct-vs-closure enforcement outcomes explicit at the acceptance boundary.
- [x] Add gate/checker normalization lemmas (`callSiteAcceptsDirect_eq_true_iff`, `callSiteAcceptsWithGraph_eq_true_iff`) so downstream theorems can switch between boolean gates and checker outputs.
- [x] Add witness-level refinement bundle (`TraitCallSiteRefinementWitnessSlice`) showing closure-aware acceptance implies direct acceptance on the fully-implemented witness state, while direct-only acceptance remains strictly weaker.
- [x] Add reusable refinement bridge surface (`TraitBoundRefinementPremise`, `callSiteAcceptsWithGraph_implies_direct_of_premise`) so future language-level checker changes can discharge one premise and inherit gate-level refinement.
- [x] Add witness-specialized premise instantiation path (`TraitBoundRefinementPremise_ord_and_eq_witness`, `callSiteAcceptsWithGraph_ord_and_eq_implies_direct_via_premise`) to connect the reusable bridge surface to a concrete fully-implemented state.
- [x] Add explicit site-level trait call boundary packaging (`TraitCallBoundarySite`, `callSiteAcceptsDirectAtSite`, `callSiteAcceptsWithGraphAtSite`, `trait_call_boundary_surface_slice`) to pin direct-vs-closure witness outcomes at boundary-sensitive sites.

## M5. Post-`61bd3a1` Language-Shift Delta Checklist

- [x] Re-audit unification-critical Rust surfaces after `feat: align function-only syntax, imports, prelude, and actor docs/tests` and confirm no structural `unify`/`unifyRows` algorithm rewrite in `rill-infer` (formal row-unification core remains aligned).
- [x] Re-probe MCP actor surface for message-form semantics (`impl Actor for T where Message = ...`, `send(actor, Msg)`, `call(actor, Msg)`) and log outcomes.
- [x] Re-probe MCP interactive prelude boundary for the new extended-prelude policy (confirm allowed bare names remain available and non-extended names reject without import).
- [x] Re-probe trait-closure boundary witness after syntax/runtime shift (confirm direct-only/supertrait-unsatisfied divergence behavior still reproduces).
- [x] Lift the actor message-style shift into an explicit Lean-facing contract surface in `Rill/Traits.lean` (`ActorDispatchModel`, `ActorMessageDispatchBoundarySlice`) so post-migration actor call-site boundaries are explicit and citable.
- [x] Add site-level actor dispatch boundary packaging (`ActorDispatchBoundarySite`, `actorDispatchAccepts*AtSite`, `actor_dispatch_boundary_surface_slice`) so message-style vs legacy dispatch outcomes are explicit at boundary-sensitive sites.
- [x] Decide whether to formalize strict-module-prelude semantics as a runtime/typing bridge artifact or keep it as implementation-only policy evidence in MCP logs.
  Decision: keep strict-module-prelude behavior as implementation-policy evidence in MCP logs for now; do not add a Lean artifact in this phase.

## M6. Kea Effect/Handler Contract Track (Complete)

- [x] WP6.1 handler core + normalization.
  Progress: `Kea/Properties/HandlerEffectRemoval.lean` landed with `EffectRow.handleRemove` and capstones (`handle_removes_effect`, `handle_preserves_other_effects`, row-tail/WF preservation, idempotence), then moved to spec-normalized composition via `EffectRow.handleComposeNormalized` plus nested same-target consequences (`nested_same_target_outer_removal_noop_of_inner_absent`, `nested_same_target_remains_absent_of_outer_absent`). MCP now confirms overlap-idempotence closure (`[Trace] ∪ [Trace] = [Trace]`) on tracked probes.
- [x] WP6.2 absent-effect closed-row no-op + clause-level closed-aware contracts.
  Progress: `Kea/Properties/HandlerAbsentEffectNoop.lean` added closed-row no-op model (`handleComposeClosedAware`, `handle_absent_effect_noop`, present/open fallback theorem). `Kea/Properties/HandlerClosedAwareContracts.lean` lifted this into clause APIs (`resultEffectsCoreClosedAware`, `resultEffectsClosedAware`) with normalized/closed bridge theorems, branch reduction/classification (`resultEffectsClosedAware_absent_closed_reduces_to_applyThen`, `resultEffectsCoreClosedAware_branch_classification`), bundle packaging (`ClosedAwareCoreBundle`, `closedAwareCoreBundle_of_classification`, `ClosedAwareResultBundle`) plus structural decomposition helpers (`closedAware{Core,Result}Bundle_{iff_components,of_components,as_components}`), and constructor-route one-hop wrappers on classification/well-typed entrypaths (`closedAwareCoreBundle_{as_components,absentClosedNoop,presentOrOpenNormalized}_of_classification`, `closedAwareResultBundle_{as_components,closedAwareHandledRemoved,closedAwareRowTailStable}_of_wellTyped`), alongside typing-facing consequences (`resultEffectsClosedAware_preserves_row_tail`, `wellTypedSlice_implies_handled_removed_closedAware`).
- [x] WP6.3 resume-linearity + clause typing integration.
  Progress: `Kea/Properties/ResumeLinearity.lean` landed (`ResumeUse`, saturating composition, `resume_at_most_once`) and was strengthened with exact combine/exclusivity theorems (`resume_combine_atMostOnce_iff`, `resume_combine_atMostOnce_implies_one_side_zero`, `resume_combine_one_one_not_atMostOnce`). `Kea/Properties/HandlerTypingContracts.lean` then integrated effect-removal + linearity into `wellTypedSlice` with explicit `resultEffectsCore`/`applyThenEffects`/`resultEffects`, handled-label non-reintroduction, resume provenance, branch exclusivity, and loop legality. MCP aligns with `E0012` double-resume rejection behavior.
  Update: added an explicit judgment-shaped clause resume-summary layer (`clauseHasResumeSummary`) and the direct linearity bridge (`clauseHasResumeSummary_implies_atMostOnce_of_wellTypedSlice`, `wellTypedSlice_hasResumeSummary_atMostOnce`), so clause-level typing assumptions now export a concrete at-most-once resume witness.
- [x] WP6.4 operation typing + tail capability + nested composition packages.
  Progress: `Kea/Properties/EffectOperationTyping.lean` added declaration/operation contracts (`EffectDecl`, `operationCallTyping`, `performOperationEffects`) with WF transport and named bundles (`OperationCallBundle`), now including structural decomposition helpers (`operationCallBundle_{iff_components,of_components,as_components}`). `Kea/Properties/TailResumptiveClassification.lean` and `Kea/Properties/TailCapabilityComposition.lean` added direct-call eligibility/classification plus named bundles (`TailResumptiveBundle`, `TailCapabilityBundle`), now include structural decomposition parity (`tailResumptive{,ClosedAware}Bundle_{iff_components,of_components,as_components}` and `tailCapability{,ClosedAware}Bundle_{iff_components,of_components,as_components}`), and include closed-aware direct-call/capability surfaces (`tail_resumptive_direct_call_sound_closedAware`, `TailResumptiveClosedAwareBundle`, `TailCapabilityClosedAwareBundle`, `tail_resumptive_eligible_capability_direct_call_sound_closedAware`). The normalized tail bundle now also carries direct-call eligibility evidence (`directCallEquivalent_of_eligible`) and the decomposition contracts were lifted to include that facet. These modules now also expose constructor-route parity wrappers from typing/well-typed entrypoints (`operationCallBundle_{as_components,declared,callTyping,rowTailStable}_of_typing`, `tail_resumptive{,_closedAware}_bundle_{as_components,classification,notInvalid}_of_wellTyped`, `tail_resumptive_{wellTyped,bundle}_direct_call_of_eligible`, and `tailCapability{,ClosedAware}Bundle_{as_components,coreCapability,resultCapability,notInvalid}_of_wellTyped`). `Kea/Properties/NestedHandlerCompositionContracts.lean` added nested same-target capstones + bundle (`NestedHandlerBundle`), structural decomposition parity for nested bundles (`nestedHandler{,ClosedAware}Bundle_{iff_components,of_components,as_components}`), an explicit closed-aware→normalized bridge for dual present/open branch assumptions (`nestedComposeClosedAware_eq_nestedCompose_of_present_or_open`), and an open-row corollary (`nestedComposeClosedAware_eq_nestedCompose_of_open_row`) for common branch-free usage. MCP probes are aligned across capability residual effects and nested same-target control.
- [x] WP6.5 fail/result lowering and catch bridge stack.
  Progress: `Kea/Properties/FailResultContracts.lean`, `FailResultEquivalence.lean`, `EffectPolymorphismSoundness.lean`, `CatchTypingBridge.lean`, and `HigherOrderCatchContracts.lean` now provide the full admissible-catch theorem stack: Fail-as-zero-resume, function-type lowering/equivalence (including closed-aware clause-output capstone `failResultContract_sound_closedAware` and decomposition helpers `failResultEquivalenceBundle_{iff_components,of_components,as_components}`), admissibility partition (`catchAdmissible` vs `catchUnnecessary`), named admissible bundles (`AdmissibleEffectPoly*Bundle`), judgment/raw-premise adapters, combined capstone classifiers, and higher-order specialization/bundles/classifiers. `FailResultEquivalence` now also exposes route-level decomposition wrappers for lowering/premise entrypoints (`lowerFailFunctionType_equivalence_bundle_as_components`, `catchTyping_fail_result_equivalence_bundle_as_components_of_premises`, `catchTyping_fail_result_equivalence_result_return_of_premises`). Higher-order/generic catch layers are now explicitly bridged at both capstone and classifier levels (`higherOrderCatchCapstoneOutcome_{of,to}_catchTypingCapstoneOutcome`, `higherOrderCatchClassification_{of_catchTypingClassification,iff_catchTypingClassification}`, `catchTypingClassification_of_higherOrderCatchClassification`, plus `higherOrderCatchTypingJudgment_{capstone,classify}_of_premises_via_catchTypingBridge`), with a packaged interoperability contract surface (`HigherOrderCatchBridgeLaws`, `higherOrderCatchBridgeLaws_of_clauseEffects`, `higherOrderCatchBridgeLaws_*`) and premise-level route wrappers through that package (`higherOrderCatchTypingJudgment_{capstone,classify}_of_premises_via_bridgeLaws`). `Kea/Properties/CatchInteroperabilitySuite.lean` now packages these cross-layer outcomes as classifier/capstone interop suites (`CatchClassifierInteropSuite`, `CatchCapstoneInteropSuite`) with premise constructors and one-hop projections, is imported in `Kea.lean`, and now includes practical constructors for Fail-presence/either-side classifier entry (`..._of_fail_present`, `..._of_genericClassification`, `..._of_higherClassification`) plus capstone projections (`catchCapstoneInteropSuite_{generic,higher}`). Runtime divergences on fail-absent and higher-order catch are closed on current MCP: fail-absent `catch` rejects with `E0012`; fail-present higher-order catch preserves residual non-Fail effects.
  Update: `FailResultEquivalence` now also has direct fail-present route parity for its catch-bridge theorem families (`catchTyping_fail_result_equivalence{,_bundle,_bundle_as_components,_result_return}_of_fail_present`), matching the existing premise-route entry surfaces.
  Update: type-valued admissible/higher-order bundle layers now have explicit structural decomposition surfaces with one-hop projection/reconstruction (`admissibleEffectPoly{Lowering,Handler}Bundle_{as_components,of_components,iff_components}` and `higherOrderCatchBundle_{as_components,of_components,iff_components}`), using `Nonempty`-framed `iff_components` contracts where needed to keep decomposition statements in `Prop`.
  Update: `CatchTypingBridge` now mirrors that decomposition style on its judgment bundle surface (`catchTypingJudgment_bundle_{as_components,of_components,iff_components}`), so catch-judgment consumers can reconstruct/project bundle components directly without dropping to the schema layer.
  Update: `CatchTypingBridge` judgment-bundle decomposition now also has the direct components-route wrapper `catchTypingJudgment_bundle_as_components_of_components`, closing `iff/of/as` theorem-route parity on this type-valued bundle surface.
  Update: raw-premise catch/higher-order entry routes now include full decomposition wrappers (`catchTypingJudgment_bundle_as_components_of_premises`, `higherOrderCatchTypingJudgment_bundle_as_components_of_premises`), so premise-level call sites can obtain complete bundle component witnesses in one step.
  Update: `CatchInteroperabilitySuite` now includes direct premise-route decomposition wrappers (`catchClassifierInteropSuite_as_components_of_premises`, `catchCapstoneInteropSuite_as_components_of_premises`, `catchCapstoneInteropSuite_as_components_of_fail_present`, `catchClassifierInteropSuite_as_components_of_fail_present`), so interop callers can consume explicit component tuples without constructing intermediate suite values first.
  Update: `CatchInteroperabilitySuite` now also includes decomposition wrappers for classifier-constructor routes (`catchClassifierInteropSuite_as_components_of_{genericClassification,higherClassification,capstoneInteropSuite}`), completing one-hop explicit-component access across classifier entry families.
  Update: `CatchInteroperabilitySuite` now also includes direct constructor-route projection wrappers for premise/fail-present entrypaths (`catch{Capstone,Classifier}InteropSuite_{generic,higher,laws}_of_{premises,fail_present}`), allowing one-step access to specific interop facets without explicit suite-value threading.
  Update: `CatchInteroperabilitySuite` now also includes direct classifier-constructor projection wrappers (`catchClassifierInteropSuite_{generic,higher,laws}_of_{genericClassification,higherClassification,capstoneInteropSuite}`), completing one-hop facet access across classifier constructor families as well.
  Update: `CatchInteroperabilitySuite` now also uses explicit component aliases for both suite layers (`CatchClassifierInteropSuiteComponents`, `CatchCapstoneInteropSuiteComponents`) and routes decomposition signatures (including `..._as_components_of_{premises,fail_present,genericClassification,higherClassification,capstoneInteropSuite}`) through those aliases for cleaner downstream theorem APIs.
  Update: `EffectPolymorphismSoundness` now includes premise-level bundle constructors/decomposition wrappers (`admissibleEffectPoly{FailLowering,Handler}_bundle_of_premises` and `..._bundle_as_components_of_premises`), so the base admissible layer also supports direct one-step bundle/component extraction from raw premises.
  Update: catch and higher-order bundle layers now include runtime-admissible fail-present entry/decomposition wrappers (`catchTypingJudgment_bundle_{of,as_components_of}_fail_present`, `higherOrderCatchTypingJudgment_bundle_{of,as_components_of}_fail_present`), aligning full bundle extraction with the same fail-present route already used by capstone classifiers.
  Update: catch and higher-order layers now also expose fail-present classifier/bundle-facet wrappers (`catchTypingJudgment_classify_of_fail_present`, `catchTypingJudgment_bundle_{clauseFailRemoved,rowTailStable,preserves_nonFail,failRemoved}_of_fail_present`, `higherOrderCatchTypingJudgment_classify_of_fail_present`, `higherOrderCatchTypingJudgment_bundle_{clauseFailRemoved,rowTailStable,preserves_nonFail,failRemoved}_of_fail_present`), completing fail-present route parity across classify + projection APIs.
  Update: `HigherOrderCatchContracts` now also has fail-present parity on both bridge-routed families (`higherOrderCatchTypingJudgment_{capstone,classify}_of_fail_present_via_{catchTypingBridge,bridgeLaws}`), so runtime-admissible routes are now explicit across direct and bridged theorem entrypaths.
  Update: catch/higher-order non-bundle core surfaces now also have fail-present wrappers (`catchTypingJudgment_{sound,rowTailStable,preserves_nonFail}_of_fail_present`, `higherOrderCatchTypingJudgment_{sound,admissibility_branch}_of_fail_present`), extending fail-present parity beyond capstone/classify/bundle APIs.
  Update: `CatchTypingBridge` now also has full premise-route bundle-facet parity (`catchTypingJudgment_bundle_{preserves_nonFail,failRemoved}_of_premises` added alongside existing clauseFailRemoved/rowTailStable wrappers), so all four bundle facets are one-hop on both premise and fail-present routes.
  Update: `EffectPolymorphismSoundness` now also includes matching fail-present soundness/bundle/decomposition entry wrappers (`admissibleEffectPoly{FailLowering,HandlerSchema}_sound_of_fail_present`, `admissibleEffectPoly{FailLowering,Handler}_bundle_of_fail_present`, `admissibleEffectPoly{FailLowering,Handler}_bundle_as_components_of_fail_present`), completing fail-present route parity at the base admissible layer.
- [x] WP6.7 package Phase-2 cross-module contract entry surfaces.
  Progress: added `Kea/Properties/EffectHandlerContractSuite.lean` (imported in `Kea.lean`) to aggregate closed-aware handler guarantees (`ClosedAwareResultBundle`), closed-aware capability preservation (`TailCapabilityClosedAwareBundle`), and catch interoperability (`CatchClassifierInteropSuite`) into one theorem surface (`EffectHandlerSuite`) with both premise-level and fail-present constructors, structural decomposition helpers (`effectHandlerSuite_iff_components`, `..._of_components`, `..._as_components`), one-hop projections for handled removal, row-tail stability, legacy handled removal, tail non-invalidity, capability preservation, and generic/higher-order catch classifier outcomes, and direct closed-aware/capability decomposition projections (`effectHandler{,Capstone}Suite_{closedAware_as_components,capabilityClosedAware_as_components}`). `CatchInteroperabilitySuite` now also has symmetric structural decomposition surfaces for both classifier/capstone layers (`catch{Classifier,Capstone}InteropSuite_iff_components`, `..._of_components`, `..._as_components`, `..._laws`) so these modules compose without record-field coupling. `EffectHandlerContractSuite` now also exposes strict capstone-level aggregation (`EffectHandlerCapstoneSuite`) with decomposition helpers, premise/fail-present constructors, capstone->classifier downgrade (`effectHandlerSuite_of_capstoneSuite`), one-hop capstone projections (`effectHandlerCapstoneSuite_{genericCatchCapstone,higherCatchCapstone,catchLaws}`), plus a coherent dual-grade package (`EffectHandlerCatchPairSuite`) with capstone/classifier coherence and pair-level projections (`effectHandlerCatchPairSuite_*`) and explicit component decomposition helpers (`effectHandlerCatchPairSuite_{iff_components,of_components,as_components}`) so one witness carries both classified and fully admissible catch consequences and can be unpacked structurally. A master composition layer (`EffectHandlerCompositionSuite`) now lifts those clause-level consequences into nested closed-aware same-target composition with outer-handler absence premises, adding decomposition, premise/fail-present constructors, and one-hop nested/catch projections (`effectHandlerCompositionSuite_*`) for end-to-end Phase-2 consumption; that master layer now also has direct clause-level one-hop wrappers (`effectHandlerCompositionSuite_{closedAwareHandledRemoved,closedAwareCapability,closedAwareRowTailStable,legacyHandledRemoved,tailNotInvalid,classifierFromCapstone}`), direct classifier/capstone projections (`effectHandlerCompositionSuite_{classifier,capstone}`), direct classifier/capstone decomposition projections (`effectHandlerCompositionSuite_{classifier_as_components,capstone_as_components}`), explicit catch-pair decomposition projection (`effectHandlerCompositionSuite_catchPair_as_components`), direct closed-aware decomposition projection (`effectHandlerCompositionSuite_closedAware_as_components`), direct capability decomposition projection (`effectHandlerCompositionSuite_capabilityClosedAware_as_components`), nested closed-aware decomposition projection (`effectHandlerCompositionSuite_nestedClosedAware_as_components`), and direct open-row bundle projections (`effectHandlerCompositionSuite_{nestedOpenRowBridgeBundle,nestedOpenRowConsequenceBundle}`), to avoid nested pair unpacking at call sites, plus direct capstone decomposition parity (`effectHandlerCompositionSuite_iff_capstone_and_nested`, `..._of_capstone_and_nested`, `..._as_capstone_and_nested`) for capstone-first consumers, explicit nested-vs-clause coherence lemmas on shared invariants (`effectHandlerCompositionSuite_nestedRowTail_eq_closedAwareRowTail`, handled-removal coherence wrappers), a named coherence package (`EffectHandlerNestedClauseCoherenceBundle` with `effectHandlerCompositionSuite_nestedClauseCoherenceBundle` + one-hop projections), and a master composition+coherence package (`EffectHandlerCompositionCoherenceSuite` with `..._of_composition`/`..._of_premises`/`..._of_fail_present`, `..._iff_composition`, one-hop coherence projections, and direct catch/capability/tail projections `..._{genericCatchClassifier,higherCatchClassifier,genericCatchCapstone,higherCatchCapstone,closedAwareCapability,tailNotInvalid}`), now including composition decomposition projections (`effectHandlerCompositionCoherenceSuite_{composition_as_components,composition_as_capstone_and_nested}`), direct catch-layer one-hop projections (`effectHandlerCompositionCoherenceSuite_{catchPair,catchPair_as_components,classifier,capstone,classifierFromCapstone}`), direct classifier/capstone decomposition projections (`effectHandlerCompositionCoherenceSuite_{classifier_as_components,capstone_as_components}`), direct closed-aware decomposition projection (`effectHandlerCompositionCoherenceSuite_closedAware_as_components`), direct capability decomposition projection (`effectHandlerCompositionCoherenceSuite_capabilityClosedAware_as_components`), direct nested-route one-hop projections (`effectHandlerCompositionCoherenceSuite_{nestedClosedAware,nestedClosedAware_as_components,nestedRowTailStable}`), and direct open-row bundle projections (`effectHandlerCompositionCoherenceSuite_{nestedOpenRowBridgeBundle,nestedOpenRowConsequenceBundle}`), so callers can consume composition + coherence through one theorem API without re-threading lower bundles. Constructor routes now also have explicit one-hop decomposition wrappers at every suite layer (`effectHandler{,Capstone}Suite_as_components_of_{premises,fail_present}`, `effectHandlerCatchPairSuite_as_components_of_{premises,fail_present}`, `effectHandlerCompositionSuite_as_components_of_{premises,fail_present}`, `effectHandlerCompositionCoherenceSuite_as_components_of_{premises,fail_present}`), and all composition layers now add direct premise/fail-present facet wrappers (`effectHandlerSuite_{closedAwareHandledRemoved,closedAwareCapability,closedAwareRowTailStable,legacyHandledRemoved,tailNotInvalid,genericCatchClassifier,higherCatchClassifier,catchLaws}_of_{premises,fail_present}`, `effectHandlerCapstoneSuite_{closedAwareHandledRemoved,closedAwareCapability,closedAwareRowTailStable,legacyHandledRemoved,tailNotInvalid,genericCatchCapstone,higherCatchCapstone,catchLaws}_of_{premises,fail_present}`, `effectHandlerCatchPairSuite_{classifier,capstone,catchLaws}_of_{premises,fail_present}`, `effectHandlerCompositionSuite_{classifier,capstone,catchLaws}_of_{premises,fail_present}`, and `effectHandlerCompositionCoherenceSuite_{composition,catchPair,classifier,capstone}_of_{premises,fail_present}`), plus open-row bundle route decomposition wrappers (`effectHandlerNestedOpenRow{Bridge,Consequence}Bundle_as_components_of_open_{base,expr}_row_{premises,fail_present}`). The module now has complete local `...Bundle_of_*` to `...Bundle_as_components_of_*` parity (including nested-clause/open-row bridge/open-row consequence and bridge<->consequence interop constructors). The suite now also exposes closed-aware→normalized nested-bridge wrappers at both composition/coherence levels (`effectHandlerCompositionSuite_nestedClosedAware_eq_nestedCompose_of_present_or_open`, `effectHandlerCompositionCoherenceSuite_nestedClosedAware_eq_nestedCompose_of_present_or_open`) and open-row corollaries (`effectHandlerComposition{,Coherence}Suite_nestedClosedAware_eq_nestedCompose_of_open_expr_row`), includes explicit composition+coherence component decomposition APIs (`effectHandlerCompositionCoherenceSuite_iff_components`, `..._of_components`, `..._as_components`), and now has direct premise-level open-row bridge entrypoints on both layers (`effectHandlerComposition{,Coherence}Suite_nestedClosedAware_eq_nestedCompose_of_open_base_row_of_{premises,fail_present}` plus coherence-layer `..._open_expr_row_of_{premises,fail_present}`), plus a named open-row bridge package (`EffectHandlerNestedOpenRowBridgeBundle` with constructors from composition/coherence/premise routes and one-hop projection, now including direct open-expr-row premise constructors `..._of_open_expr_row_{premises,fail_present}` and structural decomposition helpers `..._{iff_components,of_components,as_components}`), and now extends structural decomposition parity to the nested/clause coherence package (`effectHandlerNestedClauseCoherenceBundle_{iff_components,of_components,as_components}`) with suite-level component projection (`effectHandlerCompositionCoherenceSuite_nestedClauseCoherence_as_components`), so raw phase-2 assumptions can discharge nested bridge/coherence contracts without intermediate package construction.
  Update: completed a cross-module constructor-route parity sweep for existing component constructors by adding `...Bundle_as_components_of_components` wrappers to closed-aware handler (`closedAware{Core,Result}Bundle`), fail-result bridge (`failResultEquivalenceBundle`), nested handler (`nestedHandler{,ClosedAware}Bundle`), operation typing (`operationCallBundle`), tail capability (`tailCapability{,ClosedAware}Bundle`), and tail resumptive (`tailResumptive{,ClosedAware}Bundle`) layers.
  Update: extended components-route parity to newer suite layers by adding `..._as_components_of_components` wrappers for `DimKernelSuite`, `ShapeConstDimKernelSuite`, and the principal full-vertical master capstones (`principalBoundarySound{,NoUnify}FullVerticalMasterCapstone_as_components_of_components`), then reran corrected full-corpus scans over `formal/Kea` to verify no remaining `*_of_components` gaps where a matching `*_as_components` surface exists.
  Update: completed generalized route-parity closure for the principal full-vertical master capstones by adding `..._as_components_of_<route>` wrappers on all current route constructors (`principalBoundarySoundFullVerticalMasterCapstone_of_{masterRoutes,success,success_from_bundle,success_via_rowPolyBoundarySoundBundle,fullVerticalSuite}` and `principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_{masterCapstone,success,success_from_bundle,fullVerticalSuite,noUnifyMasterRoutes_{regular,dual},noUnifyMasterRoutes}`), then reran corrected full-corpus scans over `formal/Kea` to verify no remaining `*_of_<route>` gaps where a matching `*_as_components` surface exists.
  Update: extended the same generalized route-parity closure to `principalBoundarySoundNoUnifyFullVerticalSuite` by adding `..._as_components_of_<route>` wrappers for all current suite constructor routes (`..._of_{masterCapstone,success,success_from_bundle,fullVerticalSuite,success_via_rowPolyBoundarySoundBundle{,_from_bundle,_proved,_proved_from_bundle,_via_dualConsequenceSlices,_via_dualConsequenceSlices_from_bundle},success_via_typingRunBundleSuite{,_from_bundle,_via_dualConsequenceSlices,_via_dualConsequenceSlices_from_bundle},noUnifyMasterSurface}`), including a local Lean implicit-hook fix on three dual/proved wrapper signatures before final verification.
  Update: extended generalized route-parity closure to `principalBoundarySoundNoUnifyFullVerticalMasterSurface` by adding `..._as_components_of_<route>` wrappers for every current unified no-unify master-surface constructor route (core routes/capstones/suites/consequences plus all exposed `success_via_*` families, bundled and unbundled), then reran corrected full-corpus scans over `formal/Kea` to verify no remaining `principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_<route>` gaps against its `..._as_components` base.
  Update: completed theorem-side parity for the remaining type-valued bundles with noncomputable component constructors by adding `admissibleEffectPoly{Lowering,Handler}Bundle_as_components_of_components` and `higherOrderCatchBundle_as_components_of_components`.
  Update: completed suite-level components-route parity by adding direct `..._as_components_of_components` wrappers on catch interoperability and handler aggregate suites (`catch{Classifier,Capstone}InteropSuite` and `effectHandler{,Capstone,CatchPair,Composition,CompositionCoherence}Suite`).
  Update: `EffectHandlerContractSuite` now also has explicit component aliases for those aggregate suites (`EffectHandler{,Capstone,CatchPair,Composition,CompositionCoherence}SuiteComponents`) and routes `iff/of/as` decomposition signatures (including `..._as_components_of_{capstone,composition}`) through the aliases for clearer theorem surfaces.
  Update: closed the remaining global `*SuiteComponents` alias gap in `Kea/Typing.lean` by adding aliases for all previously uncovered principal/boundary suite structures (`PrincipalBoundaryBridgeSuite`, `PrincipalPreconditionedAllHooksSuite`, `PrincipalBoundaryVacuitySuite`, `PrincipalBoundaryNoUnifyAllHooksSuite`, `PrincipalNoUnifyToGeneralAllHooksSuite`, `PrincipalBoundaryMasterSuite`, `PrincipalBoundaryMasterRunBundleSuite`, `PrincipalBoundaryMasterRunBundleConsequenceSuite`, `PrincipalBoundaryMasterConsequenceCapstoneSuite`, `PrincipalBoundarySoundTypingRunBundleSuite`, `PrincipalBoundarySoundFullSuite`, `PrincipalBoundarySoundFullVerticalSuite`, `PrincipalBoundarySoundNoUnifyFullVerticalSuite`).
  Update: started suite-level decomposition rollout on that typing principal surface by adding `iff/of/as/as_components_of_components` theorem families for `PrincipalBoundaryBridgeSuite`, `PrincipalPreconditionedAllHooksSuite`, and `PrincipalBoundaryVacuitySuite`, so those principal bundles now support one-hop reconstruction/projection through named component aliases.
  Update: extended that decomposition rollout to the no-unify/master principal cluster by adding matching `iff/of/as/as_components_of_components` theorem families for `PrincipalBoundaryNoUnifyAllHooksSuite`, `PrincipalNoUnifyToGeneralAllHooksSuite`, and `PrincipalBoundaryMasterSuite`.
  Update: extended decomposition coverage further to master consequence and sound suite layers by adding matching theorem families for `PrincipalBoundaryMasterRunBundleSuite`, `PrincipalBoundaryMasterRunBundleConsequenceSuite`, `PrincipalBoundaryMasterConsequenceCapstoneSuite`, `PrincipalBoundarySoundTypingRunBundleSuite`, `PrincipalBoundarySoundFullSuite`, and `PrincipalBoundarySoundFullVerticalSuite` (while preserving pre-existing canonical decomposition surfaces for `PrincipalBoundarySoundNoUnifyFullVerticalSuite`).
  Update: added one-hop constructor-route decomposition wrappers on those new suite layers (`principalBoundaryMasterRunBundleSuite_as_components_of_master`, `principalBoundaryMasterRunBundleConsequenceSuite_as_components_of_{runBundleSuite,master,proved}`, `principalBoundaryMasterConsequenceCapstoneSuite_as_components_of_{master,proved}`, and `principalBoundarySoundTypingRunBundleSuite_as_components_of_{hooks,hook_bundle}`), so route constructors now expose explicit component tuples without intermediate suite plumbing.
  Update: extended that route-level decomposition pattern to boundary-sound full/full-vertical constructors by adding `principalBoundarySound{Full,FullVertical}Suite_as_components_of_success_via_{typingRunBundleSuite,typingRunBundleSuite_from_bundle,rowPolyBoundarySoundBundle,rowPolyBoundarySoundBundle_from_bundle}`.
  Update: extended alias/decomposition parity to the boundary-sound run/typing route packages in `Kea/Typing.lean` by adding `...Components` plus `..._{iff_components,of_components,as_components,as_components_of_components}` for `PrincipalBoundarySound{Expr,Field,NoUnifyExpr,NoUnifyField}RunBundleRoutes` and `PrincipalBoundarySound{Expr,Field,NoUnifyExpr,NoUnifyField}TypingRunBundleRoutes`.
  Update: extended the same alias/decomposition parity to dual-master no-unify route layers for consequence/capstone coherence packages by adding `...Components` and `..._{iff_components,of_components,as_components,as_components_of_components}` over `PrincipalNoUnify{Expr,Field}RunBundleConsequencesBothMasterConsequenceRoutes` and `PrincipalNoUnify{Expr,Field}AllHooksCapstonesBothMasterConsequenceRoutes`.
  Update: completed that dual-master no-unify route parity sweep by adding the same decomposition families for `PrincipalNoUnify{Expr,Field}AllHooksRunBundlesBothMasterConsequenceRoutes`, `PrincipalNoUnify{Expr,Field}HookIrrelevanceBothMasterConsequenceRoutes`, and `PrincipalNoUnify{Expr,Field}AllHooksRouteSurfaceBothMasterConsequenceRoutes`; a `structure ...Routes` alias scan in `Kea/Typing.lean` now returns empty.
  Update: added matching base-surface decomposition contracts for `PrincipalNoUnify{Expr,Field}AllHooksRouteSurface` (`...Components` plus `..._{iff_components,of_components,as_components,as_components_of_components}`), aligning base per-route theorem surfaces with the now-complete dual-master wrappers.
  Update: extended that same decomposition layer to `PrincipalNoUnify{Expr,Field}RunBundleConsequences` with `...Components` plus `..._{iff_components,of_components,as_components,as_components_of_components}`, so no-unify consequence bundles and no-unify all-hooks surfaces now share one alias-driven reconstruction/projection style.
  Update: applied identical alias/decomposition parity to boundary+sound `Principal{Expr,Field}RunBundleConsequences` (`...Components` plus `..._{iff_components,of_components,as_components,as_components_of_components}`), aligning consequence-bundle APIs between no-unify and general routes.
  Update: extended that alias/decomposition parity to the direct boundary+sound full bundles (`PrincipalBoundarySound{Expr,Field,NoUnifyExpr,NoUnifyField}Full`) by adding `...Components` plus `..._{iff_components,of_components,as_components,as_components_of_components}` for each surface.
  Update: extended this component-route decomposition style to dual-bundle bridge packages (`PrincipalTypingDualConsequence`, `PrincipalFieldTypingDualConsequence`) with `...Components` and `..._{iff_components,of_components,as_components,as_components_of_components}`.
  Update: applied the same decomposition pattern to recursive soundness bundle layers (`InferUnifyHasTypeUSoundBundle`, `InferUnifySoundDualBundle`) with `...Components` and `..._{iff_components,of_components,as_components,as_components_of_components}`, then cleaned newly introduced unused-parameter warnings by underscore-prefixing alias binders.
  Update: extended decomposition parity into the no-unify bridge/capstone layer by adding `...Components` and `..._{iff_components,of_components,as_components,as_components_of_components}` for `Principal{,Field}NoUnifyBridgeBundle` and `PrincipalBoundaryNoUnify{Expr,Field}AllHooksCapstone`.
  Update: extended that decomposition parity to direct no-unify and all-hooks capstone/run-bundle surfaces by adding `...Components` and `..._{iff_components,of_components,as_components,as_components_of_components}` for `PrincipalBoundaryNoUnify{Expr,Field}Capstone`, `PrincipalPreconditioned{Expr,Field}AllHooksCapstone`, and `PrincipalPreconditioned{Expr,Field}AllHooksRunBundle`.
  Update: closed remaining current route-level decomposition gaps on typing principal/sound suites by adding missing wrappers for dual-consequence and proved/master-capstone constructor families (`principal{NoUnifyToGeneralAllHooks,BoundaryNoUnifyAllHooks,BoundaryBridge,BoundaryMaster}Suite_as_components_of_*`, `principalBoundarySoundFullSuite_as_components_of_success_via_rowPolyBoundarySoundBundle_{proved,proved_from_bundle,via_dualConsequenceSlices,via_dualConsequenceSlices_from_bundle}`, and `principalBoundarySoundFullVerticalSuite_as_components_of_{masterCapstone,success_via_rowPolyBoundarySoundBundle_{proved,proved_from_bundle,via_dualConsequenceSlices,via_dualConsequenceSlices_from_bundle},success_via_typingRunBundleSuite_via_dualConsequenceSlices{,_from_bundle}}`), with a follow-up corpus scan showing no remaining `*_of_<route> -> *_as_components_of_<route>` gaps for theorem bases exposing `*_as_components`.
  Update: extended the same alias/decomposition contract style from suite layers into full-vertical route packages by adding explicit components aliases and `iff/of/as` decomposition families for `PrincipalBoundarySound{,NoUnify}FullVertical{,Master}Routes`.
  Update: completed `as_components` premise/fail-present route parity on effect-handler projection families (`effectHandlerCatchPairSuite_{classifier,capstone}`, `effectHandlerCompositionSuite_{classifier,capstone}`, and `effectHandlerCompositionCoherenceSuite_{composition,catchPair,classifier,capstone}` now each expose `..._as_components_of_{premises,fail_present}`).
  Update: completed generalized decomposition-route parity for all current theorem families with `*_as_components` bases (`*_of_<route> -> *_as_components_of_<route>`), including capstone-derived and outer-absence/coherence constructors (`effectHandlerSuite_of_capstoneSuite`, `effectHandlerCatchPairSuite_of_capstone`, `effectHandlerCompositionSuite_of_{capstone_and_nested,pair_outer_absent}`, `effectHandlerCompositionCoherenceSuite_of_composition`).
- [x] WP6.6 unify entry API across Phase-2 capstones.
  Completed by adding shared closed-aware entry packaging (`ClosedAwareResultBundle`, `closedAwareResultBundle_of_wellTyped`, `wellTypedSlice_implies_handled_removed_legacy_via_closedAware`) and routing fail/catch bridge surfaces through it (`FailResultContracts`, `EffectPolymorphismSoundness`, plus direct catch/higher-order adapters `catchTypingJudgment_clauseFailRemoved_via_closedAware`, `higherOrderCatchTypingJudgment_clauseFailRemoved_via_closedAware`, `catchTypingJudgment_clauseRowTailStable_closedAware`, `higherOrderCatchTypingJudgment_clauseRowTailStable_closedAware`), alongside closed-aware nested-handler capstones (`nestedComposeClosedAware`, `nested_handlers_compose_closedAware`, `NestedHandlerClosedAwareBundle`) and closed-aware tail-capability surfaces (`wellTyped_capability_direct_call_sound_closedAware`, `TailCapabilityClosedAwareBundle`).

## M7. Type Universe Parity (In Progress)

- [x] Add a cross-family boundary-surface package theorem (`boundary_surface_suite`) that composes per-family boundary slices and the dynamic/wrapper/grouped-tagged typing bridges (at explicit boundary sites) into one reusable citation contract.
- [x] Add an expression-level ascription bridge slice (`BoundaryAscriptionSyntax`) and wire it into the cross-family boundary surface suite.
- [x] Add a minimal algorithmic Dynamic-ascription checker (`inferDynamicAscriptionAtSite`) with soundness and variable boundary witnesses.
- [x] Package algorithmic Dynamic-ascription outcomes (`DynamicAscriptionAlgorithmicSliceAtSite`) and lift them into the cross-family boundary surface suite.
- [x] Add algorithmic↔declarative Dynamic-ascription alignment witnesses (`dynamicAscriptionAlgorithmicDeclarativeVarAlignmentAtSite`) for the core `x : Dynamic` boundary probe.
- [x] Add wrapper/grouped algorithmic ascription checkers (`inferWrapperAscriptionAtSite`, `inferGroupedTaggedAscriptionAtSite`) with site-level witness slices and lift them into the cross-family boundary surface suite.
- [x] Add wrapper/grouped algorithmic↔declarative alignment witnesses (`wrapperAscriptionAlgorithmicDeclarativeTaskAlignmentAtSite`, `groupedAscriptionAlgorithmicDeclarativeAlignmentAtSite`).
- [x] Package cross-family ascription algorithmic↔declarative alignment (`AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites`) and lift it into the cross-family boundary surface suite.
- [x] Package a unified ascription bridge suite (`BoundaryAscriptionBridgeSuiteAtSites`) and consume it from `boundary_surface_suite`.
- [x] Add expression-level `inferExpr` integration adapters/slice for ascription surfaces (`infer*ExprWithAscriptionAtSite`, `AscriptionInferExprBridgeSliceAtSites`) and fold into `BoundaryAscriptionBridgeSuiteAtSites`.
- [x] Lift `AscriptionInferExprBridgeSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Add expression-level ascription completeness slice (`AscriptionInferExprCompletenessSliceAtSites`) and fold into `BoundaryAscriptionBridgeSuiteAtSites`.
- [x] Lift `AscriptionInferExprCompletenessSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Lift `AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Add `.base` embedding slice (`AscriptionBaseEmbeddingSliceAtSites`) and fold into `BoundaryAscriptionBridgeSuiteAtSites`.
- [x] Lift `AscriptionBaseEmbeddingSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Move generic ascription primitives into `Rill/Typing.lean` (`HasTypeAtCoreBoundary`, `CoreExprWithAscription`, `HasTypeWithAscription`, `inferExprWithAscription` + soundness/completeness/iff) and rewire boundary modules to consume the core definitions.
- [x] Add Typing-level `.base` conservativity lemmas for ascription inference (`inferExprWithAscription_base_eq`, `inferExprWithAscription_base_iff`) as preparation for eventual base-`CoreExpr` `ascribe` integration.
- [x] Add Typing-level `.ascribe` boundary-equivalence lemma (`inferExprWithAscription_ascribe_iff_boundary`) to bridge algorithmic inference directly to `HasTypeAtCoreBoundary`.
- [x] Route wrapper/grouped ascription algorithmic checkers through Typing core `inferExprWithAscription` and revalidate mismatch/identity MCP controls.
- [x] Add expression-level core-infer routing slice (`AscriptionCoreInferRoutingSliceAtSites`) and lift it into both `BoundaryAscriptionBridgeSuiteAtSites` and `boundary_surface_suite`.
- [x] Relax wrapper/grouped boundary-gate semantics from strict empty-substitution success to existential unifier success (`∃ st', unify ... = .ok st'`), then restore fully quantified expression-level infer surfaces (`inferWrapperExprWithAscriptionAtSite_sound`/`_complete`/`_iff`, `inferGroupedTaggedExprWithAscriptionAtSite_sound`/`_complete`/`_iff`) and lift `AscriptionInferExprBridgeSliceAtSites` to a fully quantified cross-family soundness slice.
- [x] Add explicit ascription-node equivalence theorems for wrapper/grouped adapters (`inferWrapperAscriptionAtSite_iff`, `inferGroupedTaggedAscriptionAtSite_iff`) to close the local algorithmic↔declarative bridge at `.ascribe`.
- [x] Route wrapper/grouped ascription-node equivalence through Typing-core boundary bridges (`inferWrapperAscriptionAtSite_iff_boundary`, `inferGroupedTaggedAscriptionAtSite_iff_boundary`) and derive local `HasTypeWith*Ascription` iff theorems from those boundary-level contracts.
- [x] Generalize `AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites` from witness probes to fully quantified ascription-level equivalence across Dynamic/wrapper/grouped adapters (using `inferDynamicAscriptionAtSite_iff`, `inferWrapperAscriptionAtSite_iff`, `inferGroupedTaggedAscriptionAtSite_iff`).
- [x] Add derivation theorems from the packaged `infer`↔`HasType` slice (`ascriptionInferExprIffSliceAtSites_implies_bridge`, `..._implies_completeness`) to make slice-strength relationships explicit.
- [x] Add nominal ADT language-level typing bridge and nominal algorithmic ascription slice (`HasTypeAtNominalAdtBoundaryAtSite`, `NominalAdtTypingBridgeSliceAtSites`, `inferNominalAscriptionAtSite`, `NominalAdtAscriptionAlgorithmicSliceAtSite`) and lift them into `boundary_surface_suite`.
- [x] WP7.1 low-risk leaf parity (`Html`/`Markdown`/`Atom`/`Date`/`DateTime`) with vertical theorem slice (`TemporalLeafParity`), explicit site-level leaf boundary-policy package (`leaf_boundary_surface_slice`), and MCP validation.
- [ ] WP7.2 precision numerics + dimension kernel (`IntN`/`FloatN`/`Dim`/`DimVar`).
  Progress: `IntN`/`FloatN` landed in `Ty.lean` and propagated through substitution/free-vars/occurs/generalize/typing/unification proof surfaces; added explicit theorem slice `PrecisionLeafParity`, now including precision unification decision/iff contracts (`intN_unify_decision`, `intN_unify_ok_iff_constructor_beq_true`, `floatN_unify_decision`, `floatN_unify_ok_iff_constructor_beq_true`) and an explicit site-level precision boundary-policy layer (`PrecisionBoundarySite`, `precisionBoundaryAllowsAtSite`) with packaged closure theorem `precision_boundary_surface_slice` for width-mismatch and non-precision rejection surfaces. Added standalone `Dim`/`DimVar` kernel module (`Rill/Dimensions.lean`) with proved substitution/idempotence/unification lemmas, now including explicit decision/characterization contracts (`unifyDim_of_beq_true`, `unifyDim_const_decision`, `unifyDim_const_some_iff_eq`, `unifyDim_const_none_iff_ne`, `unifyDim_const_some_implies_empty`), explicit var/const binding contracts (`unifyDim_const_var_binds`, `unifyDimList_single_var_const_binds`, `unifyDimList_single_const_var_binds`, `unifyDimList_pair_var_const_binds_distinct`, `unifyDimList_pair_const_var_binds_distinct`, `unifyDimList_pair_same_var_const_binds_of_eq`, `unifyDimList_pair_same_var_const_none_of_ne`, `unifyDimList_pair_same_var_const_decision`, `unifyDimList_pair_const_same_var_binds_of_eq`, `unifyDimList_pair_const_same_var_none_of_ne`, `unifyDimList_pair_const_same_var_decision`, `unifyDimList_pair_var_const_some_iff_var_distinct_or_consts_eq`, `unifyDimList_pair_var_const_none_iff_var_eq_and_consts_ne`, `unifyDimList_pair_const_var_some_iff_var_distinct_or_consts_eq`, `unifyDimList_pair_const_var_none_iff_var_eq_and_consts_ne`), plus pointwise dim-list kernel contracts (`unifyDimList_reflexive`, `unifyDimList_consts_some_iff_eq`, `unifyDimList_consts_some_implies_empty`, `unifyDimList_consts_none_iff_ne`, `unifyDimList_consts_decision`, `unifyDimList_head_const_mismatch_none`, `unifyDimList_consts_length_mismatch_none`, `unifyDimList_consts_none_implies_beq_false`). MCP revalidation confirms precision boundary diagnostics (`Int32`→`Int64`, `Float32`→`Float64`, `Int`→`Int32`) and decimal checks remain aligned (`Decimal(10, 2)` accepted; scale mismatch rejects with dimension mismatch). Remaining scope is deeper dim-aware theorem families (beyond constructor-local parity slices).
  Update: `Kea/Dimensions.lean` now packages those constant dim-list kernel contracts into a named theorem surface (`DimConstListKernelSlice` via `dimConstListKernelSlice`), so downstream shape/decimal proofs can consume the full decision/mismatch/BEq contract set from one witness.
  Update: `Kea/Dimensions.lean` now also packages scalar `unifyDim` contracts into `DimConstKernelSlice` (`dimConstKernelSlice`), bundling BEq-driven success, constant decision/equivalence/mismatch, empty-substitution closure, and var/const bind routes behind one reusable scalar-kernel witness.
  Update: `Kea/Dimensions.lean` now exports a combined dimension-kernel suite (`DimKernelSuite` via `dimKernelSuite`) that packages both scalar (`DimConstKernelSlice`) and list (`DimConstListKernelSlice`) contract surfaces under one witness.
  Update: `DimKernelSuite` now has explicit decomposition/reconstruction parity (`dimKernelSuite_{as_components,of_components,iff_components}`) so scalar/list kernel consumers can switch between suite and component-pair forms in one theorem step.
  Update: `DimKernelSuite` now also exposes an explicit component alias (`DimKernelSuiteComponents`) and routes decomposition signatures through that alias for cleaner downstream APIs.
  Update: `PrecisionLeafParity` now includes explicit failure-side iff contracts (`intN_unify_err_iff_constructor_beq_false`, `floatN_unify_err_iff_constructor_beq_false`), completing constructor-level success+failure characterization for precision leaves.
  Update: `PrecisionLeafParity` now packages those constructor contracts behind `PrecisionConstructorKernelSlice` (`precisionConstructorKernelSlice`), so IntN/FloatN success/rejection/decision outcomes are consumable from one named precision witness.
  Update: `PrecisionConstructorKernelSlice` now has structural decomposition helpers (`precisionConstructorKernelSlice_{as_components,of_components,iff_components,as_components_of_components}`), aligning precision package consumption with the project-wide suite decomposition API style.
  Update: `PrecisionConstructorKernelSlice` now also exposes an explicit component alias (`PrecisionConstructorKernelSliceComponents`) and routes decomposition signatures through that alias for cleaner downstream API surfaces.
- [ ] WP7.3 decimal constructor parity.
  Progress: added `Ty.decimal` and proof slice `Rill/Properties/DecimalParity.lean` (substitution leaf, reflexive unification, constructor-BEq success/failure decision lemmas, exact decision equation + success-iff-BEq characterization, precision/scale mismatch witnesses, free-var lemmas, and bidirectional constant-dimension dim-kernel bridges: success `decimal_unify_consts_of_dim_kernel_success`, kernel-failure rejection `decimal_unify_consts_reject_of_prec_dim_kernel_none` / `decimal_unify_consts_reject_of_scale_dim_kernel_none` / `decimal_unify_consts_reject_of_dim_kernel_none`, plus success characterization `decimal_unify_consts_ok_iff_dim_kernel_success`); `DecimalParity` now also includes an explicit site-level decimal boundary-policy layer (`DecimalBoundarySite`, `decimalBoundaryAllowsAtSite`) with packaged closure theorem `decimal_boundary_surface_slice` for scale/precision mismatch and non-decimal rejection surfaces. MCP loop confirms runtime decimal annotation strictness after the implementation fix, including scale-mismatch and non-decimal boundary diagnostics on this surface path. Remaining scope is full dim-aware decomposition in the main unifier.
  Update: `DecimalParity` now adds explicit constant-dimension failure characterization and result decision lemmas (`decimal_unify_consts_err_iff_dim_kernel_none`, `decimal_unify_consts_decision_of_dim_kernel_none`), tightening the decimal bridge from dim-kernel outcomes to main unifier success/failure behavior.
  Update: `DecimalParity` now also includes the constructor-level rejection dual (`decimal_unify_err_iff_constructor_beq_false`), completing BEq-based success/failure iff coverage on the decimal constructor route.
  Update: `DecimalParity` now packages those constant-dimension bridge contracts behind `DecimalConstDimKernelSlice` (`decimalConstDimKernelSlice`), so success/rejection/iff/decision consequences are consumable from one named decimal dim-kernel witness.
  Update: `DecimalConstDimKernelSlice` now has explicit structural decomposition helpers (`decimalConstDimKernelSlice_{as_components,of_components,iff_components,as_components_of_components}` with `DecimalConstDimKernelSliceComponents`), aligning decimal package consumption with the suite decomposition API style.
  Update: `DecimalParity` now also provides a combined numeric package (`NumericConstructorKernelSuite` via `numericConstructorKernelSuite`) that bundles precision constructor and decimal dim-kernel contract slices into one theorem surface.
  Update: `NumericConstructorKernelSuite` now has explicit structural decomposition helpers (`numericConstructorKernelSuite_{as_components,of_components,iff_components,as_components_of_components}`), matching the project-wide package decomposition API style.
  Update: `NumericConstructorKernelSuite` now also exposes an explicit component alias (`NumericConstructorKernelSuiteComponents`) and routes decomposition signatures through that alias for cleaner downstream APIs.
- [ ] WP7.4 shape-carrying constructors (`FixedSizeList`/`Tensor`).
  Progress: constructors landed in `Ty.lean` and now propagate through substitution/free-vars/occurs/generalize plus typing-proof exhaustiveness; main unifier now has constructor branches for fixed-size-list/tensor; added vertical theorem slice `Rill/Properties/ShapeConstructorParity.lean` (substitution-step decomposition, reflexive unification, size/rank mismatch witnesses, element-type mismatch witnesses under matching metadata, normalized reduction/rejection contracts under explicit non-short-circuit preconditions, explicit any-fuel inner-branch propagation lemmas `fixedSizeList_inner_error_propagates_any_fuel`/`fixedSizeList_inner_success_propagates_any_fuel`/`tensor_inner_error_propagates_any_fuel`/`tensor_inner_success_propagates_any_fuel`, generalized successor-fuel mismatch contracts `fixedSizeList_dim_mismatch_any_fuel`/`tensor_rank_mismatch_any_fuel` plus arbitrary-inner mismatch generalizations `fixedSizeList_dim_mismatch_any_elem_any_fuel`/`tensor_shape_mismatch_any_elem_any_fuel`, explicit mixed var/const metadata rejection witnesses (`fixedSizeList_var_const_dim_mismatch_any_elem_any_fuel`, `fixedSizeList_const_var_dim_mismatch_any_elem_any_fuel`, `tensor_rank1_var_const_shape_mismatch_any_elem_any_fuel`, `tensor_rank1_const_var_shape_mismatch_any_elem_any_fuel`), explicit kernel-vs-constructor witnesses for mixed fixed-size-list/rank-1/rank-2 tensor metadata (`fixedSizeList_var_const_dim_kernel_success`, `fixedSizeList_const_var_dim_kernel_success`, `fixedSizeList_var_const_kernel_success_but_unify_rejects`, `fixedSizeList_const_var_kernel_success_but_unify_rejects`, `tensor_rank1_var_const_dim_kernel_success`, `tensor_rank1_const_var_dim_kernel_success`, `tensor_rank1_var_const_kernel_success_but_unify_rejects`, `tensor_rank1_const_var_kernel_success_but_unify_rejects`, `tensor_rank2_var_const_dim_kernel_success_distinct`, `tensor_rank2_var_const_kernel_success_but_unify_rejects_distinct`, `tensor_rank2_const_var_dim_kernel_success_distinct`, `tensor_rank2_const_var_kernel_success_but_unify_rejects_distinct`, `tensor_rank2_var_const_dim_kernel_some_iff_var_distinct_or_consts_eq`, `tensor_rank2_var_const_dim_kernel_none_iff_var_eq_and_consts_ne`, `tensor_rank2_const_var_dim_kernel_some_iff_var_distinct_or_consts_eq`, `tensor_rank2_const_var_dim_kernel_none_iff_var_eq_and_consts_ne`, `tensor_rank2_mixed_dim_kernel_pair_decomposition_slice`, `tensor_rank2_same_var_const_dim_kernel_success_of_eq`, `tensor_rank2_same_var_const_dim_kernel_none_of_ne`, `tensor_rank2_same_var_const_dim_kernel_some_iff_eq`, `tensor_rank2_same_var_const_unify_rejects_any`, `tensor_rank2_same_var_const_ok_iff_dim_kernel_success_iff_ne`, `tensor_rank2_same_var_const_ok_iff_dim_kernel_success_of_ne`, `tensor_rank2_same_var_const_kernel_success_but_unify_rejects_of_eq`, `tensor_rank2_const_same_var_dim_kernel_success_of_eq`, `tensor_rank2_const_same_var_dim_kernel_none_of_ne`, `tensor_rank2_const_same_var_dim_kernel_some_iff_eq`, `tensor_rank2_const_same_var_unify_rejects_any`, `tensor_rank2_const_same_var_ok_iff_dim_kernel_success_iff_ne`, `tensor_rank2_const_same_var_ok_iff_dim_kernel_success_of_ne`, `tensor_rank2_const_same_var_kernel_success_but_unify_rejects_of_eq`, `tensor_rank2_same_var_ok_iff_dim_kernel_success_split`, `tensor_rank2_same_var_const_non_generalization_iff_eq`, `tensor_rank2_const_same_var_non_generalization_iff_eq`, `tensor_rank2_same_var_non_generalization_split_iff_eq`, `tensor_rank2_var_const_non_generalization_by_var_equality`, `tensor_rank2_const_var_non_generalization_by_var_equality`, `tensor_rank2_mixed_non_generalization_by_var_equality_slice`, `tensor_rank2_var_const_ok_iff_dim_kernel_success_iff_var_eq_and_const_ne`, `tensor_rank2_const_var_ok_iff_dim_kernel_success_iff_var_eq_and_const_ne`, `tensor_rank2_mixed_ok_iff_dim_kernel_success_iff_var_eq_and_const_ne_slice`, `tensor_rank2_var_const_non_generalization_iff_not_var_eq_and_const_ne`, `tensor_rank2_const_var_non_generalization_iff_not_var_eq_and_const_ne`, `tensor_rank2_mixed_non_generalization_iff_not_var_eq_and_const_ne_slice`, `tensor_rank2_var_const_kernel_success_but_unify_rejects_iff_var_distinct_or_consts_eq`, `tensor_rank2_const_var_kernel_success_but_unify_rejects_iff_var_distinct_or_consts_eq`, `tensor_rank2_mixed_kernel_success_but_unify_rejects_iff_var_distinct_or_consts_eq_slice`, `tensor_rank2_var_const_divergence_iff_not_naive_contract`, `tensor_rank2_const_var_divergence_iff_not_naive_contract`, `tensor_rank2_mixed_divergence_iff_not_naive_contract_slice`, `fixedSizeList_var_const_divergence_iff_not_naive_contract`, `fixedSizeList_const_var_divergence_iff_not_naive_contract`, `tensor_rank1_var_const_divergence_iff_not_naive_contract`, `tensor_rank1_const_var_divergence_iff_not_naive_contract`, `mixed_shape_rank1_divergence_iff_not_naive_contract_slice`, `mixed_shape_divergence_iff_not_naive_contract_slice`, `tensor_rank2_same_var_const_divergence_iff_not_naive_contract_of_eq`, `tensor_rank2_const_same_var_divergence_iff_not_naive_contract_of_eq`, `tensor_rank2_same_var_divergence_iff_not_naive_contract_slice_of_eq`), plus packaged mixed-shape boundary citation theorem `mixed_shape_kernel_boundary_slice`, packaged repeated-var rank-2 boundary theorem `tensor_rank2_same_var_kernel_boundary_slice_of_eq`, explicit non-generalization counterexamples in both directions (including repeated-var/equal-constants rank-2 cases), and packaged non-generalization boundary theorems `mixed_shape_non_generalization_slice` and `tensor_rank2_same_var_non_generalization_slice_of_eq`, constant-dimension bridge lemmas `fixedSizeList_unify_consts_of_dim_kernel_success`/`tensor_rank1_unify_consts_of_dim_kernel_success` with explicit eq/ne acceptance/rejection corollaries, explicit dim-kernel match-decision contracts `fixedSizeList_unify_consts_match_decision` and `tensor_rank1_unify_consts_match_decision`, and generalized pointwise dim-list bridge contracts including arbitrary-inner generalizations (`tensor_unify_const_shapes_of_dim_list_kernel_success_any_elem`, `tensor_unify_const_shapes_accept_of_eq_any_elem`, `tensor_unify_const_shapes_reject_of_dim_list_kernel_none_any_elem`, `tensor_unify_const_shapes_reject_of_ne_any_elem`, `tensor_unify_const_shapes_ok_iff_dim_list_kernel_success_any_elem`, `tensor_unify_const_shapes_match_decision_any_elem`, plus `Int` wrappers `tensor_unify_const_shapes_of_dim_list_kernel_success`, `tensor_unify_const_shapes_accept_of_eq`, `tensor_unify_const_shapes_reject_of_dim_list_kernel_none`, `tensor_unify_const_shapes_reject_of_ne`, and extended mismatch/decision contracts `tensor_unify_const_shapes_reject_of_length_mismatch`, `tensor_unify_const_shapes_reject_of_head_mismatch`, `tensor_unify_const_shapes_ok_iff_dim_list_kernel_success`, `tensor_unify_const_shapes_match_decision`), kernel-failure rejection companions `fixedSizeList_unify_consts_reject_of_dim_kernel_none`/`tensor_rank1_unify_consts_reject_of_dim_kernel_none`, and success-iff-kernel-success characterizations `fixedSizeList_unify_consts_ok_iff_dim_kernel_success`/`tensor_rank1_unify_consts_ok_iff_dim_kernel_success`). Post-restart MCP re-check still confirms shape constructor annotation syntax/docs divergence on this surface path.
  Update: scalar-kernel constant-shape routes now also include explicit failure and if/then/else decision duals (`fixedSizeList_unify_consts_{err_iff_dim_kernel_none,decision_of_dim_kernel_none}` and `tensor_rank1_unify_consts_{err_iff_dim_kernel_none,decision_of_dim_kernel_none}`), completing success+failure route characterization for these rank-1 bridge paths.
  Update: `ShapeConstructorParity` now packages the scalar-kernel rank-1 shape bridge into one named witness (`Rank1ShapeConstDimKernelSlice` via `rank1ShapeConstDimKernelSlice`) bundling fixed-size-list and rank-1 tensor `ok ↔ kernel-success`, decision, and kernel-failure rejection contracts.
  Update: `ShapeConstructorParity` now also packages arbitrary-rank tensor constant-shape contracts into one named witness (`TensorConstShapeDimListKernelSlice` via `tensorConstShapeDimListKernelSlice`) bundling pointwise dim-list-kernel success/rejection/decision surfaces (`tensor_unify_const_shapes_*`, including any-element and `Int` wrappers) plus head/length mismatch rejection.
  Update: `ShapeConstructorParity` now exports a top-level constant-shape package (`ShapeConstDimKernelSuite` via `shapeConstDimKernelSuite`) that combines `DimKernelSuite` (plus direct scalar/list fields), `Rank1ShapeConstDimKernelSlice`, and `TensorConstShapeDimListKernelSlice` behind one suite witness.
  Update: `ShapeConstDimKernelSuite` now has explicit decomposition/reconstruction parity (`shapeConstDimKernelSuite_{as_components,of_components,iff_components}`), so top-level shape-suite consumers can switch between suite and explicit component tuples in one theorem step.
  Update: arbitrary-rank tensor constant-shape routes now also expose explicit failure and if/then/else decision duals (`tensor_unify_const_shapes_{err_iff_dim_list_kernel_none,decision_of_dim_list_kernel_none}{,_any_elem}`), completing success+failure characterization against pointwise dim-list-kernel outcomes.
  Update: packaged shape kernel suites now surface those duals directly: `Rank1ShapeConstDimKernelSlice` now exports fixed-size-list/rank-1 tensor `err_iff` + `decision_of_*` fields, and `TensorConstShapeDimListKernelSlice` now exports arbitrary-rank tensor `err_iff` + `decision_of_*` fields for both any-element and `.int` wrapper layers.
  Update: `Rank1ShapeConstDimKernelSlice` now has structural decomposition helpers (`rank1ShapeConstDimKernelSlice_{as_components,of_components,iff_components,as_components_of_components}` with `Rank1ShapeConstDimKernelSliceComponents`), aligning rank-1 shape package consumption with the project-wide suite decomposition style.
  Update: `TensorConstShapeDimListKernelSlice` now has structural decomposition helpers (`tensorConstShapeDimListKernelSlice_{as_components,of_components,iff_components,as_components_of_components}` with `TensorConstShapeDimListKernelSliceComponents`), aligning arbitrary-rank shape package consumption with the same decomposition style.
  Update: `ShapeConstructorParity` now also exposes a unified numeric+shape package (`NumericShapeConstDimKernelSuite` via `numericShapeConstDimKernelSuite`) with full decomposition parity (`..._{as_components,of_components,iff_components,as_components_of_components}`), combining `NumericConstructorKernelSuite` and `ShapeConstDimKernelSuite` behind one theorem surface.
  Update: top-level shape integration suites now expose explicit component aliases (`ShapeConstDimKernelSuiteComponents`, `NumericShapeConstDimKernelSuiteComponents`) and route existing decomposition signatures through those aliases for cleaner downstream API surfaces.
- [ ] WP7.5 nominal ADT parity (`Sum`/`Opaque`).
  Progress: `Sum`/`Opaque` constructors landed in `Ty.lean`, propagated through substitution/free-vars/occurs/generalize/unify plus typing-proof exhaustiveness, and are covered by `Rill/Properties/NominalAdtParity.lean` (substitution-step decomposition, reflexive unification, packaged structural slices `nominal_adt_subst_step_slice`/`nominal_adt_unifies_with_self_slice`/`nominal_adt_free_vars_slice`, nominal-name mismatch witnesses including successor-fuel contracts `sum_name_mismatch_any_fuel`/`opaque_name_mismatch_any_fuel` plus arbitrary-list generalizations `sum_name_mismatch_any_args_any_fuel`/`opaque_name_mismatch_any_params_any_fuel`, constructor-arity mismatch witnesses plus successor+1 fuel contracts `sum_arity_mismatch_any_fuel`/`opaque_arity_mismatch_any_fuel` and arbitrary-list generalizations for both directions `sum_arity_mismatch_any_nonempty_args_any_fuel`/`opaque_arity_mismatch_any_nonempty_params_any_fuel` and `sum_arity_mismatch_empty_vs_nonempty_any_fuel`/`opaque_arity_mismatch_empty_vs_nonempty_any_fuel`, normalized branch-decision equations `sum_unify_branch_decision_of_normalized`/`opaque_unify_branch_decision_of_normalized` plus packaged cross-constructor decision slice `nominal_adt_unify_branch_decision_slice_of_normalized`, normalized reduction/rejection contracts under explicit non-short-circuit preconditions, branch corollaries `sum_unify_accepts_of_normalized_args_ok`/`opaque_unify_accepts_of_normalized_params_ok` plus generic error-propagation corollaries `sum_unify_rejects_args_err_of_normalized`/`opaque_unify_rejects_params_err_of_normalized`, normalized-name-inequality convenience slices `sum_unify_rejects_of_normalized_name_ne`/`opaque_unify_rejects_of_normalized_name_ne` plus packaged cross-constructor slice `nominal_adt_unify_rejects_of_normalized_name_ne_slice`, explicit any-fuel outer-branch propagation lemmas (`sum_args_error_propagates_any_fuel`, `sum_args_success_propagates_any_fuel`, `sum_args_arity_mismatch_propagates_any_fuel`, `opaque_params_error_propagates_any_fuel`, `opaque_params_success_propagates_any_fuel`, `opaque_params_arity_mismatch_propagates_any_fuel`), and arity-rejection specializations `sum_unify_rejects_arity_mismatch_of_normalized`/`opaque_unify_rejects_arity_mismatch_of_normalized`, packaged mismatch slices `nominal_adt_name_mismatch_slice_any_lists_any_fuel`/`nominal_adt_arity_mismatch_slice_any_fuel`/`nominal_adt_mismatch_suite_any_fuel`, free-var lemmas). `NominalAdtParity` now also includes an explicit site-level boundary-policy layer (`NominalAdtBoundarySite`, `nominalAdtBoundaryAllowsAtSite`) with packaged closure theorem `nominal_adt_boundary_surface_slice` for nominal-name mismatch and non-nominal rejection surfaces. `RecordStructuralProjection` now includes both the unifier-symmetry witness `anonRecordUnifiesWithNamedRecord` and policy-closure witnesses (`record_nominal_boundary_closes_unifier_symmetry`, `record_boundary_policy_site_invariant`, `record_boundary_rejects_structural_to_named_all_sites`, `record_boundary_allows_named_to_structural_all_sites`, `record_boundary_directional_policy_all_sites`, `record_nominal_boundary_closes_unifier_symmetry_all_sites`), explicitly modeling that directional nominal-boundary checks must sit above unification at all boundary-sensitive sites. New module `Rill/Properties/NominalAdtTypingBridge.lean` now lifts nominal boundary policy into modeled typing gates (`HasTypeAtNominalAdtBoundaryAtSite`) with packaged ascription/all-sites bridge theorems (`nominal_adt_typing_bridge_ascription`, `nominal_adt_typing_bridge_all_sites`, `NominalAdtTypingBridgeSliceAtSites`), plus a minimal algorithmic nominal ascription checker/equivalence slice (`nominalAscriptionAllowsBoolAtSite`, `inferNominalAscriptionAtSite`, `inferNominalAscriptionAtSite_iff`, `NominalAdtAscriptionAlgorithmicSliceAtSite`), and `boundary_surface_suite` now includes both the nominal typing-bridge and nominal ascription-algorithmic slices explicitly. MCP validation confirms reflexive annotation behavior, nominal mismatch diagnostics (`Alpha` vs `Gamma`, `UserId` vs `OrderId`/`Int`), ADT constructor arity diagnostics (`Circle` expected 1 argument, got 2), structural-to-nominal rejection diagnostics across all four boundary-sensitive sites (`let`/call/return/ascription), named->structural projection control acceptance (`let get_name = r -> r.name; get_name(User { ... })`), normalized nominal mismatch behavior across ADT/opaque decision paths (`A` vs `B`, `Int` vs `UserId`), and non-nominal call-boundary rejection (`expected A, got Int`). Remaining scope is language-level branch-refinement theorem coverage; this is blocked on extending `Typing.CoreExpr` with ADT constructor/case forms.
- [ ] WP7.6 higher-order constructor internals (`Forall`/`App`/`Constructor`/`Existential`).
  Progress: `Forall`/`App`/`Constructor`/`Existential` landed in `Ty.lean`, propagated through substitution/free-vars/occurs/generalize/unify plus typing-proof exhaustiveness, and are covered by `Rill/Properties/HigherOrderConstructorParity.lean` + `Rill/Properties/ForallParity.lean` + `Rill/Properties/ExistentialParity.lean` (substitution-step decomposition, reflexive unification, constructor mismatch witnesses, free-var lemmas, and packaged constructor-app structural slices `constructor_app_subst_step_slice`/`constructor_app_unifies_with_self_slice`/`constructor_app_free_vars_slice`). `ForallParity` now includes generalized alpha-insensitive compatibility, constructor-level alpha-invariance, explicit canonical-equivalence closure lemmas (`forallCanonicalEq_refl/symm/trans`) with unification lifts (`forallCanonicalEq_unifies`, `forallCanonicalEq_unifies_symm`, `forallCanonicalEq_unifies_trans`) and packaged closure witness `forall_canonical_equivalence_slice`, a normalized non-short-circuit branch reduction lemma (`forall_unify_reduces_to_body_unify_of_normalized_foralls`) with accept/reject corollaries (`forall_unify_accepts_of_normalized_body_ok`, `forall_unify_rejects_of_normalized_body_err`) plus arbitrary-state success lifting (`forall_unify_accepts_of_normalized_body_ok_any`), generic body-error propagation (`forall_unify_rejects_of_normalized_body_err_any`), successor-fuel quantified-body mismatch rejection (`forall_body_mismatch_any_fuel`), explicit any-fuel body-error propagation (`forall_body_error_propagates_any_fuel`), explicit any-fuel body-success propagation (`forall_body_success_propagates_any_fuel`), concrete alpha-renaming/vacuous-binder witnesses, packaged structural slice `forall_structural_slice`, packaged concrete surface witness `forall_surface_boundary_slice`, and an explicit site-level boundary-policy layer (`ForallBoundarySite`, `forallBoundaryAllowsAtSite`) with packaged closure theorem `forall_boundary_surface_slice`. `ExistentialParity` now includes normalized reduction/rejection contracts under explicit non-short-circuit preconditions (`existential_unify_reduces_to_assoc_of_normalized`, `existential_unify_rejects_of_normalized`) plus equal-bounds associated-type-list outcome propagation corollaries (`existential_unify_accepts_of_normalized_assoc_ok`, `existential_unify_rejects_assoc_err_of_normalized_bounds_eq`), explicit any-fuel outer-branch propagation lemmas (`existential_assoc_error_propagates_any_fuel`, `existential_assoc_success_propagates_any_fuel`), successor-fuel mismatch rejection witnesses for bounds in both concrete (`existential_bounds_mismatch_any_fuel`) and arbitrary-assoc generalized form (`existential_bounds_mismatch_any_assoc_any_fuel`), associated-type arity in both concrete (`existential_assoc_length_mismatch_any_fuel`) and directional generalized forms (`existential_assoc_length_mismatch_any_nonempty_assoc_any_fuel`, `existential_assoc_length_mismatch_empty_vs_nonempty_any_fuel`), and an explicit site-level existential boundary-policy layer (`ExistentialBoundarySite`, `existentialBoundaryAllowsAtSite`) with packaged closure theorem `existential_boundary_surface_slice`. `HigherOrderConstructorParity` now includes normalized app/constructor branch contracts (`app_unify_branch_of_normalized`, `constructor_unify_reduces_to_fixed_args_of_normalized`, `constructor_unify_rejects_of_normalized_guard_false`), app-branch outcome propagation corollaries (`app_unify_rejects_ctor_err_of_normalized`, `app_unify_accepts_of_normalized_ctor_ok_args_ok`, `app_unify_rejects_args_err_of_normalized_ctor_ok`, `app_unify_rejects_args_arity_mismatch_of_normalized_ctor_ok`, `app_unify_rejects_ctor_guard_false_of_normalized_succ`), explicit any-fuel app propagation lemmas (`app_ctor_error_propagates_any_fuel`, `app_ctor_args_success_propagates_any_fuel`, `app_args_error_propagates_any_fuel`, `app_args_arity_mismatch_propagates_any_fuel`), direct constructor-headed app guard-failure rejection across fuel (`app_constructor_name_mismatch_any_fuel`, `app_constructor_arity_mismatch_any_fuel`, `app_constructor_guard_mismatch_any_fuel`), normalized fixed-argument branch success/error propagation corollaries (`constructor_unify_accepts_of_normalized_fixed_args_ok`, `constructor_unify_rejects_fixed_args_err_of_normalized`, `constructor_unify_rejects_fixed_args_arity_mismatch_of_normalized`), explicit any-fuel fixed-arg propagation lemmas (`constructor_fixed_args_error_propagates_any_fuel`, `constructor_fixed_args_success_propagates_any_fuel`), explicit any-fuel constructor-guard mismatch theorem (`constructor_guard_mismatch_any_fixed_any_fuel`), packaged guard-mismatch suite `constructor_guard_mismatch_suite_any_fuel`, packaged concrete constructor-guard witness `constructor_guard_surface_slice`, plus an explicit site-level constructor-head boundary-policy layer (`ConstructorGuardBoundarySite`, `constructorGuardBoundaryAllowsAtSite`) with packaged closure theorem `constructor_guard_boundary_surface_slice`, and successor-fuel generalized constructor mismatch contracts for arbitrary fixed-argument lists (`constructor_name_mismatch_any_fixed_any_fuel`, `constructor_arity_mismatch_any_fixed_any_fuel`). MCP validation now confirms constructor-parameter arity mismatch diagnostics for `List`/`Map` after the runtime fix (including name/arity mismatch surfaces), alongside existential boundary behavior (`any` accepted; `any Show -> Int`, `any Show -> any Eq`, and `Int -> any Show` rejected), rank-2 annotation parsing/type-checking with the correct `forall a. fn(a) -> a` syntax, acceptance of alpha-renamed/vacuous-binder-compatible quantified arguments, rejection of non-equivalent quantified body shapes at call sites (`argument 1 is not polymorphic enough: expected \`forall a. (a) -> a\``), rejection of non-`forall` arguments at the same boundary, combined List/Map surface guard mismatch diagnostics, and non-constructor-to-constructor call-boundary rejection (`expected List(Int), got Int`). Lean mirrors observed constructor-level `forall` binder canonicalization behavior. Remaining scope is language-level higher-rank theorem/runtime parity (alpha-equivalence/subsumption/evidence interactions).
- [ ] WP7.7 runtime wrappers and boundaries (`Dynamic`/`GroupedFrame`/`Task`/`Actor`/`Arc`/`Tagged`).
  Progress: `Dynamic`/`GroupedFrame`/`Task`/`Actor`/`Arc`/`Tagged` landed in `Ty.lean`, propagated through substitution/free-vars/occurs/generalize/unify plus typing-proof exhaustiveness, and are covered by `Rill/Properties/RuntimeWrapperParity.lean` + `Rill/Properties/GroupedTaggedParity.lean` (substitution-step decomposition, reflexive unification, mismatch witnesses, free-var lemmas). `RuntimeWrapperParity` includes normalized reduction contracts for wrapper constructors, explicit any-fuel wrapper-inner propagation lemmas (`task_inner_error_propagates_any_fuel`, `task_inner_success_propagates_any_fuel`, `actor_inner_error_propagates_any_fuel`, `actor_inner_success_propagates_any_fuel`, `arc_inner_error_propagates_any_fuel`, `arc_inner_success_propagates_any_fuel`), dynamic-var path contracts, successor-fuel dynamic boundary contracts, and function-return absorption witnesses from the earlier permissive slice; it now also includes an explicit Dynamic boundary-policy layer (`DynamicBoundarySite`, `dynamicBoundaryAllowsAtSite`) with site-invariance theorem (`dynamic_boundary_policy_site_invariant`), site-level narrowing/widening witnesses, a general widening law (`dynamic_boundary_allows_dynamic_from_any_all_sites`), a general non-Dynamic narrowing law (`dynamic_boundary_rejects_from_dynamic_all_sites`), closure/widening-alignment theorems (`dynamic_return_boundary_closes_unifier_absorption`, `dynamic_boundary_closes_unifier_absorption_all_sites`, `dynamic_boundary_closes_unifier_absorption_task_all_sites`, `dynamic_boundary_closes_unifier_absorption_bool_all_sites`, `dynamic_boundary_allows_unifier_widening_int_all_sites`, `dynamic_boundary_allows_unifier_widening_task_all_sites`), packaged surface theorem `dynamic_boundary_surface_slice`, and an explicit Task/Actor/Arc wrapper boundary-policy layer (`WrapperBoundarySite`, `wrapperBoundaryAllowsAtSite`) with packaged closure theorem `wrapper_boundary_surface_slice`. `BoundaryAssignability` now provides shared language-level boundary modeling (`HasTypeAtBoundary`, `allowsByBool`, `allowsByBoolAndUnify`) plus relation transport (`hasTypeAtBoundary_congr`) used by all typing-bridge modules; `allowsByBoolAndUnify` now records existential unifier success (`∃ st', unify ... = .ok st'`) rather than strict empty-substitution success. `DynamicBoundaryTypingBridge` now adds modeled ascription and site-generalized Dynamic typing bridges (`HasTypeAtAscriptionBoundaryAtSite`, `HasTypeAtAscriptionBoundary`, `hasTypeAtAscriptionBoundaryAtSite_iff_ascription`, `dynamic_boundary_typing_bridge_ascription`, `dynamic_boundary_typing_bridge_ascription_all_sites`) on top of variable/call-argument/let/return alignment, tying Dynamic boundary rejection to declarative core typing outcomes across boundary-sensitive sites. `WrapperBoundaryTypingBridge` now adds modeled ascription and site-generalized typing bridges for Task/Actor/Arc (`HasTypeAtWrapperBoundaryAtSite`, `HasTypeAtWrapperBoundary`, `hasTypeAtWrapperBoundaryAtSite_iff_ascription`, `wrapper_typing_bridge_ascription`, `wrapper_typing_bridge_all_sites`) plus wrapper uniqueness/mismatch controls, aligning wrapper boundary policy with declarative typing across boundary-sensitive sites. `GroupedTaggedParity` includes explicit inner-type mismatch witnesses, generalized successor-fuel key/metadata mismatch contracts (`groupedFrame_keys_mismatch_any_fuel`, `tagged_metadata_mismatch_any_fuel`) plus arbitrary-inner generalizations (`groupedFrame_keys_mismatch_any_inner_any_fuel`, `tagged_metadata_mismatch_any_inner_any_fuel`), normalized reduction/rejection contracts, explicit any-fuel inner-branch propagation lemmas (`groupedFrame_inner_error_propagates_any_fuel`, `groupedFrame_inner_success_propagates_any_fuel`, `tagged_inner_error_propagates_any_fuel`, `tagged_inner_success_propagates_any_fuel`), and now an explicit site-level grouped/tagged boundary-policy layer (`GroupedTaggedBoundarySite`, `groupedTaggedBoundaryAllowsAtSite`) with packaged closure theorem `grouped_tagged_boundary_surface_slice`. `GroupedTaggedTypingBridge` now adds modeled ascription and site-generalized typing bridges (`HasTypeAtGroupedTaggedBoundaryAtSite`, `HasTypeAtGroupedTaggedBoundary`, `hasTypeAtGroupedTaggedBoundaryAtSite_iff_ascription`, `grouped_tagged_typing_bridge_ascription`, `grouped_tagged_typing_bridge_all_sites`) plus grouped/tagged uniqueness/mismatch controls, aligning grouped/tagged boundary policy with declarative typing across boundary-sensitive sites. `BoundaryAscriptionSyntax` now adds an explicit expression/judgment bridge layer (`CoreExprWithAscription`, `HasTypeWithAscription`, `BoundaryAscriptionSyntaxSliceAtSites`) plus expression-level site-invariance lemmas (`hasTypeWithDynamicAscription_ascribe_iff_ascription`, `hasTypeWithWrapperAscription_ascribe_iff_ascription`, `hasTypeWithGroupedTaggedAscription_ascribe_iff_ascription`), algorithmic Dynamic/wrapper/grouped ascription checkers (`inferDynamicAscriptionAtSite`, `inferWrapperAscriptionAtSite`, `inferGroupedTaggedAscriptionAtSite`) now routed through Typing core `inferExprWithAscription`, site-level algorithmic witness slices (`DynamicAscriptionAlgorithmicSliceAtSite`, `WrapperAscriptionAlgorithmicSliceAtSite`, `GroupedTaggedAscriptionAlgorithmicSliceAtSite`), and packaged algorithmic↔declarative alignment slices (`dynamicAscriptionAlgorithmicDeclarativeVarAlignmentAtSite`, `wrapperAscriptionAlgorithmicDeclarativeTaskAlignmentAtSite`, `groupedAscriptionAlgorithmicDeclarativeAlignmentAtSite`, `AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites`), plus an expression-level `inferExpr` integration slice (`inferDynamicExprWithAscriptionAtSite`, `inferWrapperExprWithAscriptionAtSite`, `inferGroupedTaggedExprWithAscriptionAtSite`, `AscriptionInferExprBridgeSliceAtSites`, `AscriptionInferExprCompletenessSliceAtSites`, `AscriptionInferExprIffSliceAtSites`, `AscriptionCoreInferRoutingSliceAtSites`, `AscriptionBaseEmbeddingSliceAtSites`). Wrapper/grouped expression-level soundness is now fully quantified (`inferWrapperExprWithAscriptionAtSite_sound`, `inferGroupedTaggedExprWithAscriptionAtSite_sound`) with corresponding `iff` surfaces, local `.ascribe`-node equivalence surfaces are explicit (`inferWrapperAscriptionAtSite_iff`, `inferGroupedTaggedAscriptionAtSite_iff`), and both `AscriptionInferExprBridgeSliceAtSites` and `AscriptionInferExprIffSliceAtSites` now carry fully quantified cross-family contracts. `boundary_surface_suite` now includes the packaged ascription bridge suite (`BoundaryAscriptionBridgeSuiteAtSites`) and explicit inferExpr integration/completeness/equivalence slices (`AscriptionInferExprBridgeSliceAtSites`, `AscriptionInferExprCompletenessSliceAtSites`, `AscriptionInferExprIffSliceAtSites`, `AscriptionCoreInferRoutingSliceAtSites`, `AscriptionBaseEmbeddingSliceAtSites`). Rebuilt MCP confirms explicit Dynamic narrowing in implementation (`Dynamic -> concrete` rejected with `expect_type` guidance), confirms Task/Actor/Arc wrapper mismatch plus non-wrapper rejection (`Task(Int)`/`Actor(Int)`/`Arc(Int)` vs `Bool` inner mismatch and `Int` -> wrapper rejection), confirms grouped/tagged wrapper mismatch plus non-wrapper rejection on exposed paths (`GroupedFrame(Bool)` vs `GroupedFrame(Int)`, `Tagged(Bool)` vs `Tagged(Int)`, and `Int` -> grouped/tagged rejection), and confirms Dynamic return/app/let/ascription boundary behavior, while controls remain accepted; parser support for parameterized grouped key/metadata annotation syntax (`keys: [...]`) is still absent in this surface path, so metadata/key mismatch behavior there remains a Lean-level parity contract pending fuller surface syntax exposure. Bare `GroupedFrame`/`Tagged` collapse remains, but is currently treated as expected behavior for parameterless forms in this annotation path. Typing core now owns the generic ascription artifacts (`HasTypeAtCoreBoundary`, `CoreExprWithAscription`, `HasTypeWithAscription`, `inferExprWithAscription` plus soundness/completeness/iff). Remaining scope is deciding whether `ascribe` should be merged into the base `CoreExpr`/`inferExprUnify` surface.

## Operating Checklist (every milestone)

- [ ] `cd formal && lake build` passes.
- [ ] `FORMAL.md` table updated for every new theorem.
- [ ] If MCP is used for validation, append session details to `formal/mcp-log.md`.
- [ ] Keep changes formal-only unless explicitly requested otherwise.
