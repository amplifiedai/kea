# Formalization Bridge Roadmap

Concrete milestone checklist for moving from the current fuel model to an implementation-aligned well-founded substitution model, then lifting that bridge into full language-level metatheory.

## M0. Baseline and Guardrails

- [x] Zero `sorry` in `formal/Rill`.
- [x] Keep a proved preconditioned extension theorem (`unifyRows_extends_rowMap_preconditioned`) as the current contract.
- [x] Keep Rust<->Lean mapping current in `FORMAL.md`.

## M1. Substitution Bridge (In Progress)

- [x] Define acyclicity witness from idempotence (`Subst.acyclicOfIdempotent`).
- [x] Define bounded WF substitution family:
  - `applySubstBounded`
  - `applySubstRowBounded`
  - `applySubstTyListBounded`
  - `applySubstRowFieldsBounded`
- [x] Define top-level WF APIs:
  - `applySubstWF`
  - `applySubstRowWF`
  - `applySubstTyListWF`
  - `applySubstRowFieldsWF`
- [x] Prove key WF lookup/no-op lemmas (`applySubstWF_var_lookup`, `applySubstWF_var_unbound`, row-open variants).
- [x] Prove bind consistency under idempotence for WF (`applySubstWF_bindType_consistent_of_idempotent`, row-tail analogues).
- [x] Add first compat equivalence lemmas on branch-critical shapes:
  - `applySubstCompat_var_eq_applySubstWF_of_idempotent`
  - `applySubstRowCompat_empty_open_eq_applySubstRowWF_of_idempotent`
- [x] Add compat lemmas for non-var/non-open-row constructors (`list`, `map`, `record`, `tuple`) under idempotence/no-domain-vars assumptions.
- [x] Add a single theorem schema for "fuel and WF agree on all values reachable from successful unify branches under idempotence".

## M2. Unify-Level Bridge

- [x] Refactor `Unify` proofs to consume compat lemmas first, fuel details second.
  Completed via `unifyRows_preconditioned_contract_compat_first`, with `unifyRows_extends_rowMap_preconditioned_wf_split` now routed through this compat-first layer.
- [x] Introduce branch-local substitution equivalence lemmas:
  - no-subst-update branches
  - single-bind branches
  - open-open fresh-row branch
- [x] Prove a bridge theorem: successful `unifyRows` branch updates are invariant under swapping `applySubstCompat` for WF substitution, given current preconditions.

## M3. Contract Strengthening

- [x] Re-prove preconditioned global extension theorem with WF substitution phrasing.
- [x] Isolate exactly which assumptions can be weakened from `Idempotent` to `Acyclic`.
- [x] Keep theorem names and statement intent aligned with Rust proptest mapping.

## M4. Typing-System Expansion (Post-Bridge)

- [x] Kickoff slice: add minimal declarative typing + algorithmic soundness for literals, vars, closed anonymous records, and projection (`Rill/Typing.lean`).
- [x] Extend kickoff to monomorphic `let` + typed lambda/application in `Rill/Typing.lean` (syntax-directed app on lambda heads).
- [x] Generalize monomorphic app soundness from lambda-head-only to function-valued expressions in `Rill/Typing.lean`.
- [x] Prove algorithmic/declarative equivalence on the current core slice (`inferExpr_sound`, `inferExpr_complete`, `inferExpr_iff_hasType`).
- [x] Add environment-congruence transport lemmas for core typing (`hasType_lookup_congr`, `inferExpr_lookup_congr`).
- [x] Add unification-threaded algorithmic typing (`inferExprUnify`, `inferFieldsUnify`) with explicit app/proj soundness-hook interfaces.
- [x] Add branch-local soundness wrappers for unification-backed app/proj steps (`inferExprUnify_app_step_sound`, `inferExprUnify_proj_step_sound`).
- [x] Prove recursive soundness on the non-app/proj fragment (`inferExprUnify_sound_no_unify_branches`, `inferFieldsUnify_sound_no_unify_branches`) as scaffolding for full vertical theorem.
- [x] Add structural size measures (`exprSize`, `fieldsSize`) to support well-founded mutual recursion for the full preconditioned theorem.
- [x] Lift unification-threaded inference to a full preconditioned soundness theorem (`inferExprUnify_sound_preconditioned`, `inferFieldsUnify_sound_preconditioned`) with explicit app/proj hooks.
- [x] Document principal-typing boundary for the vertical slice via uniqueness theorems (`inferExprUnify_deterministic`, `inferExprUnify_type_unique_preconditioned`).
- [x] Refine app-branch boundary with a derivable weaker hook (`AppUnifySoundHookWeak`, `appUnifySoundHookWeak_proved`).
- [x] Introduce two-judgment architecture scaffold (`HasType` + `HasTypeU`) with explicit substitution admissibility and lift lemmas.
- [x] Show counterexample recovery in `HasTypeU` (`app_counterexample_hasTypeU`), validating the architecture shift.
- [x] Discharge a unification-aware app hook from substitution admissibility alone (`AppUnifySoundHookUResolved`, `appUnifySoundHookUResolved_proved`) once a resolved function-shape equation is available.
- [x] Add successor-fuel app hook variant (`AppUnifySoundHookUResolvedSucc`, `appUnifySoundHookUResolvedSucc_proved`) aligned with current bindTypeVar/idempotence bridge equalities.
- [x] Add one-step app bridge theorem in the unification-aware judgment (`inferExprUnify_app_step_sound_hasTypeU_resolved`) parameterized by explicit resolved function-shape equality.
- [x] Prove global resolved-shape assumptions are not derivable in the current fuel model (`not_AppResolvedShapeFromUnify`, `not_ProjResolvedShapeFromUnify`, `not_UnifyResolvedShapePremises`), tightening the vertical-slice boundary.
- [x] Land a hook-free app vertical theorem on a concrete true fragment (`inferExprUnify_app_vertical_closed_fresh_empty_subst`) using no-unify child inference + closed/fresh empty-subst app bridge.
- [x] Land a hook-free projection vertical theorem on a concrete true fragment (`inferExprUnify_proj_vertical_resolved`) using no-unify receiver inference + explicit resolved closed-row witness.
- [x] Add top-level projection inference corollary for the resolved vertical slice (`inferExprUnify_proj_vertical_resolved_of_infer`).
- [x] Compose app+projection vertical slices into a single packaged theorem surface (`VerticalHookFreeUnifySlices`, `verticalHookFreeUnifySlices_proved`).
- [x] Timebox an evaluator-side generalizability spike (`Rill/Eval.lean`): minimal semantics + determinism + initial progress/composition lemmas (`eval_progress_lit`, `eval_progress_var_of_envCovers`, `eval_let_of_eval_steps`, `eval_progress_record_of_evalFields`), literal-preservation lemmas (`eval_preserves_int_lit`, `eval_preserves_bool_lit`, `eval_preserves_string_lit`), variable-preservation under typed runtime environments (`eval_preserves_var_of_envTyped`), executable fragment predicates (`EvalFragmentExpr`, `EvalFragmentFields`), and initial executable soundness slices (`eval_sound_atomic`, `inferEval_sound_atomic`).
- [x] Extend evaluator spike to a non-atomic executable soundness slice over the full evaluator fragment (`eval_sound_evalFragment`, `evalFields_sound_evalFragment`, `inferEval_sound_evalFragment`) with record runtime typing transport (`ValueFieldsHasType`, `valueFieldsHasType_get`) and let-environment extension (`envWellTyped_cons`).
- [x] Add reduced lam/app vertical slice via beta-style direct app-lam execution (`.app (.lam ...) arg`) with no first-class function values in the fragment (`EvalFragmentFull`, `EvalFragmentFullFields`, `eval_app_lam_of_eval_arg`, `eval_sound_evalFragmentFull`, `evalFields_sound_evalFragmentFull`, `inferEval_sound_evalFragmentFull`).
- [x] Bridge from app unification success to weak-hook equality premise (`applySubstCompat stAfter.subst fuel (.var resVar) = retTy`) under explicit substitution assumptions.
  Completed via the app-equality bridge/theorem family in `Kea/Typing.lean` (`app_unify_result_eq_of_bindTypeVar_idempotent`, `app_unify_result_eq_of_unify_function_shape_idempotent`, shifted contract wrappers `app_unify_result_eq_of_unify_success_contract_succ` and closed/fresh specializations), with explicit no-op-domain contracts (`AppUnifyNoopDomain`) and resolved-shape/`HasTypeU` hook packaging (`AppResolvedShapeFromUnifyClosedFreshSucc`, `AppUnifySoundHookUClosedFreshSucc`).
- [ ] Prove full principal types for the row-polymorphic inference fragment beyond the current preconditioned vertical boundary.
  Progress: added packaged preconditioned principal-typing slice in `Kea/Typing.lean` (`PrincipalTypingSlicePreconditioned`, `principalTypingSlicePreconditioned_of_success`), strengthened the hook-free no-unify fragment with expression+field completeness/equivalence packaging (`inferExprUnify_complete_no_unify_branches`, `inferFieldsUnify_complete_no_unify_branches`, `inferExprUnify_ok_iff_inferExpr_no_unify_branches`, `inferFieldsUnify_ok_iff_inferFields_no_unify_branches`, `PrincipalTypingNoUnifySlices`), added a no-unify-to-preconditioned bridge (`principalTypingSlicePreconditioned_of_success_no_unify`), added bundled-hook principal entrypoints (`UnifyHookPremises`, `principalTypingSlicePreconditioned_of_success_from_bundle`, `principalTypingSlicePreconditioned_of_success_no_unify_from_bundle`), added core declarative principality packaging for syntax-directed inference (`hasType_unique`, `inferExpr_principal`, `PrincipalTypingSliceCore`, `principalTypingSliceCore_of_infer`), added no-unify unify-success bridges into those core principal packages (`principalTypingSliceCore_of_unify_success_no_unify`, `principalFieldTypingSliceCore_of_unify_success_no_unify`), added a general core-principal-to-preconditioned bridge (`principalTypingSlicePreconditioned_of_success_of_core_principal`), and added the converse preconditioned-to-core bridge (`principalTypingSliceCore_of_preconditioned_success`, bundle variant); remaining work is lifting this from the current hook/precondition boundary to the full row-polymorphic fragment.
- [x] Extend to DataFrame verb typing judgments once core typing soundness is stable.
  N/A for Kea scope: DataFrame/column verb formalization remains in the archived Rill track and is not part of Kea language formalization.
- [x] Add supertrait/evidence bridge kickoff model (`Rill/Traits.lean`): trait graph closure (`TraitGraph`) + closure-aware satisfaction/bound-checking surfaces (`satisfiesWithGraph`, `checkTraitBoundsWithGraph`) for MCP-observed evidence behavior.
- [x] Add concrete supertrait-gap boundary witness theorems (`satisfies_direct_ord_only`, `requiredTraits_ord_requires_eq`, `satisfiesWithGraph_ord_only_false`, `supertrait_gap_witness`) matching MCP-observed direct-impl vs closure-aware divergence.
- [x] Add bound-checking gap witness trio (`checkTraitBoundsWithGraph_ord_only_reports_missing_super`, `checkTraitBounds_direct_ord_only_accepts`, `checkTraitBoundsWithGraph_ord_and_eq_accepts`) to make the direct-vs-closure discrepancy executable at the trait-bound checker surface.
- [x] Package the trait-closure boundary into a single citation surface (`TraitClosureGapSlice`, `traitClosureGapSlice_proved`) for downstream paper and bridge theorem references.
- [x] Add no-impl witness theorems (`checkTraitBounds_direct_no_impl_reports_ord`, `checkTraitBoundsWithGraph_no_impl_reports_ord_and_eq`) to pin expected trait-bound failures when neither direct nor supertrait impls exist.
- [x] Add call-site gate model + bundle (`callSiteAcceptsDirect`, `callSiteAcceptsWithGraph`, `TraitCallSiteEnforcementSlice`) to make direct-vs-closure enforcement outcomes explicit at the acceptance boundary.
- [x] Add gate/checker normalization lemmas (`callSiteAcceptsDirect_eq_true_iff`, `callSiteAcceptsWithGraph_eq_true_iff`) so downstream theorems can switch between boolean gates and checker outputs.
- [x] Add witness-level refinement bundle (`TraitCallSiteRefinementWitnessSlice`) showing closure-aware acceptance implies direct acceptance on the fully-implemented witness state, while direct-only acceptance remains strictly weaker.
- [x] Add reusable refinement bridge surface (`TraitBoundRefinementPremise`, `callSiteAcceptsWithGraph_implies_direct_of_premise`) so future language-level checker changes can discharge one premise and inherit gate-level refinement.
- [x] Add witness-specialized premise instantiation path (`TraitBoundRefinementPremise_ord_and_eq_witness`, `callSiteAcceptsWithGraph_ord_and_eq_implies_direct_via_premise`) to connect the reusable bridge surface to a concrete fully-implemented state.
- [x] Add explicit site-level trait call boundary packaging (`TraitCallBoundarySite`, `callSiteAcceptsDirectAtSite`, `callSiteAcceptsWithGraphAtSite`, `trait_call_boundary_surface_slice`) to pin direct-vs-closure witness outcomes at boundary-sensitive sites.

## M5. Post-`61bd3a1` Language-Shift Delta Checklist

- [x] Re-audit unification-critical Rust surfaces after `feat: align function-only syntax, imports, prelude, and actor docs/tests` and confirm no structural `unify`/`unifyRows` algorithm rewrite in `rill-infer` (formal row-unification core remains aligned).
- [x] Re-probe MCP actor surface for message-form semantics (`impl Actor for T where Message = ...`, `send(actor, Msg)`, `call(actor, Msg)`) and log outcomes.
- [x] Re-probe MCP interactive prelude boundary for the new extended-prelude policy (confirm allowed bare names remain available and non-extended names reject without import).
- [x] Re-probe trait-closure boundary witness after syntax/runtime shift (confirm direct-only/supertrait-unsatisfied divergence behavior still reproduces).
- [x] Lift the actor message-style shift into an explicit Lean-facing contract surface in `Rill/Traits.lean` (`ActorDispatchModel`, `ActorMessageDispatchBoundarySlice`) so post-migration actor call-site boundaries are explicit and citable.
- [x] Add site-level actor dispatch boundary packaging (`ActorDispatchBoundarySite`, `actorDispatchAccepts*AtSite`, `actor_dispatch_boundary_surface_slice`) so message-style vs legacy dispatch outcomes are explicit at boundary-sensitive sites.
- [x] Decide whether to formalize strict-module-prelude semantics as a runtime/typing bridge artifact or keep it as implementation-only policy evidence in MCP logs.
  Decision: keep strict-module-prelude behavior as implementation-policy evidence in MCP logs for now; do not add a Lean artifact in this phase.

## M6. Kea Effect/Handler Contract Track (Complete)

- [x] WP6.1 handler core + normalization.
  Progress: `Kea/Properties/HandlerEffectRemoval.lean` landed with `EffectRow.handleRemove` and capstones (`handle_removes_effect`, `handle_preserves_other_effects`, row-tail/WF preservation, idempotence), then moved to spec-normalized composition via `EffectRow.handleComposeNormalized` plus nested same-target consequences (`nested_same_target_outer_removal_noop_of_inner_absent`, `nested_same_target_remains_absent_of_outer_absent`). MCP now confirms overlap-idempotence closure (`[Trace] ∪ [Trace] = [Trace]`) on tracked probes.
- [x] WP6.2 absent-effect closed-row no-op + clause-level closed-aware contracts.
  Progress: `Kea/Properties/HandlerAbsentEffectNoop.lean` added closed-row no-op model (`handleComposeClosedAware`, `handle_absent_effect_noop`, present/open fallback theorem). `Kea/Properties/HandlerClosedAwareContracts.lean` lifted this into clause APIs (`resultEffectsCoreClosedAware`, `resultEffectsClosedAware`) with normalized/closed bridge theorems, branch reduction/classification (`resultEffectsClosedAware_absent_closed_reduces_to_applyThen`, `resultEffectsCoreClosedAware_branch_classification`), bundle packaging (`ClosedAwareCoreBundle`, `closedAwareCoreBundle_of_classification`), and typing-facing consequences (`resultEffectsClosedAware_preserves_row_tail`, `wellTypedSlice_implies_handled_removed_closedAware`).
- [x] WP6.3 resume-linearity + clause typing integration.
  Progress: `Kea/Properties/ResumeLinearity.lean` landed (`ResumeUse`, saturating composition, `resume_at_most_once`) and was strengthened with exact combine/exclusivity theorems (`resume_combine_atMostOnce_iff`, `resume_combine_atMostOnce_implies_one_side_zero`, `resume_combine_one_one_not_atMostOnce`). `Kea/Properties/HandlerTypingContracts.lean` then integrated effect-removal + linearity into `wellTypedSlice` with explicit `resultEffectsCore`/`applyThenEffects`/`resultEffects`, handled-label non-reintroduction, resume provenance, branch exclusivity, and loop legality. MCP aligns with `E0012` double-resume rejection behavior.
- [x] WP6.4 operation typing + tail capability + nested composition packages.
  Progress: `Kea/Properties/EffectOperationTyping.lean` added declaration/operation contracts (`EffectDecl`, `operationCallTyping`, `performOperationEffects`) with WF transport and named bundles (`OperationCallBundle`). `Kea/Properties/TailResumptiveClassification.lean` and `Kea/Properties/TailCapabilityComposition.lean` added direct-call eligibility/classification plus named bundles (`TailResumptiveBundle`, `TailCapabilityBundle`), and now include closed-aware direct-call/capability surfaces (`tail_resumptive_direct_call_sound_closedAware`, `TailResumptiveClosedAwareBundle`, `TailCapabilityClosedAwareBundle`, `tail_resumptive_eligible_capability_direct_call_sound_closedAware`). `Kea/Properties/NestedHandlerCompositionContracts.lean` added nested same-target capstones + bundle (`NestedHandlerBundle`). MCP probes are aligned across capability residual effects and nested same-target control.
- [x] WP6.5 fail/result lowering and catch bridge stack.
  Progress: `Kea/Properties/FailResultContracts.lean`, `FailResultEquivalence.lean`, `EffectPolymorphismSoundness.lean`, `CatchTypingBridge.lean`, and `HigherOrderCatchContracts.lean` now provide the full admissible-catch theorem stack: Fail-as-zero-resume, function-type lowering/equivalence (including closed-aware clause-output capstone `failResultContract_sound_closedAware`), admissibility partition (`catchAdmissible` vs `catchUnnecessary`), named admissible bundles (`AdmissibleEffectPoly*Bundle`), judgment/raw-premise adapters, combined capstone classifiers, and higher-order specialization/bundles/classifiers. Runtime divergences on fail-absent and higher-order catch are closed on current MCP: fail-absent `catch` rejects with `E0012`; fail-present higher-order catch preserves residual non-Fail effects.
- [x] WP6.6 unify entry API across Phase-2 capstones.
  Completed by adding shared closed-aware entry packaging (`ClosedAwareResultBundle`, `closedAwareResultBundle_of_wellTyped`, `wellTypedSlice_implies_handled_removed_legacy_via_closedAware`) and routing fail/catch bridge surfaces through it (`FailResultContracts`, `EffectPolymorphismSoundness`, plus direct catch/higher-order adapters `catchTypingJudgment_clauseFailRemoved_via_closedAware`, `higherOrderCatchTypingJudgment_clauseFailRemoved_via_closedAware`, `catchTypingJudgment_clauseRowTailStable_closedAware`, `higherOrderCatchTypingJudgment_clauseRowTailStable_closedAware`), alongside closed-aware nested-handler capstones (`nestedComposeClosedAware`, `nested_handlers_compose_closedAware`, `NestedHandlerClosedAwareBundle`) and closed-aware tail-capability surfaces (`wellTyped_capability_direct_call_sound_closedAware`, `TailCapabilityClosedAwareBundle`).

## M7. Type Universe Parity (In Progress)

- [x] Add a cross-family boundary-surface package theorem (`boundary_surface_suite`) that composes per-family boundary slices and the dynamic/wrapper/grouped-tagged typing bridges (at explicit boundary sites) into one reusable citation contract.
- [x] Add an expression-level ascription bridge slice (`BoundaryAscriptionSyntax`) and wire it into the cross-family boundary surface suite.
- [x] Add a minimal algorithmic Dynamic-ascription checker (`inferDynamicAscriptionAtSite`) with soundness and variable boundary witnesses.
- [x] Package algorithmic Dynamic-ascription outcomes (`DynamicAscriptionAlgorithmicSliceAtSite`) and lift them into the cross-family boundary surface suite.
- [x] Add algorithmic↔declarative Dynamic-ascription alignment witnesses (`dynamicAscriptionAlgorithmicDeclarativeVarAlignmentAtSite`) for the core `x : Dynamic` boundary probe.
- [x] Add wrapper/grouped algorithmic ascription checkers (`inferWrapperAscriptionAtSite`, `inferGroupedTaggedAscriptionAtSite`) with site-level witness slices and lift them into the cross-family boundary surface suite.
- [x] Add wrapper/grouped algorithmic↔declarative alignment witnesses (`wrapperAscriptionAlgorithmicDeclarativeTaskAlignmentAtSite`, `groupedAscriptionAlgorithmicDeclarativeAlignmentAtSite`).
- [x] Package cross-family ascription algorithmic↔declarative alignment (`AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites`) and lift it into the cross-family boundary surface suite.
- [x] Package a unified ascription bridge suite (`BoundaryAscriptionBridgeSuiteAtSites`) and consume it from `boundary_surface_suite`.
- [x] Add expression-level `inferExpr` integration adapters/slice for ascription surfaces (`infer*ExprWithAscriptionAtSite`, `AscriptionInferExprBridgeSliceAtSites`) and fold into `BoundaryAscriptionBridgeSuiteAtSites`.
- [x] Lift `AscriptionInferExprBridgeSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Add expression-level ascription completeness slice (`AscriptionInferExprCompletenessSliceAtSites`) and fold into `BoundaryAscriptionBridgeSuiteAtSites`.
- [x] Lift `AscriptionInferExprCompletenessSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Lift `AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Add `.base` embedding slice (`AscriptionBaseEmbeddingSliceAtSites`) and fold into `BoundaryAscriptionBridgeSuiteAtSites`.
- [x] Lift `AscriptionBaseEmbeddingSliceAtSites` explicitly into `boundary_surface_suite` (not only via the packaged ascription bridge suite).
- [x] Move generic ascription primitives into `Rill/Typing.lean` (`HasTypeAtCoreBoundary`, `CoreExprWithAscription`, `HasTypeWithAscription`, `inferExprWithAscription` + soundness/completeness/iff) and rewire boundary modules to consume the core definitions.
- [x] Add Typing-level `.base` conservativity lemmas for ascription inference (`inferExprWithAscription_base_eq`, `inferExprWithAscription_base_iff`) as preparation for eventual base-`CoreExpr` `ascribe` integration.
- [x] Add Typing-level `.ascribe` boundary-equivalence lemma (`inferExprWithAscription_ascribe_iff_boundary`) to bridge algorithmic inference directly to `HasTypeAtCoreBoundary`.
- [x] Route wrapper/grouped ascription algorithmic checkers through Typing core `inferExprWithAscription` and revalidate mismatch/identity MCP controls.
- [x] Add expression-level core-infer routing slice (`AscriptionCoreInferRoutingSliceAtSites`) and lift it into both `BoundaryAscriptionBridgeSuiteAtSites` and `boundary_surface_suite`.
- [x] Relax wrapper/grouped boundary-gate semantics from strict empty-substitution success to existential unifier success (`∃ st', unify ... = .ok st'`), then restore fully quantified expression-level infer surfaces (`inferWrapperExprWithAscriptionAtSite_sound`/`_complete`/`_iff`, `inferGroupedTaggedExprWithAscriptionAtSite_sound`/`_complete`/`_iff`) and lift `AscriptionInferExprBridgeSliceAtSites` to a fully quantified cross-family soundness slice.
- [x] Add explicit ascription-node equivalence theorems for wrapper/grouped adapters (`inferWrapperAscriptionAtSite_iff`, `inferGroupedTaggedAscriptionAtSite_iff`) to close the local algorithmic↔declarative bridge at `.ascribe`.
- [x] Route wrapper/grouped ascription-node equivalence through Typing-core boundary bridges (`inferWrapperAscriptionAtSite_iff_boundary`, `inferGroupedTaggedAscriptionAtSite_iff_boundary`) and derive local `HasTypeWith*Ascription` iff theorems from those boundary-level contracts.
- [x] Generalize `AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites` from witness probes to fully quantified ascription-level equivalence across Dynamic/wrapper/grouped adapters (using `inferDynamicAscriptionAtSite_iff`, `inferWrapperAscriptionAtSite_iff`, `inferGroupedTaggedAscriptionAtSite_iff`).
- [x] Add derivation theorems from the packaged `infer`↔`HasType` slice (`ascriptionInferExprIffSliceAtSites_implies_bridge`, `..._implies_completeness`) to make slice-strength relationships explicit.
- [x] Add nominal ADT language-level typing bridge and nominal algorithmic ascription slice (`HasTypeAtNominalAdtBoundaryAtSite`, `NominalAdtTypingBridgeSliceAtSites`, `inferNominalAscriptionAtSite`, `NominalAdtAscriptionAlgorithmicSliceAtSite`) and lift them into `boundary_surface_suite`.
- [x] WP7.1 low-risk leaf parity (`Html`/`Markdown`/`Atom`/`Date`/`DateTime`) with vertical theorem slice (`TemporalLeafParity`), explicit site-level leaf boundary-policy package (`leaf_boundary_surface_slice`), and MCP validation.
- [ ] WP7.2 precision numerics + dimension kernel (`IntN`/`FloatN`/`Dim`/`DimVar`).
  Progress: `IntN`/`FloatN` landed in `Ty.lean` and propagated through substitution/free-vars/occurs/generalize/typing/unification proof surfaces; added explicit theorem slice `PrecisionLeafParity`, now including precision unification decision/iff contracts (`intN_unify_decision`, `intN_unify_ok_iff_constructor_beq_true`, `floatN_unify_decision`, `floatN_unify_ok_iff_constructor_beq_true`) and an explicit site-level precision boundary-policy layer (`PrecisionBoundarySite`, `precisionBoundaryAllowsAtSite`) with packaged closure theorem `precision_boundary_surface_slice` for width-mismatch and non-precision rejection surfaces. Added standalone `Dim`/`DimVar` kernel module (`Rill/Dimensions.lean`) with proved substitution/idempotence/unification lemmas, now including explicit decision/characterization contracts (`unifyDim_of_beq_true`, `unifyDim_const_decision`, `unifyDim_const_some_iff_eq`, `unifyDim_const_none_iff_ne`, `unifyDim_const_some_implies_empty`), explicit var/const binding contracts (`unifyDim_const_var_binds`, `unifyDimList_single_var_const_binds`, `unifyDimList_single_const_var_binds`, `unifyDimList_pair_var_const_binds_distinct`, `unifyDimList_pair_const_var_binds_distinct`, `unifyDimList_pair_same_var_const_binds_of_eq`, `unifyDimList_pair_same_var_const_none_of_ne`, `unifyDimList_pair_same_var_const_decision`, `unifyDimList_pair_const_same_var_binds_of_eq`, `unifyDimList_pair_const_same_var_none_of_ne`, `unifyDimList_pair_const_same_var_decision`, `unifyDimList_pair_var_const_some_iff_var_distinct_or_consts_eq`, `unifyDimList_pair_var_const_none_iff_var_eq_and_consts_ne`, `unifyDimList_pair_const_var_some_iff_var_distinct_or_consts_eq`, `unifyDimList_pair_const_var_none_iff_var_eq_and_consts_ne`), plus pointwise dim-list kernel contracts (`unifyDimList_reflexive`, `unifyDimList_consts_some_iff_eq`, `unifyDimList_consts_some_implies_empty`, `unifyDimList_consts_none_iff_ne`, `unifyDimList_consts_decision`, `unifyDimList_head_const_mismatch_none`, `unifyDimList_consts_length_mismatch_none`, `unifyDimList_consts_none_implies_beq_false`). MCP revalidation confirms precision boundary diagnostics (`Int32`→`Int64`, `Float32`→`Float64`, `Int`→`Int32`) and decimal checks remain aligned (`Decimal(10, 2)` accepted; scale mismatch rejects with dimension mismatch). Remaining scope is deeper dim-aware theorem families (beyond constructor-local parity slices).
- [ ] WP7.3 decimal constructor parity.
  Progress: added `Ty.decimal` and proof slice `Rill/Properties/DecimalParity.lean` (substitution leaf, reflexive unification, constructor-BEq success/failure decision lemmas, exact decision equation + success-iff-BEq characterization, precision/scale mismatch witnesses, free-var lemmas, and bidirectional constant-dimension dim-kernel bridges: success `decimal_unify_consts_of_dim_kernel_success`, kernel-failure rejection `decimal_unify_consts_reject_of_prec_dim_kernel_none` / `decimal_unify_consts_reject_of_scale_dim_kernel_none` / `decimal_unify_consts_reject_of_dim_kernel_none`, plus success characterization `decimal_unify_consts_ok_iff_dim_kernel_success`); `DecimalParity` now also includes an explicit site-level decimal boundary-policy layer (`DecimalBoundarySite`, `decimalBoundaryAllowsAtSite`) with packaged closure theorem `decimal_boundary_surface_slice` for scale/precision mismatch and non-decimal rejection surfaces. MCP loop confirms runtime decimal annotation strictness after the implementation fix, including scale-mismatch and non-decimal boundary diagnostics on this surface path. Remaining scope is full dim-aware decomposition in the main unifier.
- [ ] WP7.4 shape-carrying constructors (`FixedSizeList`/`Tensor`).
  Progress: constructors landed in `Ty.lean` and now propagate through substitution/free-vars/occurs/generalize plus typing-proof exhaustiveness; main unifier now has constructor branches for fixed-size-list/tensor; added vertical theorem slice `Rill/Properties/ShapeConstructorParity.lean` (substitution-step decomposition, reflexive unification, size/rank mismatch witnesses, element-type mismatch witnesses under matching metadata, normalized reduction/rejection contracts under explicit non-short-circuit preconditions, explicit any-fuel inner-branch propagation lemmas `fixedSizeList_inner_error_propagates_any_fuel`/`fixedSizeList_inner_success_propagates_any_fuel`/`tensor_inner_error_propagates_any_fuel`/`tensor_inner_success_propagates_any_fuel`, generalized successor-fuel mismatch contracts `fixedSizeList_dim_mismatch_any_fuel`/`tensor_rank_mismatch_any_fuel` plus arbitrary-inner mismatch generalizations `fixedSizeList_dim_mismatch_any_elem_any_fuel`/`tensor_shape_mismatch_any_elem_any_fuel`, explicit mixed var/const metadata rejection witnesses (`fixedSizeList_var_const_dim_mismatch_any_elem_any_fuel`, `fixedSizeList_const_var_dim_mismatch_any_elem_any_fuel`, `tensor_rank1_var_const_shape_mismatch_any_elem_any_fuel`, `tensor_rank1_const_var_shape_mismatch_any_elem_any_fuel`), explicit kernel-vs-constructor witnesses for mixed fixed-size-list/rank-1/rank-2 tensor metadata (`fixedSizeList_var_const_dim_kernel_success`, `fixedSizeList_const_var_dim_kernel_success`, `fixedSizeList_var_const_kernel_success_but_unify_rejects`, `fixedSizeList_const_var_kernel_success_but_unify_rejects`, `tensor_rank1_var_const_dim_kernel_success`, `tensor_rank1_const_var_dim_kernel_success`, `tensor_rank1_var_const_kernel_success_but_unify_rejects`, `tensor_rank1_const_var_kernel_success_but_unify_rejects`, `tensor_rank2_var_const_dim_kernel_success_distinct`, `tensor_rank2_var_const_kernel_success_but_unify_rejects_distinct`, `tensor_rank2_const_var_dim_kernel_success_distinct`, `tensor_rank2_const_var_kernel_success_but_unify_rejects_distinct`, `tensor_rank2_var_const_dim_kernel_some_iff_var_distinct_or_consts_eq`, `tensor_rank2_var_const_dim_kernel_none_iff_var_eq_and_consts_ne`, `tensor_rank2_const_var_dim_kernel_some_iff_var_distinct_or_consts_eq`, `tensor_rank2_const_var_dim_kernel_none_iff_var_eq_and_consts_ne`, `tensor_rank2_mixed_dim_kernel_pair_decomposition_slice`, `tensor_rank2_same_var_const_dim_kernel_success_of_eq`, `tensor_rank2_same_var_const_dim_kernel_none_of_ne`, `tensor_rank2_same_var_const_dim_kernel_some_iff_eq`, `tensor_rank2_same_var_const_unify_rejects_any`, `tensor_rank2_same_var_const_ok_iff_dim_kernel_success_iff_ne`, `tensor_rank2_same_var_const_ok_iff_dim_kernel_success_of_ne`, `tensor_rank2_same_var_const_kernel_success_but_unify_rejects_of_eq`, `tensor_rank2_const_same_var_dim_kernel_success_of_eq`, `tensor_rank2_const_same_var_dim_kernel_none_of_ne`, `tensor_rank2_const_same_var_dim_kernel_some_iff_eq`, `tensor_rank2_const_same_var_unify_rejects_any`, `tensor_rank2_const_same_var_ok_iff_dim_kernel_success_iff_ne`, `tensor_rank2_const_same_var_ok_iff_dim_kernel_success_of_ne`, `tensor_rank2_const_same_var_kernel_success_but_unify_rejects_of_eq`, `tensor_rank2_same_var_ok_iff_dim_kernel_success_split`, `tensor_rank2_same_var_const_non_generalization_iff_eq`, `tensor_rank2_const_same_var_non_generalization_iff_eq`, `tensor_rank2_same_var_non_generalization_split_iff_eq`, `tensor_rank2_var_const_non_generalization_by_var_equality`, `tensor_rank2_const_var_non_generalization_by_var_equality`, `tensor_rank2_mixed_non_generalization_by_var_equality_slice`, `tensor_rank2_var_const_ok_iff_dim_kernel_success_iff_var_eq_and_const_ne`, `tensor_rank2_const_var_ok_iff_dim_kernel_success_iff_var_eq_and_const_ne`, `tensor_rank2_mixed_ok_iff_dim_kernel_success_iff_var_eq_and_const_ne_slice`, `tensor_rank2_var_const_non_generalization_iff_not_var_eq_and_const_ne`, `tensor_rank2_const_var_non_generalization_iff_not_var_eq_and_const_ne`, `tensor_rank2_mixed_non_generalization_iff_not_var_eq_and_const_ne_slice`, `tensor_rank2_var_const_kernel_success_but_unify_rejects_iff_var_distinct_or_consts_eq`, `tensor_rank2_const_var_kernel_success_but_unify_rejects_iff_var_distinct_or_consts_eq`, `tensor_rank2_mixed_kernel_success_but_unify_rejects_iff_var_distinct_or_consts_eq_slice`, `tensor_rank2_var_const_divergence_iff_not_naive_contract`, `tensor_rank2_const_var_divergence_iff_not_naive_contract`, `tensor_rank2_mixed_divergence_iff_not_naive_contract_slice`, `fixedSizeList_var_const_divergence_iff_not_naive_contract`, `fixedSizeList_const_var_divergence_iff_not_naive_contract`, `tensor_rank1_var_const_divergence_iff_not_naive_contract`, `tensor_rank1_const_var_divergence_iff_not_naive_contract`, `mixed_shape_rank1_divergence_iff_not_naive_contract_slice`, `mixed_shape_divergence_iff_not_naive_contract_slice`, `tensor_rank2_same_var_const_divergence_iff_not_naive_contract_of_eq`, `tensor_rank2_const_same_var_divergence_iff_not_naive_contract_of_eq`, `tensor_rank2_same_var_divergence_iff_not_naive_contract_slice_of_eq`), plus packaged mixed-shape boundary citation theorem `mixed_shape_kernel_boundary_slice`, packaged repeated-var rank-2 boundary theorem `tensor_rank2_same_var_kernel_boundary_slice_of_eq`, explicit non-generalization counterexamples in both directions (including repeated-var/equal-constants rank-2 cases), and packaged non-generalization boundary theorems `mixed_shape_non_generalization_slice` and `tensor_rank2_same_var_non_generalization_slice_of_eq`, constant-dimension bridge lemmas `fixedSizeList_unify_consts_of_dim_kernel_success`/`tensor_rank1_unify_consts_of_dim_kernel_success` with explicit eq/ne acceptance/rejection corollaries, explicit dim-kernel match-decision contracts `fixedSizeList_unify_consts_match_decision` and `tensor_rank1_unify_consts_match_decision`, and generalized pointwise dim-list bridge contracts including arbitrary-inner generalizations (`tensor_unify_const_shapes_of_dim_list_kernel_success_any_elem`, `tensor_unify_const_shapes_accept_of_eq_any_elem`, `tensor_unify_const_shapes_reject_of_dim_list_kernel_none_any_elem`, `tensor_unify_const_shapes_reject_of_ne_any_elem`, `tensor_unify_const_shapes_ok_iff_dim_list_kernel_success_any_elem`, `tensor_unify_const_shapes_match_decision_any_elem`, plus `Int` wrappers `tensor_unify_const_shapes_of_dim_list_kernel_success`, `tensor_unify_const_shapes_accept_of_eq`, `tensor_unify_const_shapes_reject_of_dim_list_kernel_none`, `tensor_unify_const_shapes_reject_of_ne`, and extended mismatch/decision contracts `tensor_unify_const_shapes_reject_of_length_mismatch`, `tensor_unify_const_shapes_reject_of_head_mismatch`, `tensor_unify_const_shapes_ok_iff_dim_list_kernel_success`, `tensor_unify_const_shapes_match_decision`), kernel-failure rejection companions `fixedSizeList_unify_consts_reject_of_dim_kernel_none`/`tensor_rank1_unify_consts_reject_of_dim_kernel_none`, and success-iff-kernel-success characterizations `fixedSizeList_unify_consts_ok_iff_dim_kernel_success`/`tensor_rank1_unify_consts_ok_iff_dim_kernel_success`). Post-restart MCP re-check still confirms shape constructor annotation syntax/docs divergence on this surface path.
- [ ] WP7.5 nominal ADT parity (`Sum`/`Opaque`).
  Progress: `Sum`/`Opaque` constructors landed in `Ty.lean`, propagated through substitution/free-vars/occurs/generalize/unify plus typing-proof exhaustiveness, and are covered by `Rill/Properties/NominalAdtParity.lean` (substitution-step decomposition, reflexive unification, packaged structural slices `nominal_adt_subst_step_slice`/`nominal_adt_unifies_with_self_slice`/`nominal_adt_free_vars_slice`, nominal-name mismatch witnesses including successor-fuel contracts `sum_name_mismatch_any_fuel`/`opaque_name_mismatch_any_fuel` plus arbitrary-list generalizations `sum_name_mismatch_any_args_any_fuel`/`opaque_name_mismatch_any_params_any_fuel`, constructor-arity mismatch witnesses plus successor+1 fuel contracts `sum_arity_mismatch_any_fuel`/`opaque_arity_mismatch_any_fuel` and arbitrary-list generalizations for both directions `sum_arity_mismatch_any_nonempty_args_any_fuel`/`opaque_arity_mismatch_any_nonempty_params_any_fuel` and `sum_arity_mismatch_empty_vs_nonempty_any_fuel`/`opaque_arity_mismatch_empty_vs_nonempty_any_fuel`, normalized branch-decision equations `sum_unify_branch_decision_of_normalized`/`opaque_unify_branch_decision_of_normalized` plus packaged cross-constructor decision slice `nominal_adt_unify_branch_decision_slice_of_normalized`, normalized reduction/rejection contracts under explicit non-short-circuit preconditions, branch corollaries `sum_unify_accepts_of_normalized_args_ok`/`opaque_unify_accepts_of_normalized_params_ok` plus generic error-propagation corollaries `sum_unify_rejects_args_err_of_normalized`/`opaque_unify_rejects_params_err_of_normalized`, normalized-name-inequality convenience slices `sum_unify_rejects_of_normalized_name_ne`/`opaque_unify_rejects_of_normalized_name_ne` plus packaged cross-constructor slice `nominal_adt_unify_rejects_of_normalized_name_ne_slice`, explicit any-fuel outer-branch propagation lemmas (`sum_args_error_propagates_any_fuel`, `sum_args_success_propagates_any_fuel`, `sum_args_arity_mismatch_propagates_any_fuel`, `opaque_params_error_propagates_any_fuel`, `opaque_params_success_propagates_any_fuel`, `opaque_params_arity_mismatch_propagates_any_fuel`), and arity-rejection specializations `sum_unify_rejects_arity_mismatch_of_normalized`/`opaque_unify_rejects_arity_mismatch_of_normalized`, packaged mismatch slices `nominal_adt_name_mismatch_slice_any_lists_any_fuel`/`nominal_adt_arity_mismatch_slice_any_fuel`/`nominal_adt_mismatch_suite_any_fuel`, free-var lemmas). `NominalAdtParity` now also includes an explicit site-level boundary-policy layer (`NominalAdtBoundarySite`, `nominalAdtBoundaryAllowsAtSite`) with packaged closure theorem `nominal_adt_boundary_surface_slice` for nominal-name mismatch and non-nominal rejection surfaces. `RecordStructuralProjection` now includes both the unifier-symmetry witness `anonRecordUnifiesWithNamedRecord` and policy-closure witnesses (`record_nominal_boundary_closes_unifier_symmetry`, `record_boundary_policy_site_invariant`, `record_boundary_rejects_structural_to_named_all_sites`, `record_boundary_allows_named_to_structural_all_sites`, `record_boundary_directional_policy_all_sites`, `record_nominal_boundary_closes_unifier_symmetry_all_sites`), explicitly modeling that directional nominal-boundary checks must sit above unification at all boundary-sensitive sites. New module `Rill/Properties/NominalAdtTypingBridge.lean` now lifts nominal boundary policy into modeled typing gates (`HasTypeAtNominalAdtBoundaryAtSite`) with packaged ascription/all-sites bridge theorems (`nominal_adt_typing_bridge_ascription`, `nominal_adt_typing_bridge_all_sites`, `NominalAdtTypingBridgeSliceAtSites`), plus a minimal algorithmic nominal ascription checker/equivalence slice (`nominalAscriptionAllowsBoolAtSite`, `inferNominalAscriptionAtSite`, `inferNominalAscriptionAtSite_iff`, `NominalAdtAscriptionAlgorithmicSliceAtSite`), and `boundary_surface_suite` now includes both the nominal typing-bridge and nominal ascription-algorithmic slices explicitly. MCP validation confirms reflexive annotation behavior, nominal mismatch diagnostics (`Alpha` vs `Gamma`, `UserId` vs `OrderId`/`Int`), ADT constructor arity diagnostics (`Circle` expected 1 argument, got 2), structural-to-nominal rejection diagnostics across all four boundary-sensitive sites (`let`/call/return/ascription), named->structural projection control acceptance (`let get_name = r -> r.name; get_name(User { ... })`), normalized nominal mismatch behavior across ADT/opaque decision paths (`A` vs `B`, `Int` vs `UserId`), and non-nominal call-boundary rejection (`expected A, got Int`). Remaining scope is language-level branch-refinement theorem coverage; this is blocked on extending `Typing.CoreExpr` with ADT constructor/case forms.
- [ ] WP7.6 higher-order constructor internals (`Forall`/`App`/`Constructor`/`Existential`).
  Progress: `Forall`/`App`/`Constructor`/`Existential` landed in `Ty.lean`, propagated through substitution/free-vars/occurs/generalize/unify plus typing-proof exhaustiveness, and are covered by `Rill/Properties/HigherOrderConstructorParity.lean` + `Rill/Properties/ForallParity.lean` + `Rill/Properties/ExistentialParity.lean` (substitution-step decomposition, reflexive unification, constructor mismatch witnesses, free-var lemmas, and packaged constructor-app structural slices `constructor_app_subst_step_slice`/`constructor_app_unifies_with_self_slice`/`constructor_app_free_vars_slice`). `ForallParity` now includes generalized alpha-insensitive compatibility, constructor-level alpha-invariance, explicit canonical-equivalence closure lemmas (`forallCanonicalEq_refl/symm/trans`) with unification lifts (`forallCanonicalEq_unifies`, `forallCanonicalEq_unifies_symm`, `forallCanonicalEq_unifies_trans`) and packaged closure witness `forall_canonical_equivalence_slice`, a normalized non-short-circuit branch reduction lemma (`forall_unify_reduces_to_body_unify_of_normalized_foralls`) with accept/reject corollaries (`forall_unify_accepts_of_normalized_body_ok`, `forall_unify_rejects_of_normalized_body_err`) plus arbitrary-state success lifting (`forall_unify_accepts_of_normalized_body_ok_any`), generic body-error propagation (`forall_unify_rejects_of_normalized_body_err_any`), successor-fuel quantified-body mismatch rejection (`forall_body_mismatch_any_fuel`), explicit any-fuel body-error propagation (`forall_body_error_propagates_any_fuel`), explicit any-fuel body-success propagation (`forall_body_success_propagates_any_fuel`), concrete alpha-renaming/vacuous-binder witnesses, packaged structural slice `forall_structural_slice`, packaged concrete surface witness `forall_surface_boundary_slice`, and an explicit site-level boundary-policy layer (`ForallBoundarySite`, `forallBoundaryAllowsAtSite`) with packaged closure theorem `forall_boundary_surface_slice`. `ExistentialParity` now includes normalized reduction/rejection contracts under explicit non-short-circuit preconditions (`existential_unify_reduces_to_assoc_of_normalized`, `existential_unify_rejects_of_normalized`) plus equal-bounds associated-type-list outcome propagation corollaries (`existential_unify_accepts_of_normalized_assoc_ok`, `existential_unify_rejects_assoc_err_of_normalized_bounds_eq`), explicit any-fuel outer-branch propagation lemmas (`existential_assoc_error_propagates_any_fuel`, `existential_assoc_success_propagates_any_fuel`), successor-fuel mismatch rejection witnesses for bounds in both concrete (`existential_bounds_mismatch_any_fuel`) and arbitrary-assoc generalized form (`existential_bounds_mismatch_any_assoc_any_fuel`), associated-type arity in both concrete (`existential_assoc_length_mismatch_any_fuel`) and directional generalized forms (`existential_assoc_length_mismatch_any_nonempty_assoc_any_fuel`, `existential_assoc_length_mismatch_empty_vs_nonempty_any_fuel`), and an explicit site-level existential boundary-policy layer (`ExistentialBoundarySite`, `existentialBoundaryAllowsAtSite`) with packaged closure theorem `existential_boundary_surface_slice`. `HigherOrderConstructorParity` now includes normalized app/constructor branch contracts (`app_unify_branch_of_normalized`, `constructor_unify_reduces_to_fixed_args_of_normalized`, `constructor_unify_rejects_of_normalized_guard_false`), app-branch outcome propagation corollaries (`app_unify_rejects_ctor_err_of_normalized`, `app_unify_accepts_of_normalized_ctor_ok_args_ok`, `app_unify_rejects_args_err_of_normalized_ctor_ok`, `app_unify_rejects_args_arity_mismatch_of_normalized_ctor_ok`, `app_unify_rejects_ctor_guard_false_of_normalized_succ`), explicit any-fuel app propagation lemmas (`app_ctor_error_propagates_any_fuel`, `app_ctor_args_success_propagates_any_fuel`, `app_args_error_propagates_any_fuel`, `app_args_arity_mismatch_propagates_any_fuel`), direct constructor-headed app guard-failure rejection across fuel (`app_constructor_name_mismatch_any_fuel`, `app_constructor_arity_mismatch_any_fuel`, `app_constructor_guard_mismatch_any_fuel`), normalized fixed-argument branch success/error propagation corollaries (`constructor_unify_accepts_of_normalized_fixed_args_ok`, `constructor_unify_rejects_fixed_args_err_of_normalized`, `constructor_unify_rejects_fixed_args_arity_mismatch_of_normalized`), explicit any-fuel fixed-arg propagation lemmas (`constructor_fixed_args_error_propagates_any_fuel`, `constructor_fixed_args_success_propagates_any_fuel`), explicit any-fuel constructor-guard mismatch theorem (`constructor_guard_mismatch_any_fixed_any_fuel`), packaged guard-mismatch suite `constructor_guard_mismatch_suite_any_fuel`, packaged concrete constructor-guard witness `constructor_guard_surface_slice`, plus an explicit site-level constructor-head boundary-policy layer (`ConstructorGuardBoundarySite`, `constructorGuardBoundaryAllowsAtSite`) with packaged closure theorem `constructor_guard_boundary_surface_slice`, and successor-fuel generalized constructor mismatch contracts for arbitrary fixed-argument lists (`constructor_name_mismatch_any_fixed_any_fuel`, `constructor_arity_mismatch_any_fixed_any_fuel`). MCP validation now confirms constructor-parameter arity mismatch diagnostics for `List`/`Map` after the runtime fix (including name/arity mismatch surfaces), alongside existential boundary behavior (`any` accepted; `any Show -> Int`, `any Show -> any Eq`, and `Int -> any Show` rejected), rank-2 annotation parsing/type-checking with the correct `forall a. fn(a) -> a` syntax, acceptance of alpha-renamed/vacuous-binder-compatible quantified arguments, rejection of non-equivalent quantified body shapes at call sites (`argument 1 is not polymorphic enough: expected \`forall a. (a) -> a\``), rejection of non-`forall` arguments at the same boundary, combined List/Map surface guard mismatch diagnostics, and non-constructor-to-constructor call-boundary rejection (`expected List(Int), got Int`). Lean mirrors observed constructor-level `forall` binder canonicalization behavior. Remaining scope is language-level higher-rank theorem/runtime parity (alpha-equivalence/subsumption/evidence interactions).
- [ ] WP7.7 runtime wrappers and boundaries (`Dynamic`/`GroupedFrame`/`Task`/`Actor`/`Arc`/`Tagged`).
  Progress: `Dynamic`/`GroupedFrame`/`Task`/`Actor`/`Arc`/`Tagged` landed in `Ty.lean`, propagated through substitution/free-vars/occurs/generalize/unify plus typing-proof exhaustiveness, and are covered by `Rill/Properties/RuntimeWrapperParity.lean` + `Rill/Properties/GroupedTaggedParity.lean` (substitution-step decomposition, reflexive unification, mismatch witnesses, free-var lemmas). `RuntimeWrapperParity` includes normalized reduction contracts for wrapper constructors, explicit any-fuel wrapper-inner propagation lemmas (`task_inner_error_propagates_any_fuel`, `task_inner_success_propagates_any_fuel`, `actor_inner_error_propagates_any_fuel`, `actor_inner_success_propagates_any_fuel`, `arc_inner_error_propagates_any_fuel`, `arc_inner_success_propagates_any_fuel`), dynamic-var path contracts, successor-fuel dynamic boundary contracts, and function-return absorption witnesses from the earlier permissive slice; it now also includes an explicit Dynamic boundary-policy layer (`DynamicBoundarySite`, `dynamicBoundaryAllowsAtSite`) with site-invariance theorem (`dynamic_boundary_policy_site_invariant`), site-level narrowing/widening witnesses, a general widening law (`dynamic_boundary_allows_dynamic_from_any_all_sites`), a general non-Dynamic narrowing law (`dynamic_boundary_rejects_from_dynamic_all_sites`), closure/widening-alignment theorems (`dynamic_return_boundary_closes_unifier_absorption`, `dynamic_boundary_closes_unifier_absorption_all_sites`, `dynamic_boundary_closes_unifier_absorption_task_all_sites`, `dynamic_boundary_closes_unifier_absorption_bool_all_sites`, `dynamic_boundary_allows_unifier_widening_int_all_sites`, `dynamic_boundary_allows_unifier_widening_task_all_sites`), packaged surface theorem `dynamic_boundary_surface_slice`, and an explicit Task/Actor/Arc wrapper boundary-policy layer (`WrapperBoundarySite`, `wrapperBoundaryAllowsAtSite`) with packaged closure theorem `wrapper_boundary_surface_slice`. `BoundaryAssignability` now provides shared language-level boundary modeling (`HasTypeAtBoundary`, `allowsByBool`, `allowsByBoolAndUnify`) plus relation transport (`hasTypeAtBoundary_congr`) used by all typing-bridge modules; `allowsByBoolAndUnify` now records existential unifier success (`∃ st', unify ... = .ok st'`) rather than strict empty-substitution success. `DynamicBoundaryTypingBridge` now adds modeled ascription and site-generalized Dynamic typing bridges (`HasTypeAtAscriptionBoundaryAtSite`, `HasTypeAtAscriptionBoundary`, `hasTypeAtAscriptionBoundaryAtSite_iff_ascription`, `dynamic_boundary_typing_bridge_ascription`, `dynamic_boundary_typing_bridge_ascription_all_sites`) on top of variable/call-argument/let/return alignment, tying Dynamic boundary rejection to declarative core typing outcomes across boundary-sensitive sites. `WrapperBoundaryTypingBridge` now adds modeled ascription and site-generalized typing bridges for Task/Actor/Arc (`HasTypeAtWrapperBoundaryAtSite`, `HasTypeAtWrapperBoundary`, `hasTypeAtWrapperBoundaryAtSite_iff_ascription`, `wrapper_typing_bridge_ascription`, `wrapper_typing_bridge_all_sites`) plus wrapper uniqueness/mismatch controls, aligning wrapper boundary policy with declarative typing across boundary-sensitive sites. `GroupedTaggedParity` includes explicit inner-type mismatch witnesses, generalized successor-fuel key/metadata mismatch contracts (`groupedFrame_keys_mismatch_any_fuel`, `tagged_metadata_mismatch_any_fuel`) plus arbitrary-inner generalizations (`groupedFrame_keys_mismatch_any_inner_any_fuel`, `tagged_metadata_mismatch_any_inner_any_fuel`), normalized reduction/rejection contracts, explicit any-fuel inner-branch propagation lemmas (`groupedFrame_inner_error_propagates_any_fuel`, `groupedFrame_inner_success_propagates_any_fuel`, `tagged_inner_error_propagates_any_fuel`, `tagged_inner_success_propagates_any_fuel`), and now an explicit site-level grouped/tagged boundary-policy layer (`GroupedTaggedBoundarySite`, `groupedTaggedBoundaryAllowsAtSite`) with packaged closure theorem `grouped_tagged_boundary_surface_slice`. `GroupedTaggedTypingBridge` now adds modeled ascription and site-generalized typing bridges (`HasTypeAtGroupedTaggedBoundaryAtSite`, `HasTypeAtGroupedTaggedBoundary`, `hasTypeAtGroupedTaggedBoundaryAtSite_iff_ascription`, `grouped_tagged_typing_bridge_ascription`, `grouped_tagged_typing_bridge_all_sites`) plus grouped/tagged uniqueness/mismatch controls, aligning grouped/tagged boundary policy with declarative typing across boundary-sensitive sites. `BoundaryAscriptionSyntax` now adds an explicit expression/judgment bridge layer (`CoreExprWithAscription`, `HasTypeWithAscription`, `BoundaryAscriptionSyntaxSliceAtSites`) plus expression-level site-invariance lemmas (`hasTypeWithDynamicAscription_ascribe_iff_ascription`, `hasTypeWithWrapperAscription_ascribe_iff_ascription`, `hasTypeWithGroupedTaggedAscription_ascribe_iff_ascription`), algorithmic Dynamic/wrapper/grouped ascription checkers (`inferDynamicAscriptionAtSite`, `inferWrapperAscriptionAtSite`, `inferGroupedTaggedAscriptionAtSite`) now routed through Typing core `inferExprWithAscription`, site-level algorithmic witness slices (`DynamicAscriptionAlgorithmicSliceAtSite`, `WrapperAscriptionAlgorithmicSliceAtSite`, `GroupedTaggedAscriptionAlgorithmicSliceAtSite`), and packaged algorithmic↔declarative alignment slices (`dynamicAscriptionAlgorithmicDeclarativeVarAlignmentAtSite`, `wrapperAscriptionAlgorithmicDeclarativeTaskAlignmentAtSite`, `groupedAscriptionAlgorithmicDeclarativeAlignmentAtSite`, `AscriptionAlgorithmicDeclarativeAlignmentSliceAtSites`), plus an expression-level `inferExpr` integration slice (`inferDynamicExprWithAscriptionAtSite`, `inferWrapperExprWithAscriptionAtSite`, `inferGroupedTaggedExprWithAscriptionAtSite`, `AscriptionInferExprBridgeSliceAtSites`, `AscriptionInferExprCompletenessSliceAtSites`, `AscriptionInferExprIffSliceAtSites`, `AscriptionCoreInferRoutingSliceAtSites`, `AscriptionBaseEmbeddingSliceAtSites`). Wrapper/grouped expression-level soundness is now fully quantified (`inferWrapperExprWithAscriptionAtSite_sound`, `inferGroupedTaggedExprWithAscriptionAtSite_sound`) with corresponding `iff` surfaces, local `.ascribe`-node equivalence surfaces are explicit (`inferWrapperAscriptionAtSite_iff`, `inferGroupedTaggedAscriptionAtSite_iff`), and both `AscriptionInferExprBridgeSliceAtSites` and `AscriptionInferExprIffSliceAtSites` now carry fully quantified cross-family contracts. `boundary_surface_suite` now includes the packaged ascription bridge suite (`BoundaryAscriptionBridgeSuiteAtSites`) and explicit inferExpr integration/completeness/equivalence slices (`AscriptionInferExprBridgeSliceAtSites`, `AscriptionInferExprCompletenessSliceAtSites`, `AscriptionInferExprIffSliceAtSites`, `AscriptionCoreInferRoutingSliceAtSites`, `AscriptionBaseEmbeddingSliceAtSites`). Rebuilt MCP confirms explicit Dynamic narrowing in implementation (`Dynamic -> concrete` rejected with `expect_type` guidance), confirms Task/Actor/Arc wrapper mismatch plus non-wrapper rejection (`Task(Int)`/`Actor(Int)`/`Arc(Int)` vs `Bool` inner mismatch and `Int` -> wrapper rejection), confirms grouped/tagged wrapper mismatch plus non-wrapper rejection on exposed paths (`GroupedFrame(Bool)` vs `GroupedFrame(Int)`, `Tagged(Bool)` vs `Tagged(Int)`, and `Int` -> grouped/tagged rejection), and confirms Dynamic return/app/let/ascription boundary behavior, while controls remain accepted; parser support for parameterized grouped key/metadata annotation syntax (`keys: [...]`) is still absent in this surface path, so metadata/key mismatch behavior there remains a Lean-level parity contract pending fuller surface syntax exposure. Bare `GroupedFrame`/`Tagged` collapse remains, but is currently treated as expected behavior for parameterless forms in this annotation path. Typing core now owns the generic ascription artifacts (`HasTypeAtCoreBoundary`, `CoreExprWithAscription`, `HasTypeWithAscription`, `inferExprWithAscription` plus soundness/completeness/iff). Remaining scope is deciding whether `ascribe` should be merged into the base `CoreExpr`/`inferExprUnify` surface.

## Operating Checklist (every milestone)

- [ ] `cd formal && lake build` passes.
- [ ] `FORMAL.md` table updated for every new theorem.
- [ ] If MCP is used for validation, append session details to `formal/mcp-log.md`.
- [ ] Keep changes formal-only unless explicitly requested otherwise.
