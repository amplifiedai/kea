# Brief: Lean Formalization Migration

**Status:** active
**Priority:** Phase 0c-0e (parallel track — formal agent works alongside implementation)
**Depends on:** 0c-effect-handlers (effect rows must be in the type system before formalizing them)
**Blocks:** nothing directly — formal proofs validate but don't gate implementation

## Motivation

Rill has a substantial Lean 4 formalization: ~50 source files, 153 MCP-verified
log entries, covering HM inference, Rémy row unification, lacks constraints,
generalize/instantiate, supertrait graphs, declarative/algorithmic typing
soundness, evaluator soundness slices, and nominal/boundary typing bridges.

This work transfers to Kea because Kea's core type system *is* Rill's, extended
with effect rows. The Lean model's `Ty` inductive, `Subst`, `Unify`, `Generalize`,
`LacksConstraints`, and `Traits` modules map directly to kea-types and kea-infer.
The MCP-first verification workflow (predict → probe → classify → act → trace)
transfers unchanged — Kea already has `kea-mcp` with `type_check`, `diagnose`,
and `get_type`.

Migrating gives us:

1. **Formal backing during the riskiest phases.** 0d and 0e are where subtle
   type/effect interactions surface. Having machine-checked proofs for the
   underlying type system catches issues that proptests miss.
2. **Effect typing formalization as new work.** No language we know of has a
   Lean formalization of row-typed algebraic effect handlers. This is novel
   and publishable.
3. **Continuity.** The formal agent has 153 sessions of context and workflow
   discipline. Migrating while that context is fresh is cheaper than recreating
   it later.

## What Transfers (Phase 1: Core Type System)

Direct migration from `rill/formal/Rill/` — rename `Rill` → `Kea`, extend
`Ty` with effect rows.

### Definitions (migrate as-is, extend for effects)

| Rill module | Kea module | Migration notes |
|-------------|-----------|-----------------|
| `Ty.lean` | `Kea/Ty.lean` | Add `EffRow` to `Ty` inductive. Add effect variable kind. |
| `Substitution.lean` | `Kea/Substitution.lean` | Extend `applySubst` for effect rows. |
| `FreeVars.lean` | `Kea/FreeVars.lean` | Add `freeEffectVars` mutual case. |
| `OccursCheck.lean` | `Kea/OccursCheck.lean` | Extend occurs check to effect variables. |
| `LacksConstraints.lean` | `Kea/LacksConstraints.lean` | Transfer as-is. |
| `Unify.lean` | `Kea/Unify.lean` | Extend for effect row unification. |
| `Generalize.lean` | `Kea/Generalize.lean` | Quantify effect variables. |
| `Traits.lean` | `Kea/Traits.lean` | Transfer as-is. |
| `Typing.lean` | `Kea/Typing.lean` | Extend typing judgments with effect annotations. |

### Properties (migrate, re-prove after Ty extension)

Transfer all Properties/ files. Most proofs should survive the `Ty` extension
with minor fixups (additional cases in mutual recursion). Files that need
substantive rework:

- `UnifyReflexive.lean` — add effect row reflexivity case
- `UnifyConsistent.lean` — extend for effect unification
- `SubstIdempotent.lean` — additional effect substitution case
- `RemyPreservesLabels.lean` — effect rows use same Rémy decomposition
- `TraitBoundsPreserved.lean` — effect variables in trait bounds

Files that transfer unchanged:
- `LacksBlocksDuplicate.lean` — no effect interaction
- `RowFieldsSorted.lean` — structural, no effect interaction
- `DecomposeFields.lean` — structural

### Drop (Rill-specific, don't migrate)

- `ColExpr.lean` — Rill column expression DSL
- `DataFrame.lean` — Rill dataframe verb typing
- `Dimensions.lean` — Rill dimension model (Kea has its own in kea-types)
- `Eval.lean` — Rill evaluator semantics (Kea compiles, doesn't interpret)
- All `Properties/DataFrame*`, `Properties/ColumnBoundary*` — Rill domain
- All `Properties/*Parity*.lean` — Rill-specific type constructor parity slices
- All `Properties/*Boundary*.lean`, `Properties/*Bridge*.lean` — Rill boundary typing

### Maybe migrate later (if Kea adds equivalent features)

- `Eval.lean` evaluator soundness — could inform Kea REPL semantics or
  comptime evaluation, but not urgent

## What's New (Phase 2: Effect Typing Formalization)

This is genuinely new work — no Rill equivalent exists.

### Effect declarations and operations

```lean
-- Effect declaration typing
inductive EffectDecl where
  | mk : Name → List TypeParam → List OperationSig → EffectDecl

-- Effect operation typing: performing an operation adds the effect
-- to the current row
```

### Handler typing (KERNEL §5.13)

The core theorem to prove:

```
Given:
  expr : T  with effects {E, R...}
  handler for E covers all operations
  each handler body : _  with effects {H...}
Then:
  handle expr { ... } : T  with effects {H..., R...}
```

This is the **effect removal** theorem — the most important property
of the handler system.

### Target theorems (new)

| Theorem | Statement | Difficulty |
|---------|-----------|------------|
| `handle_removes_effect` | Handler for E removes E from effect row | Medium |
| `handle_adds_handler_effects` | Handler body effects appear in result | Medium |
| `handle_preserves_other_effects` | Unhandled effects pass through | Medium |
| `resume_at_most_once` | Static linearity check is sound | Hard |
| `fail_is_zero_resume` | Fail handler never resumes; equivalent to Result | Medium |
| `fail_result_equivalence` | `catch expr` ≡ Result-passing transformation | Hard |
| `nested_handlers_compose` | Inner handler shadows outer for same effect | Medium |
| `effect_polymorphism_sound` | Effect variable generalization/instantiation preserves soundness | Hard |
| `tail_resumptive_classification` | Tail-resumptive handler compiles equivalently to direct call | Medium |
| `capability_direct_call_sound` | Unintercepted capability effect = direct runtime call | Easy |

### MCP-first workflow

Same protocol as Rill:

1. **Predict**: State Lean conjecture + preconditions
2. **Probe**: Run kea-mcp checks (happy path, boundary, adversarial)
3. **Classify**: Agreement / precondition gap / model divergence
4. **Act**: Prove, revise, or log divergence
5. **Traceability**: Link theorems, file edits, MCP evidence

The formal agent should maintain `formal/mcp-log.md` in the same format.

## Scheduling: Parallel, Not Sequential

The formal agent should run **in parallel** with 0c/0d/0e implementation:

```
0c implementation ←→ Phase 1 migration (core type system)
0d implementation ←→ Phase 1 proof repair (Ty extension fixups)
0e implementation ←→ Phase 2 new work (effect typing proofs)
```

### Why parallel works

1. **Independent codebases.** Lean proofs don't depend on Rust compilation.
   The formal agent uses MCP to probe the running Kea compiler, same as
   it did with Rill.

2. **MCP-first absorbs design churn.** If effect typing rules change during
   0e, the formal agent discovers this via MCP probes before proving. The
   predict→probe→classify loop is designed for exactly this.

3. **The formal agent has context now.** 153 MCP log entries, deep familiarity
   with the Rémy/HM model, the two-judgment architecture, supertrait gaps.
   This context decays if we wait.

4. **Formal work feeds back into implementation.** The Rill formalization
   found real discrepancies (supertrait gap witnesses, substitution bridge
   issues). Same will happen with effect typing.

### Risk: design churn in effect typing

The main risk is that handler typing rules change during 0e prototyping
(e.g., switching from evidence passing to CPS changes how handlers compose).
Mitigation:

- Phase 1 (core migration) is zero risk — the HM+row core is stable.
- Phase 2 effect proofs should start with the **type-level** properties
  (effect removal, handler composition) which are strategy-independent.
  Compilation strategy (evidence vs CPS) only affects **codegen-level**
  properties, which are Phase 2 stretch goals anyway.

## Implementation Plan

### Phase 1: Core migration (start after 0c lands effect rows)

1. Create `kea/formal/` directory with Lake project, batteries dependency.
2. Copy `Rill/Ty.lean` → `Kea/Ty.lean`. Extend `Ty` inductive with effect
   row constructors.
3. Migrate `Substitution`, `FreeVars`, `OccursCheck` — extend mutual
   recursion for effect rows.
4. Migrate `Unify` — add effect row unification cases.
5. Migrate `Generalize` — add effect variable quantification.
6. Migrate `LacksConstraints`, `Traits` — transfer directly.
7. Re-prove all Properties/ theorems. Fix broken cases from Ty extension.
8. Migrate `Typing.lean` — extend with effect annotations.
9. Set up MCP-first workflow against kea-mcp. First log entries.

### Phase 2: Effect typing formalization (start during 0d/0e)

1. Model effect declarations and operation typing.
2. Model handler expressions and typing rule (§5.13).
3. Prove `handle_removes_effect` — the core property.
4. Prove handler composition (nested handlers).
5. Model resume and prove at-most-once linearity.
6. Model Fail as zero-resume and prove Result equivalence.
7. Prove effect polymorphism soundness.
8. (Stretch) Model tail-resumptive classification and prove
   compilation equivalence.

### Phase 2.5: Vertical integration (during/after 0e)

1. Connect effect typing to the existing typing soundness theorems.
2. Prove that the full type+effect system is sound (the big theorem).
3. If evaluator semantics exist in Kea, extend evaluator soundness.

## Testing / Verification

- `lake build` must succeed with zero `sorry` at each milestone.
- MCP log entries for every theorem that touches runtime behavior.
- Rust proptest↔Lean theorem mapping maintained in a FORMAL.md.
- CI integration: `lake build` in Kea CI (separate job, non-blocking
  initially, blocking after Phase 1 completes).

## Definition of Done

### Phase 1

- `kea/formal/` exists with Lake project.
- All core type system modules migrated and extended for effect rows.
- All transferable Properties/ theorems re-proved.
- Zero `sorry`.
- MCP-first workflow operational against kea-mcp.

### Phase 2

- Effect declaration/operation typing modeled.
- Handler typing rule (§5.13) modeled and effect removal proved.
- Resume at-most-once proved.
- Fail/Result equivalence proved.
- Nested handler composition proved.
- Effect polymorphism soundness proved.
- Zero `sorry`.
- FORMAL.md mapping maintained.

## Non-Goals

- Formalizing codegen / MIR lowering (too implementation-specific).
- Formalizing the actor/concurrency model (Phase 3+ work).
- Formalizing memory model / ownership (depends on 0f stabilizing).
- Blocking implementation on formal proofs (formal work validates,
  doesn't gate).

## Progress

- 2026-02-26: Brief moved from `todo/` to `in-progress/` to start Phase 1 migration in parallel with 0d codegen work.
- 2026-02-26: Bootstrapped `formal/` in Kea by cannibalizing `/Users/chris/Projects/rill/formal`, renaming the Lean namespace target from `Rill` to `Kea`, and preserving the roadmap + MCP verification history baseline.
- 2026-02-26: `cd formal && lake build` passes in Kea after namespace-portability proof repairs in `SubstBridge`, `UnifyReflexive`, `PrecisionLeafParity`, and `ShapeConstructorParity` (warning-only simp lint remains).
- 2026-02-26: Repository guardrail check passes after formalization bootstrap (`mise run check`).
- 2026-02-26: Aligned core formal typing surface with `kea-types` effect rows (`Ty.functionEff`, `EffectRow`, `Kind`) and propagated constructor coverage through `Substitution`, `FreeVars`, `OccursCheck`, `Unify`, `Generalize`, `Typing`, plus proof repair in `SubstCompose`/`SubstBridge`/`SubstIdempotent`/`UnifyReflexive`.
- 2026-02-26: Added phase-1 WF scaffold modules (`WellFormed`, `WfSubstitution`, `WfRename`, `WfGeneralize`) and integrated them into `formal/Kea.lean`.
- 2026-02-26: Added `WfUnify` unifier-update WF lemmas (`bindTypeVar_ok_preserves_wf_range`, row bind variants) and centralized `Subst.WellFormedRange` + bind-preservation lemmas in `WfSubstitution` for shared reuse across follow-on unifier proofs.
- 2026-02-26: Added row/effect WF constructor helper lemmas in `WellFormed` (`closed`, `mkOpen`, `emptyClosed`, `emptyOpen`, `pure`) and extended `WfUnify` with `unifyRows`-shaped WF helpers (`subst_bindClosedRow_preserves_wf_range`, `subst_bindOpenRows_preserves_wf_range`) to reduce branch-local proof boilerplate.
- 2026-02-26: Extended `WfUnify` with state-level WF range transport lemmas (`SubstWellFormedRange` wrappers for `freshTypeVar`, `freshRowVar`, and non-`subst` record updates) plus state-level bind wrappers (`bindTypeVar_ok_preserves_substWellFormedRange`, closed/open row update variants) to support direct `unifyRows` branch proof reuse.
- 2026-02-26: Added `unifyRows`-branch-oriented WF wrappers in `WfUnify` that compose substitution + lacks + fresh-row updates (`bindClosedRow_update_with_lacks_preserves_substWellFormedRange`, `bindOpenRows_update_with_lacks_preserves_substWellFormedRange`, `freshOpenRows_update_with_lacks_preserves_substWellFormedRange`) for direct use in open/closed row branch proofs.
- 2026-02-26: Added `WfUnifyExtends` bridge module to package row-branch updates as combined contracts (`ExtendsRowBindings` + `SubstWellFormedRange`) and integrated it into the top-level formal import surface.
- 2026-02-26: Extended `WfUnifyExtends` with branch-shaped `unifyRows` combined contracts under existing idempotence preconditions (open-closed, closed-open, open-open fresh branch) so extension and WF-range obligations can be discharged together from one theorem surface.
- 2026-02-26: Added full-state open-open combined contract in `WfUnifyExtends` (covers `lacks` + `traitBounds` + fresh counters) so branch proofs can preserve both extension and WF-range across all non-`subst` state updates in one step.
- 2026-02-26: Added a preconditioned combined dispatcher (`unifyRows_success_update_extendsAndWf_idempotent`) with explicit WF-annotated branch-shape predicate (`UnifyRowsSuccessUpdateShapeWf`), mirroring `UnifyExtends` while returning extension + WF-range as one reusable contract.
- 2026-02-26: Added canonical contract naming/projection in `WfUnifyExtends` (`unifyRows_contract_extendsAndWf`, `unifyRows_extends_rowMap_preconditioned_of_contract_extendsAndWf`) plus shape projection (`unifyRowsSuccessUpdateShapeWf_implies_shape`) to align with existing `UnifyExtends` contract ergonomics.
- 2026-02-26: Added `unifyRows_contract_full_wf` in `WfUnifyExtends`, composing the new extension+WF-range contract with existing compat/WF swap-invariance (`CompatWFAgreeOnDomainLookupsAcyclic`) into one downstream theorem surface.
- 2026-02-26: Strengthened `WfGeneralize` with a non-mono instantiation WF theorem (`instantiate_preserves_wf_of_mapping_respects_ctx`) that lifts instantiation WF through the rename mapping when mapping outputs are known to respect target kind/row contexts.
- 2026-02-26: Refactored `WfGeneralize` instantiate-WF machinery with reusable mapping helpers (`instantiateTypeFold`, `instantiateRowFold`, `instantiateVarMapping`) and added a cleaner primary theorem surface (`instantiate_preserves_wf_of_instantiateVarMapping_respects_ctx`).
- 2026-02-26: Added `WfSubstitution` extension-monotonicity bridge (`Subst.wellFormedRange_of_extends`) so WF-range invariants can be transported backward across established substitution extension relations.
- 2026-02-26: Added projection lemmas in `WfUnifyExtends` to recover both (a) direct `stNext` WF-range and (b) legacy `unifyRows_contract_wf` assumptions from the WF-annotated branch-shape contract.
- 2026-02-26: Added direct projection from WF-annotated branch-shape assumptions to the legacy unsplit contract (`unifyRows_extends_rowMap_preconditioned_wf_of_shape_wf`), avoiding manual shape conversion at call sites.
- 2026-02-26: Added bundled `UnifyState` WF transport over non-`subst` updates (`substWellFormedRange_with_non_subst_fields`) and used it to simplify full-state open-open WF contract proofs in `WfUnifyExtends`.
- 2026-02-26: Added substitution extension helpers in `WfSubstitution` (`extends_bindType_if_unbound`, `extends_bindRow_if_unbound`) to bridge unbound-bind updates into `Subst.Extends`, supporting future WF-range transport and extension-composition proofs.
- 2026-02-26: Added a direct single-state combined contract for unbound closed-row bind updates in `WfUnifyExtends` (`closedBind_extendsAndWfRange_if_unbound`) to reduce precondition threading at branch-call sites.
- 2026-02-26: Added a direct single-state open-open combined contract for two unbound row binds in `WfUnifyExtends` (`openOpenBind_extendsAndWfRange_if_unbound_twice`) to mirror the existing two-bind extension helper while preserving WF-range in the same theorem.
- 2026-02-26: Added boilerplate-reduction helpers in `WfUnifyExtends`: shape constructors (`unifyRowsSuccessUpdateShapeWf_*`) and no-update combined-contract wrappers (`noUpdate_extendsAndWfRange`, `noUpdate_with_non_subst_fields_extendsAndWfRange`) for faster branch proof assembly.
- 2026-02-26: Added identity renaming utilities in `WfRename` (`VarMapping.id`, lookup simplifications, `respectsCtx_id`, and rename-id WF corollaries across Ty/Row/TyList/RowFields/EffectRow) to streamline instantiate/generalize proof setup.
- 2026-02-26: Added structural identity lemmas for renaming (`renameType_id_eq`, `renameRow_id_eq`, `renameTyList_id_eq`, `renameRowFields_id_eq`, `renameEffectRow_id_eq`) so identity mappings can be eliminated by rewriting during later WF proofs.
- 2026-02-26: Exposed instantiation mapping helpers in `WfGeneralize` (`instantiateTypeFold`, `instantiateRowFold`, `instantiateVarMapping`) and added an ergonomic combined theorem (`instantiate_preserves_wf`) that discharges WF from either monomorphic instantiation or a mapping-context witness.
- 2026-02-26: Added single-bind branch wrappers in `WfUnifyExtends` that jump directly to the full contract surface (extension + WF-range + compat/WF acyclic agreement) for open-closed and closed-open successful `unifyRows` updates.
- 2026-02-26: Added the open-open fresh-branch full-contract wrapper in `WfUnifyExtends` (`unifyRows_open_open_contract_full_wf_idempotent_fresh`), completing branch-level access to extension + WF-range + compat/WF acyclic agreement.
- 2026-02-26: Added explicit no-update full-contract wrapper in `WfUnifyExtends` (`noUpdate_contract_full_wf`) so the no-subst-update branch has the same extension+WF+compat contract shape as bind-update branches.
- 2026-02-26: Re-ran MCP-first row-branch probes on restarted `kea-mcp` (`reset_session` + `get_type`/`type_check`/`diagnose`) for `WfUnifyExtends` no-update/single-bind/open-open wrappers; outcomes matched expected success/error boundaries (logged in `formal/mcp-log.md`).
- 2026-02-26: Added `bindTypeVar`-success combined contracts in `WfUnifyExtends` (`bindTypeVar_ok_extendsAndWfRange`, `bindTypeVar_ok_with_non_subst_fields_extendsAndWfRange`, `bindTypeVar_ok_contract_full_wf`) to extend the WF contract layer beyond row-branch updates.
- 2026-02-26: Added `unify` var-left bridge + lifted contracts in `WfUnifyExtends` (`unify_var_left_eq_bindTypeVar`, `unify_var_left_ok_contract_full_wf`, `unify_var_left_ok_with_non_subst_fields_contract_full_wf`) so var-branch unifier successes discharge the same full WF contract surface without manual `bindTypeVar` rewrites.
- 2026-02-26: Added one-hop projection lemmas for var-left unifier bridge contracts in `WfUnifyExtends` (base + non-`subst` state variants), exposing extension/WF-range/acyclic facets directly from `unify_var_left_ok_*_contract_full_wf`.
- 2026-02-26: Added safe var-right unifier bridge wrappers in `WfUnifyExtends` (`unify_var_right_*_of_non_var`) including non-`subst` full-state contract surfaces, making the bridge layer symmetric while preserving branch-sound preconditions.
- 2026-02-26: Added WF-empty corollaries for well-founded row/effect-row substitution in `WfSubstitution` (`applySubstRowWF_empty_preserves_wf`, `applySubstEffectRowWF_empty_preserves_wf`) to complete empty-substitution WF coverage across effect-row forms.
- 2026-02-26: Added `TyList`/`RowFields` WF-preservation and empty-substitution lemmas in `WfSubstitution` (`applySubstTyList_preserves_wf_of_no_domain_vars`, `applySubstRowFields_preserves_wf_of_no_domain_vars`, `applySubstTyList_empty_preserves_wf`, `applySubstRowFields_empty_preserves_wf`) to close container-level WF baseline gaps.
- 2026-02-26: Added full-state `bindTypeVar` contract packaging in `WfUnifyExtends` (`bindTypeVar_ok_with_non_subst_fields_contract_full_wf`) so type-var bind success paths retain extension + WF-range + compat/WF-acyclic agreement under non-`subst` state updates.
- 2026-02-26: Added `bindTypeVar` WF transport wrappers in `WfUnify` for non-`subst` state updates (`bindTypeVar_ok_with_lacks_preserves_substWellFormedRange`, `bindTypeVar_ok_with_non_subst_fields_preserves_substWellFormedRange`) to reduce downstream state-proof boilerplate.
- 2026-02-26: Added `WfGeneralize` component-wise effect-row wrapper (`generalize_functionEff_preserves_wf_of_component_no_domain_vars`) so `Ty.functionEff` generalization can be consumed from split param/effect/return no-domain assumptions.
- 2026-02-26: Added projection lemmas for `bindTypeVar` full contracts in `WfUnifyExtends` (extension-only and WF-range-only, including non-`subst` state variants) to reduce contract-destruct boilerplate at call sites.
- 2026-02-26: Added `instantiate_functionEff_preserves_wf` in `WfGeneralize`, completing the pair of effect-row-focused `functionEff` wrappers across both `generalize` and `instantiate`.
- 2026-02-26: Added explicit `functionEff` WF substitution wrappers in `WfSubstitution` (`applySubst_functionEff_preserves_wf_of_component_no_domain_vars`, `applySubstWF_functionEff_preserves_wf_of_component_no_domain_vars`) so effect-row function types have direct fuel/WF-preservation surfaces (not only compat alias coverage).
- 2026-02-26: Added effect-row compat surface in `Substitution` (`applySubstEffectRowCompat`) and corresponding `WfSubstitution` lemmas (`applySubstEffectRowCompat_preserves_wf_of_no_domain_vars`, `applySubstEffectRowCompat_empty_preserves_wf`) to keep effect-row proof call sites aligned with compat substitution APIs.
- 2026-02-26: Added `TyList`/`RowFields` compat substitution aliases in `Substitution` (`applySubstTyListCompat`, `applySubstRowFieldsCompat`) and matching `WfSubstitution` lemmas (`*_preserves_wf_of_no_domain_vars`, `*_empty_preserves_wf`) to complete container-level compat WF coverage.
- 2026-02-26: Added acyclic-agreement projection lemmas for `bindTypeVar` full contracts in `WfUnifyExtends` (base + non-`subst` state variants), so extension/WF-range/compat facets are each available via one-hop projections.
- 2026-02-26: Added `functionEff` convenience wrappers in `WfGeneralize` for common entrypoints (`generalize_functionEff_empty_preserves_wf`, `instantiate_functionEff_mono_preserves_wf`, `instantiate_functionEff_preserves_wf_of_mapping_respects_ctx`) to reduce boilerplate at effect-row call sites.
- 2026-02-26: Added new packaging module `WfEffectRowLadder` and wired it into `Kea.lean`, exposing citable `functionEff` WF slices (`FunctionEffSubstWfSlice`, `FunctionEffGenInstWfSlice`) that bundle substitution + generalize + instantiate obligations.
- 2026-02-26: Added immediate-use specializations in `WfEffectRowLadder` (`functionEff_subst_wf_slice_empty`, `functionEff_gen_inst_wf_slice_mono`) for empty-substitution and monomorphic-instantiation effect-row workflows.
- 2026-02-26: Re-ran MCP probes for effect-row annotation boundaries (`reset_session` + `type_check`/`get_type`/`diagnose`): declared `-[Log]>` effects are preserved, pure control remains pure, and too-weak declared effect rows (e.g. `-[IO]>` with `Log.log`) are rejected; logged in `formal/mcp-log.md`.
- 2026-02-26: Extended `WfEffectRowLadder` with `bindTypeVar` contract packaging for `Ty.functionEff` (`FunctionEffBindTypeVarContractSlice`, `functionEff_bindTypeVar_contract_slice`), linking effect-row WF assumptions to extension + WF-range + compat/WF-acyclic guarantees after successful type-var binding.
- 2026-02-26: Added projection helpers for `FunctionEffBindTypeVarContractSlice` in `WfEffectRowLadder` (extension, WF-range, and acyclic-agreement projections) to reduce destructuring boilerplate for downstream effect-row proofs.
- 2026-02-26: Added full-state `bindTypeVar` contract packaging/projections for `Ty.functionEff` in `WfEffectRowLadder` (`FunctionEffBindTypeVarFullStateContractSlice`, `functionEff_bindTypeVar_full_state_*`) so non-`subst` state updates are covered by the same packaged effect-row contract surface.
- 2026-02-26: Added base/full-state conversion lemmas for `WfEffectRowLadder` bind-contract slices (`functionEff_bindTypeVar_full_state_slice_to_base`, `functionEff_bindTypeVar_base_slice_to_full_state`) and routed full-state projections through the shared base projection path.
- 2026-02-26: Added capstone bundle theorem in `WfEffectRowLadder` (`functionEff_wf_ladder_bundle_of_bind_success`) to expose substitution + generalize/instantiate + bind-contract slices together from one `Ty.functionEff` proof entrypoint.
- 2026-02-26: Added full-state capstone bundle theorem in `WfEffectRowLadder` (`functionEff_wf_ladder_bundle_of_bind_success_full_state`) so the same one-shot `functionEff` WF ladder packaging is available after non-`subst` `UnifyState` updates.
- 2026-02-26: Added one-hop bundle projection helpers in `WfEffectRowLadder` (base + full-state) so extension, WF-range, and compat/WF-acyclic obligations can be extracted directly from bundled `functionEff` assumptions without extra destructuring.
- 2026-02-26: Added named bundle contracts in `WfEffectRowLadder` (`FunctionEffWfLadderBundle`, `FunctionEffWfLadderBundleFullState`) with constructor/projection helpers, stabilizing a single theorem-surface name for downstream effect-row WF consumers.
- 2026-02-26: Completed named bundle projection coverage in `WfEffectRowLadder` with direct extension/WF/acyclic extractors (base + full-state), yielding a complete one-hop API from bundle assumptions to all unifier contract facets.
- 2026-02-26: Added `unify` var-left entry wrappers in `WfEffectRowLadder` (`functionEff_unify_var_left_*`) plus bundle constructors (`functionEff_wf_ladder_bundle_of_unify_var_left_success*`), allowing effect-row WF contract packaging to start from successful unifier var-branches (with explicit reduced-form branch preconditions).
- 2026-02-26: Refined `WfEffectRowLadder` var-left `unify` wrappers to discharge the constructor-mismatch BEq premise internally via `beqTy` reduction, removing that manual precondition from downstream call sites.
- 2026-02-26: Added symmetric var-right `unify` entry wrappers/bundle constructors in `WfEffectRowLadder` (`functionEff_unify_var_right_*`, including full-state variants), grounded in the new `WfUnifyExtends` non-var right-branch bridge.
- 2026-02-26: `cd formal && lake build` passes after full `functionEff` exhaustiveness repair in remaining Phase-1 core proofs.
- 2026-02-26: Added explicit WF effect-row bridge lemmas in `SubstBridge` (`applySubstEffectRowWF_noop`, `applySubstEffectRowWF_empty`) so effect rows have the same no-domain-vars/empty-substitution identity surface as rows.
- 2026-02-26: Added fuel-vs-WF effect-row bridge lemmas in `SubstBridge` (`applySubstEffectRowCompat_eq_applySubstEffectRowWF_of_no_domain_vars`, `applySubstEffectRow_empty_eq_applySubstEffectRowWF_empty`) and introduced `Substitution.applySubstEffectRow` helper to make the effect-row substitution boundary explicit.
- 2026-02-26: Added explicit `Ty.functionEff` compat-vs-WF constructor corollary (`applySubstCompat_functionEff_eq_applySubstWF_of_no_domain_vars`) to expose a named bridge surface for effectful function types.
- 2026-02-26: Added component-wise `Ty.functionEff` bridge corollary (`applySubstCompat_functionEff_eq_applySubstWF_of_component_no_domain_vars`) so downstream proofs can consume separate no-domain assumptions for params/effects/return without flattening free-var lists manually.
- 2026-02-26: Added explicit WF judgment layer (`Kea/WellFormed.lean`) and WF-preservation lemmas for both fuel and WF substitution under no-domain-vars preconditions (`Kea/Properties/WfSubstitution.lean`), including effect-row variants.
- 2026-02-26: Extended WF substitution lemma surface with empty-substitution preservation theorems for type/row/effect-row forms to stabilize the WF baseline API for downstream unification/generalization work.
- 2026-02-26: Added `applySubstCompat`/`applySubstRowCompat` WF-preservation lemmas so existing compat substitution call sites can consume the WF layer without changing substitution entry points.
- 2026-02-26: Added component-wise `functionEff` WF-preservation lemma for compat substitution (`applySubstCompat_functionEff_preserves_wf_of_component_no_domain_vars`) to align the WF API with effect-row function decomposition used in existing bridge proofs.
- 2026-02-26: Added first `generalize/instantiate` WF theorems (`Kea/Properties/WfGeneralize.lean`): no-domain-vars/empty-substitution WF preservation for `generalize`, plus monomorphic `instantiate` equality and WF preservation.
- 2026-02-26: Added WF preservation for renaming (`Kea/Properties/WfRename.lean`) with explicit mapping-context assumptions (`VarMapping.RespectsCtx`), covering type/row/type-list/row-fields/effect-row renaming as groundwork for polymorphic `instantiate` WF proofs.
- 2026-02-26: Phase-2 kickoff landed in `Kea/Properties/HandlerEffectRemoval.lean` with row-level handler elimination model (`EffectRow.handleRemove`) and first capstone theorem surface: `handle_removes_effect`, `handle_preserves_other_effects`, row-tail preservation, idempotence, and WF preservation.
- 2026-02-26: MCP probe sweep for handler elimination confirmed non-overlap behavior (`[IO, Log] --handle Log--> [IO]`, `[Log] --handle Log--> []`) and logged an overlap divergence: when handler-body effects overlap with residual effects, inference currently emits duplicate labels (e.g. inferred `()-[IO, IO]> ()`), which cannot be expressed in declared effect-row annotations.
- 2026-02-26: Continued Phase-2 on the spec path by adding normalized composition semantics in `HandlerEffectRemoval` (`RowFields.insertIfAbsent`, `RowFields.unionIdem`, `EffectRow.handleComposeNormalized`) and proving preconditioned composition theorems (`handle_adds_handler_effects`, `handle_preserves_other_effects_normalized`, `handle_removes_effect_normalized_of_handler_absent`, `handleComposeNormalized_preserves_wellFormed`).
- 2026-02-26: Extended normalized-composition coverage with nested same-target handler consequences (`nested_same_target_outer_removal_noop_of_inner_absent`, `nested_same_target_remains_absent_of_outer_absent`) plus composed row-tail preservation (`handleComposeNormalized_preserves_row_tail`).
- 2026-02-26: Added `Kea/Properties/ResumeLinearity.lean` scaffold for Phase-2 resume linearity (`ResumeUse` summary algebra, `combine` composition, exclusivity-preserving at-most-once lemmas, and named `resume_at_most_once` surface) and imported it via `formal/Kea.lean`.
- 2026-02-26: Strengthened `ResumeLinearity` with exact combine characterization (`resume_combine_atMostOnce_iff`) and branch-exclusivity corollaries (`resume_combine_atMostOnce_implies_one_side_zero`, `resume_combine_one_one_not_atMostOnce`) to directly support "resume not in both branches" style obligations.
- 2026-02-26: Added explicit branch/loop legality surfaces in `ResumeLinearity` (`ResumeUse.conditionalLegal`, `ResumeUse.loopLift`, `ResumeUse.loopLegal`) with corresponding iff/corollary lemmas, and re-probed `kea-mcp`: zero-resume handler clauses typecheck while sequential and both-branch double-resume cases are rejected with `E0012`.
- 2026-02-26: Added `Kea/Properties/HandlerTypingContracts.lean` as the first integration layer connecting normalized handler effect composition and resume-linearity obligations via a clause-level contract (`HandleClauseContract.wellTypedSlice`) plus bridge theorems (`wellTypedSlice_implies_handled_removed`, branch exclusivity, loop legality).
- 2026-02-26: Refined `Kea/Properties/HandlerTypingContracts.lean` with concrete premises (`thenEffects`, `clauseCoverageComplete`), explicit effect-result assembly (`resultEffectsCore`, `applyThenEffects`, `resultEffects`), no-reintroduction invariants, and resume-provenance extraction lemmas; `cd formal && lake build` passes.
- 2026-02-26: Added `Kea/Properties/EffectOperationTyping.lean` (imported via `formal/Kea.lean`) with effect declaration/operation-call scaffold (`EffectDecl`, `operationCallTyping`, `performOperationEffects`) and capstones `operationCallTyping_adds_declared_effect` + `capability_direct_call_sound`; `cd formal && lake build` passes.
- 2026-02-26: Re-probed runtime alignment for `capability_direct_call_sound` on latest `kea-mcp`: from `body : () -[Log, Trace]> ()`, handling `Trace` yields `run : () -[Log]> ()` and handling `Log` yields `run2 : () -[Trace]> ()` (both `diagnose` clean); divergence none.
- 2026-02-26: Extended `EffectOperationTyping` with WF transport (`performOperationEffects_preserves_wellFormed`) so effect-row updates from operation calls now compose directly with the WF formalization ladder; `cd formal && lake build` passes.
- 2026-02-26: Re-probed operation-call effect-row behavior on latest `kea-mcp`: `call_log` infers `() -[Log]> ()`, while explicit too-weak declaration (`fn bad() -[Trace]> Unit` with `Log.log`) rejects with `E0001`; aligns with `EffectOperationTyping` contract surfaces.
- 2026-02-26: Added named operation-call bundle packaging in `EffectOperationTyping` (`OperationCallBundle`, `operationCallBundle_of_typing`, `operationCallBundle_effectAdded_of_typing`) so declaration/effect-addition/row-tail guarantees compose from one theorem surface; `cd formal && lake build` passes.
- 2026-02-26: Added `Kea/Properties/TailResumptiveClassification.lean` (imported via `formal/Kea.lean`) with `TailResumptiveClass`/`classifyClause` and capstones `tail_resumptive_classification` + `tail_resumptive_direct_call_sound` for the tail-resumptive fast-path contract surface; `cd formal && lake build` passes.
- 2026-02-26: Extended `TailResumptiveClassification` with named bundle packaging (`TailResumptiveBundle`, `tail_resumptive_bundle_of_wellTyped`, `tail_resumptive_bundle_notInvalid`) so downstream proofs can consume tail-resumptive classification/provenance in one contract surface; `cd formal && lake build` passes.
- 2026-02-26: Re-probed tail-resumptive runtime alignment on latest `kea-mcp`: with `body : () -[Log]> ()`, both `run_no_then` and identity-`then` `run_then` infer `() -> ()` and diagnose clean, matching `tail_resumptive_direct_call_sound`.
- 2026-02-26: Added `Kea/Properties/TailCapabilityComposition.lean` (imported via `formal/Kea.lean`) to compose operation-call capability preservation with tail-resumptive equivalence (`tail_resumptive_eligible_capability_direct_call_sound`, plus a well-typed-clause wrapper); `cd formal && lake build` passes.
- 2026-02-26: Strengthened `TailCapabilityComposition` with a general well-typed capability lift (`resultEffects_preserves_core_label_true`, `wellTyped_capability_direct_call_sound`) so capability preservation now composes through full `resultEffects` (including optional `then` union), with tail-resumptive theorem retained as a corollary; `cd formal && lake build` passes.
- 2026-02-26: Added named bundle packaging in `TailCapabilityComposition` (`TailCapabilityBundle`, `tailCapabilityBundle_of_wellTyped`, `tailCapabilityBundle_resultCapability_of_wellTyped`) for one-name consumption of core/result capability guarantees under well-typed boundaries; `cd formal && lake build` passes.
- 2026-02-26: Added `Kea/Properties/NestedHandlerCompositionContracts.lean` (imported via `formal/Kea.lean`) with explicit nested same-target composition surfaces (`nested_handlers_compose`, row-tail and non-target preservation, `NestedHandlerBundle`) to make the Phase-2 nested composition target directly citable; `cd formal && lake build` passes.
- 2026-02-26: MCP probe on valid nested same-target shape (`nested_same` with `inner = handle body() ...`, then `handle inner ...`) infers `() -> ()` and diagnoses clean; aligns with nested composition contract boundary.
- 2026-02-26: MCP probe on handled-absent resumptive shape (`handle Log.log(1)` with `Trace` clause) rejects with `E0001` as expected for non-well-typed declarations (handler does not eliminate `Log`), so composition claims remain precondition-gated to well-typed clauses.
- 2026-02-26: After phantom-IO fix (`746a4cb`, `9812380`) and MCP restart, re-probed handled-absent closed-row cases: mismatched handlers are now accepted as no-ops on effect rows (`probe_log : () -[Log]> ()`, `probe_trace : () -[Trace]> ()`, diagnose clean), matching the `handler_absent_effect_noop` contract.
- 2026-02-26: Added `Kea/Properties/HandlerAbsentEffectNoop.lean` (imported via `formal/Kea.lean`) with closed-row-aware absent-effect no-op surfaces (`handleComposeClosedAware`, `handle_absent_effect_noop`, present/open fallback theorem) to codify the implementation-aligned behavior.
- 2026-02-26: Added `Kea/Properties/HandlerClosedAwareContracts.lean` (imported via `formal/Kea.lean`) to bridge absent-effect no-op behavior into clause-level contract APIs (`resultEffectsCoreClosedAware`/`resultEffectsClosedAware` and closed-vs-normalized equivalence theorems); `cd formal && lake build` passes.
- 2026-02-26: Added `Kea/Properties/FailResultContracts.lean` and imported it via `formal/Kea.lean`; introduced Fail-specialized contract surfaces (`failAsZeroResume`, `resultLowering`, `FailResultContract`) with capstone consequences (`failResultContract_sound`, `failResultContract_loopLegal`); `cd formal && lake build` passes.
- 2026-02-26: Extended `FailResultContracts` with explicit function-type lowering/equivalence surfaces (`lowerFailEffects`, `lowerFailFunctionType`, `failResultFunctionEquivalent`) and preservation/removal lemmas (`lowerFailEffects_*`, `lowerFailFunctionType_noop_effect_of_absent`, `failResultFunctionEquivalent_implies_result_return`); `cd formal && lake build` passes.
- 2026-02-26: Added `Kea/Properties/FailResultEquivalence.lean` (imported via `formal/Kea.lean`) with named capstone/bundle surfaces (`fail_result_equivalence`, `FailResultEquivalenceBundle`, catch-premise adapters) so Fail/Result equivalence is available as a direct theorem API; `cd formal && lake build` passes.
- 2026-02-26: Added `Kea/Properties/EffectPolymorphismSoundness.lean` and imported it via `formal/Kea.lean`; introduced polymorphic effect-row soundness contracts (`rowTailStable`, `labelsPreservedExcept`, `EffectPolyFailLoweringContract`) with capstones (`lowerFailEffects_effectPoly_sound`, `effectPolyFailLowering_sound`, `effectPolyFailLowering_noop_if_fail_absent`); `cd formal && lake build` passes.
- 2026-02-26: Extended `EffectPolymorphismSoundness` with concrete handler-typing schema bridges (`EffectPolyHandlerSchema`, `effectPolyHandlerSchema_sound`, `effectPolyHandlerSchema_noop_if_fail_absent`) so `wellTypedSlice` + Fail-zero-resume premises now project directly into polymorphic function lowering guarantees; `cd formal && lake build` passes.
- 2026-02-26: Re-probed on `kea-mcp` after fix `cbb70b3`: Fail-absent `catch` now rejects with `E0012` (`expression cannot fail; catch is unnecessary`), while Fail-present and higher-order Fail-lowering probes remain aligned; divergence closed in `formal/mcp-log.md`.
- 2026-02-26: Added catch-admissibility formal surfaces in `FailResultContracts` (`catchAdmissible`, `catchUnnecessary`, exclusivity lemmas) and propagated them into `EffectPolymorphismSoundness` with precondition-gated wrappers (`effectPolyFailLowering_sound_of_catchAdmissible`, `catchUnnecessary_implies_no_admissible_poly_lowering`, schema variants); `cd formal && lake build` passes.
- 2026-02-26: Added runtime-aligned admissible wrappers in `EffectPolymorphismSoundness` (`AdmissibleEffectPolyFailLoweringContract`, `AdmissibleEffectPolyHandlerSchema`) and capstone entrypoints (`admissibleEffectPolyFailLowering_sound`, `admissibleEffectPolyHandlerSchema_sound`, `admissibleEffectPolyHandlerSchema_not_unnecessary`) so downstream usage is constrained to Fail-present `catch` cases by construction; `cd formal && lake build` passes.
- 2026-02-26: Added direct premise adapters in `EffectPolymorphismSoundness` (`mkAdmissibleEffectPolyFailLoweringContract`, `mkAdmissibleEffectPolyHandlerSchema`, plus `*_sound_of_premises`) so handler typing assumptions map to admissible capstones without manual structure assembly; `cd formal && lake build` passes.
- 2026-02-26: Added one-hop admissible projection helpers in `EffectPolymorphismSoundness` for both contracts and schemas (`*_rowTailStable`, `*_preserves_nonFail`, `*_failRemoved*`) to expose each guarantee independently from a single admissible assumption; `cd formal && lake build` passes.
- 2026-02-26: Added named admissible bundle contracts in `EffectPolymorphismSoundness` (`AdmissibleEffectPolyLoweringBundle`, `AdmissibleEffectPolyHandlerBundle`) with bundle constructors/projections (`admissibleEffectPoly*_bundle_*`) for stable one-name capstone consumption; `cd formal && lake build` passes.
- 2026-02-26: Added admissibility partition lemmas in `FailResultContracts` (`catchAdmissible_implies_not_unnecessary`, `catchAdmissible_xor_unnecessary`) and branch extractors in `EffectPolymorphismSoundness` (`admissibleEffectPoly*_*_admissibility_branch`) so runtime branch classification is explicit in theorem surfaces; `cd formal && lake build` passes.
- 2026-02-26: Added `Kea/Properties/CatchTypingBridge.lean` (imported via `formal/Kea.lean`) with a judgment-shaped premise bundle (`CatchTypingJudgment`) and direct theorem adapters (`catchTypingJudgment_sound`, row-tail/non-Fail projections, admissibility branch) into admissible effect-polymorphism capstones; `cd formal && lake build` passes.
- 2026-02-26: Extended `CatchTypingBridge` with judgment-level named bundle ergonomics (`CatchTypingBundle`, `catchTypingJudgment_bundle`, and `catchTypingJudgment_bundle_*` projections) for one-name consumption of clause-removal and lowered-effect guarantees; `cd formal && lake build` passes.
- 2026-02-26: Added direct premise adapters in `CatchTypingBridge` (`mkCatchTypingJudgment`, `catchTypingJudgment_sound_of_premises`, noncomputable `catchTypingJudgment_bundle_of_premises`) to enable judgment-free entry into the bridge capstones; `cd formal && lake build` passes.
- 2026-02-26: Added one-hop `of_premises` projections in `CatchTypingBridge` (`catchTypingJudgment_rowTailStable_of_premises`, `catchTypingJudgment_preserves_nonFail_of_premises`, and bundle-facet helpers) so raw-premise call sites can consume targeted guarantees directly; `cd formal && lake build` passes.
- 2026-02-26: Extended `CatchTypingBridge` with combined/classified premise surfaces (`CatchTypingCapstoneOutcome`, `catchTypingJudgment_capstone_of_premises`, `catchTypingJudgment_classify_of_premises`) plus Fail-presence/absence wrappers (`catchTypingJudgment_capstone_of_fail_present`, `catchTypingUnnecessary_of_fail_absent`) to match the higher-order runtime-aligned entry pattern; `cd formal && lake build` passes.
- 2026-02-26: Re-probed on latest restarted MCP binary: higher-order typed-Fail catch case now aligns (`(() -[Fail(String), Log]> Int) -[Log]> Result(Int, String)`), first-order typed case remains aligned, and fail-absent case still rejects with `E0012`; divergence closed in `formal/mcp-log.md`.
- 2026-02-26: Added `Kea/Properties/HigherOrderCatchContracts.lean` and imported it via `formal/Kea.lean`; introduced higher-order-specialized theorem surfaces (`higherOrderCatchType`, `HigherOrderCatchTypingJudgment`, soundness/admissibility theorems) so post-fix higher-order behavior is represented directly in formal APIs; `cd formal && lake build` passes.
- 2026-02-26: Extended `HigherOrderCatchContracts` with direct raw-premise adapters (`higherOrderCatchTypingJudgment_sound_of_premises`, `higherOrderCatchTypingJudgment_admissibility_branch_of_premises`) to avoid manual judgment assembly at higher-order call sites; `cd formal && lake build` passes.
- 2026-02-26: Added higher-order named bundle ergonomics in `HigherOrderCatchContracts` (`HigherOrderCatchBundle`, `higherOrderCatchTypingJudgment_bundle`, projection helpers, and `higherOrderCatchTypingJudgment_bundle_of_premises`) for stable one-name capstone consumption at higher-order call sites; `cd formal && lake build` passes.
- 2026-02-26: Added one-hop higher-order bundle `of_premises` projections in `HigherOrderCatchContracts` (`higherOrderCatchTypingJudgment_bundle_clauseFailRemoved_of_premises`, `*_rowTailStable_of_premises`, `*_preserves_nonFail_of_premises`) so raw-premise entrypoints expose targeted guarantees directly; `cd formal && lake build` passes.
- 2026-02-26: Added higher-order combined capstone `higherOrderCatchTypingJudgment_capstone_of_premises` (plus `higherOrderCatchTypingJudgment_bundle_failRemoved_of_premises`) so one raw-premise theorem now yields clause Fail removal, lowered-row guarantees, and admissibility branch facts together; `cd formal && lake build` passes.
- 2026-02-26: Added higher-order presence/absence entry wrappers (`higherOrderCatchTypingJudgment_capstone_of_fail_present`, `higherOrderCatchUnnecessary_of_fail_absent`) so consumers can enter the runtime-aligned capstone path directly from Fail-label evidence; `cd formal && lake build` passes.
- 2026-02-26: Added higher-order single-entry classification over `HigherOrderCatchCapstoneOutcome` (`higherOrderCatchTypingJudgment_classify_of_premises`) so raw typing premises now produce either full capstone consequences or the `catchUnnecessary` branch without a separate admissibility assumption; `cd formal && lake build` passes.
- 2026-02-27 11:17: Extended `Kea/Properties/HandlerClosedAwareContracts.lean` with closed-aware branch reduction/classification packaging (`resultEffectsClosedAware_absent_closed_reduces_to_applyThen`, `resultEffectsCoreClosedAware_branch_classification`, `ClosedAwareCoreBundle`, `closedAwareCoreBundle_of_classification`) and revalidated with `cd formal && lake build`.
- 2026-02-27 11:23: Added typing-facing closed-aware consequences (`resultEffectsClosedAware_preserves_row_tail`, `wellTypedSlice_implies_handled_removed_closedAware`) and backfilled `formal/ROADMAP.md` with full Kea Phase-2 progress history under M6 (`WP6.1`–`WP6.6`), then revalidated with `cd formal && lake build`.
- 2026-02-27 11:33: Closed M2 by adding compat-first unification bridge packaging (`unifyRows_preconditioned_contract_compat_first`) and routing `unifyRows_extends_rowMap_preconditioned_wf_split` through that layer; updated `FORMAL.md` and marked M2 complete in `formal/ROADMAP.md`; `cd formal && lake build` passes.
- 2026-02-27 11:58: Closed `M6/WP6.6` by adding shared closed-aware entry packaging (`ClosedAwareResultBundle`, `wellTypedSlice_implies_handled_removed_legacy_via_closedAware`), routing Fail/catch bridges through it (`FailResultContracts`, `EffectPolymorphismSoundness`), and adding closed-aware nested-handler capstones/bundle (`nestedComposeClosedAware`, `NestedHandlerClosedAwareBundle`); `cd formal && lake build` passes.
- 2026-02-27 11:59: Added direct catch-level closed-aware adapters (`catchTypingJudgment_clauseFailRemoved_via_closedAware`, `higherOrderCatchTypingJudgment_clauseFailRemoved_via_closedAware`) and routed higher-order clause-removal through them; `cd formal && lake build` passes.
- 2026-02-27 12:01: Extended Fail/catch closed-aware surfaces with a closed-aware Fail capstone (`failResultContract_sound_closedAware`) plus clause row-tail adapters in catch layers (`catchTypingJudgment_clauseRowTailStable_closedAware`, `higherOrderCatchTypingJudgment_clauseRowTailStable_closedAware`); `cd formal && lake build` passes.
- 2026-02-27 12:04: Extended closed-aware integration to tail-capability composition (`wellTyped_capability_direct_call_sound_closedAware`, `TailCapabilityClosedAwareBundle`) and strengthened closed-aware helper lemmas (`handleComposeClosedAware_preserves_other_effects`, `resultEffectsClosedAware_preserves_other_effects`); `cd formal && lake build` passes.
- 2026-02-27 12:06: Extended tail-resumptive classification with closed-aware direct-call equivalence surfaces (`directCallEquivalentClosedAware`, `tail_resumptive_direct_call_sound_closedAware`) to align fast-path contracts with the shared closed-aware API; `cd formal && lake build` passes.
- 2026-02-27 12:07: Added a named closed-aware tail-resumptive bundle surface (`TailResumptiveClosedAwareBundle`, `tail_resumptive_closedAware_bundle_of_wellTyped`) with one-hop eligible projection for downstream tail/capability composition proofs; `cd formal && lake build` passes.
- 2026-02-27 12:32: Extended closed-aware tail-capability composition with eligible and well-typed fast-path corollaries (`tail_resumptive_eligible_capability_direct_call_sound_closedAware`, `tail_resumptive_wellTyped_capability_direct_call_sound_closedAware`) and routed closed-aware `notInvalid` through `TailResumptiveClosedAwareBundle`; `cd formal && lake build` passes.
- 2026-02-27 12:34: Backfilled roadmap state by closing the stale M4 weak-hook app-equality bridge item and linking it to existing `Kea/Typing.lean` theorem families (`app_unify_result_eq_of_unify_success_contract_succ` + closed/fresh specializations, `AppUnifyNoopDomain`, resolved-shape hook packaging); formal trackers updated.
- 2026-02-27 12:35: Marked the stale M4 DataFrame-verb typing follow-up as N/A for Kea scope in `formal/ROADMAP.md`; retained principal-typing extension as the only remaining M4 language-level open item.
- 2026-02-27 12:37: Added a packaged preconditioned principal-typing slice in `Kea/Typing.lean` (`PrincipalTypingSlicePreconditioned`, `principalTypingSlicePreconditioned_of_success`) bundling determinism, declarative uniqueness, and `inferExpr` agreement from successful `inferExprUnify` runs; `cd formal && lake build` passes.
- 2026-02-27 12:49: Added the missing hook-free no-unify principal/equivalence theorem stack in `Kea/Typing.lean` (expression+field completeness, state-preservation, and iff surfaces culminating in `PrincipalTypingNoUnifySlices`), aligned `FORMAL.md` + `formal/ROADMAP.md` to the landed theorem names, and revalidated with `cd formal && lake build`.
- 2026-02-27 12:50: Added `principalTypingSlicePreconditioned_of_success_no_unify` in `Kea/Typing.lean`, bridging no-unify successful runs back into the same `PrincipalTypingSlicePreconditioned` API without relying on app/proj hook assumptions; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 12:53: Added core declarative principality packaging in `Kea/Typing.lean` (`hasType_unique`, `inferExpr_principal`, `PrincipalTypingSliceCore`, `principalTypingSliceCore_of_infer`) to expose a hook-free principal baseline at the syntax-directed core judgment; updated `FORMAL.md` + `formal/ROADMAP.md` and revalidated with `cd formal && lake build`.
- 2026-02-27 12:58: Added bundled-hook principal entrypoints in `Kea/Typing.lean` (`UnifyHookPremises`, `principalTypingSlicePreconditioned_of_success_from_bundle`, `principalTypingSlicePreconditioned_of_success_no_unify_from_bundle`) to reduce principal-slice call-site assumptions to a single hook package; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 12:59: Added no-unify unify-success bridges into core principal bundles (`principalTypingSliceCore_of_unify_success_no_unify`, `principalFieldTypingSliceCore_of_unify_success_no_unify`) so successful hook-free `inferExprUnify`/`inferFieldsUnify` runs project directly to declarative principal packages; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:01: Added a general core-principal-to-preconditioned bridge (`principalTypingSlicePreconditioned_of_success_of_core_principal`) and refactored the no-unify preconditioned theorem to route through it, reducing duplicated reasoning while preserving the existing bundle APIs; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:02: Added converse preconditioned-to-core principal bridges (`principalTypingSliceCore_of_preconditioned_success`, `principalTypingSliceCore_of_preconditioned_success_from_bundle`) so successful preconditioned runs project back into core principality packaging; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:03: Added packaged no-unify bridge exports (`PrincipalNoUnifyBridgeBundle`, `principalNoUnifyBridgeBundle_of_success`, `principalNoUnifyBridgeBundle_of_success_from_hook_bundle`) so one successful no-unify run now yields both core and preconditioned principal packages from a single theorem surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:06: Added full field-side preconditioned principality parity (`inferFieldsUnify_deterministic`, `inferFieldsUnify_row_unique_preconditioned`, `PrincipalFieldTypingSlicePreconditioned`) with direct/bundle/no-unify/core-bridge constructors (`principalFieldTypingSlicePreconditioned_of_success*` family), aligning field theorem surfaces with the expression principal stack; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:07: Added packaged no-unify field bridge exports (`PrincipalFieldNoUnifyBridgeBundle`, `principalFieldNoUnifyBridgeBundle_of_success`, `principalFieldNoUnifyBridgeBundle_of_success_from_hook_bundle`) so one successful no-unify `inferFieldsUnify` run now yields both core and preconditioned field principal packages from one theorem surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:08: Added converse preconditioned-to-core field principal bridges (`principalFieldTypingSliceCore_of_preconditioned_success`, `principalFieldTypingSliceCore_of_preconditioned_success_from_bundle`) to complete expression/field symmetry for principal bridge directions; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:10: Added combined no-unify bridge capstone packaging (`PrincipalNoUnifyExprBridgeSlice`, `PrincipalNoUnifyFieldBridgeSlice`, `PrincipalNoUnifyBridgeSlices`, `principalNoUnifyBridgeSlices_proved`) so expression+field hook-free bridge APIs are exported through one proved theorem surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:40: Added successful-run equivalence bridges between preconditioned and core principal slices for both expressions and fields (`principalTypingSlicePreconditioned_iff_core_of_success`, `principalTypingSlicePreconditioned_iff_core_of_success_from_bundle`, `principalFieldTypingSlicePreconditioned_iff_core_of_success`, `principalFieldTypingSlicePreconditioned_iff_core_of_success_from_bundle`), then updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:41: Added combined successful-run equivalence capstone packaging (`PrincipalPreconditionedExprCoreIffSlice`, `PrincipalPreconditionedFieldCoreIffSlice`, `PrincipalPreconditionedCoreIffSlices`, `principalPreconditionedCoreIffSlices_proved`) so preconditioned↔core principality is exported through one expression+field theorem surface under bundled hooks; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:43: Added one-hop projection helpers from the combined capstones (`principalNoUnifyBridgeSlices_expr/field`, `principalPreconditionedCoreIffSlices_expr/field`) so downstream proofs can consume expression and field branches directly from packaged slice assumptions; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:45: Added top-level suite packaging for the M4 principal boundary (`PrincipalBoundaryBridgeSuite`, `principalBoundaryBridgeSuite_proved`) plus suite-level one-hop projections (`principalBoundaryBridgeSuite_noUnify_*`, `principalBoundaryBridgeSuite_preconditionedCoreIff_*`) to expose both capstones from one theorem surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:46: Added suite-based no-unify convenience entrypoints (`principalNoUnifyCoreExpr/Field_of_success_via_suite`, `principalNoUnifyPreconditionedExpr/Field_of_success_via_suite`) so successful no-unify runs can project directly to core/preconditioned principal packages from `principalBoundaryBridgeSuite_proved`; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:48: Added suite-based generic successful-run conversion wrappers in both directions (`principalCoreExpr/Field_of_preconditioned_success_via_suite`, `principalPreconditionedExpr/Field_of_core_success_via_suite`) so preconditioned↔core transport is one-step at call sites for both expressions and fields; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:50: Added suite coherence lemmas (`principalBoundaryBridgeSuite_noUnify_*_coherent_*`) to show no-unify bundle witnesses and preconditioned↔core equivalence witnesses inter-derive each other for both expressions and fields; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 13:59: Added no-unify principal capstone packaging in `Kea/Typing.lean` (`PrincipalBoundaryNoUnifyExprCapstone`, `PrincipalBoundaryNoUnifyFieldCapstone`, `PrincipalBoundaryNoUnifyCapstoneSlices`, plus suite-derived constructors/projections/coherence wrappers) so successful no-unify runs now expose both witnesses and their successful-run equivalence through one capstone surface; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 14:01: Added one-hop extraction helpers from the combined no-unify capstone slices (`principalBoundaryNoUnifyCapstoneSlices_expr_*`, `principalBoundaryNoUnifyCapstoneSlices_field_*`) for direct core/preconditioned/`↔` access at expression and field call sites; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 14:02: Added hook-passing parity entrypoints for capstone construction (`principalBoundaryNoUnifyExpr/FieldCapstone_of_success`, `principalBoundaryNoUnifyExpr/FieldCapstone_of_success_from_hook_bundle`) so no-unify capstones can be built from either direct hooks or bundled hook premises; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 14:06: Added fixed-run hook-transport/irrelevance theorems for preconditioned principality (`principalTypingSlicePreconditioned_transport_hooks_of_success`, `principalTypingSlicePreconditioned_hook_irrelevant_of_success`, plus field analogues), making hook witness independence explicit once inference success is fixed; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 14:07: Packaged fixed-run hook-independence into combined expression+field slices (`PrincipalPreconditionedHookIrrelevanceSlices`, `principalPreconditionedHookIrrelevanceSlices_proved`) with one-hop branch projections (`principalPreconditionedHookIrrelevanceSlices_expr/field`) for direct downstream use; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 14:09: Added top-level vacuity-suite packaging (`PrincipalBoundaryVacuitySuite`, `principalBoundaryVacuitySuite_proved`) with one-hop projections for both no-unify capstones and fixed-run hook-irrelevance branches (`principalBoundaryVacuitySuite_*`), consolidating these M4 theorem surfaces under one entrypoint; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 14:11: Added no-unify all-hooks capstone surfaces (`PrincipalBoundaryNoUnifyExpr/FieldAllHooksCapstone`, `PrincipalBoundaryNoUnifyAllHooksCapstoneSlices`, branch projections) so one no-unify success now exports hook-free core plus per-hook preconditioned/`↔` consequences directly; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 14:25: Added all-hooks-derived irrelevance packaging (`PrincipalBoundaryNoUnifyAllHooksIrrelevanceSlices`, `principalBoundaryNoUnifyAllHooksIrrelevanceSlices_proved`, expression/field projections) and direct capstone coherence lemmas (`principalBoundaryNoUnifyExpr/FieldAllHooksCapstone_hook_irrelevant`) so hook-independence is now explicitly derivable from all-hooks capstones on no-unify successes; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 14:26: Added top-level all-hooks suite packaging (`PrincipalBoundaryNoUnifyAllHooksSuite`, `principalBoundaryNoUnifyAllHooksSuite_proved`) with one-hop projections for both all-hooks capstones and derived irrelevance branches (`principalBoundaryNoUnifyAllHooksSuite_*`), consolidating the no-unify all-hooks theorem surface under one entrypoint; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 14:38: Added compatibility bridges from all-hooks back to hook-specific no-unify capstones (`principalBoundaryNoUnifyExpr/FieldCapstone_of_allHooks`) and derived the legacy no-unify capstone slice surface from all-hooks proofs (`principalBoundaryNoUnifyCapstoneSlices_of_allHooksCapstones`, `principalBoundaryNoUnifyCapstoneSlices_of_allHooksSuite`); formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 14:40: Added a top-level principal boundary master suite (`PrincipalBoundaryMasterSuite`, `principalBoundaryMasterSuite_proved`) with one-hop projections spanning bridge/vacuity/all-hooks surfaces and all-hooks→hooked compatibility (`principalBoundaryMasterSuite_*`), consolidating the current M4 boundary theorem APIs under a single entrypoint; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 14:42: Added all-hooks-suite no-unify convenience wrappers (`principalNoUnifyCore*` and `principalNoUnifyPreconditioned*_*_via_allHooksSuite`, including any-hooks forms) so core/preconditioned consequences are directly consumable from no-unify successes without manual capstone destructuring; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 15:07: Added general successful-run all-hooks capstone packaging (`PrincipalPreconditionedExpr/FieldAllHooksCapstone`, `PrincipalPreconditionedAllHooksCapstoneSlices`, one-hop projections) so arbitrary successful `inferExprUnify`/`inferFieldsUnify` runs export core + any-hooks preconditioned consequences from one hook witness pair; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 15:09: Added top-level general all-hooks suite packaging (`PrincipalPreconditionedAllHooksSuite`, `principalPreconditionedAllHooksSuite_proved`) with capstone-derived irrelevance (`principalPreconditionedHookIrrelevanceSlices_of_allHooksCapstones`) and one-hop projections (`principalPreconditionedAllHooksSuite_*`) so this non-no-unify layer is directly consumable as a single theorem surface; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 15:11: Extended the principal boundary master suite to include the general all-hooks successful-run layer (`PrincipalBoundaryMasterSuite.allHooks`, `principalBoundaryMasterSuite_allHooks_*`) while keeping bridge/vacuity/no-unify-all-hooks projections, so one master entrypoint now spans both no-unify and arbitrary-success all-hooks APIs; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 15:13: Added general-all-hooks-suite convenience wrappers (`principalCore*` and `principalPreconditioned*_*_via_generalAllHooksSuite`, including any-hooks forms) so arbitrary successful runs can project core/preconditioned consequences directly from the new all-hooks suite without manual capstone destructuring; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 15:15: Added master-suite convenience wrappers (`principalCore*` and `principalPreconditioned*_*_via_masterSuite`, including any-hooks forms) so arbitrary successful-run consequences can be consumed directly from `PrincipalBoundaryMasterSuite` without manually routing through nested suite layers; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 15:17: Added master-suite no-unify convenience wrappers (`principalNoUnifyCore*` and `principalNoUnifyPreconditioned*_*_via_masterSuite`, including any-hooks forms) so no-unify consequences now use the same top-level master entrypoint as arbitrary-success consequences; formal trackers updated and revalidated with `cd formal && lake build`.
- 2026-02-27 15:28: Added explicit no-unify-to-general all-hooks bridge projections in `Kea/Typing.lean` (`principalPreconditionedExpr/FieldAllHooksCapstone_of_noUnifyAllHooks`, suite/master `*_capstone_*_as_general`) so successful no-unify witnesses can be consumed directly on the general successful-run all-hooks theorem surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 15:35: Added success-level no-unify-to-general capstones/wrappers (`principalPreconditionedExpr/FieldAllHooksCapstone_of_success_noUnify`, `principalCore*` and `principalPreconditioned*AnyHooks*_of_success_noUnify_via_generalAllHooks`) so no-unify successful runs can project directly into general all-hooks core/preconditioned consequences without first constructing suite witnesses; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 15:42: Added bundled-hook and irrelevance parity wrappers on the no-unify-to-general path (`principalPreconditionedExpr/Field_of_success_noUnify_via_generalAllHooks`, `principalPreconditionedExpr/Field_hookIrrelevant_of_success_noUnify_via_generalAllHooks`) to keep expression/field and any-hooks/bundled/irrelevance theorem surfaces aligned; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 15:49: Packaged the no-unify-to-general bridge into a dedicated suite surface (`PrincipalNoUnifyToGeneralAllHooksSuite`, capstone + irrelevance slices, and one-hop expr/field projections) so this path is consumable through one proved theorem API parallel to other M4 suite layers; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 15:55: Extended `PrincipalBoundaryMasterSuite` with the dedicated no-unify-to-general bridge field (`noUnifyToGeneralAllHooks`) plus master-level capstone/irrelevance projections (`principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_*`), and routed existing `*_noUnifyAllHooks_*_as_general` adapters through this canonical path; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 16:04: Added hook-irrelevance convenience wrappers across suite entrypoints (`principalPreconditioned*hookIrrelevant*_via_generalAllHooksSuite`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_masterSuite`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_allHooksSuite`) to complete any-hooks/bundled/irrelevance API parity on both general and no-unify success paths; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 16:12: Routed master-suite no-unify core/preconditioned convenience wrappers (`principalNoUnifyCore*` / `principalNoUnifyPreconditioned*_*_via_masterSuite`) through the canonical `principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_*` projections, consolidating no-unify-as-general consumption on one master path; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 16:18: Routed all-hooks-suite no-unify convenience wrappers (including hook-irrelevance variants) through `PrincipalNoUnifyToGeneralAllHooksSuite_proved`, aligning master and all-hooks entrypoints to the same canonical no-unify-to-general bridge surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 16:26: Added bidirectional compatibility theorems between `PrincipalBoundaryNoUnifyAllHooksSuite` and `PrincipalNoUnifyToGeneralAllHooksSuite` (including proved derived forms), then routed `PrincipalBoundaryMasterSuite.noUnifyToGeneralAllHooks` construction through the no-unify-all-hooks derived path to make the canonical relation explicit; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 16:33: Added parameterized no-unify-to-general convenience wrappers (`principalNoUnifyToGeneralCore*`, `principalNoUnifyToGeneralPreconditioned*_*`) and routed both master/all-hooks no-unify convenience entrypoints through this reusable layer, consolidating expression/field + any-hooks/bundled/irrelevance access on one suite API; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 16:41: Added no-unify `preconditioned ↔ core` convenience wrappers on the canonical no-unify-to-general layer (`principalNoUnifyToGeneralPreconditionedCoreIff*`) and lifted them through master/all-hooks entrypoints (`principalNoUnifyPreconditionedCoreIff*_of_success_via_*Suite`) to complete no-unify wrapper parity; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 16:48: Added arbitrary-success bundled-hook `preconditioned ↔ core` convenience wrappers for general/master entrypoints (`principalPreconditionedCoreIff*_of_success_via_generalAllHooksSuite`, `principalPreconditionedCoreIff*_of_success_via_masterSuite`) to mirror the no-unify wrapper surface and maintain API parity across both paths; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 16:56: Added no-unify any-hooks `preconditioned ↔ core` wrappers on canonical/master/all-hooks entrypoints (`principalNoUnifyToGeneralPreconditionedCoreIff*AnyHooks*`, `principalNoUnifyPreconditionedCoreIff*AnyHooks*_of_success_via_*Suite`) and routed bundled wrappers through these APIs to complete any-hooks/bundled parity for the no-unify `↔` surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 17:03: Added arbitrary-success any-hooks `preconditioned ↔ core` wrappers for general/master entrypoints (`principalPreconditionedCoreIff*AnyHooks*_of_success_via_generalAllHooksSuite`, `principalPreconditionedCoreIff*AnyHooks*_of_success_via_masterSuite`) and routed bundled wrappers through them, completing any-hooks/bundled parity for both no-unify and non-no-unify `↔` surfaces; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 17:10: Added a parameterized arbitrary-success convenience layer over `PrincipalPreconditionedAllHooksSuite` (`principalGeneralAllHooks*`) and routed both `via_generalAllHooksSuite` and `via_masterSuite` wrappers through it, consolidating non-no-unify expression/field core/preconditioned/`↔`/irrelevance consumption on one canonical API; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 17:18: Added missing direct no-unify-to-general `preconditioned ↔ core` wrappers on the proved general-all-hooks success path (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_generalAllHooks`, `principalPreconditionedCoreIff*_of_success_noUnify_via_generalAllHooks`) to complete expression/field parity without suite destructuring; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 17:25: Added projection-side weak-hook refinement in `Kea/Typing.lean` (`ProjUnifySoundHookWeak`, `projUnifySoundHookWeak_proved`) and packaged app+projection weak premises (`UnifyHookPremisesWeak`, `unifyHookPremisesWeak_proved`) to tighten the M4 hook-boundary API before the next lift step; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 17:33: Strengthened the weak-hook boundary bridge with strong→weak adapters (`appUnifySoundHookWeak_of_appUnifySoundHook`, `projUnifySoundHookWeak_of_projUnifySoundHook`, `unifyHookPremisesWeak_of_unifyHookPremises`) so existing preconditioned hook assumptions now project directly into the weak-hook package surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 17:41: Added master no-unify-to-general naming-parity wrappers for fixed-run `preconditioned ↔ core` transport (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_masterSuite`, `principalPreconditionedCoreIff*_of_success_noUnify_via_masterSuite`) routed through canonical no-unify master wrappers; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 17:48: Added explicit weak-boundary one-step branch soundness surfaces (`inferExprUnify_app_step_sound_weak`, `inferExprUnify_proj_step_sound_weak`) so weak-hook assumptions are consumable directly at app/proj step theorem APIs; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 17:56: Added strong-hook-lifted weak-step corollaries (`inferExprUnify_app_step_sound_weak_of_strong`, `inferExprUnify_proj_step_sound_weak_of_strong`) so existing strong hook witnesses can flow through the new weak-step branch API without restating premises; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 18:04: Added weak/strong-bundle weak-step entrypoints (`inferExprUnify_app_step_sound_weak_from_bundle`, `inferExprUnify_proj_step_sound_weak_from_bundle`, `inferExprUnify_app_step_sound_weak_from_strong_bundle`, `inferExprUnify_proj_step_sound_weak_from_strong_bundle`) so both hook package shapes now feed the same weak-step branch API directly; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 18:12: Added a canonical weak local-step bundle surface (`UnifyStepSoundWeak`) with constructors from weak/strong hook packages (`unifyStepSoundWeak_of_hookPremisesWeak`, `unifyStepSoundWeak_of_unifyHookPremises`) and direct step-bundle entrypoints (`inferExprUnify_*_step_sound_weak_from_stepBundle`) so downstream proofs can depend on one stable weak-boundary bundle API; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 18:20: Added direct proved/strong-package weak-step entrypoints (`inferExprUnify_*_step_sound_weak_proved`, `inferExprUnify_*_step_sound_weak_from_unifyHookPremises`) so call sites consume weak app/proj step APIs without manual weak-bundle assembly; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 18:28: Added all-hooks no-unify naming-parity wrappers for fixed-run `preconditioned ↔ core` transport (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_allHooksSuite`, `principalPreconditionedCoreIff*_of_success_noUnify_via_allHooksSuite`) routed through canonical all-hooks no-unify wrappers; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 18:36: Added master/all-hooks no-unify naming-parity wrappers for core/preconditioned/hook-irrelevance surfaces (`principalCore*`, `principalPreconditioned*_*`, `principalPreconditioned*hookIrrelevant*_of_success_noUnify_via_*Suite`) routed through canonical `principalNoUnify*` wrappers; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 18:44: Added arbitrary-success all-hooks capstone entry wrappers across general/master suite layers (`principalPreconditionedExpr/FieldAllHooksCapstone_of_success_via_generalAllHooksSuite`, bundled `..._from_bundle` forms, and matching `..._via_masterSuite` forms) so one successful run now exports full core+any-hooks preconditioned+`↔` consequences as a single packaged theorem surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 18:52: Added bundled-baseline arbitrary-success convenience wrappers across general/master entrypoints (`principalCore*`, `principalPreconditioned*AnyHooks*`, `principalPreconditionedCoreIff*AnyHooks*_of_success_via_*Suite_from_bundle`) so one `UnifyHookPremises` seed now drives the non-no-unify principal API without split baseline-hook arguments; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 19:00: Completed bundled-baseline parity for bundled target-hook arbitrary-success wrappers (`principalPreconditioned*_*_of_success_via_*Suite_from_bundle`, including `preconditioned ↔ core` forms) so single-seed entrypoints now cover both any-hooks and bundled-target theorem consumption across general/master layers; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 19:19: Added run-level arbitrary-success all-hooks bundle contracts (`PrincipalPreconditionedExpr/FieldAllHooksRunBundle`) with constructors from capstones/success (split and bundled seed hooks) plus general/master suite entry wrappers (`..._of_success_via_generalAllHooksSuite(_from_bundle)`, `..._of_success_via_masterSuite(_from_bundle)`), so capstone + fixed-run hook-irrelevance consequences are exported through one theorem output per successful run; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 19:27: Added combined arbitrary-success run-bundle slice packaging (`PrincipalPreconditionedAllHooksRunBundleExpr/FieldSlice`, `PrincipalPreconditionedAllHooksRunBundleSlices`, proved theorem, and expression/field one-hop projections) to align run-bundle consumption with existing capstone/suite slice APIs; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 19:35: Extended `PrincipalPreconditionedAllHooksSuite` with run-bundle slices (`runBundles`) and added suite-level run-bundle projections (`principalPreconditionedAllHooksSuite_runBundle_expr/field`), so one general-all-hooks suite witness now exports capstones, irrelevance, and run-bundle packaging together; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 19:42: Added master-suite run-bundle one-hop projections (`principalBoundaryMasterSuite_allHooks_runBundle_expr/field`) so top-level `PrincipalBoundaryMasterSuite` consumers can extract arbitrary-success all-hooks run bundles without dropping to nested suite fields; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 19:50: Extended no-unify-to-general all-hooks packaging with run-bundle slices/projections (`PrincipalNoUnifyToGeneralAllHooks*RunBundle*`, suite `runBundles`, suite/master one-hop run-bundle projections) and updated no-unify-all-hooks compatibility construction (`principalNoUnifyToGeneralAllHooksSuite_of_noUnifyAllHooksSuite`) to populate the new run-bundle field; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 19:58: Extended no-unify all-hooks packaging with run-bundle slices/projections (`PrincipalBoundaryNoUnifyAllHooks*RunBundle*`, suite `runBundles`, suite/master one-hop run-bundle projections) and updated no-unify-to-general compatibility construction (`principalBoundaryNoUnifyAllHooksSuite_of_noUnifyToGeneralAllHooksSuite`) to preserve the expanded suite shape; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 20:06: Added explicit run-bundle compatibility theorems between no-unify and no-unify-to-general suite layers (both directions plus canonical proved variants: `...RunBundleSlices_of_...Suite`, `...RunBundleSlices_proved_via_...`), making cross-suite equivalence first-class at the run-bundle slice boundary; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 20:14: Added direct no-unify run-bundle convenience wrappers across general/master/all-hooks entrypoints (`principalPreconditioned*AllHooksRunBundle_of_success_noUnify_via_*`), so no-unify successful runs can target the run-bundle API without manual suite/capstone reconstruction; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 20:22: Added a top-level master run-bundle aggregate (`PrincipalBoundaryMasterRunBundleSuite`, `principalBoundaryMasterRunBundleSuite_of_master`, `..._proved`) and no-unify-as-general run-bundle projections (`principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_*_as_general`) so all-hooks/no-unify/no-unify-to-general run-bundle entrypoints are consumable through one master-derived theorem API; fixed resulting Lean unused-binder warnings by marking seed-hook binders as intentionally unused (`_h_app0`, `_h_proj0`); updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 20:30: Added one-hop projection/coherence helpers for `PrincipalBoundaryMasterRunBundleSuite` (`..._allHooks_*`, `..._noUnifyAllHooks_*`, `..._noUnifyToGeneral_*`, `..._noUnify_*_as_general`) so run-bundle consumers can stay on projection APIs instead of manual record-field destructuring; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 20:38: Added direct convenience wrappers over the proved master run-bundle suite (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterRunBundleSuite*`, including bundled-seed and no-unify variants) so run-bundle call sites avoid explicit suite-threading boilerplate; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 20:46: Added canonical no-unify run-bundle convenience wrappers on no-unify suite layers (`principalBoundaryNoUnifyRunBundle*_*_via_allHooksSuite`, `principalNoUnifyToGeneralRunBundle*_*_of_success`) so higher-level wrappers route through stable per-suite run-bundle API names; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 20:54: Added naming-parity no-unify run-bundle wrappers on all-hooks/master entrypoints (`principalNoUnifyRunBundle*_*_via_allHooksSuite`, `principalNoUnifyRunBundle*_*_via_masterSuite`) and rerouted no-unify run-bundle convenience wrappers through canonical per-suite run-bundle APIs (`principalNoUnifyToGeneralRunBundle*_*_of_success`); updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 21:02: Added parameterized arbitrary-success run-bundle convenience wrappers on the general-all-hooks layer (`principalGeneralAllHooksRunBundleExpr/Field_of_success`) and rerouted both general/master run-bundle entry wrappers through that canonical layer; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 21:10: Added direct run-bundle projection helpers for expression/field core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance surfaces (`principalPreconditioned*AllHooksRunBundle_*`) so run-bundle consumers can extract principal consequences without manual capstone-field destructuring; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 21:18: Added naming-parity no-unify run-bundle wrappers on the master-run-bundle-suite path (`principalNoUnifyRunBundle*_*_via_masterRunBundleSuite`) and rerouted the long-form no-unify run-bundle wrappers through these aliases to keep master run-bundle entry naming consistent; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 21:26: Added master-run-bundle no-unify consequence wrappers for core/any-hooks-preconditioned/hook-irrelevance (`principalNoUnifyCore*`, `principalNoUnifyPreconditioned*AnyHooks*`, `principalNoUnifyPreconditioned*hookIrrelevant*_*_via_masterRunBundleSuite`) by projecting through no-unify run-bundle aliases; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 21:34: Completed master-run-bundle no-unify wrapper parity by adding bundled preconditioned and bundled/any-hooks preconditioned↔core surfaces (`principalNoUnifyPreconditioned*_of_success_via_masterRunBundleSuite`, `principalNoUnifyPreconditionedCoreIff*_*_via_masterRunBundleSuite`) on top of the existing core/any-hooks/hook-irrelevance path; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 21:42: Routed master-suite no-unify consequence wrappers (core, preconditioned, preconditioned↔core, hook-irrelevance) through no-unify run-bundle projection helpers, aligning master no-unify API consumption with the canonical run-bundle path; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 21:50: Added long-form no-unify-to-general naming-parity wrappers on master-run-bundle-suite (`principalCore*`, `principalPreconditioned*_*`, `principalPreconditionedCoreIff*_*`, `principalPreconditioned*hookIrrelevant*_*_of_success_noUnify_via_masterRunBundleSuite`) to mirror master/all-hooks naming conventions; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 21:58: Added packaged per-run no-unify consequence bundles on master-run-bundle-suite (`PrincipalNoUnifyExpr/FieldRunBundleConsequences`, constructors `..._of_success_via_masterRunBundleSuite`) so core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance are consumable from one theorem output; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 22:06: Lifted master-run-bundle no-unify consequence bundles to slice-level packaging (`PrincipalNoUnifyExpr/FieldRunBundleConsequenceSlice`, combined `PrincipalNoUnifyRunBundleConsequenceSlices`, proved + one-hop projections) so expression/field no-unify bundle consequences are consumable through one reusable theorem surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 22:14: Added top-level master run-bundle consequence suite (`PrincipalBoundaryMasterRunBundleConsequenceSuite`) with constructors from master/master-run-bundle suites, proved theorem, and no-unify expr/field one-hop consequence projections, so run-bundle and no-unify consequence surfaces now share one aggregate API; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 22:22: Added direct convenience wrappers over `principalBoundaryMasterRunBundleConsequenceSuite_proved` (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite` plus core/any-hooks projections) so no-unify consequence-bundle consumption is one-step from the aggregate consequence suite; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 22:30: Extended the master-run-bundle-consequence-suite convenience layer to full no-unify parity by adding bundled preconditioned, bundled/any-hooks preconditioned↔core, and hook-irrelevance wrappers (`principalPreconditioned*_*`, `principalPreconditionedCoreIff*_*`, `principalPreconditioned*hookIrrelevant*_*_of_success_noUnify_via_masterRunBundleConsequenceSuite`); updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 22:38: Added inherited run-bundle projection helpers on the master-run-bundle consequence suite (`principalBoundaryMasterRunBundleConsequenceSuite_{allHooks,noUnifyAllHooks,noUnifyToGeneral}_{expr,field}`) so callers can access run-bundle and consequence surfaces from one aggregate API entrypoint; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 22:46: Added matching run-bundle convenience wrappers over `principalBoundaryMasterRunBundleConsequenceSuite_proved` (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterRunBundleConsequenceSuite*` plus no-unify variants), so arbitrary-success and no-unify run-bundle access also routes through the same aggregate consequence-suite entrypoint; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 22:54: Added full `principalNoUnify*` naming-parity aliases on master-run-bundle-consequence-suite (core, preconditioned, preconditioned↔core, hook-irrelevance for expr+field) routed through existing long-form no-unify-to-general wrappers, aligning naming conventions with master/all-hooks layers; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 23:02: Added master-suite one-hop projections into the consequence-suite layer (`principalBoundaryMasterSuite_runBundleConsequenceSuite`, `principalBoundaryMasterSuite_noUnifyRunBundleConsequences_{expr,field}`) so top-level master consumers can access no-unify consequence bundles directly via one-hop APIs; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 23:10: Routed master-suite no-unify consequence wrappers (core, preconditioned, preconditioned↔core, hook-irrelevance for expr+field) through `principalBoundaryMasterSuite_noUnifyRunBundleConsequences_{expr,field}` plus consequence-suite no-unify-to-general run-bundle projections, keeping top-level no-unify theorem consumption on the canonical consequence path; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 23:18: Added top-level master run-bundle projection wrappers via the consequence-suite aggregate (`principalBoundaryMasterSuite_{allHooks,noUnifyAllHooks,noUnifyToGeneral}AllHooks_runBundle_{expr,field}_via_consequenceSuite`) and routed master no-unify run-bundle convenience wrappers through that layer so consequence-path entrypoints are explicit and consistent; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 23:26: Added bundled-hook no-unify `_from_bundle` wrappers on both master paths (`..._of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle`, `..._of_success_noUnify_via_masterSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), completing no-unify bundled-hook naming parity with existing arbitrary-success wrapper families; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 23:34: Added `principalNoUnify*..._from_bundle` alias wrappers on the same master paths (`..._via_masterRunBundleConsequenceSuite_from_bundle`, `..._via_masterSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), completing bundled-hook parity for both long-form and no-unify naming families; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 23:42: Added matching all-hooks no-unify bundled-hook `_from_bundle` wrappers for both long-form and `principalNoUnify*` naming families (`..._of_success_noUnify_via_allHooksSuite_from_bundle`, `..._via_allHooksSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), closing bundled-hook parity across all-hooks/master/master-consequence entry layers; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 23:50: Added consequence-bundle-to-capstone projections (`principalNoUnifyExpr/FieldRunBundleConsequences_capstone`) and top-level master `..._via_consequenceSuite` capstone/irrelevance wrappers (`principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_{expr,field,irrelevance_*}_via_consequenceSuite`), extending consequence-path coverage beyond run-bundle surfaces; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-27 23:58: Added consequence-path no-unify-as-general aliases on top-level master projections (`principalBoundaryMasterSuite_noUnifyAllHooks_{expr,field,runBundle_*}_as_general_via_consequenceSuite`), restoring no-unify-as-general coherence on the consequence routing layer; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:06: Added no-unify capstone convenience wrappers on both master paths (`principalPreconditioned*AllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite`, `principalPreconditioned*AllHooksCapstone_of_success_noUnify_via_masterSuite`), bringing capstone-level no-unify entrypoints into parity with run-bundle/consequence surfaces; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:14: Added no-unify capstone alias wrappers (`principalNoUnify*AllHooksCapstone_of_success_via_*Suite`) across all-hooks/master/master-consequence entry layers, completing capstone naming parity with the existing run-bundle/consequence alias families; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:22: Added bundled-hook no-unify capstone wrappers/aliases (`...AllHooksCapstone_of_success_noUnify_via_*Suite_from_bundle`, `principalNoUnify*AllHooksCapstone_of_success_via_*Suite_from_bundle`) across all-hooks/master/master-consequence layers, completing `_from_bundle` parity for capstone no-unify entry surfaces; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:30: Added arbitrary-success capstone wrappers on the consequence path (`principalBoundaryMasterSuite_allHooks_{expr,field}_via_consequenceSuite`, `principalPreconditioned*AllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite*`) so consequence-route APIs now expose capstone entry surfaces for arbitrary-success slices as well as no-unify slices; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:38: Added arbitrary-success hook-irrelevance wrappers on the consequence route (`principalBoundaryMasterSuite_allHooks_irrelevance_{expr,field}_via_consequenceSuite`, `principalPreconditioned*hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite*`, `principalPreconditioned*hookIrrelevant_of_success_via_masterSuite*`), extending consequence-path coverage to fixed-run irrelevance for non-no-unify slices; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:46: Added bundled-hook no-unify hook-irrelevance wrappers/aliases (`...hookIrrelevant_of_success_noUnify_via_*Suite_from_bundle`, `principalNoUnifyPreconditioned*hookIrrelevant_of_success_via_*Suite_from_bundle`) across all-hooks/master/master-consequence layers, completing `_from_bundle` parity for no-unify irrelevance surfaces; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:54: Added bundled-hook arbitrary-success irrelevance wrappers on the general-all-hooks path (`principalPreconditioned*hookIrrelevant_of_success_via_generalAllHooksSuite_from_bundle`), closing the remaining `_from_bundle` parity gap for non-no-unify irrelevance entrypoints; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:02: Added a master consequence capstone aggregate (`PrincipalBoundaryMasterConsequenceCapstoneSuite`) with constructor/proved/master one-hop and expression/field capstone+irrelevance projections, so consequence-path capstone/irrelevance surfaces are consumable from one packaged theorem API; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:10: Added direct convenience wrappers over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (arbitrary-success + no-unify capstone families, `principalNoUnify*` aliases, and `_from_bundle` variants), making the new consequence-capstone aggregate one-step consumable at call sites; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:18: Added full hook-irrelevance convenience/alias parity over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalPreconditioned*hookIrrelevant*_of_success_via_masterConsequenceCapstoneSuite*`, `..._of_success_noUnify_via_masterConsequenceCapstoneSuite*`, and `principalNoUnifyPreconditioned*hookIrrelevant*_via_masterConsequenceCapstoneSuite*`, including `_from_bundle` variants), completing one-step consequence-capstone aggregate coverage for both arbitrary-success and no-unify irrelevance surfaces; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:26: Added direct core/preconditioned/preconditioned↔core convenience wrappers over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalCore*`, `principalPreconditioned*{,_anyHooks}*`, `principalPreconditionedCoreIff*{,_anyHooks}*` on `..._via_masterConsequenceCapstoneSuite*`, including bundled-baseline variants), making the consequence-capstone aggregate path one-step consumable for full principal-boundary surfaces beyond capstone/irrelevance; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:34: Added full no-unify principal-surface parity over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalNoUnifyCore*`, `principalNoUnifyPreconditioned*{,_anyHooks}*`, `principalNoUnifyPreconditionedCoreIff*{,_anyHooks}*` plus long-form `..._of_success_noUnify_via_masterConsequenceCapstoneSuite*` aliases and bundled variants), so no-unify consequence-capstone entrypoints now match arbitrary-success coverage for core/preconditioned/`↔` theorem APIs; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:42: Added missing bundled-baseline `_from_bundle` aliases for core/any-hooks consequence-capstone surfaces (`principal{NoUnify,}Core*`, `principal{NoUnify,}Preconditioned*AnyHooks*`, `principal{NoUnify,}PreconditionedCoreIff*AnyHooks*`, plus long-form no-unify-to-general counterparts on `..._via_masterConsequenceCapstoneSuite*`), completing bundled-seed naming parity across capstone/irrelevance/core/preconditioned/`↔` entrypoints; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:50: Added direct run-bundle convenience wrappers on `..._via_masterConsequenceCapstoneSuite*` (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterConsequenceCapstoneSuite*`, no-unify variants, and `principalNoUnifyRunBundle*` aliases), so the consequence-capstone route now exports packaged `capstone + hook-irrelevance` bundles in one step; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:57: Added direct packaged no-unify consequence constructors on `..._via_masterConsequenceCapstoneSuite*` (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite`), so consequence-capstone entrypoints now emit the full no-unify bundle surface (core/preconditioned/`↔`/irrelevance) in one theorem output; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:59: Added bundled-hook `_from_bundle` aliases for those consequence-capstone no-unify consequence constructors (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite_from_bundle`), completing naming parity for packaged no-unify consequence entrypoints on this route; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:01: Added a packaged no-unify consequence slice layer for the consequence-capstone route (`PrincipalNoUnifyExpr/FieldRunBundleConsequenceSliceViaMasterConsequenceCapstoneSuite`, combined `PrincipalNoUnifyRunBundleConsequenceSlicesViaMasterConsequenceCapstoneSuite`, proved theorem, and expression/field one-hop projections), giving this route a reusable all-runs bundle API shape parallel to the master-run-bundle consequence path; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:03: Added explicit cross-route no-unify consequence coherence constructors (`PrincipalNoUnifyExpr/FieldRunBundleConsequencesBothMasterConsequenceRoutes` plus `principalNoUnify*RunBundleConsequences_on_both_master_consequence_routes`) so one theorem output now carries witnesses from both `masterConsequenceCapstone` and `masterRunBundleConsequence` entry layers; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:05: Lifted that cross-route no-unify consequence coherence into reusable all-runs slice packaging (`PrincipalNoUnify*RunBundleConsequencesBothMasterConsequenceRoutesSlice`, combined `...RoutesSlices`, proved theorem, and expression/field projections), aligning route-coherence consumption with the existing slice-based theorem API style; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:08: Added route-specific one-hop/canonical projections from those cross-route slices (`...RoutesSlices_{expr,field}_via_{masterConsequenceCapstone,masterRunBundleConsequence}` and `principalNoUnify*RunBundleConsequences_via_*_from_cross_route_slices`), so each route’s consequence bundle is directly consumable from one shared coherence proof surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:10: Added canonical no-unify all-hooks capstone projections from that cross-route coherence surface (`principalNoUnify*AllHooksCapstone_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`), so both routes now reach capstone consequences through one shared coherence entrypoint; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:18: Added canonical cross-route projections for core, any-hooks preconditioned, any-hooks `preconditioned ↔ core`, and fixed-run hook-irrelevance on both routes (`principalNoUnify{Core,Preconditioned*,PreconditionedCoreIff*,Preconditioned*hookIrrelevant}_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`), so downstream theorem use can stay on the shared cross-route slice surface across all no-unify principal consequence facets; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:20: Added bundled-target hook projections on top of those cross-route any-hooks surfaces (`principalNoUnifyPreconditioned*` and `principalNoUnifyPreconditionedCoreIff*` via both routes from cross-route slices), eliminating manual `h_hooks.1/h_hooks.2` threading when consuming the shared coherence API; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:21: Added `_from_bundle` alias wrappers for those bundled-target cross-route projections (`principalNoUnifyPreconditioned*...from_cross_route_slices_from_bundle`, `principalNoUnifyPreconditionedCoreIff*...from_cross_route_slices_from_bundle` on both routes), completing naming parity with the broader no-unify wrapper families; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:24: Added long-form no-unify-to-general aliases on the same cross-route route surfaces (`principalCore*`, `principalPreconditioned*AnyHooks*`, `principalPreconditionedCoreIff*AnyHooks*`, `principalPreconditioned*hookIrrelevant*_of_success_noUnify_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`), so call sites can stay on familiar naming families while consuming the shared cross-route coherence path; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:27: Added matching `_from_bundle` aliases for those long-form cross-route no-unify-to-general wrappers (core/any-hooks/`preconditioned ↔ core`/hook-irrelevance on both routes), completing bundled-hook naming parity for the new cross-route theorem family; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:35: Added full `principalNoUnify*...of_success_via_masterRunBundleConsequence_from_cross_route_slices` naming-parity aliases (core, preconditioned, preconditioned↔core, hook-irrelevance, run-bundle consequences, and capstone, including `_from_bundle` variants), closing no-unify alias parity on the master-run-bundle-consequence cross-route surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:44: Mirrored that same `principalNoUnify*...of_success_via_masterConsequenceCapstone_from_cross_route_slices` alias family (core, preconditioned, preconditioned↔core, hook-irrelevance, run-bundle consequences, and capstone, including `_from_bundle` variants), bringing cross-route no-unify naming parity to a 62/62 theorem-surface match between the two master consequence routes; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 02:52: Added the remaining bundled-seed `_from_bundle` aliases for no-unify cross-route wrappers on both master consequence routes (core, any-hooks preconditioned, any-hooks `preconditioned ↔ core`, run-bundle, and packaged consequence surfaces), so every `principalNoUnify*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` theorem now has a bundled-seed counterpart; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 03:01: Added the missing bundled-seed `_from_bundle` aliases on `masterRunBundleConsequenceSuite` for no-unify core/any-hooks/run-bundle/consequence wrappers (`principalNoUnify{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,RunBundle*,Expr/FieldRunBundleConsequences}...`), completing bundled-seed parity across all no-unify theorem surfaces on that suite route; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 03:10: Added full bundled-seed `_from_bundle` parity on `masterRunBundleSuite` for all no-unify wrappers (run-bundle, core, any-hooks preconditioned, bundled preconditioned, any-hooks/bundled `preconditioned ↔ core`, hook-irrelevance, and packaged consequences), so every `principalNoUnify*...of_success_via_masterRunBundleSuite` theorem now has a bundled-seed companion; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 03:20: Added the remaining bundled-seed `_from_bundle` aliases on `allHooksSuite` and `masterSuite` for no-unify core/any-hooks/run-bundle wrappers, closing the last suite-level parity gaps; parity checks now report `missing_from_bundle = 0` across all seven no-unify route families (`allHooks`, `master`, `masterRunBundle`, `masterRunBundleConsequence`, `masterConsequenceCapstone`, and both cross-route surfaces); updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 03:29: Added the final bundled-seed aliases on the proved-boundary `...via_suite` wrappers (`principalNoUnify{Core,Preconditioned}{Expr,Field}_of_success_via_suite_from_bundle`), closing the remaining global gap so every `principalNoUnify*...of_success_via_*` theorem now has a `_from_bundle` companion (`missing_count = 0` on full theorem-name parity scan); updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 03:39: Added bundled-seed `_from_bundle` parity for the long-form no-unify-to-general `masterRunBundleConsequenceSuite` wrappers (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*AllHooksRunBundle}_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle`), closing that route’s long-form parity gap (`missing = 0` for `..._of_success_noUnify_via_masterRunBundleConsequenceSuite`); updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 03:49: Added the same long-form bundled-seed parity layer on `allHooksSuite` and `masterSuite` (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*AllHooksRunBundle}_of_success_noUnify_via_{allHooksSuite,masterSuite}_from_bundle`), reducing long-form no-unify parity gaps to the two remaining routes (`generalAllHooks`, `masterRunBundleSuite`); updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 03:59: Closed the remaining long-form no-unify bundled-seed gaps on `masterRunBundleSuite` and `generalAllHooks` with matching `_from_bundle` alias families (including fixed-run preconditioned, fixed-run `preconditioned ↔ core`, and hook-irrelevance variants where applicable), bringing long-form parity to full closure (`global_longform_missing = 0` for all `..._of_success_noUnify_via_*` theorem names); updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 04:08: Added the last four bundled-seed aliases surfaced by the broad `..._of_success_via_*` scan (`principalBoundaryNoUnify{ExprCapstone,FieldCapstone}_of_success_via_suite_from_bundle`, `principalBoundaryNoUnifyRunBundle{Expr,Field}_of_success_via_allHooksSuite_from_bundle`), bringing global bundle-name parity to full closure (`missing_bundle = 0` across all `..._of_success_via_*` theorem names); updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 04:18: Added explicit cross-route all-hooks capstone coherence packaging (`PrincipalNoUnifyExpr/FieldAllHooksCapstonesBothMasterConsequenceRoutes`, combined capstone slices, and per-route one-hop/canonical projections), so capstone-level route coherence is now consumable from one shared theorem API parallel to the existing consequence-bundle coherence layer; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 04:28: Added explicit cross-route all-hooks run-bundle coherence packaging (`PrincipalNoUnifyExpr/FieldAllHooksRunBundlesBothMasterConsequenceRoutes`, combined run-bundle slices, and per-route one-hop/canonical projections), and routed `principalNoUnifyRunBundle*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` through this canonical layer; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 04:39: Added explicit cross-route fixed-run hook-irrelevance coherence packaging (`PrincipalNoUnifyExpr/FieldHookIrrelevanceBothMasterConsequenceRoutes`, combined irrelevance slices, and per-route one-hop/canonical projections), and routed `principalNoUnifyPreconditioned*hookIrrelevant...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` through this canonical layer; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 04:51: Added a higher-level cross-route all-hooks route-surface bundle (`PrincipalNoUnifyExpr/FieldAllHooksRouteSurfaceBothMasterConsequenceRoutes`, combined slices, and per-route canonical projections) so each master consequence route now exports capstone + run-bundle + fixed-run irrelevance as one packaged per-run theorem surface; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 05:01: Routed top-level cross-route all-hooks capstone aliases (`principalNoUnify*AllHooksCapstone_of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through the new all-hooks route-surface canonical projections, keeping capstone consumption on the unified route-surface layer; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 05:12: Routed top-level cross-route all-hooks run-bundle and fixed-run irrelevance aliases (`principalNoUnifyRunBundle*...` and `principalNoUnifyPreconditioned*hookIrrelevant...` on both master consequence routes) through the same route-surface canonical projections, completing unified consumption of capstone/run-bundle/irrelevance from one cross-route entry layer; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 05:24: Extended the cross-route all-hooks route-surface bundle with packaged consequence outputs (`PrincipalNoUnifyExpr/FieldRunBundleConsequences`) and routed `principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` through that same canonical layer, so consequence outputs now join capstone/run-bundle/irrelevance on one route-surface entrypoint; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 05:38: Added one-hop and canonical route-surface projections for core, any-hooks preconditioned, and any-hooks `preconditioned ↔ core` (`principalNoUnify*AllHooksRouteSurface_{core,preconditioned_anyHooks,preconditionedCoreIff_anyHooks}` plus `..._via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`), making the unified cross-route surface layer directly consumable for core/any-hooks theorem facets; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 05:52: Routed canonical cross-route core/any-hooks/any-hooks-`↔`/fixed-run-irrelevance projections (`principalNoUnify{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*hookIrrelevant}_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through the route-surface canonical APIs, consolidating those canonical theorem families on one coherence layer; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 06:05: Added bundled-target one-hop/canonical route-surface projections (`principalNoUnify*AllHooksRouteSurface_{preconditioned,preconditionedCoreIff}` with per-route `..._via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`) and routed canonical bundled-target cross-route projections (`principalNoUnifyPreconditioned*` / `principalNoUnifyPreconditionedCoreIff* ... from_cross_route_slices`) through those APIs; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 06:18: Added facet-level canonical `_from_cross_route_surface_slices` wrappers for capstone/run-bundle/consequence/fixed-run-irrelevance on both routes and routed top no-unify alias entrypoints (`principalNoUnify*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through those named surface wrappers, making the surface layer explicit end-to-end; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 06:31: Routed long-form no-unify-to-general cross-route aliases (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*hookIrrelevant}_of_success_noUnify_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through `_from_cross_route_surface_slices` canonical wrappers, extending explicit surface-layer consumption to long-form entrypoints; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 06:44: Added bundled-seed `_from_bundle` convenience aliases for canonical cross-route surface projections on both master consequence routes (core, any-hooks preconditioned, any-hooks `preconditioned ↔ core`, run-bundle, packaged consequences, and capstone), so surface-layer call sites can start from one `UnifyHookPremises` witness without dropping back to `...from_cross_route_slices`; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 06:57: Closed the remaining canonical surface bundled-seed parity gaps (all-hooks route-surface, bundled-target preconditioned, bundled-target `preconditioned ↔ core`, and fixed-run hook-irrelevance on both master consequence routes), bringing `...from_cross_route_surface_slices` bundle parity to full closure (`missing_from_bundle = 0` across 40 theorem names); updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:19: Added full surface-name parity wrappers for no-unify cross-route success entrypoints (`principalNoUnify*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`, including `_from_bundle` variants), closing `of_success_via_*` surface naming gaps at 72/72 and preserving proof bodies through the existing `...from_cross_route_slices` theorems; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:20: Added long-form no-unify-to-general surface-name parity wrappers (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*hookIrrelevant}_of_success_noUnify_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`, including `_from_bundle` variants), closing long-form `of_success_noUnify_via_*` surface naming gaps at 32/32 while reusing existing `...from_cross_route_slices` theorem bodies; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:23: Added direct all-hooks route-surface success wrappers on the canonical surface layer (`principalNoUnify{Expr,Field}AllHooksRouteSurface_of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`, with `_from_bundle` variants), so packaged route-surface theorem consumption now has explicit success-name entrypoints on both master consequence routes; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:26: Added a packaged unification-aware recursive soundness bundle in `Kea/Typing.lean` (`InferUnifyHasTypeUSoundBundle` plus constructors `inferUnifyHasTypeUSoundBundle_of_{hooks,hook_bundle,resolved}` and one-hop expr/field projections), so `HasTypeU` recursive soundness for `inferExprUnify`/`inferFieldsUnify` is consumable from one theorem surface under weak hook or resolved-shape premises; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:28: Extended that bundle surface with strong-hook constructors (`inferUnifyHasTypeUSoundBundle_of_{strong_hooks,strong_hook_bundle}`), so the same packaged `HasTypeU` recursive soundness API is now reachable directly from strong `AppUnifySoundHook`/`ProjUnifySoundHook` assumptions without manual weak-hook conversion; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:29: Added direct bundle-entry recursive `HasTypeU` soundness wrappers for both weak and strong hook packages (`infer{Expr,Fields}Unify_sound_preconditioned_hasTypeU_from_{hook_bundle,strong_hook_bundle}`), complementing the resolved-bundle path so all premise-package shapes now have one-step expr/field entrypoints before bundling; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:35: Added canonical `via_sound_bundle` wrappers over the new `InferUnifyHasTypeUSoundBundle` (`infer{Expr,Fields}Unify_sound_preconditioned_hasTypeU_{via_sound_bundle,from_*_via_sound_bundle}`), covering generic bundle, weak-bundle, strong-bundle, and resolved-bundle entry surfaces; fixed a strong-bundle implicit-inference edge by routing the strong variants through existing strong-bundle entrypoints while keeping the same API contract; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:36: Added one-hop constructor projections for the packaged `HasTypeU` recursive soundness bundle (`inferUnifyHasTypeUSoundBundle_{expr,field}_of_{hook_bundle,strong_hook_bundle,resolved}`), so weak/strong/resolved premise constructors each expose direct expr/field theorem entrypoints without manual bundle destructuring; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:39: Added a dual recursive-soundness package in `Kea/Typing.lean` (`InferUnifySoundDualBundle`, constructors `inferUnifySoundDualBundle_of_{hooks,hook_bundle}`, and direct projections `inferUnifySoundDualBundle_{expr,field}_{hasType,hasTypeU}`), so one unification-success witness now yields both `HasType` and `HasTypeU` recursive soundness consequences through one theorem API; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:42: Added canonical `via_dual_bundle` wrapper entrypoints for both judgments (`infer{Expr,Fields}Unify_sound_preconditioned_via_dual_bundle`, `infer{Expr,Fields}Unify_sound_preconditioned_hasTypeU_via_dual_bundle`) plus bundled-hook adapters (`..._from_hook_bundle_via_dual_bundle`), so dual-bundle consumers now have one-step theorem APIs parallel to the existing `via_sound_bundle` surfaces; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:43: Added one-hop bundled-hook constructor projections for each dual-bundle facet (`inferUnifySoundDualBundle_{expr,field}_{hasType,hasTypeU}_of_hook_bundle`), so all four dual consequences are now directly consumable from `UnifyHookPremises` without manual bundle assembly/destructuring; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:44: Added bridge theorems from the dual recursive-soundness package back into the existing `HasTypeU` package surface (`inferUnifyHasTypeUSoundBundle_of_dual_bundle`, `inferUnifyHasTypeUSoundBundle_of_dual_hook_bundle`), so current `InferUnifyHasTypeUSoundBundle`/`via_sound_bundle` call sites can consume the new dual path without API fork; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:49: Added dual-bundle principal-slice wrappers (`principal{,Field}TypingSlicePreconditioned_of_success{_from_hook_bundle}_via_dual_bundle`) plus one-step agreement extractors (`infer{Expr,Fields}Unify_infer{Expr,Fields}_agrees_of_success{_from_hook_bundle}_via_dual_bundle`), so successful-run principal consequences and algorithmic agreement facts are directly consumable from the dual theorem surface; fixed resulting unused-binder warnings by marking the dual bundle argument intentionally unused in the two principal wrapper constructors; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:51: Added dual-bundle wrappers for principal core-bridge consequences (`principal{,Field}TypingSliceCore_of_preconditioned_success{_from_hook_bundle}_via_dual_bundle`, `principal{,Field}TypingSlicePreconditioned_iff_core_of_success{_from_hook_bundle}_via_dual_bundle`), so dual-API call sites can consume preconditioned→core and preconditioned↔core results directly without switching back to raw hook argument paths; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:53: Added packaged per-run dual principal consequence bundles (`Principal{,Field}TypingDualConsequence`) with constructors from successful runs (`..._of_success_via_dual_bundle`, bundled-hook variants), so preconditioned/core/`↔`/algorithmic-agreement consequences are now consumable from one theorem output per successful run; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:54: Added one-hop projections for those dual principal consequence bundles (`principal{,Field}TypingDualConsequence_{preconditioned,core,iff_core,inferExpr_agrees/inferFields_agrees}`), so each bundled facet is directly consumable without manual record destructuring; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:55: Added combined successful-run dual consequence slices (`PrincipalDual{Expr,Field}ConsequenceSlice`, `PrincipalDualConsequenceSlices`, `principalDualConsequenceSlices_proved`) and one-hop expression/field slice projections, so dual principal bundles are now consumable through the same slice-style API used by the broader principal-capstone theorem surfaces; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:56: Added canonical proved-slice dual entrypoints (`principal{,Field}TypingDualConsequence_of_success_via_proved_slice`) and one-step agreement extractors (`infer{Expr,Fields}Unify_infer{Expr,Fields}_agrees_of_success_via_dual_proved_slice`), so callers can consume the combined dual consequence slice without threading explicit slice witnesses; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:58: Added compatibility/equivalence bridges between the dual consequence slice and the existing preconditioned↔core slice surface (`principalPreconditionedCoreIffSlices_of_dualConsequenceSlices`, `principalDualConsequenceSlices_of_principalPreconditionedCoreIffSlices`, `principalDualConsequenceSlices_iff_principalPreconditionedCoreIffSlices`) plus canonical proved-surface adapters in both directions; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 00:59: Added compatibility/equivalence adapters between dual consequence bundles and existing no-unify bridge bundles (`principal{,Field}NoUnifyBridgeBundle_of_dualConsequence`, `principal{,Field}TypingDualConsequence_of_noUnifyBridgeBundle`, `principal{,Field}TypingDualConsequence_iff_noUnifyBridgeBundle_of_success`), so both theorem surfaces are now directly interoperable on successful runs; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:01: Added suite-level adapters from dual consequence slices into the existing boundary stack (`principalNoUnifyBridgeSlices_of_dualConsequenceSlices`, `principalBoundaryBridgeSuite_of_dualConsequenceSlices`, `principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices`), so the dual API now feeds the established principal bridge suite surface directly; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:02: Added the reverse suite adapter and full equivalence (`principalDualConsequenceSlices_of_principalBoundaryBridgeSuite`, `principalBoundaryBridgeSuite_iff_dualConsequenceSlices`) plus canonical dual-slice recovery from the existing proved suite (`principalDualConsequenceSlices_proved_via_principalBoundaryBridgeSuite`), closing bidirectional interoperability between boundary-suite and dual-slice theorem surfaces; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 01:03: Lifted the dual-routed bridge path into the top-level master suite (`principalBoundaryMasterSuite_proved_via_dualConsequenceSlices`) and added direct preconditioned↔core wrappers on that route (`principalBoundaryMasterSuite_preconditionedCoreIff_{expr,field}_via_dualConsequenceSlices`), so dual-slice interoperability now reaches the master-suite entry layer; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 07:15: Added dual-routed suite convenience wrappers for no-unify/core/preconditioned and preconditioned↔core conversions (`principalNoUnify*...via_suite_via_dualConsequenceSlices`, `principal{Core,Preconditioned}*...via_suite_via_dualConsequenceSlices`, expression+field); fixed an ordering break by relocating these wrappers to the section where `principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices` is in scope, then revalidated with `cd formal && lake build`; updated formal trackers.
- 2026-02-28 07:17: Added dual-routed master-suite convenience wrappers for arbitrary successful runs (`principal{Core,Preconditioned*,PreconditionedCoreIff*}{Expr,Field}_of_success_via_masterSuite_via_dualConsequenceSlices`, including any-hooks + bundled-hook forms), so master-entry theorem consumption stays on one explicit dual route without manually threading `PrincipalBoundaryMasterSuite`; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 07:19: Added dual-routed master-suite no-unify convenience wrappers (`principalNoUnify{Core,Preconditioned*,PreconditionedCoreIff*}{Expr,Field}_of_success_via_masterSuite_via_dualConsequenceSlices`, including any-hooks + bundled-hook forms), so no-unify master entrypoint families now match the arbitrary-success dual-route convenience layer; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 07:21: Generalized top-level master↔dual interoperability (`principalBoundaryMasterSuite_of_dualConsequenceSlices`, `principalDualConsequenceSlices_of_principalBoundaryMasterSuite`, `principalBoundaryMasterSuite_iff_dualConsequenceSlices`) and routed `principalBoundaryMasterSuite_proved_via_dualConsequenceSlices` through that generalized bridge; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 07:23: Added dual-routed no-unify-to-general master-suite convenience wrappers (`principal{Core,Preconditioned*,PreconditionedCoreIff*}{Expr,Field}_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices`, including any-hooks + bundled-hook forms), closing dual-route naming/entrypoint parity between arbitrary-success and no-unify-to-general master APIs; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 07:45: Added bundled-seed `_from_bundle` parity aliases for all dual-routed master-suite convenience families (`..._of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle`, `principalNoUnify*..._of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle`, and `..._of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle`, expression+field, any-hooks/bundled/core/`↔` surfaces), so one `UnifyHookPremises` witness now drives the full dual-routed master convenience API; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 07:54: Added bundled-seed aliases for the dual-routed suite no-unify convenience wrappers (`principalNoUnify{Core,Preconditioned}{Expr,Field}_of_success_via_suite_via_dualConsequenceSlices_from_bundle`), closing the remaining `_from_bundle` parity gap on the dual `via_suite` no-unify path; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 08:02: Added bundled-seed aliases for the dual-routed suite preconditioned↔core conversion wrappers (`principal{Core,Preconditioned}{Expr,Field}_of_{preconditioned,core}_success_via_suite_via_dualConsequenceSlices_from_bundle`), making the full dual `via_suite` convenience layer bundle-entry complete across no-unify and conversion surfaces; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 08:13: Added a packaged current row-polymorphic boundary capstone (`PrincipalRowPolyBoundaryBundle`) combining `PrincipalBoundaryMasterSuite` with `VerticalHookFreeUnifySlices`, with canonical constructors (`principalRowPolyBoundaryBundle_{proved,proved_via_dualConsequenceSlices}`) and one-hop principal/vertical/dual projections; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 08:22: Added an explicit decomposition bridge for that capstone (`principalRowPolyBoundaryBundle_of_dual_and_vertical`, `principalRowPolyBoundaryBundle_iff_dual_and_vertical`), so the current row-polymorphic boundary package is now consumable as `dual principal slice ∧ hook-free vertical slice`; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 08:31: Added one-hop boundary-bundle consumption wrappers (`principalRowPolyBoundaryBundle_preconditionedCoreIff_{expr,field}`, `principalRowPolyBoundaryBundle_vertical_{app,proj}`), so a single `PrincipalRowPolyBoundaryBundle` witness now directly serves both principal equivalence and hook-free app/proj vertical theorem facets; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 08:42: Added a higher capstone package combining boundary + recursive soundness (`PrincipalRowPolyBoundarySoundBundle`) with direct/dual/bundled constructors and one-hop dual-soundness wrappers (`principalRowPolyBoundarySoundBundle_{expr,field}_hasTypeU`), so boundary and dual-judgment recursive soundness are now consumable from one theorem witness; updated formal trackers and revalidated with `cd formal && lake build`.
- 2026-02-28 08:52: Extended that capstone with explicit decomposition + full judgment symmetry (`principalRowPolyBoundarySoundBundle_iff_boundary_and_soundDual`, plus one-hop `principalRowPolyBoundarySoundBundle_{expr,field}_hasType` wrappers), making both `HasType` and `HasTypeU` recursive soundness facets directly consumable from the combined boundary+soundness package; updated formal trackers and revalidated with `cd formal && lake build`.
- **Next:** continue lifting the M4 principal boundary from the current hook/precondition slice toward the full row-polymorphic fragment.
