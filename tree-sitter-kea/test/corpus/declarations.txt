==================
Simple function
==================

fn add(x: Int, y: Int) -> Int
  x

---

(source_file
  (function_declaration
    name: (identifier)
    (parameter_list
      (parameter
        pattern: (variable_pattern
          (identifier))
        type: (named_type
          (upper_identifier)))
      (parameter
        pattern: (variable_pattern
          (identifier))
        type: (named_type
          (upper_identifier))))
    (pure_return_type
      type: (named_type
        (upper_identifier)))
    (indent)
    (identifier)
    (dedent)))

==================
Effect declaration
==================

effect IO
  fn stdout(msg: String) -[IO]> Unit

---

(source_file
  (effect_declaration
    name: (upper_identifier)
    (indent)
    (function_signature
      name: (identifier)
      (parameter_list
        (parameter
          pattern: (variable_pattern
            (identifier))
          type: (named_type
            (upper_identifier))))
      (effect_return_type
        (effect_row
          (effect_ref
            name: (upper_identifier)))
        type: (named_type
          (upper_identifier))))
    (dedent)))

==================
Type definition
==================

type Color = Red | Green | Blue

---

(source_file
  (type_definition
    name: (upper_identifier)
    (variant
      name: (upper_identifier))
    (variant
      name: (upper_identifier))
    (variant
      name: (upper_identifier)))
  (newline))

==================
Struct definition
==================

struct User
  name: String
  age: Int

---

(source_file
  (struct_definition
    name: (upper_identifier)
    (indent)
    (struct_field
      name: (identifier)
      type: (named_type
        (upper_identifier)))
    (newline)
    (struct_field
      name: (identifier)
      type: (named_type
        (upper_identifier)))
    (dedent)))

==================
Trait definition
==================

trait Eq a
  fn eq(x: a, y: a) -> Bool

---

(source_file
  (trait_definition
    name: (upper_identifier)
    param: (identifier)
    (indent)
    (function_signature
      name: (identifier)
      (parameter_list
        (parameter
          pattern: (variable_pattern
            (identifier))
          type: (named_type
            (identifier)))
        (parameter
          pattern: (variable_pattern
            (identifier))
          type: (named_type
            (identifier))))
      (pure_return_type
        type: (named_type
          (upper_identifier))))
    (dedent)))

==================
Use declaration
==================

use IO
use Test

---

(source_file
  (use_declaration
    module: (upper_identifier))
  (newline)
  (use_declaration
    module: (upper_identifier))
  (newline))

==================
Doc block on function
==================

doc Adds two integers together.
fn add(x: Int, y: Int) -> Int
  x

---

(source_file
  (documented_declaration
    (doc_block
      (doc_start)
      (doc_body))
    (newline)
    (function_declaration
      name: (identifier)
      (parameter_list
        (parameter
          pattern: (variable_pattern
            (identifier))
          type: (named_type
            (upper_identifier)))
        (parameter
          pattern: (variable_pattern
            (identifier))
          type: (named_type
            (upper_identifier))))
      (pure_return_type
        type: (named_type
          (upper_identifier)))
      (indent)
      (identifier)
      (dedent))))

==================
Multi-line doc block
==================

doc
  A user record.
  Contains name and age fields.
struct User
  name: String
  age: Int

---

(source_file
  (documented_declaration
    (doc_block
      (doc_start)
      (doc_body))
    (newline)
    (struct_definition
      name: (upper_identifier)
      (indent)
      (struct_field
        name: (identifier)
        type: (named_type
          (upper_identifier)))
      (newline)
      (struct_field
        name: (identifier)
        type: (named_type
          (upper_identifier)))
      (dedent))))

==================
Block-form doc with indented body
==================

doc
  Return true when a list has no elements.
  Checks the outermost constructor.
fn is_empty(xs: List a) -> Bool
  case xs
    Nil -> true
    Cons(_, _) -> false

---

(source_file
  (documented_declaration
    (doc_block
      (doc_start)
      (doc_body))
    (newline)
    (function_declaration
      name: (identifier)
      (parameter_list
        (parameter
          pattern: (variable_pattern
            (identifier))
          type: (applied_type
            constructor: (upper_identifier)
            arg: (named_type
              (identifier)))))
      (pure_return_type
        type: (named_type
          (upper_identifier)))
      (indent)
      (case_expression
        scrutinee: (identifier)
        (indent)
        (case_arm
          pattern: (constructor_pattern
            constructor: (upper_identifier))
          body: (boolean))
        (newline)
        (case_arm
          pattern: (constructor_pattern
            constructor: (upper_identifier)
            (wildcard_pattern)
            (wildcard_pattern))
          body: (boolean))
        (dedent))
      (dedent))))

==================
Doc block on effect
==================

doc Side-effectful I/O operations.
effect IO
  fn stdout(msg: String) -[IO]> Unit

---

(source_file
  (documented_declaration
    (doc_block
      (doc_start)
      (doc_body))
    (newline)
    (effect_declaration
      name: (upper_identifier)
      (indent)
      (function_signature
        name: (identifier)
        (parameter_list
          (parameter
            pattern: (variable_pattern
              (identifier))
            type: (named_type
              (upper_identifier))))
        (effect_return_type
          (effect_row
            (effect_ref
              name: (upper_identifier)))
          type: (named_type
            (upper_identifier))))
      (dedent))))

==================
Doc block with blank lines between paragraphs
==================

doc
  List provides operations over immutable linked lists.

  Use Cons to build lists and Nil for empty.
  Most transformations use map, filter, and fold.
enum List a
  Nil
  Cons(a, List a)

---

(source_file
  (documented_declaration
    (doc_block
      (doc_start)
      (doc_body))
    (newline)
    (type_definition
      name: (upper_identifier)
      param: (identifier)
      (indent)
      (variant
        name: (upper_identifier))
      (newline)
      (variant
        name: (upper_identifier)
        (named_type
          (identifier))
        (applied_type
          constructor: (upper_identifier)
          arg: (named_type
            (identifier))))
      (dedent))))

==================
Test declaration
==================

test "simple test"
  true

---

(source_file
  (test_declaration
    name: (string)
    (indent)
    (boolean)
    (dedent)))
