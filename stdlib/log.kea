use IO
use List
use State

alias LogList = List String

effect Log
  --| Emit a debug-level message.
  --|
  --|   Log.debug("starting")
  fn debug(msg: String) -> Unit

  --| Emit an info-level message.
  --|
  --|   Log.info("ready")
  fn info(msg: String) -> Unit

  --| Emit a warning-level message.
  --|
  --|   Log.warn("retrying")
  fn warn(msg: String) -> Unit

  --| Emit an error-level message.
  --|
  --|   Log.error("failed")
  fn error(msg: String) -> Unit

--| Run `f` with `Log.*` routed to stdout.
--|
--|   Log.with_stdout_logger(|| ->
--|     Log.info("ready")
--|     7
--|   )   -- => 7
fn with_stdout_logger(f: fn() -[Log, e]> T) -[IO, e]> T
  handle f()
    Log.debug(msg) ->
      IO.stdout(msg)
      resume ()
    Log.info(msg) ->
      IO.stdout(msg)
      resume ()
    Log.warn(msg) ->
      IO.stdout(msg)
      resume ()
    Log.error(msg) ->
      IO.stdout(msg)
      resume ()

fn reverse_logs_into(xs: LogList, acc: LogList) -> LogList
  case xs
    Nil -> acc
    Cons(x, rest) ->
      reverse_logs_into(rest, Cons(x, acc))

fn reverse_logs(xs: LogList) -> LogList
  reverse_logs_into(xs, Nil)

fn collect_logs(f: fn() -[Log]> T) -[State LogList]> T
  handle f()
    Log.debug(msg) ->
      State.put(Cons(msg, State.get()))
      resume ()
    Log.info(msg) ->
      State.put(Cons(msg, State.get()))
      resume ()
    Log.warn(msg) ->
      State.put(Cons(msg, State.get()))
      resume ()
    Log.error(msg) ->
      State.put(Cons(msg, State.get()))
      resume ()

--| Run `f` and collect all emitted logs.
--|
--| Returns `(result, logs)` where `logs` preserves emission order.
--|
--|   Log.with_collected_logs(|| ->
--|     Log.info("ready")
--|     7
--|   )   -- => (7, Cons("ready", Nil))
fn with_collected_logs(f: fn() -[Log]> T) -> (T, LogList)
  let pair = State.with_state(Nil, || ->
    collect_logs(f)
  )
  let value = pair.0
  let logs_reversed = pair.1
  (value, reverse_logs(logs_reversed))
