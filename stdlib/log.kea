use IO
use List
use State

alias LogList = List String

doc
  Log defines structured logging operations and handlers.

  Use `Log.with_stdout_logger` to route logs to console output,
  or `Log.with_collected_logs` to capture logs as pure data.
effect Log
  doc
    Emit a debug-level message.

      Log.debug("starting")
  fn debug(msg: String) -> Unit

  doc
    Emit an info-level message.

      Log.info("ready")
  fn info(msg: String) -> Unit

  doc
    Emit a warning-level message.

      Log.warn("retrying")
  fn warn(msg: String) -> Unit

  doc
    Emit an error-level message.

      Log.error("failed")
  fn error(msg: String) -> Unit

doc
  Run `f` with `Log.*` routed to stdout.

    Log.with_stdout_logger(||
      Log.info("ready")
      7
    )   -- => 7
fn with_stdout_logger(f: fn() -[Log, e]> T) -[IO, e]> T
  handle f()
    Log.debug(msg) ->
      IO.stdout(msg)
      resume ()
    Log.info(msg) ->
      IO.stdout(msg)
      resume ()
    Log.warn(msg) ->
      IO.stdout(msg)
      resume ()
    Log.error(msg) ->
      IO.stdout(msg)
      resume ()

doc
  Reverse `xs` into `acc`.

    Log.reverse_logs_into(Cons("a", Nil), Nil)   -- => Cons("a", Nil)
    Log.reverse_logs_into(Nil, Cons("z", Nil))   -- => Cons("z", Nil)
fn reverse_logs_into(xs: LogList, acc: LogList) -> LogList
  case xs
    Nil -> acc
    Cons(x, rest) ->
      reverse_logs_into(rest, Cons(x, acc))

doc
  Reverse a log list while preserving all messages.

    Log.reverse_logs(Cons("a", Cons("b", Nil)))   -- => Cons("b", Cons("a", Nil))
    Log.reverse_logs(Nil)                          -- => Nil
fn reverse_logs(xs: LogList) -> LogList
  reverse_logs_into(xs, Nil)

doc
  Run `f` while collecting emitted `Log.*` messages in reverse order.

    Log.collect_logs(||
      Log.info("ready")
      1
    )
fn collect_logs(f: fn() -[Log]> T) -[State LogList]> T
  handle f()
    Log.debug(msg) ->
      State.put(Cons(msg, State.get()))
      resume ()
    Log.info(msg) ->
      State.put(Cons(msg, State.get()))
      resume ()
    Log.warn(msg) ->
      State.put(Cons(msg, State.get()))
      resume ()
    Log.error(msg) ->
      State.put(Cons(msg, State.get()))
      resume ()

doc
  Run `f` and collect all emitted logs.

  Returns `(result, logs)` where `logs` preserves emission order.

    Log.with_collected_logs(||
      Log.info("ready")
      7
    )   -- => (7, Cons("ready", Nil))
fn with_collected_logs(f: fn() -[Log]> T) -> (T, LogList)
  let pair = State.with_state(Nil, ||
    collect_logs(f)
  )
  let value = pair.0
  let logs_reversed = pair.1
  (value, reverse_logs(logs_reversed))
