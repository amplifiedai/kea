# Kea Type System Formalization

Lean 4 formalization of Kea's type-and-effect system.

This work starts by cannibalizing the existing Rill formal corpus and then extending it for Kea's effect-row and handler semantics.

## Current Status

- **Phase 1 (active):** Core migration from Rill `formal/` into `kea/formal/`, with effect-row surface aligned to Kea (`Ty.functionEff` + `EffectRow`) and current Lean build green.
- **Phase 1 (active):** Core migration now includes explicit WF judgments and substitution-preservation lemmas for the effect-row-extended core surface.
- **Phase 1 (active):** Operation/fail bridge bundles now expose decomposition helpers (`operationCallBundle_{iff_components,of_components,as_components}` in `Kea/Properties/EffectOperationTyping.lean` and `failResultEquivalenceBundle_{iff_components,of_components,as_components}` in `Kea/Properties/FailResultEquivalence.lean`) to keep these mid-stack contract packages aligned with the one-hop decomposition API style.
- **Phase 1 (active):** Fail-result bridge routes now also expose one-hop premise/lowering decomposition wrappers (`lowerFailFunctionType_equivalence_bundle_as_components` and `catchTyping_fail_result_equivalence_bundle_{as_components,result_return}_of_premises`), completing constructor-route facet access on `FailResultEquivalenceBundle` APIs.
- **Phase 1 (active):** `FailResultEquivalence` catch-bridge routes now have full premise/fail-present entry parity (`catchTyping_fail_result_equivalence{,_bundle,_bundle_as_components,_result_return}_of_{premises,fail_present}`), so admissible and direct fail-label entrypoints expose the same one-hop equivalence/bundle/result-return theorem surfaces.
- **Phase 1 (active):** Closed-aware handler bundle surfaces in `Kea/Properties/HandlerClosedAwareContracts.lean` now have structural decomposition helpers (`closedAware{Core,Result}Bundle_{iff_components,of_components,as_components}`), so branch-classification and result-entry packages align with the project-wide decomposition API style.
- **Phase 1 (active):** Closed-aware handler bundles now also have constructor-route decomposition/projection wrappers (`closedAwareCoreBundle_{as_components,absentClosedNoop,presentOrOpenNormalized}_of_classification` and `closedAwareResultBundle_{as_components,closedAwareHandledRemoved,closedAwareRowTailStable}_of_wellTyped`), completing one-hop facet access on classification and well-typed entry routes.
- **Phase 1 (active):** Tail bundle surfaces now have structural decomposition helpers in `Kea/Properties/TailResumptiveClassification.lean` and `Kea/Properties/TailCapabilityComposition.lean` (`tailResumptive{,ClosedAware}Bundle_{iff_components,of_components,as_components}` and `tailCapability{,ClosedAware}Bundle_{iff_components,of_components,as_components}`), aligning tail-classification/capability packaging with the project-wide `iff/of/as` contract style.
- **Phase 1 (active):** Tail/operation constructor routes now also expose one-hop decomposition/projection wrappers from typing/well-typed premises (`operationCallBundle_{as_components,declared,callTyping,rowTailStable}_of_typing`, `tail_resumptive{,_closedAware}_bundle_{as_components,classification,notInvalid}_of_wellTyped`, `tail_resumptive_{wellTyped,bundle}_direct_call_of_eligible`, and `tailCapability{,ClosedAware}Bundle_{as_components,coreCapability,resultCapability,notInvalid}_of_wellTyped`), completing route-level parity between bundle constructors and direct facet access.
- **Phase 1 (active):** `TailResumptiveBundle` now carries normalized direct-call eligibility evidence (`directCallEquivalent_of_eligible`), with decomposition APIs updated accordingly (`tailResumptiveBundle_{iff_components,of_components,as_components}` now include the eligibility→direct-call facet), aligning normalized and closed-aware tail bundle contract shape.
- **Phase 1 (active):** `Kea/Properties/NestedHandlerCompositionContracts.lean` now exposes structural decomposition helpers for both normalized and closed-aware nested bundles (`nestedHandlerBundle_{iff_components,of_components,as_components}` and `nestedHandlerClosedAwareBundle_{iff_components,of_components,as_components}`), keeping nested-handler package consumption aligned with the wider Phase-2 `iff/of/as` theorem style.
- **Phase 1 (active):** Cross-module bundle constructor parity now includes direct component-route wrappers on all current `...Bundle_of_components` entrypoints (`closedAware{Core,Result}Bundle_as_components_of_components`, `failResultEquivalenceBundle_as_components_of_components`, `nestedHandler{,ClosedAware}Bundle_as_components_of_components`, `operationCallBundle_as_components_of_components`, `tailCapability{,ClosedAware}Bundle_as_components_of_components`, and `tailResumptive{,ClosedAware}Bundle_as_components_of_components`), so constructor assumptions can be consumed on explicit component tuples in one step throughout the Phase-2 bridge stack.
- **Phase 1 (active):** Type-valued bundle layers now also expose direct components-route wrappers (`admissibleEffectPoly{Lowering,Handler}Bundle_as_components_of_components` and `higherOrderCatchBundle_as_components_of_components`), giving one-hop theorem parity for bundles whose component constructors are noncomputable defs.
- **Phase 1 (active):** `CatchTypingBridge` type-valued judgment bundle now also has direct components-route closure (`catchTypingJudgment_bundle_as_components_of_components`), completing `iff/of/as` parity on judgment-level bundle decomposition APIs.
- **Phase 1 (active):** `Kea/Dimensions.lean` now packages constant dim-list kernel behavior behind `DimConstListKernelSlice` (`dimConstListKernelSlice`), bundling success/failure characterizations (`unifyDimList_consts_{some_iff_eq,none_iff_ne,decision}`), empty-substitution closure (`..._some_implies_empty`), and mismatch/BEq consequences (`..._head_const_mismatch_none`, `..._length_mismatch_none`, `..._none_implies_beq_false`) into one reusable theorem surface for shape/decimal dim-aware proofs.
- **Phase 1 (active):** `Kea/Dimensions.lean` now also packages scalar `unifyDim` contracts behind `DimConstKernelSlice` (`dimConstKernelSlice`), bundling constant decision/equivalence/mismatch lemmas (`unifyDim_const_{decision,some_iff_eq,none_iff_ne,mismatch,some_implies_empty}`), BEq-driven success (`unifyDim_of_beq_true`), and var/const binding routes (`unifyDim_{var_const,const_var}_binds`) into one reusable kernel witness.
- **Phase 1 (active):** `Kea/Dimensions.lean` now exports a top-level dimension package (`DimKernelSuite` via `dimKernelSuite`) that combines `DimConstKernelSlice` and `DimConstListKernelSlice` into one suite witness for scalar+list kernel consumption.
- **Phase 1 (active):** `DimKernelSuite` now has explicit decomposition/reconstruction APIs (`dimKernelSuite_{as_components,of_components,iff_components}`), keeping the dimension suite aligned with the project-wide `iff/of/as` contract style.
- **Phase 1 (active):** `DimKernelSuite` now also exposes an explicit component alias (`DimKernelSuiteComponents`) and routes decomposition signatures through it for cleaner downstream APIs.
- **Phase 1 (active):** `Kea/Properties/PrecisionLeafParity.lean` now includes explicit rejection characterizations (`intN_unify_err_iff_constructor_beq_false`, `floatN_unify_err_iff_constructor_beq_false`), completing success+failure iff surfaces for precision constructor unification.
- **Phase 1 (active):** `PrecisionLeafParity` now exports a packaged constructor kernel witness (`PrecisionConstructorKernelSlice` via `precisionConstructorKernelSlice`) bundling IntN/FloatN success iff, rejection iff, and decision contracts into one reusable theorem surface.
- **Phase 1 (active):** `PrecisionConstructorKernelSlice` now has structural decomposition parity (`precisionConstructorKernelSlice_{as_components,of_components,iff_components,as_components_of_components}`), so precision package consumers can switch between bundled and explicit contract tuples in one step.
- **Phase 1 (active):** `PrecisionConstructorKernelSlice` now also exposes an explicit component alias (`PrecisionConstructorKernelSliceComponents`) and routes decomposition signatures through it for cleaner downstream APIs.
- **Phase 1 (active):** `Kea/Properties/DecimalParity.lean` now includes deeper constant-dimension unifier characterization (`decimal_unify_consts_err_iff_dim_kernel_none` and `decimal_unify_consts_decision_of_dim_kernel_none`), so decimal success/failure is expressed directly in terms of dim-kernel none/some outcomes rather than constructor-BEq-only surfaces.
- **Phase 1 (active):** `DecimalParity` now also includes the constructor-level rejection dual (`decimal_unify_err_iff_constructor_beq_false`), completing direct BEq-based success/failure iff coverage for decimal constructor unification.
- **Phase 1 (active):** `DecimalParity` now exports a packaged constant-dimension kernel witness (`DecimalConstDimKernelSlice` via `decimalConstDimKernelSlice`) that bundles success, precision/scale rejection, combined rejection, success iff, rejection iff, and decision contracts for decimal constant-dimension unifier routes.
- **Phase 1 (active):** `DecimalConstDimKernelSlice` now has structural decomposition parity (`decimalConstDimKernelSlice_{as_components,of_components,iff_components,as_components_of_components}` plus `DecimalConstDimKernelSliceComponents`), so decimal dim-kernel packages can switch between bundled and explicit contract tuples in one step.
- **Phase 1 (active):** `DecimalParity` now also exports a combined numeric package (`NumericConstructorKernelSuite` via `numericConstructorKernelSuite`) that bundles precision constructor contracts (`PrecisionConstructorKernelSlice`) with decimal constant-dimension contracts (`DecimalConstDimKernelSlice`) behind one theorem surface.
- **Phase 1 (active):** `NumericConstructorKernelSuite` now has structural decomposition parity (`numericConstructorKernelSuite_{as_components,of_components,iff_components,as_components_of_components}`), so numeric package consumers can switch between bundled and explicit precision+decimal components in one step.
- **Phase 1 (active):** `NumericConstructorKernelSuite` now also exposes an explicit component alias (`NumericConstructorKernelSuiteComponents`) and routes decomposition signatures through it, aligning with the alias-based package style used in newer suite layers.
- **Phase 1 (active):** `Kea/Properties/ShapeConstructorParity.lean` now exports a rank-1 shape/dim bridge package (`Rank1ShapeConstDimKernelSlice` via `rank1ShapeConstDimKernelSlice`) that bundles fixed-size-list and rank-1 tensor constant-dimension contracts (`..._ok_iff_dim_kernel_success`, `..._match_decision`, `..._reject_of_dim_kernel_none`) into one reusable witness keyed by `unifyDim`.
- **Phase 1 (active):** `ShapeConstructorParity` now also includes explicit failure/decision duals for the scalar-kernel constant-shape routes (`fixedSizeList_unify_consts_{err_iff_dim_kernel_none,decision_of_dim_kernel_none}` and `tensor_rank1_unify_consts_{err_iff_dim_kernel_none,decision_of_dim_kernel_none}`), completing success+failure characterization at the fixed-size-list/rank-1 tensor bridge layer.
- **Phase 1 (active):** `Kea/Properties/ShapeConstructorParity.lean` now also exports an arbitrary-rank tensor constant-shape bridge package (`TensorConstShapeDimListKernelSlice` via `tensorConstShapeDimListKernelSlice`) that bundles pointwise dim-list-kernel success/rejection/decision contracts (including `..._ok_iff_dim_list_kernel_success{,_any_elem}`, `..._match_decision{,_any_elem}`, `..._reject_of_dim_list_kernel_none_any_elem`, and head/length mismatch rejection) into one reusable witness keyed by `unifyDimList`.
- **Phase 1 (active):** `ShapeConstructorParity` arbitrary-rank tensor routes now also have explicit failure/decision duals (`tensor_unify_const_shapes_{err_iff_dim_list_kernel_none,decision_of_dim_list_kernel_none}{,_any_elem}`), so pointwise dim-list-kernel success/failure now drives both acceptance and rejection equations directly at both generic-element and `.int` wrappers.
- **Phase 1 (active):** Packaged shape kernel contracts now carry those failure/decision duals directly: `Rank1ShapeConstDimKernelSlice` now includes `fixedSizeList_unify_consts_{err_iff_dim_kernel_none,decision_of_dim_kernel_none}` and `tensor_rank1_unify_consts_{err_iff_dim_kernel_none,decision_of_dim_kernel_none}`, and `TensorConstShapeDimListKernelSlice` now includes `tensor_unify_const_shapes_{err_iff_dim_list_kernel_none,decision_of_dim_list_kernel_none}{,_any_elem}`.
- **Phase 1 (active):** `Rank1ShapeConstDimKernelSlice` now has structural decomposition parity (`rank1ShapeConstDimKernelSlice_{as_components,of_components,iff_components,as_components_of_components}` plus `Rank1ShapeConstDimKernelSliceComponents`), so rank-1 shape packages can switch between bundled and explicit contract tuples in one step.
- **Phase 1 (active):** `TensorConstShapeDimListKernelSlice` now has structural decomposition parity (`tensorConstShapeDimListKernelSlice_{as_components,of_components,iff_components,as_components_of_components}` plus `TensorConstShapeDimListKernelSliceComponents`), so arbitrary-rank shape packages can switch between bundled and explicit contract tuples in one step.
- **Phase 1 (active):** `Kea/Properties/ShapeConstructorParity.lean` now also exports a top-level constant-shape suite (`ShapeConstDimKernelSuite` via `shapeConstDimKernelSuite`) that packages `DimKernelSuite` (plus direct scalar/list fields), `Rank1ShapeConstDimKernelSlice`, and `TensorConstShapeDimListKernelSlice` into one theorem witness for downstream shape/dimension route consumption.
- **Phase 1 (active):** `ShapeConstructorParity` now also exports a unified numeric+shape package (`NumericShapeConstDimKernelSuite` via `numericShapeConstDimKernelSuite`) with decomposition helpers (`numericShapeConstDimKernelSuite_{as_components,of_components,iff_components,as_components_of_components}`), combining `NumericConstructorKernelSuite` and `ShapeConstDimKernelSuite` behind one theorem surface.
- **Phase 1 (active):** Top-level shape integration suites now expose explicit component aliases (`ShapeConstDimKernelSuiteComponents`, `NumericShapeConstDimKernelSuiteComponents`) and route existing decomposition theorems through those aliases for clearer downstream signatures.
- **Phase 1 (active):** `ShapeConstDimKernelSuite` now has explicit decomposition/reconstruction APIs (`shapeConstDimKernelSuite_{as_components,of_components,iff_components}`), keeping the top-level shape/dimension suite on the same `iff/of/as` contract style used across the formal corpus.
- **Phase 1 (active):** `CatchInteroperabilitySuite` now exposes explicit component aliases (`CatchClassifierInteropSuiteComponents`, `CatchCapstoneInteropSuiteComponents`) and routes decomposition signatures through them, including premise/fail-present and classifier-route `..._as_components_of_*` wrappers, so interop theorem APIs stay aligned with alias-based package decomposition style.
- **Phase 1 (active):** `EffectHandlerContractSuite` now exposes explicit component aliases on its top suite layers (`EffectHandler{,Capstone,CatchPair,Composition,CompositionCoherence}SuiteComponents`) and routes `iff/of/as` decomposition signatures through those aliases, including capstone/composition route wrappers, for cleaner aggregate-contract APIs.
- **Phase 1 (active):** `Kea/Typing.lean` now defines `...SuiteComponents` aliases for all remaining principal suite structures (`PrincipalBoundary*`, `PrincipalPreconditionedAllHooksSuite`, `PrincipalNoUnifyToGeneralAllHooksSuite`, and boundary-sound full/vertical suite layers), closing global suite-alias coverage across the formal corpus.
- **Phase 1 (active):** `Kea/Typing.lean` now also adds structural decomposition APIs for the principal bridge cluster (`principalBoundaryBridgeSuite_{iff_components,of_components,as_components,as_components_of_components}`, `principalPreconditionedAllHooksSuite_{iff_components,of_components,as_components,as_components_of_components}`, `principalBoundaryVacuitySuite_{iff_components,of_components,as_components,as_components_of_components}`), enabling one-hop bundle<->component routing on those theorem surfaces.
- **Phase 1 (active):** `Kea/Typing.lean` now extends that decomposition layer to no-unify/master cluster suites (`principalBoundaryNoUnifyAllHooksSuite_*`, `principalNoUnifyToGeneralAllHooksSuite_*`, `principalBoundaryMasterSuite_*` with `iff/of/as/as_components_of_components` families), giving explicit component-route reconstruction/projection on those bundled principal surfaces.
- **Phase 1 (active):** `Kea/Typing.lean` now extends decomposition APIs to master consequence/sound suite layers (`principalBoundaryMaster{RunBundle,RunBundleConsequence,ConsequenceCapstone}Suite_*`, `principalBoundarySound{TypingRunBundle,Full,FullVertical}Suite_*`), with explicit `iff/of/as/as_components_of_components` coverage aligned to their `...SuiteComponents` aliases.
- **Phase 1 (active):** `Kea/Typing.lean` now adds one-hop constructor-route decomposition wrappers on those suite surfaces (`principalBoundaryMasterRunBundle{,Consequence}Suite_as_components_of_{master,runBundleSuite,proved}`, `principalBoundaryMasterConsequenceCapstoneSuite_as_components_of_{master,proved}`, `principalBoundarySoundTypingRunBundleSuite_as_components_of_{hooks,hook_bundle}`), so route constructors can emit explicit component tuples directly.
- **Phase 1 (active):** Added matching route-level decomposition wrappers for boundary-sound full surfaces (`principalBoundarySoundFullSuite_as_components_of_success_via_{typingRunBundleSuite,typingRunBundleSuite_from_bundle,rowPolyBoundarySoundBundle,rowPolyBoundarySoundBundle_from_bundle}` and `principalBoundarySoundFullVerticalSuite_as_components_of_success_via_{typingRunBundleSuite,typingRunBundleSuite_from_bundle,rowPolyBoundarySoundBundle,rowPolyBoundarySoundBundle_from_bundle}`), so key full/full-vertical constructor routes now project directly to component aliases.
- **Phase 1 (active):** Route-level decomposition parity on `Kea/Typing.lean` is now closed for current `*_of_<route>` theorem families with `*_as_components` bases (including dual-consequence/master-capstone and proved/dual-routed full/full-vertical constructor routes), validated by a corpus scan reporting no remaining gaps.
- **Phase 1 (active):** Added explicit components/decomposition APIs for full-vertical route packages in `Kea/Typing.lean` (`PrincipalBoundarySound{,NoUnify}FullVertical{,Master}RoutesComponents` plus `..._iff_components`, `..._of_components`, `..._as_components`, `..._as_components_of_components`), extending alias-based theorem consumption from suite layers into route-layer bundles.
- **Phase 1 (active):** Components-route wrapper parity now also includes the new dim/shape suite and principal-capstone layers (`dimKernelSuite_as_components_of_components`, `shapeConstDimKernelSuite_as_components_of_components`, `principalBoundarySoundFullVerticalMasterCapstone_as_components_of_components`, and `principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components_of_components`); corrected full-corpus theorem scans over `formal/Kea` now report no remaining `*_of_components` gaps for bases exposing `*_as_components`.
- **Phase 1 (active):** Generalized route-wrapper parity for the principal full-vertical master capstones is now closed (`principalBoundarySoundFullVerticalMasterCapstone_as_components_of_{masterRoutes,success,success_from_bundle,success_via_rowPolyBoundarySoundBundle,fullVerticalSuite}` and `principalBoundarySoundNoUnifyFullVerticalMasterCapstone_as_components_of_{masterCapstone,success,success_from_bundle,fullVerticalSuite,noUnifyMasterRoutes_{regular,dual},noUnifyMasterRoutes}`); corrected full-corpus scans over `formal/Kea` now report no remaining `*_of_<route>` gaps where the base theorem exposes `*_as_components`.
- **Phase 1 (active):** `principalBoundarySoundNoUnifyFullVerticalSuite` now has full direct route-decomposition wrappers (`..._as_components_of_{masterCapstone,success,success_from_bundle,fullVerticalSuite,success_via_rowPolyBoundarySoundBundle{,_from_bundle,_proved,_proved_from_bundle,_via_dualConsequenceSlices,_via_dualConsequenceSlices_from_bundle},success_via_typingRunBundleSuite{,_from_bundle,_via_dualConsequenceSlices,_via_dualConsequenceSlices_from_bundle},noUnifyMasterSurface}`), so all currently exposed suite constructor routes now flow to explicit component tuples in one theorem step.
- **Phase 1 (active):** `principalBoundarySoundNoUnifyFullVerticalMasterSurface` now has full direct route-decomposition wrappers (`..._as_components_of_{components,routes,capstone,success,success_from_bundle,fullVerticalMasterRoutes,fullVerticalMasterSurface,masterCapstone,fullVerticalSuite,consequences,noUnifyFullVerticalSuite,success_via_noUnifyMasterRoutes{,_from_bundle},success_via_rowPolyBoundarySoundBundle{,_from_bundle},success_via_typingRunBundleSuite{,_from_bundle},success_via_dualConsequenceSlices{,_from_bundle},success_via_fullVerticalMasterCapstone{,_from_bundle},success_via_noUnifyMasterCapstone{,_from_bundle},success_via_fullVerticalMasterRoutes{,_from_bundle}}`), so all currently exposed unified no-unify master-surface constructor routes now flow to explicit route+capstone component tuples in one theorem step.
- **Phase 1 (active):** `Kea/Properties/EffectHandlerContractSuite.lean` now has full structural decomposition parity for catch/open-row/coherence packages (`effectHandlerCatchPairSuite_{iff_components,of_components,as_components}`, `effectHandlerNestedOpenRowBridgeBundle_{iff_components,of_components,as_components}`, and `effectHandlerNestedClauseCoherenceBundle_{iff_components,of_components,as_components}`), plus suite-level decomposition/catch/nested/open-row projections (`effectHandler{,Capstone}Suite_{closedAware_as_components,capabilityClosedAware_as_components}`, `effectHandlerCompositionSuite_{classifier,classifier_as_components,capstone,capstone_as_components,catchPair_as_components,closedAware_as_components,capabilityClosedAware_as_components,nestedClosedAware_as_components,nestedOpenRowBridgeBundle,nestedOpenRowConsequenceBundle}`, and `effectHandlerCompositionCoherenceSuite_{composition_as_components,composition_as_capstone_and_nested,catchPair,catchPair_as_components,classifier,classifier_as_components,capstone,capstone_as_components,classifierFromCapstone,closedAware_as_components,capabilityClosedAware_as_components,nestedClosedAware,nestedClosedAware_as_components,nestedRowTailStable,nestedClauseCoherence_as_components,nestedOpenRowBridgeBundle,nestedOpenRowConsequenceBundle}`), now including constructor-route decomposition wrappers from premise/fail-present entrypoints (`effectHandler{,Capstone}Suite_as_components_of_{premises,fail_present}`, `effectHandlerCatchPairSuite_as_components_of_{premises,fail_present}`, `effectHandlerCompositionSuite_as_components_of_{premises,fail_present}`, `effectHandlerCompositionCoherenceSuite_as_components_of_{premises,fail_present}`), keeping Phase-2 contract bundles uniformly consumable through named one-hop APIs.
- **Phase 1 (active):** `EffectHandlerSuite` now also has direct premise/fail-present facet projection wrappers (`effectHandlerSuite_{closedAwareHandledRemoved,closedAwareCapability,closedAwareRowTailStable,legacyHandledRemoved,tailNotInvalid,genericCatchClassifier,higherCatchClassifier,catchLaws}_of_{premises,fail_present}`), enabling one-step theorem entry from raw constructor preconditions to each key aggregate consequence.
- **Phase 1 (active):** `EffectHandlerCapstoneSuite` now has matching direct premise/fail-present facet projection wrappers (`effectHandlerCapstoneSuite_{closedAwareHandledRemoved,closedAwareCapability,closedAwareRowTailStable,legacyHandledRemoved,tailNotInvalid,genericCatchCapstone,higherCatchCapstone,catchLaws}_of_{premises,fail_present}`), completing classifier/capstone route-projection symmetry on the aggregate handler surface.
- **Phase 1 (active):** `EffectHandlerCatchPairSuite` now has direct premise/fail-present projection wrappers for both aggregate witnesses and bridge laws (`effectHandlerCatchPairSuite_{classifier,capstone,catchLaws}_of_{premises,fail_present}`), giving one-step route entry from raw assumptions into coherent pair-level consequences.
- **Phase 1 (active):** `EffectHandlerCompositionSuite` now has matching direct premise/fail-present projection wrappers (`effectHandlerCompositionSuite_{classifier,capstone,catchLaws}_of_{premises,fail_present}`), extending one-hop route access through the outer-handler composition layer.
- **Phase 1 (active):** `EffectHandlerCompositionCoherenceSuite` now has direct premise/fail-present projection wrappers (`effectHandlerCompositionCoherenceSuite_{composition,catchPair,classifier,capstone}_of_{premises,fail_present}`), giving one-step route entry into the composition+coherence package and its core projections.
- **Phase 1 (active):** Open-row bridge/consequence packages now expose premise/fail-present decomposition wrappers (`effectHandlerNestedOpenRow{Bridge,Consequence}Bundle_as_components_of_open_{base,expr}_row_{premises,fail_present}`), so open-row routes can consume equality/handled-removal components directly.
- **Phase 1 (active):** `EffectHandlerContractSuite` now has complete local constructor/decomposition parity for `...Bundle_of_*` routes via matching `...Bundle_as_components_of_*` wrappers (including nested-clause and open-row bridge/consequence constructors), removing remaining one-hop decomposition gaps in the handler aggregate module.
- **Phase 1 (active):** Suite-level component-route parity is now also explicit on interoperability/handler aggregates (`catch{Classifier,Capstone}InteropSuite_as_components_of_components` and `effectHandler{,Capstone}Suite_as_components_of_components`, `effectHandler{CatchPair,Composition,CompositionCoherence}Suite_as_components_of_components`), so suite constructor assumptions and explicit component tuples are interchangeable in one theorem step across the Phase-2 top layer.
- **Phase 1 (active):** Effect-handler projection routes now also have full premise/fail-present decomposition parity for `as_components` surfaces (`effectHandlerCatchPairSuite_{classifier,capstone}_as_components_of_{premises,fail_present}`, `effectHandlerCompositionSuite_{classifier,capstone}_as_components_of_{premises,fail_present}`, and `effectHandlerCompositionCoherenceSuite_{composition,catchPair,classifier,capstone}_as_components_of_{premises,fail_present}`), so constructor-route projections can move directly to explicit component tuples without intermediate theorem chaining.
- **Phase 1 (active):** Generalized route parity is now closed for theorem families with decomposition surfaces: every current `*_of_<route>` theorem whose base exposes `*_as_components` now also has `*_as_components_of_<route>` (including capstone-derived and outer-absence/coherence route constructors such as `effectHandlerSuite_as_components_of_capstoneSuite`, `effectHandlerCatchPairSuite_as_components_of_capstone`, `effectHandlerCompositionSuite_as_components_of_{capstone_and_nested,pair_outer_absent}`, and `effectHandlerCompositionCoherenceSuite_as_components_of_composition`).
- **Phase 1 (active):** Unification-side WF contracts are now staged (`Kea/WellFormed`, `Kea/Properties/WfSubstitution`, `Kea/Properties/WfRename`, `Kea/Properties/WfGeneralize`, `Kea/Properties/WfUnify`), including branch-shaped row-update lemmas for `unifyRows`.
- **Phase 1 (active):** Combined row-branch contracts now include extension + WF range + compat/WF swap packaging via `Kea/Properties/WfUnifyExtends` (`unifyRows_contract_full_wf`).
- **Phase 1 (active):** `WfUnifyExtends` now has branch-complete wrappers (no-update, single-bind, open-open fresh) for direct full-contract discharge at common `unifyRows` success shapes.
- **Phase 1 (active):** `WfUnifyExtends` now includes `bindTypeVar` combined contracts (`bindTypeVar_ok_extendsAndWfRange`, `bindTypeVar_ok_contract_full_wf`) so type-var bind success paths share the same extension + WF range + acyclic compat/WF packaging surface.
- **Phase 1 (active):** `WfUnifyExtends` now includes a direct `unify` var-left bridge (`unify_var_left_eq_bindTypeVar`) and lifted full-contract wrappers (`unify_var_left_ok_*_contract_full_wf`), so WF contracts can be discharged directly from var-branch unifier successes.
- **Phase 1 (active):** `WfUnifyExtends` now includes one-hop projections for the var-left unifier bridge contracts (base + non-`subst` state variants), exposing extension, WF-range, and acyclic compat/WF facets directly.
- **Phase 1 (active):** `WfUnifyExtends` now also includes a safe var-right bridge under explicit non-var preconditions (`unify_var_right_*_of_non_var`), with both base and non-`subst` full-contract wrappers.
- **Phase 1 (active):** `WfUnifyExtends` now includes full-state `bindTypeVar` packaging (`bindTypeVar_ok_with_non_subst_fields_contract_full_wf`) so type-var bind contracts compose cleanly with non-`subst` state updates.
- **Phase 1 (active):** `WfUnifyExtends` now includes contract projections for `bindTypeVar` full contracts (extension-only and WF-range-only, including non-`subst` state variants) to simplify downstream theorem consumption.
- **Phase 1 (active):** `WfUnifyExtends` now also projects the acyclic compat/WF agreement component out of `bindTypeVar` full contracts (base + non-`subst` state variants), completing one-hop access to all three contract facets.
- **Phase 1 (active):** `WfUnify` now includes `bindTypeVar` WF transport wrappers over non-`subst` state edits (`bindTypeVar_ok_with_lacks_preserves_substWellFormedRange`, `bindTypeVar_ok_with_non_subst_fields_preserves_substWellFormedRange`) for direct reuse in branch/state proofs.
- **Phase 1 (active):** `WfSubstitution` now includes WF-empty corollaries for well-founded row/effect-row substitution (`applySubstRowWF_empty_preserves_wf`, `applySubstEffectRowWF_empty_preserves_wf`) to complete the empty-substitution WF baseline across effect-row forms.
- **Phase 1 (active):** `WfSubstitution` now includes `TyList`/`RowFields` WF-preservation and empty-substitution lemmas (`applySubstTyList_preserves_wf_of_no_domain_vars`, `applySubstRowFields_preserves_wf_of_no_domain_vars`, `applySubstTyList_empty_preserves_wf`, `applySubstRowFields_empty_preserves_wf`) to close container-level WF gaps.
- **Phase 1 (active):** `WfSubstitution` now includes explicit `Ty.functionEff` component-wise WF wrappers for both fuel and WF substitution (`applySubst_functionEff_preserves_wf_of_component_no_domain_vars`, `applySubstWF_functionEff_preserves_wf_of_component_no_domain_vars`), alongside the existing compat wrapper.
- **Phase 1 (active):** Added explicit effect-row compat alias/surface (`applySubstEffectRowCompat`) and `WfSubstitution` lemmas (`applySubstEffectRowCompat_preserves_wf_of_no_domain_vars`, `applySubstEffectRowCompat_empty_preserves_wf`) so effect-row call sites can stay on compat APIs end-to-end.
- **Phase 1 (active):** Added compat aliases for `TyList`/`RowFields` (`applySubstTyListCompat`, `applySubstRowFieldsCompat`) with matching `WfSubstitution` preservation/empty lemmas, completing container-level compat WF surfaces.
- **Phase 1 (active):** `WfGeneralize` now includes a component-wise effect-row wrapper (`generalize_functionEff_preserves_wf_of_component_no_domain_vars`) for `Ty.functionEff` generalization under split no-domain assumptions.
- **Phase 1 (active):** `WfGeneralize` now includes `instantiate_functionEff_preserves_wf`, aligning effect-row `instantiate` WF coverage with the `functionEff` component-wise `generalize` wrapper.
- **Phase 1 (active):** `WfGeneralize` now includes `functionEff` convenience wrappers for `generalize`/`instantiate` entrypoints (`generalize_functionEff_empty_preserves_wf`, `instantiate_functionEff_mono_preserves_wf`, `instantiate_functionEff_preserves_wf_of_mapping_respects_ctx`) so common mono/non-mono cases can be discharged directly.
- **Phase 1 (active):** Added `Kea/Properties/WfEffectRowLadder.lean` and imported it in `Kea.lean`; it packages effect-row `functionEff` WF obligations into citable slices (`FunctionEffSubstWfSlice`, `FunctionEffGenInstWfSlice`) spanning substitution, generalize, and instantiate.
- **Phase 1 (active):** `WfEffectRowLadder` now includes direct specializations (`functionEff_subst_wf_slice_empty`, `functionEff_gen_inst_wf_slice_mono`) for immediate empty-substitution and monomorphic instantiate use.
- **Phase 1 (active):** `WfEffectRowLadder` now includes a unifier-success contract slice for `Ty.functionEff` (`FunctionEffBindTypeVarContractSlice`, `functionEff_bindTypeVar_contract_slice`) linking effect-row WF premises to `bindTypeVar` extension/WF/acyclic-agreement guarantees.
- **Phase 1 (active):** `WfEffectRowLadder` now includes projection helpers for the `FunctionEffBindTypeVarContractSlice` (extension-only, WF-range-only, and acyclic-agreement) so packaged assumptions can be consumed directly.
- **Phase 1 (active):** `WfEffectRowLadder` now also provides full-state `bindTypeVar` contract packaging/projections (`FunctionEffBindTypeVarFullStateContractSlice` and `functionEff_bindTypeVar_full_state_*`) for non-`subst` state updates.
- **Phase 1 (active):** Added explicit conversion lemmas between base and full-state `functionEff` bind-contract slices (`functionEff_bindTypeVar_full_state_slice_to_base`, `functionEff_bindTypeVar_base_slice_to_full_state`) so either surface can be used interchangeably.
- **Phase 1 (active):** Added capstone bundle theorem `functionEff_wf_ladder_bundle_of_bind_success` to export substitution, generalize/instantiate, and bind-contract slices from one `functionEff` entrypoint.
- **Phase 1 (active):** Added full-state capstone bundle theorem `functionEff_wf_ladder_bundle_of_bind_success_full_state`, lifting the one-shot `functionEff` WF ladder packaging to the non-`subst` state-update surface.
- **Phase 1 (active):** `WfEffectRowLadder` now includes one-hop projection helpers from both bundle theorems (base + full-state), including direct extraction of extension, WF-range, and compat/WF-acyclic guarantees from a single packaged assumption.
- **Phase 1 (active):** `WfEffectRowLadder` now exposes named bundle contracts (`FunctionEffWfLadderBundle`, `FunctionEffWfLadderBundleFullState`) with constructor/projection helpers, so downstream proofs can depend on stable one-name theorem surfaces rather than raw conjunction shapes.
- **Phase 1 (active):** Named bundle contracts now include direct extension/WF/acyclic projection lemmas (base + full-state), giving a complete one-hop API from a bundle assumption to each unifier contract facet.
- **Phase 1 (active):** `WfEffectRowLadder` now also supports var-left `unify` entrypoints (`functionEff_unify_var_left_*`) and corresponding one-shot bundle constructors, so effect-row WF contracts can start from successful `unify` var-branches as well as direct `bindTypeVar`.
- **Phase 1 (active):** Var-left `unify` entry wrappers in `WfEffectRowLadder` now discharge the constructor-mismatch BEq premise internally (`beqTy` reduction), keeping downstream theorem calls on semantic WF assumptions only.
- **Phase 1 (active):** `WfEffectRowLadder` now includes symmetric var-right `unify` entry wrappers/bundles (`functionEff_unify_var_right_*`, including full-state variants), backed by the new non-var right-branch bridge.
- **Phase 1 (active):** M2 compat-first bridge refactor is now complete in `Kea/Properties/UnifyExtends.lean` (`unifyRows_preconditioned_contract_compat_first`), with `unifyRows_extends_rowMap_preconditioned_wf_split` routed through the compat-first layer.
- **Phase 1 (active):** M4 weak-hook app-equality bridge target is now closed in `Kea/Typing.lean` via the contract theorem family (`app_unify_result_eq_of_unify_success_contract_succ` and specializations) built on `AppUnifyNoopDomain` + resolved-shape packaging.
- **Phase 1 (active):** Added the projection-side weak-hook refinement and bundle packaging in `Kea/Typing.lean` (`ProjUnifySoundHookWeak`, `projUnifySoundHookWeak_proved`, `UnifyHookPremisesWeak`, `unifyHookPremisesWeak_proved`) plus strong→weak adapters (`appUnifySoundHookWeak_of_appUnifySoundHook`, `projUnifySoundHookWeak_of_projUnifySoundHook`, `unifyHookPremisesWeak_of_unifyHookPremises`) to mirror and connect the app/projection weak-hook boundary surfaces.
- **Phase 1 (active):** Added explicit weak-boundary branch-step soundness surfaces (`inferExprUnify_app_step_sound_weak`, `inferExprUnify_proj_step_sound_weak`), strong-hook lifted weak-step corollaries (`inferExprUnify_app_step_sound_weak_of_strong`, `inferExprUnify_proj_step_sound_weak_of_strong`), and weak/strong-bundle entrypoints (`inferExprUnify_*_step_sound_weak_from_bundle`, `inferExprUnify_*_step_sound_weak_from_strong_bundle`) so weak-hook assumptions are consumable directly at app/proj one-step theorem call sites.
- **Phase 1 (active):** Added a canonical weak local-step bundle surface (`UnifyStepSoundWeak`) with constructors from weak/strong hook packages (`unifyStepSoundWeak_of_hookPremisesWeak`, `unifyStepSoundWeak_of_unifyHookPremises`) and direct step-bundle entrypoints (`inferExprUnify_*_step_sound_weak_from_stepBundle`) for stable downstream weak-boundary consumption.
- **Phase 1 (active):** Added direct proved/strong-package weak-step entrypoints (`inferExprUnify_*_step_sound_weak_proved`, `inferExprUnify_*_step_sound_weak_from_unifyHookPremises`) so call sites can consume weak step APIs without manual weak-bundle construction.
- **Phase 1 (active):** Added all-hooks no-unify naming-parity wrappers for fixed-run `preconditioned ↔ core` transport (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_allHooksSuite`, `principalPreconditionedCoreIff*_of_success_noUnify_via_allHooksSuite`) routed through the canonical all-hooks no-unify wrapper path.
- **Phase 1 (active):** Added master/all-hooks no-unify naming-parity wrappers for core/preconditioned/hook-irrelevance surfaces (`principalCore*`, `principalPreconditioned*_*`, `principalPreconditioned*hookIrrelevant*_of_success_noUnify_via_*Suite`) routed through canonical `principalNoUnify*` wrappers.
- **Phase 1 (active):** Added general-all-hooks/master capstone entry wrappers for arbitrary successful runs (`principalPreconditionedExpr/FieldAllHooksCapstone_of_success_via_generalAllHooksSuite`, `..._from_bundle`, `..._via_masterSuite`, `..._via_masterSuite_from_bundle`) so full core+any-hooks-preconditioned+`↔` boundary consequences are consumable through one theorem surface per success run.
- **Phase 1 (active):** Added bundled-baseline arbitrary-success convenience wrappers for general/master entrypoints (`principalCore*`, `principalPreconditioned*AnyHooks*`, `principalPreconditionedCoreIff*AnyHooks*_of_success_via_*Suite_from_bundle`) so callers can seed the whole non-no-unify principal surface with one `UnifyHookPremises` witness.
- **Phase 1 (active):** Completed bundled-baseline parity for bundled target-hook outputs on arbitrary-success general/master entrypoints (`principalPreconditioned*_*_of_success_via_*Suite_from_bundle`, including `preconditioned ↔ core` forms) so both any-hooks and bundled-target consumption now share the same single-seed API surface.
- **Phase 1 (active):** Added run-level arbitrary-success all-hooks bundle contracts (`PrincipalPreconditionedExpr/FieldAllHooksRunBundle`) with constructors from capstones/success (split and bundled seed hooks), plus suite entry wrappers (`..._of_success_via_generalAllHooksSuite(_from_bundle)`, `..._of_success_via_masterSuite(_from_bundle)`) so capstone + hook-irrelevance consequences are exported as one theorem output per successful run.
- **Phase 1 (active):** Added run-bundle projection helpers for core/preconditioned/preconditioned↔core/hook-irrelevance surfaces (`principalPreconditioned*AllHooksRunBundle_{core,preconditioned_anyHooks,preconditioned,preconditionedCoreIff_anyHooks,preconditionedCoreIff,hook_irrelevant}`) so run-bundle consumers can extract the principal boundary consequences directly without manual capstone-field threading.
- **Phase 1 (active):** Added combined run-bundle slice packaging (`PrincipalPreconditionedAllHooksRunBundleExpr/FieldSlice`, `PrincipalPreconditionedAllHooksRunBundleSlices`, proved + one-hop projections) so arbitrary-success run bundles are consumable through the same expression/field slice pattern as existing capstone/suite layers.
- **Phase 1 (active):** Extended `PrincipalPreconditionedAllHooksSuite` to carry run-bundle slices directly (`runBundles`) and added suite-level run-bundle projections (`principalPreconditionedAllHooksSuite_runBundle_expr/field`), making capstones, irrelevance, and run-bundle packaging available from one general-all-hooks suite witness.
- **Phase 1 (active):** Added parameterized arbitrary-success run-bundle convenience wrappers on the general-all-hooks layer (`principalGeneralAllHooksRunBundleExpr/Field_of_success`) and rerouted both general/master run-bundle entry wrappers through that layer, keeping arbitrary-success run-bundle access on one canonical path.
- **Phase 1 (active):** Added master-suite run-bundle one-hop projections (`principalBoundaryMasterSuite_allHooks_runBundle_expr/field`) so top-level master consumers can extract arbitrary-success all-hooks run bundles without dropping to nested suite fields.
- **Phase 1 (active):** Extended no-unify-to-general all-hooks packaging with run-bundle slices and projections (`PrincipalNoUnifyToGeneralAllHooks*RunBundle*`, suite field `runBundles`, suite/master one-hop run-bundle projections), and updated no-unify-all-hooks ↔ no-unify-to-general compatibility construction to populate the new run-bundle field.
- **Phase 1 (active):** Extended no-unify all-hooks packaging with run-bundle slices (`PrincipalBoundaryNoUnifyAllHooks*RunBundle*`), integrated them into `PrincipalBoundaryNoUnifyAllHooksSuite` (`runBundles` + suite projections), added master one-hop no-unify run-bundle projections, and updated no-unify-to-general ↔ no-unify-all-hooks compatibility construction to preserve the expanded suite shape.
- **Phase 1 (active):** Added explicit run-bundle compatibility theorems between no-unify and no-unify-to-general suite layers (both directions, plus canonical proved variants), making the cross-suite relation first-class at the run-bundle slice level.
- **Phase 1 (active):** Added direct no-unify run-bundle convenience wrappers across general/master/all-hooks entrypoints (`principalPreconditioned*AllHooksRunBundle_of_success_noUnify_via_*`) so successful no-unify runs can target the run-bundle API without manual suite/capstone reconstruction.
- **Phase 1 (active):** Added a top-level master run-bundle aggregate (`PrincipalBoundaryMasterRunBundleSuite`, `principalBoundaryMasterRunBundleSuite_of_master`, `..._proved`) plus no-unify-as-general run-bundle projections (`principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_*_as_general`) so run-bundle entry surfaces across all-hooks/no-unify/no-unify-to-general are packaged behind one master-derived theorem API.
- **Phase 1 (active):** Added one-hop projection/coherence helpers for `PrincipalBoundaryMasterRunBundleSuite` (`..._allHooks_*`, `..._noUnifyAllHooks_*`, `..._noUnifyToGeneral_*`, `..._noUnify_*_as_general`) so downstream consumers can use the master run-bundle aggregate without manual record-field destructuring.
- **Phase 1 (active):** Added direct convenience wrappers on the proved master run-bundle suite (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterRunBundleSuite*`, including bundled-seed and no-unify variants) so callers can consume run-bundle surfaces without manually threading suite witnesses.
- **Phase 1 (active):** Added naming-parity no-unify run-bundle wrappers on the master-run-bundle-suite path (`principalNoUnifyRunBundle*_*_via_masterRunBundleSuite`) and routed the long-form no-unify wrappers through them, keeping no-unify run-bundle entry naming consistent across master surfaces.
- **Phase 1 (active):** Added no-unify consequence wrappers on the master-run-bundle-suite path for core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance (`principalNoUnifyCore*`, `principalNoUnifyPreconditioned*_*`, `principalNoUnifyPreconditionedCoreIff*_*`, `principalNoUnifyPreconditioned*hookIrrelevant*_*_via_masterRunBundleSuite`) by projecting through the no-unify run-bundle aliases.
- **Phase 1 (active):** Added matching long-form no-unify-to-general naming-parity wrappers on the master-run-bundle-suite path (`principalCore*`, `principalPreconditioned*_*`, `principalPreconditionedCoreIff*_*`, `principalPreconditioned*hookIrrelevant*_*_of_success_noUnify_via_masterRunBundleSuite`) so this surface now mirrors master/all-hooks no-unify naming conventions.
- **Phase 1 (active):** Added packaged per-run no-unify consequence bundles on the master-run-bundle-suite path (`PrincipalNoUnifyExpr/FieldRunBundleConsequences`) with constructors from successful no-unify runs, bundling core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance into one theorem output.
- **Phase 1 (active):** Lifted the master-run-bundle no-unify consequence bundles to slice-level packaging (`PrincipalNoUnifyExpr/FieldRunBundleConsequenceSlice`, combined `PrincipalNoUnifyRunBundleConsequenceSlices`, proved + one-hop projections) so expression/field no-unify consequence bundles are consumable through one reusable theorem surface.
- **Phase 1 (active):** Added a top-level master run-bundle consequence suite (`PrincipalBoundaryMasterRunBundleConsequenceSuite`, constructors from master/master-run-bundle suites, proved theorem, and no-unify expr/field one-hop consequence projections) so run-bundle surfaces and no-unify consequence slices are now packaged behind one aggregate API.
- **Phase 1 (active):** Added master-suite projections into the consequence-suite layer (`principalBoundaryMasterSuite_runBundleConsequenceSuite`, `principalBoundaryMasterSuite_noUnifyRunBundleConsequences_{expr,field}`) so top-level master consumers can access no-unify consequence bundles directly through one-hop APIs.
- **Phase 1 (active):** Added run-bundle projection helpers from the master run-bundle consequence suite (`principalBoundaryMasterRunBundleConsequenceSuite_{allHooks,noUnifyAllHooks,noUnifyToGeneral}_{expr,field}`), so consumers can access the inherited run-bundle surfaces directly from the consequence-suite aggregate.
- **Phase 1 (active):** Routed the master-suite no-unify consequence wrappers (core, preconditioned, preconditioned↔core, hook-irrelevance for expr+field) through `principalBoundaryMasterSuite_noUnifyRunBundleConsequences_{expr,field}` and consequence-suite no-unify-to-general run-bundle projections, keeping top-level master no-unify consumption on the canonical consequence path.
- **Phase 1 (active):** Added top-level master run-bundle projection wrappers via the consequence-suite aggregate (`principalBoundaryMasterSuite_{allHooks,noUnifyAllHooks,noUnifyToGeneral}AllHooks_runBundle_{expr,field}_via_consequenceSuite`) and routed master no-unify run-bundle convenience wrappers through those names for consistent consequence-path entrypoints.
- **Phase 1 (active):** Added bundled-hook no-unify `_from_bundle` wrappers on both master paths (`..._of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle`, `..._of_success_noUnify_via_masterSuite_from_bundle` for preconditioned and preconditioned↔core expr+field) to complete no-unify bundled-hook naming parity with the existing arbitrary-success wrapper families.
- **Phase 1 (active):** Added `principalNoUnify*..._from_bundle` alias wrappers on both master paths (`..._via_masterRunBundleConsequenceSuite_from_bundle`, `..._via_masterSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), completing bundled-hook parity across both long-form and `principalNoUnify*` naming families.
- **Phase 1 (active):** Added matching all-hooks no-unify bundled-hook `_from_bundle` wrappers for both long-form and `principalNoUnify*` naming families (`..._of_success_noUnify_via_allHooksSuite_from_bundle`, `..._via_allHooksSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), closing bundled-hook parity across all-hooks/master/master-consequence entry layers.
- **Phase 1 (active):** Added direct consequence-bundle-to-capstone projections (`principalNoUnifyExpr/FieldRunBundleConsequences_capstone`) and top-level master `..._via_consequenceSuite` capstone/irrelevance wrappers (`principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_{expr,field,irrelevance_*}_via_consequenceSuite`), extending the consequence-path API beyond run-bundle surfaces.
- **Phase 1 (active):** Added consequence-path no-unify-as-general aliases on top-level master projections (`principalBoundaryMasterSuite_noUnifyAllHooks_{expr,field,runBundle_*}_as_general_via_consequenceSuite`), restoring the old no-unify-as-general coherence shape on the new consequence-suite routing layer.
- **Phase 1 (active):** Added no-unify capstone convenience wrappers on both master paths (`principalPreconditioned*AllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite`, `principalPreconditioned*AllHooksCapstone_of_success_noUnify_via_masterSuite`), bringing capstone-level no-unify entrypoints into parity with run-bundle/consequence surfaces.
- **Phase 1 (active):** Added no-unify capstone aliases (`principalNoUnify*AllHooksCapstone_of_success_via_*Suite`) across all-hooks/master/master-consequence entry layers, completing capstone naming parity alongside existing run-bundle and consequence alias families.
- **Phase 1 (active):** Added bundled-hook no-unify capstone wrappers/aliases (`...AllHooksCapstone_of_success_noUnify_via_*Suite_from_bundle` and `principalNoUnify*AllHooksCapstone_of_success_via_*Suite_from_bundle`) across all-hooks/master/master-consequence layers, completing `_from_bundle` parity for capstone no-unify entry surfaces.
- **Phase 1 (active):** Added arbitrary-success capstone entry wrappers on the consequence path (`principalBoundaryMasterSuite_allHooks_{expr,field}_via_consequenceSuite`, `principalPreconditioned*AllHooksCapstone_of_success_via_masterRunBundleConsequenceSuite*`), so consequence-path APIs now expose capstone surfaces for both arbitrary-success and no-unify slices.
- **Phase 1 (active):** Added arbitrary-success hook-irrelevance wrappers on the consequence route (`principalBoundaryMasterSuite_allHooks_irrelevance_{expr,field}_via_consequenceSuite`, `principalPreconditioned*hookIrrelevant_of_success_via_masterRunBundleConsequenceSuite*`, `principalPreconditioned*hookIrrelevant_of_success_via_masterSuite*`), extending consequence-path coverage to fixed-run irrelevance for non-no-unify slices.
- **Phase 1 (active):** Added bundled-hook no-unify hook-irrelevance wrappers/aliases (`...hookIrrelevant_of_success_noUnify_via_*Suite_from_bundle`, `principalNoUnifyPreconditioned*hookIrrelevant_of_success_via_*Suite_from_bundle`) across all-hooks/master/master-consequence layers, completing `_from_bundle` parity for no-unify irrelevance surfaces.
- **Phase 1 (active):** Added bundled-hook arbitrary-success irrelevance wrappers on the general-all-hooks path (`principalPreconditioned*hookIrrelevant_of_success_via_generalAllHooksSuite_from_bundle`), closing the remaining `_from_bundle` parity gap for non-no-unify irrelevance entrypoints.
- **Phase 1 (active):** Added a master consequence capstone aggregate (`PrincipalBoundaryMasterConsequenceCapstoneSuite`, constructor/proved theorems, master one-hop, and expression/field capstone+irrelevance projections) so arbitrary-success and no-unify capstone/irrelevance surfaces are consumable from one packaged consequence-path theorem API.
- **Phase 1 (active):** Added direct convenience wrappers over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (arbitrary-success + no-unify capstone families, including `principalNoUnify*` aliases and `_from_bundle` variants) so consequence-capstone aggregation is one-step consumable at call sites.
- **Phase 1 (active):** Added full hook-irrelevance convenience/alias parity over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalPreconditioned*hookIrrelevant*_of_success_via_masterConsequenceCapstoneSuite*`, `..._of_success_noUnify_via_masterConsequenceCapstoneSuite*`, and `principalNoUnifyPreconditioned*hookIrrelevant*_via_masterConsequenceCapstoneSuite*`), completing arbitrary-success/no-unify + `_from_bundle` consumption on the consequence-capstone aggregate path.
- **Phase 1 (active):** Added direct core/preconditioned/preconditioned↔core convenience wrappers over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalCore*`, `principalPreconditioned*{,_anyHooks}*`, `principalPreconditionedCoreIff*{,_anyHooks}*` on `..._via_masterConsequenceCapstoneSuite*`, including bundled-baseline variants), making the consequence-capstone aggregate path one-step consumable for full principal-boundary theorem surfaces beyond capstone/irrelevance.
- **Phase 1 (active):** Added full no-unify principal-surface parity over `PrincipalBoundaryMasterConsequenceCapstoneSuite_proved` (`principalNoUnifyCore*`, `principalNoUnifyPreconditioned*{,_anyHooks}*`, `principalNoUnifyPreconditionedCoreIff*{,_anyHooks}*` plus long-form `..._of_success_noUnify_via_masterConsequenceCapstoneSuite*` aliases and bundled variants), so no-unify consequence-capstone consumption now matches arbitrary-success coverage for core/preconditioned/`↔` theorem APIs.
- **Phase 1 (active):** Added missing bundled-baseline `_from_bundle` aliases for core/any-hooks surfaces on `..._via_masterConsequenceCapstoneSuite*` (arbitrary-success + no-unify + long-form no-unify-to-general families), completing bundled-seed naming parity across capstone, irrelevance, core, preconditioned, and `preconditioned↔core` consequence-capstone entrypoints.
- **Phase 1 (active):** Added direct run-bundle convenience wrappers on `..._via_masterConsequenceCapstoneSuite*` (arbitrary-success + no-unify, with bundled variants and `principalNoUnifyRunBundle*` aliases), so the consequence-capstone route now exports packaged `capstone + hook-irrelevance` bundles in one step.
- **Phase 1 (active):** Added direct packaged no-unify consequence constructors on `..._via_masterConsequenceCapstoneSuite*` (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite`), so this route now emits the full no-unify bundle surface (core/preconditioned/`↔`/irrelevance) in one theorem output, mirroring the master-run-bundle-consequence path.
- **Phase 1 (active):** Added bundled-hook `_from_bundle` aliases for those consequence-capstone no-unify consequence constructors (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterConsequenceCapstoneSuite_from_bundle`), completing naming parity for packaged no-unify consequence entrypoints on this route.
- **Phase 1 (active):** Added a packaged no-unify consequence slice layer for the consequence-capstone route (`PrincipalNoUnifyExpr/FieldRunBundleConsequenceSliceViaMasterConsequenceCapstoneSuite`, combined `PrincipalNoUnifyRunBundleConsequenceSlicesViaMasterConsequenceCapstoneSuite`, proved theorem, and expression/field one-hop projections), giving this route a reusable all-runs bundle API shape parallel to the master-run-bundle consequence path.
- **Phase 1 (active):** Added explicit cross-route no-unify consequence coherence constructors (`PrincipalNoUnifyExpr/FieldRunBundleConsequencesBothMasterConsequenceRoutes` plus `principalNoUnify*RunBundleConsequences_on_both_master_consequence_routes`) that package witnesses from both `masterConsequenceCapstone` and `masterRunBundleConsequence` entry layers in one theorem output.
- **Phase 1 (active):** Lifted that cross-route coherence into reusable all-runs slice packaging (`PrincipalNoUnify*RunBundleConsequencesBothMasterConsequenceRoutesSlice`, combined `...RoutesSlices`, proved theorem, expression/field projections), aligning route-coherence consumption with the existing slice-based theorem API style.
- **Phase 1 (active):** Added route-specific one-hop/canonical projections from those cross-route slices (`...RoutesSlices_{expr,field}_via_{masterConsequenceCapstone,masterRunBundleConsequence}` and `principalNoUnify*RunBundleConsequences_via_*_from_cross_route_slices`), so each route’s consequence bundle can be consumed directly from one shared coherence proof surface.
- **Phase 1 (active):** Added canonical no-unify all-hooks capstone projections from that cross-route coherence surface (`principalNoUnify*AllHooksCapstone_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`), so both routes now reach capstone consequences through the same shared coherence entrypoint.
- **Phase 1 (active):** Added explicit cross-route all-hooks capstone coherence packaging (`PrincipalNoUnifyExpr/FieldAllHooksCapstonesBothMasterConsequenceRoutes`, combined slice capstone surface, and per-route one-hop projections), so capstone-level route coherence is now consumable directly from one shared theorem API, parallel to the existing consequence-bundle coherence layer.
- **Phase 1 (active):** Added explicit cross-route all-hooks run-bundle coherence packaging (`PrincipalNoUnifyExpr/FieldAllHooksRunBundlesBothMasterConsequenceRoutes`, combined run-bundle slices, and per-route one-hop projections) and routed `principalNoUnifyRunBundle*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` through this canonical layer.
- **Phase 1 (active):** Added explicit cross-route fixed-run hook-irrelevance coherence packaging (`PrincipalNoUnifyExpr/FieldHookIrrelevanceBothMasterConsequenceRoutes`, combined irrelevance slices, and per-route one-hop projections) and routed `principalNoUnifyPreconditioned*hookIrrelevant...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` through this canonical layer.
- **Phase 1 (active):** Added a higher-level cross-route all-hooks route-surface bundle (`PrincipalNoUnifyExpr/FieldAllHooksRouteSurfaceBothMasterConsequenceRoutes`, combined slices, and per-route canonical projections) so each master consequence route now exposes capstone + run-bundle + fixed-run irrelevance as one packaged per-run theorem surface.
- **Phase 1 (active):** Routed top-level cross-route all-hooks capstone aliases (`principalNoUnify*AllHooksCapstone_of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through the new route-surface canonical projections, so call sites consume capstones via the unified all-hooks route-surface layer.
- **Phase 1 (active):** Routed top-level cross-route all-hooks run-bundle and fixed-run irrelevance aliases (`principalNoUnifyRunBundle*...` and `principalNoUnifyPreconditioned*hookIrrelevant...` on both master consequence routes) through the same route-surface canonical projections, completing unified consumption of all all-hooks facets (capstone/run-bundle/irrelevance) from one cross-route entry layer.
- **Phase 1 (active):** Extended that route-surface bundle with packaged consequence outputs (`PrincipalNoUnifyExpr/FieldRunBundleConsequences`) and routed cross-route consequence aliases through it (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`), so all major no-unify facets now consume one shared route-surface layer.
- **Phase 1 (active):** Added one-hop and canonical route-surface projections for core, any-hooks preconditioned, and any-hooks `preconditioned ↔ core` (`principalNoUnify*AllHooksRouteSurface_{core,preconditioned_anyHooks,preconditionedCoreIff_anyHooks}` plus `..._via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`), making the unified surface layer directly consumable for core/any-hooks theorem facets as well.
- **Phase 1 (active):** Routed the canonical cross-route core/any-hooks/any-hooks-`↔`/fixed-run-irrelevance projections (`principalNoUnify{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*hookIrrelevant}_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through the new route-surface canonical APIs, consolidating those canonical theorem families on one coherence layer.
- **Phase 1 (active):** Added bundled-target one-hop/canonical route-surface projections (`principalNoUnify*AllHooksRouteSurface_{preconditioned,preconditionedCoreIff}` plus per-route `..._via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`) and routed the canonical bundled-target cross-route projections (`principalNoUnifyPreconditioned*` / `principalNoUnifyPreconditionedCoreIff* ... from_cross_route_slices`) through those APIs.
- **Phase 1 (active):** Added facet-level canonical `_from_cross_route_surface_slices` wrappers for capstone/run-bundle/consequence/fixed-run-irrelevance on both routes and routed the top no-unify alias entrypoints (`principalNoUnify*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through those named surface wrappers for explicit end-to-end surface-layer consumption.
- **Phase 1 (active):** Routed long-form no-unify-to-general cross-route aliases (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*hookIrrelevant}_of_success_noUnify_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`) through `_from_cross_route_surface_slices` canonical wrappers, extending explicit surface-layer consumption to long-form entrypoints.
- **Phase 1 (active):** Added bundled-seed `_from_bundle` convenience aliases for canonical cross-route surface projections on both master consequence routes (core, any-hooks preconditioned, any-hooks `preconditioned ↔ core`, run-bundle, packaged consequences, and capstone), so one `UnifyHookPremises` seed now drives direct `...from_cross_route_surface_slices` consumption.
- **Phase 1 (active):** Closed the remaining canonical surface bundled-seed gaps (all-hooks route-surface, bundled-target preconditioned, bundled-target `preconditioned ↔ core`, and fixed-run hook-irrelevance on both routes), bringing full `_from_bundle` parity to `...from_cross_route_surface_slices` theorem names (`missing_from_bundle = 0` across 40 names).
- **Phase 1 (active):** Added full no-unify success-name parity wrappers on the same surface layer (`principalNoUnify*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`, including `_from_bundle` variants), closing `of_success_via_*` surface naming gaps at 72/72 while reusing existing cross-route proof bodies.
- **Phase 1 (active):** Added long-form no-unify-to-general surface-name parity wrappers (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*hookIrrelevant}_of_success_noUnify_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`, including `_from_bundle` variants), closing long-form `of_success_noUnify_via_*` surface naming gaps at 32/32.
- **Phase 1 (active):** Added direct all-hooks route-surface success wrappers on that same layer (`principalNoUnify{Expr,Field}AllHooksRouteSurface_of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_surface_slices`, with `_from_bundle` variants), so packaged route-surface consumption now has explicit success-name entrypoints on both routes.
- **Phase 1 (active):** Added a packaged unification-aware recursive soundness bundle in `Kea/Typing.lean` (`InferUnifyHasTypeUSoundBundle` with constructors from weak hooks, bundled weak hooks, and resolved-shape premises), plus one-hop expr/field projections for direct `HasTypeU` theorem consumption.
- **Phase 1 (active):** Extended that recursive `HasTypeU` bundle with strong-hook constructors (`inferUnifyHasTypeUSoundBundle_of_{strong_hooks,strong_hook_bundle}`), unifying strong/weak/resolved premise entrypoints on one packaged soundness API.
- **Phase 1 (active):** Added direct bundle-entry `HasTypeU` recursive soundness wrappers (`infer{Expr,Fields}Unify_sound_preconditioned_hasTypeU_from_{hook_bundle,strong_hook_bundle}`), completing one-step expr/field entry coverage across weak-bundle, strong-bundle, and resolved-bundle premise paths.
- **Phase 1 (active):** Added canonical `via_sound_bundle` wrappers over that bundle (`infer{Expr,Fields}Unify_sound_preconditioned_hasTypeU_{via_sound_bundle,from_*_via_sound_bundle}`), giving one-path theorem consumption across generic/weak/strong/resolved bundle entry surfaces.
- **Phase 1 (active):** Added one-hop constructor projections for that bundle (`inferUnifyHasTypeUSoundBundle_{expr,field}_of_{hook_bundle,strong_hook_bundle,resolved}`), so each weak/strong/resolved constructor has direct expr/field theorem entrypoints without manual bundle destructuring.
- **Phase 1 (active):** Added canonical cross-route projections for core, any-hooks preconditioned, any-hooks `preconditioned ↔ core`, and fixed-run hook-irrelevance on both routes (`principalNoUnify{Core,Preconditioned*,PreconditionedCoreIff*,Preconditioned*hookIrrelevant}_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`), so downstream theorem use can stay on the shared cross-route slice surface across all principal no-unify consequence facets.
- **Phase 1 (active):** Added bundled-target hook projections on top of those cross-route any-hooks surfaces (`principalNoUnifyPreconditioned*` and `principalNoUnifyPreconditionedCoreIff*` via both routes from cross-route slices), eliminating manual `h_hooks.1/h_hooks.2` threading when consuming the shared coherence API.
- **Phase 1 (active):** Added `_from_bundle` alias wrappers for those bundled-target cross-route projections (`principalNoUnifyPreconditioned*...from_cross_route_slices_from_bundle`, `principalNoUnifyPreconditionedCoreIff*...from_cross_route_slices_from_bundle` on both routes), completing naming parity with the broader no-unify wrapper families.
- **Phase 1 (active):** Added long-form no-unify-to-general aliases on the same cross-route route surfaces (`principalCore*`, `principalPreconditioned*AnyHooks*`, `principalPreconditionedCoreIff*AnyHooks*`, `principalPreconditioned*hookIrrelevant*_of_success_noUnify_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices`), so call sites can stay on familiar naming families while consuming the shared cross-route coherence path.
- **Phase 1 (active):** Added matching `_from_bundle` aliases for those long-form cross-route no-unify-to-general wrappers (core/any-hooks/`preconditioned ↔ core`/hook-irrelevance on both routes), completing bundled-hook naming parity for the new cross-route theorem family.
- **Phase 1 (active):** Added full `principalNoUnify*...of_success_via_masterRunBundleConsequence_from_cross_route_slices` naming-parity aliases (core, preconditioned, preconditioned↔core, hook-irrelevance, run-bundle consequences, and capstone, including `_from_bundle` variants), so the master-run-bundle-consequence cross-route surface now has complete no-unify naming parity with the established long-form wrappers.
- **Phase 1 (active):** Mirrored that same `principalNoUnify*...of_success_via_masterConsequenceCapstone_from_cross_route_slices` alias family (core, preconditioned, preconditioned↔core, hook-irrelevance, run-bundle consequences, and capstone, including `_from_bundle` variants), bringing cross-route no-unify naming parity to 62/62 theorem-surface match between the two master consequence routes.
- **Phase 1 (active):** Added the remaining bundled-seed `_from_bundle` aliases for no-unify cross-route wrappers on both master consequence routes (core, any-hooks preconditioned, any-hooks `preconditioned ↔ core`, run-bundle, and packaged consequence surfaces), so every `principalNoUnify*...of_success_via_{masterConsequenceCapstone,masterRunBundleConsequence}_from_cross_route_slices` theorem now has a bundled-seed counterpart.
- **Phase 1 (active):** Added the missing bundled-seed `_from_bundle` aliases on `masterRunBundleConsequenceSuite` for no-unify core/any-hooks/run-bundle/consequence wrappers (`principalNoUnify{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,RunBundle*,Expr/FieldRunBundleConsequences}...`), so this suite now has complete bundled-seed parity across all its no-unify theorem surfaces.
- **Phase 1 (active):** Added full bundled-seed `_from_bundle` parity on `masterRunBundleSuite` for all no-unify wrappers (run-bundle, core, any-hooks preconditioned, bundled preconditioned, any-hooks/bundled `preconditioned ↔ core`, hook-irrelevance, and packaged consequences), so every `principalNoUnify*...of_success_via_masterRunBundleSuite` theorem now has a bundled-seed companion.
- **Phase 1 (active):** Added the remaining bundled-seed `_from_bundle` aliases on `allHooksSuite` and `masterSuite` for no-unify core/any-hooks/run-bundle wrappers, closing the last suite-level parity gaps; parity checks now report `missing_from_bundle = 0` across all seven no-unify route families (`allHooks`, `master`, `masterRunBundle`, `masterRunBundleConsequence`, `masterConsequenceCapstone`, and both cross-route surfaces).
- **Phase 1 (active):** Added the final bundled-seed aliases on the legacy proved-boundary `...via_suite` wrappers (`principalNoUnify{Core,Preconditioned}{Expr,Field}_of_success_via_suite_from_bundle`), closing the remaining global gap so every `principalNoUnify*...of_success_via_*` theorem now has a `_from_bundle` companion (`missing_count = 0` on a full theorem-name parity scan).
- **Phase 1 (active):** Added bundled-seed `_from_bundle` parity for the long-form no-unify-to-general `masterRunBundleConsequenceSuite` wrappers (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*AllHooksRunBundle}_of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle`), closing that route’s long-form parity gap (`missing = 0` for `..._of_success_noUnify_via_masterRunBundleConsequenceSuite`).
- **Phase 1 (active):** Added the same long-form bundled-seed parity layer on `allHooksSuite` and `masterSuite` (`principal{Core,Preconditioned*AnyHooks,PreconditionedCoreIff*AnyHooks,Preconditioned*AllHooksRunBundle}_of_success_noUnify_via_{allHooksSuite,masterSuite}_from_bundle`), reducing long-form no-unify parity gaps to the two remaining routes: `generalAllHooks` and `masterRunBundleSuite`.
- **Phase 1 (active):** Closed the remaining long-form no-unify bundled-seed gaps on `masterRunBundleSuite` and `generalAllHooks` with the matching `_from_bundle` alias families (including fixed-run preconditioned, fixed-run `preconditioned ↔ core`, and hook-irrelevance variants where applicable), bringing long-form parity to full closure (`global_longform_missing = 0` for all `..._of_success_noUnify_via_*` theorem names).
- **Phase 1 (active):** Added the last four bundled-seed aliases surfaced by the broad `..._of_success_via_*` scan (`principalBoundaryNoUnify{ExprCapstone,FieldCapstone}_of_success_via_suite_from_bundle`, `principalBoundaryNoUnifyRunBundle{Expr,Field}_of_success_via_allHooksSuite_from_bundle`), bringing global bundle-name parity to full closure (`missing_bundle = 0` across all `..._of_success_via_*` theorem names).
- **Phase 1 (active):** Added direct convenience wrappers over `principalBoundaryMasterRunBundleConsequenceSuite_proved` (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite` plus core/any-hooks projections) so no-unify consequence-bundle consumption is one-step from the aggregate consequence suite.
- **Phase 1 (active):** Extended the master-run-bundle-consequence-suite convenience layer to full no-unify parity (`principalPreconditioned*_*`, `principalPreconditionedCoreIff*_*`, `principalPreconditioned*hookIrrelevant*_*_of_success_noUnify_via_masterRunBundleConsequenceSuite`), so bundled/any-hooks and `↔`/irrelevance surfaces are all one-step from the aggregate consequence suite.
- **Phase 1 (active):** Added matching run-bundle convenience wrappers over `principalBoundaryMasterRunBundleConsequenceSuite_proved` (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterRunBundleConsequenceSuite*` and no-unify variants), so arbitrary-success and no-unify run-bundle access can also route through the same aggregate consequence-suite entrypoint.
- **Phase 1 (active):** Added full `principalNoUnify*` naming-parity aliases on the master-run-bundle-consequence-suite path (core, preconditioned, preconditioned↔core, hook-irrelevance for expr+field) by routing through the long-form no-unify-to-general wrappers.
- **Phase 1 (active):** Added canonical no-unify run-bundle convenience wrappers on the no-unify suite layers themselves (`principalBoundaryNoUnifyRunBundle*_*_via_allHooksSuite`, `principalNoUnifyToGeneralRunBundle*_*_of_success`) so higher-level wrappers can route through stable per-suite API names.
- **Phase 1 (active):** Added naming-parity no-unify run-bundle wrappers on all-hooks/master paths (`principalNoUnifyRunBundle*_*_via_allHooksSuite`, `principalNoUnifyRunBundle*_*_via_masterSuite`) and rerouted no-unify run-bundle convenience entrypoints through canonical per-suite APIs (`principalNoUnifyToGeneralRunBundle*_*_of_success`) to keep higher-level run-bundle access on one canonical route.
- **Phase 1 (active):** Routed master-suite no-unify consequence wrappers (core, preconditioned, preconditioned↔core, hook-irrelevance) through no-unify run-bundle projection helpers, so the master no-unify API now consumes the same run-bundle canonical layer used elsewhere.
- **Phase 1 (active):** M4 DataFrame-verb typing follow-up is explicitly scoped out for Kea (tracked as N/A in `formal/ROADMAP.md`); remaining M4 scope is principal-typing extension on the Kea core language.
- **Phase 1 (active):** Added a packaged preconditioned principal-typing slice in `Kea/Typing.lean` (`PrincipalTypingSlicePreconditioned`, `principalTypingSlicePreconditioned_of_success`) to export determinism + declarative uniqueness + `inferExpr` agreement from one successful `inferExprUnify` run.
- **Phase 1 (active):** Added a hook-free no-unify principal/equivalence surface in `Kea/Typing.lean` (`inferExprUnify_complete_no_unify_branches`, `inferFieldsUnify_complete_no_unify_branches`, `inferExprUnify_ok_iff_inferExpr_no_unify_branches`, `inferFieldsUnify_ok_iff_inferFields_no_unify_branches`) with combined packaging in `PrincipalTypingNoUnifySlices`.
- **Phase 1 (active):** Added a no-unify bridge back into the preconditioned principal bundle (`principalTypingSlicePreconditioned_of_success_no_unify`), making hook assumptions vacuous on the no-unify fragment while preserving the same bundle API.
- **Phase 1 (active):** Added bundled-hook API entrypoints (`UnifyHookPremises`, `principalTypingSlicePreconditioned_of_success_from_bundle`, `principalTypingSlicePreconditioned_of_success_no_unify_from_bundle`) so principal bundle consumers can pass one hook package instead of separate app/proj assumptions.
- **Phase 1 (active):** Added core declarative principality packaging for syntax-directed inference (`hasType_unique`, `inferExpr_principal`, `PrincipalTypingSliceCore`, `principalTypingSliceCore_of_infer`) to expose a hook-free principal baseline on the core typing judgment itself.
- **Phase 1 (active):** Added no-unify success bridges from `inferExprUnify`/`inferFieldsUnify` into core principal packages (`principalTypingSliceCore_of_unify_success_no_unify`, `principalFieldTypingSliceCore_of_unify_success_no_unify`) so successful hook-free unify runs map directly to principal declarative slices.
- **Phase 1 (active):** Added a core-principal-to-preconditioned bridge (`principalTypingSlicePreconditioned_of_success_of_core_principal`) and routed the no-unify preconditioned theorem through it, reducing duplicated proof obligations and making hook assumptions explicitly vacuous once core principality is established.
- **Phase 1 (active):** Added the converse preconditioned-to-core bridge (`principalTypingSliceCore_of_preconditioned_success`, plus bundle entrypoint) so successful preconditioned inference runs can project directly to the core principal package.
- **Phase 1 (active):** Added a packaged no-unify bridge bundle (`PrincipalNoUnifyBridgeBundle`, constructors from direct hooks and hook bundles) that exports both core and preconditioned principal consequences from one successful no-unify run.
- **Phase 1 (active):** Added full field-side preconditioned principality parity (`inferFieldsUnify_deterministic`, `inferFieldsUnify_row_unique_preconditioned`, `PrincipalFieldTypingSlicePreconditioned`) with direct/bundle/no-unify/core-bridge entrypoints, mirroring the expression principal theorem stack.
- **Phase 1 (active):** Added packaged no-unify field bridge exports (`PrincipalFieldNoUnifyBridgeBundle`, direct and hook-bundle constructors) so one successful no-unify `inferFieldsUnify` run yields both core and preconditioned field principal packages.
- **Phase 1 (active):** Added the converse preconditioned-to-core field bridge (`principalFieldTypingSliceCore_of_preconditioned_success`, plus bundle entrypoint), completing expression/field symmetry for principal bridge directions.
- **Phase 1 (active):** Added a combined no-unify bridge slice capstone (`PrincipalNoUnifyBridgeSlices`, `principalNoUnifyBridgeSlices_proved`) that packages both expression and field no-unify bridge APIs into one proved theorem surface.
- **Phase 1 (active):** Added successful-run equivalence bridges between preconditioned and core principal slices (expression + field, direct and hook-bundle variants), tightening the M4 boundary to explicit `↔` contracts at fixed successful runs.
- **Phase 1 (active):** Added combined successful-run preconditioned↔core capstone packaging (`PrincipalPreconditionedCoreIffSlices`, `principalPreconditionedCoreIffSlices_proved`) for expression+field principality under bundled hooks.
- **Phase 1 (active):** Added one-hop projection helpers from the combined capstones (`principalNoUnifyBridgeSlices_expr/field`, `principalPreconditionedCoreIffSlices_expr/field`) so downstream proofs can consume expression or field slices directly.
- **Phase 1 (active):** Added top-level principal boundary suite packaging (`PrincipalBoundaryBridgeSuite`, `principalBoundaryBridgeSuite_proved`) with one-hop projections for no-unify and preconditioned↔core branches across expressions and fields.
- **Phase 1 (active):** Added suite-based convenience entrypoints (`principalNoUnifyCoreExpr/Field_of_success_via_suite`, `principalNoUnifyPreconditionedExpr/Field_of_success_via_suite`) for direct extraction of core/preconditioned principality from successful no-unify runs.
- **Phase 1 (active):** Added suite-based successful-run conversion wrappers in both directions (`principalCore*/principalPreconditioned*_*_via_suite`) for expressions and fields, making preconditioned↔core transport one-step at call sites.
- **Phase 1 (active):** Added suite coherence lemmas (`principalBoundaryBridgeSuite_noUnify_*_coherent_*`) showing the no-unify bundle witnesses and preconditioned↔core equivalence witnesses inter-derive each other for expressions and fields.
- **Phase 1 (active):** Added no-unify principal capstone packaging (`PrincipalBoundaryNoUnifyExprCapstone`, `PrincipalBoundaryNoUnifyFieldCapstone`, `PrincipalBoundaryNoUnifyCapstoneSlices`) with suite-derived constructors and one-hop projections/coherence wrappers so one successful no-unify run exposes both witnesses and their successful-run equivalence surface.
- **Phase 1 (active):** Added one-hop projection helpers from the combined no-unify capstone slices (`principalBoundaryNoUnifyCapstoneSlices_expr_*`, `principalBoundaryNoUnifyCapstoneSlices_field_*`) for direct extraction of core/preconditioned/`↔` witnesses at expression and field call sites.
- **Phase 1 (active):** Added unbundled-hook and hook-bundle capstone entrypoints (`principalBoundaryNoUnifyExpr/FieldCapstone_of_success`, `principalBoundaryNoUnifyExpr/FieldCapstone_of_success_from_hook_bundle`) so no-unify capstone construction works uniformly with either hook-passing style.
- **Phase 1 (active):** Added fixed-run hook-transport/irrelevance theorems for preconditioned principality (`principalTypingSlicePreconditioned_transport_hooks_of_success`, `principalTypingSlicePreconditioned_hook_irrelevant_of_success`, field analogues), making hook-witness independence explicit once inference success is fixed.
- **Phase 1 (active):** Added combined hook-irrelevance slice packaging (`PrincipalPreconditionedHookIrrelevanceSlices`, `principalPreconditionedHookIrrelevanceSlices_proved`) with expression/field one-hop projections for direct fixed-run hook-independence consumption.
- **Phase 1 (active):** Added top-level principal vacuity suite packaging (`PrincipalBoundaryVacuitySuite`, `principalBoundaryVacuitySuite_proved`) with one-hop projections for both no-unify capstones and fixed-run hook-irrelevance branches.
- **Phase 1 (active):** Added no-unify all-hooks capstone packaging (`PrincipalBoundaryNoUnifyExpr/FieldAllHooksCapstone`, `PrincipalBoundaryNoUnifyAllHooksCapstoneSlices`) so the no-unify boundary exposes hook-free core + per-hook preconditioned/`↔` consequences from one successful run.
- **Phase 1 (active):** Added no-unify all-hooks irrelevance packaging (`PrincipalBoundaryNoUnifyAllHooksIrrelevanceSlices`) derived directly from all-hooks capstones, with expression/field one-hop projections for hook-independence on successful no-unify runs.
- **Phase 1 (active):** Added top-level no-unify all-hooks suite packaging (`PrincipalBoundaryNoUnifyAllHooksSuite`, `principalBoundaryNoUnifyAllHooksSuite_proved`) with one-hop projections for both all-hooks capstones and derived irrelevance branches.
- **Phase 1 (active):** Added compatibility bridges from all-hooks back to hook-specific no-unify capstones (`principalBoundaryNoUnifyExpr/FieldCapstone_of_allHooks`) and derived the legacy no-unify capstone slices from the proved all-hooks suite (`principalBoundaryNoUnifyCapstoneSlices_of_allHooksSuite`).
- **Phase 1 (active):** Added a top-level principal boundary master suite (`PrincipalBoundaryMasterSuite`, `principalBoundaryMasterSuite_proved`) aggregating bridge, vacuity, general all-hooks, and no-unify all-hooks surfaces with one-hop projections for preconditioned↔core, hook-irrelevance, general all-hooks capstones, and both all-hooks/hook-specific no-unify capstones.
- **Phase 1 (active):** Added all-hooks-suite convenience wrappers for no-unify runs (`principalNoUnifyCore*` / `principalNoUnifyPreconditioned*_*_via_allHooksSuite`, including any-hooks forms) to expose core/preconditioned consequences without manual all-hooks capstone destructuring.
- **Phase 1 (active):** Added general successful-run all-hooks capstone packaging (`PrincipalPreconditionedExpr/FieldAllHooksCapstone`, `PrincipalPreconditionedAllHooksCapstoneSlices`) so arbitrary successful `inferExprUnify`/`inferFieldsUnify` runs can export core + any-hooks preconditioned consequences from one hook witness pair.
- **Phase 1 (active):** Added a top-level general all-hooks suite (`PrincipalPreconditionedAllHooksSuite`, `principalPreconditionedAllHooksSuite_proved`) with capstone-derived irrelevance (`principalPreconditionedHookIrrelevanceSlices_of_allHooksCapstones`) and one-hop projections for both capstone and irrelevance branches.
- **Phase 1 (active):** Added general-all-hooks-suite convenience wrappers (`principalCore*` / `principalPreconditioned*_*_via_generalAllHooksSuite`, including any-hooks forms) for arbitrary successful runs, removing manual capstone destructuring at call sites.
- **Phase 1 (active):** Added master-suite convenience wrappers (`principalCore*` / `principalPreconditioned*_*_via_masterSuite`, including any-hooks forms) so arbitrary successful-run consequences can be consumed directly from `PrincipalBoundaryMasterSuite`.
- **Phase 1 (active):** Added master-suite no-unify convenience wrappers (`principalNoUnifyCore*` / `principalNoUnifyPreconditioned*_*_via_masterSuite`, including any-hooks forms) so no-unify consequences are also consumable directly from the same master surface.
- **Phase 1 (active):** Added no-unify-to-general all-hooks bridge projections (`principalPreconditionedExpr/FieldAllHooksCapstone_of_noUnifyAllHooks`, `principalBoundaryNoUnifyAllHooksSuite_capstone_*_as_general`, `principalBoundaryMasterSuite_noUnifyAllHooks_*_as_general`) so every successful no-unify all-hooks witness is explicitly consumable on the general successful-run all-hooks API.
- **Phase 1 (active):** Added success-level no-unify-to-general convenience wrappers (`principalPreconditionedExpr/FieldAllHooksCapstone_of_success_noUnify`, `principalCore*` / `principalPreconditioned*AnyHooks*_of_success_noUnify_via_generalAllHooks`) so successful no-unify runs can project directly into the general all-hooks core/preconditioned consequences without first building no-unify suite witnesses.
- **Phase 1 (active):** Added no-unify-to-general parity wrappers for bundled hooks and hook-irrelevance (`principalPreconditionedExpr/Field_of_success_noUnify_via_generalAllHooks`, `principalPreconditionedExpr/Field_hookIrrelevant_of_success_noUnify_via_generalAllHooks`) to keep expression/field and any-hooks/bundled/irrelevance APIs aligned on the same success path.
- **Phase 1 (active):** Added a packaged no-unify-to-general all-hooks suite (`PrincipalNoUnifyToGeneralAllHooksSuite`, proved capstone/irrelevance slices, and one-hop expr/field projections) so this bridge now has a single theorem surface parallel to the other M4 suite layers.
- **Phase 1 (active):** Extended `PrincipalBoundaryMasterSuite` with the no-unify-to-general all-hooks suite and master-level projections (`principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_*`), then routed existing `*_noUnifyAllHooks_*_as_general` adapters through that canonical field.
- **Phase 1 (active):** Added missing hook-irrelevance convenience wrappers across suite entrypoints (`principalPreconditioned*hookIrrelevant*_via_generalAllHooksSuite`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_masterSuite`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_allHooksSuite`) so any-hooks/bundled/irrelevance parity now holds on general and no-unify paths.
- **Phase 1 (active):** Routed master-suite no-unify core/preconditioned convenience wrappers (`principalNoUnifyCore*` / `principalNoUnifyPreconditioned*_*_via_masterSuite`) through the canonical `principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_*` projections, consolidating no-unify-as-general consumption on one path.
- **Phase 1 (active):** Routed all-hooks-suite no-unify convenience wrappers (including hook-irrelevance variants) through `PrincipalNoUnifyToGeneralAllHooksSuite_proved`, so both master and all-hooks entrypoints now consume the same canonical no-unify-to-general bridge surface.
- **Phase 1 (active):** Added bidirectional compatibility between no-unify-all-hooks and no-unify-to-general suites (`principalNoUnifyToGeneralAllHooksSuite_of_noUnifyAllHooksSuite`, `principalBoundaryNoUnifyAllHooksSuite_of_noUnifyToGeneralAllHooksSuite`, plus proved derived forms), and now construct `PrincipalBoundaryMasterSuite.noUnifyToGeneralAllHooks` via the no-unify-all-hooks suite path.
- **Phase 1 (active):** Added parameterized no-unify-to-general convenience wrappers (`principalNoUnifyToGeneralCore*`, `principalNoUnifyToGeneralPreconditioned*_*`) and routed master/all-hooks no-unify convenience entrypoints through them, consolidating expression/field + any-hooks/bundled/irrelevance access behind one reusable suite API.
- **Phase 1 (active):** Added no-unify-to-general `preconditioned ↔ core` convenience wrappers (`principalNoUnifyToGeneralPreconditionedCoreIff*`) and exposed them through both master/all-hooks entrypoints (`principalNoUnifyPreconditionedCoreIff*_of_success_via_*Suite`) for complete no-unify API parity.
- **Phase 1 (active):** Added arbitrary-success `preconditioned ↔ core` convenience wrappers for the general all-hooks and master paths (`principalPreconditionedCoreIff*_of_success_via_generalAllHooksSuite`, `principalPreconditionedCoreIff*_of_success_via_masterSuite`), completing wrapper parity across no-unify and non-no-unify surfaces.
- **Phase 1 (active):** Added `any-hooks` no-unify `preconditioned ↔ core` wrappers (`principalNoUnifyToGeneralPreconditionedCoreIff*AnyHooks*`) and corresponding master/all-hooks entrypoints (`principalNoUnifyPreconditionedCoreIff*AnyHooks*_of_success_via_*Suite`), with bundled variants now routed through these canonical any-hooks forms.
- **Phase 1 (active):** Added matching `any-hooks` arbitrary-success `preconditioned ↔ core` wrappers for general/master paths (`principalPreconditionedCoreIff*AnyHooks*_of_success_via_generalAllHooksSuite`, `principalPreconditionedCoreIff*AnyHooks*_of_success_via_masterSuite`) and routed bundled variants through them.
- **Phase 1 (active):** Added a parameterized arbitrary-success convenience layer (`principalGeneralAllHooks*`) over `PrincipalPreconditionedAllHooksSuite` and routed both `via_generalAllHooksSuite` and `via_masterSuite` wrapper families through it, consolidating non-no-unify consumption on one canonical API.
- **Phase 1 (active):** Added direct no-unify-to-general `preconditioned ↔ core` wrappers on the proved general-all-hooks success path (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_generalAllHooks`, `principalPreconditionedCoreIff*_of_success_noUnify_via_generalAllHooks`) for expression/field parity without suite destructuring.
- **Phase 1 (active):** Added master no-unify-to-general naming-parity wrappers for fixed-run `preconditioned ↔ core` transport (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_masterSuite`, `principalPreconditionedCoreIff*_of_success_noUnify_via_masterSuite`) routed through canonical `principalNoUnifyPreconditionedCoreIff*_*_via_masterSuite` paths.
- **Phase 1 (active):** Added a dual recursive-soundness package in `Kea/Typing.lean` (`InferUnifySoundDualBundle`) that exports both `HasType` and `HasTypeU` consequences from one unification-success witness (constructors from hook pairs and hook bundles, plus direct expr/field projections for each judgment), so M4 call sites can choose either judgment surface from a single theorem API.
- **Phase 1 (active):** Added canonical `via_dual_bundle` recursive-soundness entrypoints (expression/field for both `HasType` and `HasTypeU`) plus bundled-hook adapters (`infer{Expr,Fields}Unify_sound_preconditioned{,_hasTypeU}_from_hook_bundle_via_dual_bundle`), so dual-bundle call sites now have one-step theorem APIs matching the existing `via_sound_bundle` ergonomics.
- **Phase 1 (active):** Added one-hop bundled-hook constructor projections for each dual-bundle facet (`inferUnifySoundDualBundle_{expr,field}_{hasType,hasTypeU}_of_hook_bundle`), so all four consequences are directly consumable from `UnifyHookPremises` without manually constructing or destructuring the dual bundle.
- **Phase 1 (active):** Added dual-to-`HasTypeU` bundle bridge theorems (`inferUnifyHasTypeUSoundBundle_of_dual_bundle`, `inferUnifyHasTypeUSoundBundle_of_dual_hook_bundle`) so the new dual package composes directly with existing `InferUnifyHasTypeUSoundBundle` consumers and `via_sound_bundle` theorem paths.
- **Phase 1 (active):** Added dual-bundle principal-slice wrappers (`principal{,Field}TypingSlicePreconditioned_of_success{_from_hook_bundle}_via_dual_bundle`) and one-step agreement extractors (`infer{Expr,Fields}Unify_infer{Expr,Fields}_agrees_of_success{_from_hook_bundle}_via_dual_bundle`), so successful-run principal consequences and algorithmic-agreement facts are directly consumable from the dual theorem surface.
- **Phase 1 (active):** Added dual-bundle wrappers for the principal core-bridge surfaces (`principal{,Field}TypingSliceCore_of_preconditioned_success{_from_hook_bundle}_via_dual_bundle`, `principal{,Field}TypingSlicePreconditioned_iff_core_of_success{_from_hook_bundle}_via_dual_bundle`), so dual API consumers can reach preconditioned→core and `↔` consequences directly without reverting to raw hook-argument theorem families.
- **Phase 1 (active):** Added packaged per-run dual principal consequence bundles (`Principal{,Field}TypingDualConsequence`) with constructors from successful runs (`..._of_success_via_dual_bundle`, bundled-hook variants), packaging preconditioned slice, core slice, preconditioned↔core equivalence, and algorithmic-agreement witnesses behind one theorem output.
- **Phase 1 (active):** Added one-hop projections for those per-run dual consequence bundles (`principal{,Field}TypingDualConsequence_{preconditioned,core,iff_core,inferExpr_agrees/inferFields_agrees}`), so all bundled facets are directly consumable without manual record destructuring.
- **Phase 1 (active):** Added combined successful-run dual consequence slices (`PrincipalDual{Expr,Field}ConsequenceSlice`, `PrincipalDualConsequenceSlices`, `principalDualConsequenceSlices_proved`) with one-hop expression/field projections, so per-run dual bundles are now available through the same slice-level API style used by the broader principal-capstone track.
- **Phase 1 (active):** Added canonical proved-slice dual entrypoints (`principal{,Field}TypingDualConsequence_of_success_via_proved_slice`) and one-step agreement extractors (`infer{Expr,Fields}Unify_infer{Expr,Fields}_agrees_of_success_via_dual_proved_slice`), so downstream theorem use can consume the combined dual slice without threading explicit slice witnesses.
- **Phase 1 (active):** Added compatibility/equivalence bridges between dual consequence slices and the existing preconditioned↔core slice surface (`principalPreconditionedCoreIffSlices_of_dualConsequenceSlices`, `principalDualConsequenceSlices_of_principalPreconditionedCoreIffSlices`, `principalDualConsequenceSlices_iff_principalPreconditionedCoreIffSlices`) plus canonical proved-surface adapters in both directions.
- **Phase 1 (active):** Added compatibility/equivalence adapters between dual consequence bundles and existing no-unify bridge bundles (`principal{,Field}NoUnifyBridgeBundle_of_dualConsequence`, `principal{,Field}TypingDualConsequence_of_noUnifyBridgeBundle`, `principal{,Field}TypingDualConsequence_iff_noUnifyBridgeBundle_of_success`), so the new dual surface composes directly with established bridge-bundle consumers.
- **Phase 1 (active):** Added suite-level adapters from dual consequence slices into the established boundary stack (`principalNoUnifyBridgeSlices_of_dualConsequenceSlices`, `principalBoundaryBridgeSuite_of_dualConsequenceSlices`, `principalBoundaryBridgeSuite_proved_via_dualConsequenceSlices`), so the new dual API now plugs directly into the existing principal bridge suite surface.
- **Phase 1 (active):** Added the reverse suite adapter and full equivalence (`principalDualConsequenceSlices_of_principalBoundaryBridgeSuite`, `principalBoundaryBridgeSuite_iff_dualConsequenceSlices`) plus canonical dual-slice recovery from the existing proved suite (`principalDualConsequenceSlices_proved_via_principalBoundaryBridgeSuite`), closing bidirectional interoperability between boundary-suite and dual-slice APIs.
- **Phase 1 (active):** Lifted that dual-routed bridge path into the top-level master suite (`principalBoundaryMasterSuite_proved_via_dualConsequenceSlices`) and added direct preconditioned↔core wrappers on that route (`principalBoundaryMasterSuite_preconditionedCoreIff_{expr,field}_via_dualConsequenceSlices`), so dual-slice interoperability now reaches the master-suite entry layer.
- **Phase 1 (active):** Added dual-routed suite convenience wrappers for no-unify/core/preconditioned and preconditioned↔core conversions (`principalNoUnify*...via_suite_via_dualConsequenceSlices`, `principal{Core,Preconditioned}*...via_suite_via_dualConsequenceSlices`, expression+field), keeping call sites on a single named dual route at the suite convenience layer.
- **Phase 1 (active):** Added dual-routed master-suite convenience wrappers for arbitrary successful runs (`principal{Core,Preconditioned*,PreconditionedCoreIff*}{Expr,Field}_of_success_via_masterSuite_via_dualConsequenceSlices`, including any-hooks and bundled-hook forms), so master entrypoint consumers can stay on one explicit dual route without manually passing `PrincipalBoundaryMasterSuite`.
- **Phase 1 (active):** Added dual-routed master-suite no-unify convenience wrappers (`principalNoUnify{Core,Preconditioned*,PreconditionedCoreIff*}{Expr,Field}_of_success_via_masterSuite_via_dualConsequenceSlices`, including any-hooks and bundled-hook forms), so both arbitrary-success and no-unify master entrypoint families now have explicit dual-route counterparts.
- **Phase 1 (active):** Generalized the top-level dual bridge from a proved-instance adapter to full bidirectional interoperability (`principalBoundaryMasterSuite_of_dualConsequenceSlices`, `principalDualConsequenceSlices_of_principalBoundaryMasterSuite`, `principalBoundaryMasterSuite_iff_dualConsequenceSlices`), then routed `principalBoundaryMasterSuite_proved_via_dualConsequenceSlices` through that generalized theorem.
- **Phase 1 (active):** Added dual-routed no-unify-to-general master-suite convenience wrappers (`principal{Core,Preconditioned*,PreconditionedCoreIff*}{Expr,Field}_of_success_noUnify_via_masterSuite_via_dualConsequenceSlices`, including any-hooks and bundled-hook forms), closing naming/entrypoint parity between arbitrary-success and no-unify-to-general master APIs on the dual route.
- **Phase 1 (active):** Added bundled-seed `_from_bundle` parity wrappers for all three dual-routed master-suite convenience families (`..._of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle`, `principalNoUnify*..._of_success_via_masterSuite_via_dualConsequenceSlices_from_bundle`, and `..._of_success_noUnify_via_masterSuite_via_dualConsequenceSlices_from_bundle`, expression+field, any-hooks+bundled+core/`↔` surfaces), so one `UnifyHookPremises` seed now drives the full dual-routed master convenience API without split hook arguments.
- **Phase 1 (active):** Added bundled-seed dual-route parity aliases on the suite no-unify path (`principalNoUnify{Core,Preconditioned}{Expr,Field}_of_success_via_suite_via_dualConsequenceSlices_from_bundle`), closing the remaining `_from_bundle` gap on the dual-routed `via_suite` no-unify convenience surface.
- **Phase 1 (active):** Added bundled-seed aliases for the dual-routed suite conversion wrappers (`principal{Core,Preconditioned}{Expr,Field}_of_{preconditioned,core}_success_via_suite_via_dualConsequenceSlices_from_bundle`), making the full dual `via_suite` convenience layer bundle-entry complete across no-unify and preconditioned↔core conversion surfaces.
- **Phase 1 (active):** Added a packaged current row-polymorphic boundary surface (`PrincipalRowPolyBoundaryBundle`) that combines the top-level principal boundary master suite with the proved hook-free app/proj vertical slice (`VerticalHookFreeUnifySlices`), including canonical constructors (`..._proved`, `..._proved_via_dualConsequenceSlices`) and one-hop principal/vertical/dual projections.
- **Phase 1 (active):** Added an explicit decomposition bridge for that package (`principalRowPolyBoundaryBundle_of_dual_and_vertical`, `principalRowPolyBoundaryBundle_iff_dual_and_vertical`), making the current boundary surface equivalent to `dual principal slice ∧ hook-free vertical slice`.
- **Phase 1 (active):** Added bundle-level one-hop consumption wrappers (`principalRowPolyBoundaryBundle_preconditionedCoreIff_{expr,field}`, `principalRowPolyBoundaryBundle_vertical_{app,proj}`), so the row-polymorphic boundary package now directly exposes both principal equivalence facets and hook-free app/proj vertical facets.
- **Phase 1 (active):** Added a higher capstone package combining boundary + recursive soundness (`PrincipalRowPolyBoundarySoundBundle`) with canonical constructors (direct, dual-routed, and bundled-hook) and one-hop projections/wrappers into `InferUnifySoundDualBundle` (`..._expr_hasTypeU`, `..._field_hasTypeU`), so boundary and dual-judgment soundness are consumable from one theorem witness.
- **Phase 1 (active):** Extended that capstone with explicit decomposition and full judgment symmetry (`principalRowPolyBoundarySoundBundle_iff_boundary_and_soundDual`, plus one-hop `..._expr/field_hasType` wrappers), so both `HasType` and `HasTypeU` recursive soundness facets are now first-class from the combined boundary+soundness package.
- **Phase 1 (active):** Added direct principal-success one-hop wrappers from the combined boundary+soundness capstone (`principalRowPolyBoundarySoundBundle_{core,preconditioned,preconditionedCoreIff}{Expr,Field}_of_success`), so core/preconditioned/`↔` theorem consumption now works from a single capstone witness without manually threading master-suite arguments.
- **Phase 1 (active):** Added matching no-unify principal-success one-hop wrappers on that same capstone (`principalRowPolyBoundarySoundBundle_{core,preconditioned,preconditionedCoreIff}{Expr,Field}_of_success_noUnify`), so the no-unify core/preconditioned/`↔` theorem surfaces are equally consumable from one combined boundary+soundness witness.
- **Phase 1 (active):** Added any-hooks one-hop wrappers on that capstone for both arbitrary-success and no-unify runs (`principalRowPolyBoundarySoundBundle_preconditioned{,CoreIff}{Expr,Field}_anyHooks_of_success{_noUnify}`), completing direct capstone consumption across bundled and any-hooks principal theorem families.
- **Phase 1 (active):** Added run-bundle and hook-irrelevance one-hop wrappers on that capstone for both arbitrary-success and no-unify runs (`principalRowPolyBoundarySoundBundle_{runBundle,hookIrrelevant}{Expr,Field}_of_success{_noUnify}`), so packaging now directly covers capstone/principal/run-bundle/irrelevance facets from one boundary+soundness witness.
- **Phase 1 (active):** Added explicit run-bundle-route coherence wrappers on that capstone (`principalRowPolyBoundarySoundBundle_{core,hookIrrelevant}{Expr,Field}_of_success{_noUnify}_via_runBundle`), making the direct core/irrelevance APIs explicitly derivable through the packaged run-bundle projection path.
- **Phase 1 (active):** Extended run-bundle-route coherence on that capstone to the preconditioned and `preconditioned ↔ core` theorem families (`principalRowPolyBoundarySoundBundle_preconditioned{,CoreIff}{Expr,Field}{,_anyHooks}_of_success{_noUnify}_via_runBundle`), so all core/preconditioned/`↔`/irrelevance facets now share an explicit route through the packaged run-bundle projections.
- **Phase 1 (active):** Added bundled-seed `_from_bundle` aliases across that full `..._via_runBundle` wrapper family (`principalRowPolyBoundarySoundBundle_{core,preconditioned{,_anyHooks},preconditionedCoreIff{,_anyHooks},hookIrrelevant}{Expr,Field}_of_success{_noUnify}_via_runBundle_from_bundle`), closing bundle-entry naming parity on the direct run-bundle route.
- **Phase 1 (active):** Added no-unify packaged consequence-bundle wrappers on that same run-bundle route (`principalRowPolyBoundarySoundBundle_noUnify{Expr,Field}RunBundleConsequences_of_success_via_runBundle` plus `_from_bundle` aliases), so one boundary+sound capstone witness can now emit full no-unify consequence records (core/preconditioned/`↔`/irrelevance) through the run-bundle path.
- **Phase 1 (active):** Added no-unify one-hop wrappers routed through those capstone consequence bundles (`principalRowPolyBoundarySoundBundle_{core,preconditioned,preconditionedCoreIff,hookIrrelevant}{Expr,Field}_of_success_noUnify_via_runBundleConsequences`, with any-hooks variants), so all no-unify principal theorem facets now have an explicit consequence-bundle route on the boundary+sound capstone path.
- **Phase 1 (active):** Added arbitrary-success packaged consequence-bundle wrappers on that same route (`Principal{,Field}RunBundleConsequences` plus `principalRowPolyBoundarySoundBundle_{expr,field}RunBundleConsequences_of_success_via_runBundle` and `_from_bundle` aliases), so boundary+sound capstone witnesses now emit full consequence records for both arbitrary-success and no-unify runs through the run-bundle path.
- **Phase 1 (active):** Added arbitrary-success one-hop wrappers through those packaged consequence bundles (`principalRowPolyBoundarySoundBundle_{core,preconditioned,preconditionedCoreIff,hookIrrelevant}{Expr,Field}_of_success_via_runBundleConsequences`, with any-hooks variants), completing consequence-route one-hop symmetry between arbitrary-success and no-unify facets on the boundary+sound capstone path.
- **Phase 1 (active):** Added bundled-seed `_from_bundle` aliases for the full capstone consequence-route wrapper family (`..._of_success{_noUnify}_via_runBundleConsequences_from_bundle` across core/preconditioned/`↔`/irrelevance for expr+field, including any-hooks variants), completing bundle-entry naming parity on this boundary+sound run-bundle consequence surface.
- **Phase 1 (active):** Added boundary+sound run-bundle route-pair packaging (`PrincipalBoundarySound{,NoUnify}{Expr,Field}RunBundleRoutes` plus `principalRowPolyBoundarySoundBundle_{,noUnify}{Expr,Field}RunBundleRoutes_of_success`), so one capstone witness now jointly exports both the all-hooks run-bundle witness and its packaged consequence witness for arbitrary-success and no-unify runs.
- **Phase 1 (active):** Added one-hop projection APIs for those route-pair surfaces (`principalBoundarySound{,NoUnify}{Expr,Field}RunBundleRoutes_{runBundle,consequences}`), so downstream consumers can extract either route witness through named theorem entrypoints instead of record-field destructuring.
- **Phase 1 (active):** Added direct hook-seeded and bundled-hook route-pair entrypoints (`principalBoundarySound{,NoUnify}{Expr,Field}RunBundleRoutes_of_success{_from_bundle}`), so route-pair APIs are now directly accessible from hook premises without manually constructing `PrincipalRowPolyBoundarySoundBundle`.
- **Phase 1 (active):** Added combined typing+route packages (`PrincipalBoundarySound{,NoUnify}{Expr,Field}TypingRunBundleRoutes` plus `principalRowPolyBoundarySoundBundle_{,noUnify}{Expr,Field}TypingRunBundleRoutes_of_success`) that jointly export recursive soundness (`HasType`/`HasTypeU`) and route-pair witnesses from one capstone-success proof.
- **Phase 1 (active):** Added direct hook-seeded and bundled-hook entrypoints for those typing+route packages (`principalBoundarySound{,NoUnify}{Expr,Field}TypingRunBundleRoutes_of_success{_from_bundle}`) and one-hop projections (`..._hasType`, `..._hasTypeU`, `..._routes`), making the combined soundness+route surface directly consumable from hook premises without record-field destructuring.
- **Phase 1 (active):** Added a hook-parameterized typing-route suite (`PrincipalBoundarySoundTypingRunBundleSuite`) with direct/bundled constructors (`..._of_hooks`, `..._of_hook_bundle`) and branch projections (`..._{expr,field,noUnifyExpr,noUnifyField}`), so one suite witness now packages arbitrary-success and no-unify expression/field typing-route surfaces together.
- **Phase 1 (active):** Added suite-level recursive-soundness wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_{hasType,hasTypeU}`), making `HasType`/`HasTypeU` extraction directly consumable from the typing-route suite without intermediate package destructuring.
- **Phase 1 (active):** Added suite-level principal-core wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_core_of_success`), making core principality directly consumable from the typing-route suite on arbitrary-success and no-unify expression/field paths.
- **Phase 1 (active):** Added suite-level any-hooks preconditioned wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_preconditioned_anyHooks_of_success`), so per-hook preconditioned principality is directly consumable from the typing-route suite on arbitrary-success and no-unify expression/field paths.
- **Phase 1 (active):** Added suite-level bundled-hook preconditioned wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_preconditioned_of_success`), so bundled-hook preconditioned principality is directly consumable from the typing-route suite on arbitrary-success and no-unify expression/field paths.
- **Phase 1 (active):** Added suite-level any-hooks `preconditioned ↔ core` wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_preconditionedCoreIff_anyHooks_of_success`), so per-hook equivalence between preconditioned and core principality is directly consumable from the typing-route suite on arbitrary-success and no-unify expression/field paths.
- **Phase 1 (active):** Added suite-level bundled-hook `preconditioned ↔ core` and fixed-run hook-irrelevance wrappers (`principalBoundarySoundTypingRunBundleSuite_{expr,field,noUnifyExpr,noUnifyField}_{preconditionedCoreIff,hookIrrelevant}_of_success`), completing direct suite-level consumption of the principal theorem matrix across arbitrary-success and no-unify expression/field paths.
- **Phase 1 (active):** Added direct hook-seeded convenience wrappers over that suite for recursive soundness/core surfaces (`principalBoundarySound{,NoUnify}{Expr,Field}_{hasType,hasTypeU,core}_of_success_via_typingRunBundleSuite`), so these outcomes are directly consumable from hook premises without explicitly constructing the suite witness.
- **Phase 1 (active):** Added bundled-hook `_from_bundle` aliases for those direct typing-suite convenience wrappers (`principalBoundarySound{,NoUnify}{Expr,Field}_{hasType,hasTypeU,core}_of_success_via_typingRunBundleSuite_from_bundle`), completing bundle-entry naming parity on this direct consumption layer.
- **Phase 1 (active):** Closed the no-unify recursive-soundness gap on that direct layer by adding `principalBoundarySoundNoUnify{Expr,Field}_{hasType,hasTypeU}_of_success_via_typingRunBundleSuite` plus `_from_bundle` aliases, so no-unify `HasType`/`HasTypeU` are now directly consumable from hook premises with full bundle-entry parity.
- **Phase 1 (active):** Added direct hook-seeded preconditioned principality wrappers over that suite (`principalBoundarySound{,NoUnify}{Expr,Field}_preconditioned{,_anyHooks}_of_success_via_typingRunBundleSuite`), so any-hooks and bundled-hook preconditioned surfaces are now directly consumable from hook premises on arbitrary-success and no-unify expression/field paths.
- **Phase 1 (active):** Added direct hook-seeded `preconditioned ↔ core` wrappers over that suite (`principalBoundarySound{,NoUnify}{Expr,Field}_preconditionedCoreIff{,_anyHooks}_of_success_via_typingRunBundleSuite`), so any-hooks and bundled-hook equivalence surfaces are directly consumable from hook premises on arbitrary-success and no-unify expression/field paths.
- **Phase 1 (active):** Added direct hook-seeded fixed-run hook-irrelevance wrappers over that suite (`principalBoundarySound{,NoUnify}{Expr,Field}_hookIrrelevant_of_success_via_typingRunBundleSuite`), so fixed-run hook-independence is directly consumable from hook premises on arbitrary-success and no-unify expression/field paths.
- **Phase 1 (active):** Added bundled-hook `_from_bundle` aliases for direct typing-suite principality/equivalence/irrelevance wrappers (`principalBoundarySound{,NoUnify}{Expr,Field}_{preconditioned,preconditionedCoreIff{,_anyHooks},hookIrrelevant}_of_success_via_typingRunBundleSuite_from_bundle`), closing bundle-entry naming parity across this direct suite-consumption layer.
- **Phase 1 (active):** Added packaged arbitrary-success full capstones on that direct typing-suite surface (`PrincipalBoundarySound{Expr,Field}Full` with constructors `principalBoundarySound{Expr,Field}Full_of_success_via_typingRunBundleSuite` and bundled aliases), so recursive soundness + full principal matrix (core/preconditioned/`↔`/irrelevance) is now consumable from one theorem witness per successful expression/field run.
- **Phase 1 (active):** Added packaged no-unify full capstones on that same direct typing-suite surface (`PrincipalBoundarySoundNoUnify{Expr,Field}Full` with constructors `principalBoundarySoundNoUnify{Expr,Field}Full_of_success_via_typingRunBundleSuite` and bundled aliases), so no-unify recursive soundness + full principal matrix is also consumable from one theorem witness per successful expression/field run.
- **Phase 1 (active):** Added a top-level full-suite package over direct typing-suite runs (`PrincipalBoundarySoundFullSuite` with direct/bundled constructors and one-hop expr/field/no-unify projections), so arbitrary-success and no-unify full surfaces are jointly consumable from one theorem API.
- **Phase 1 (active):** Added a boundary+sound-bundle route constructor for that full-suite package (`principalBoundarySoundFullSuite_of_success_via_rowPolyBoundarySoundBundle` plus bundled alias), so one `PrincipalRowPolyBoundarySoundBundle` witness now exports the full direct arbitrary-success/no-unify expr+field theorem surface.
- **Phase 1 (active):** Added canonical and dual-routed entrypoints for that row-poly full-suite path (`..._via_rowPolyBoundarySoundBundle_{proved,via_dualConsequenceSlices}` plus bundled aliases), so hook-seeded/bundled call sites can consume the full-suite route without manually constructing the intermediate boundary+sound bundle.
- **Phase 1 (active):** Added a combined full+vertical capstone package (`PrincipalBoundarySoundFullVerticalSuite` with row-poly-bundle constructor, bundled alias, and one-hop full/vertical/app/proj projections), so direct full principal surfaces and hook-free vertical guarantees are consumable together from one theorem witness.
- **Phase 1 (active):** Expanded that `FullVertical` surface with canonical+dual entrypoints, decomposition theorem (`principalBoundarySoundFullVerticalSuite_iff_full_and_vertical`), and direct expr/field/no-unify projections, completing one-hop API parity for full principal + vertical joint consumption.
- **Phase 1 (active):** Added direct typing-suite entrypoints for `FullVertical` (`principalBoundarySoundFullVerticalSuite_of_success_via_typingRunBundleSuite` with bundled/dual aliases), so callers can reach the same combined full-principal+vertical surface without explicitly routing through `rowPolyBoundarySoundBundle`.
- **Phase 1 (active):** Added `FullVertical` route-pair packaging (`PrincipalBoundarySoundFullVerticalRoutes`) with direct/bundled/dual constructors and one-hop route projections, so typing-suite and row-poly-bundle entry routes can be consumed from one named theorem surface.
- **Phase 1 (active):** Extended `FullVertical` route-pair projections to full/vertical/app/proj one-hop wrappers on each branch (`viaTypingSuite_*`, `viaRowPolyBundle_*`), using direct field-level projections to keep the API order-independent and build-stable.
- **Phase 1 (active):** Added branch-level consequence projections on `FullVertical` routes for expr/field/no-unify plus local `full ∧ vertical` decomposition (`..._as_full_and_vertical`), completing one-hop consumption of principal and vertical facets per route branch.
- **Phase 1 (active):** Added constructor naming parity on `FullVerticalRoutes` (`..._via_rowPolyBoundarySoundBundle`, `..._via_typingRunBundleSuite`, `..._via_dualConsequenceSlices`, with bundled aliases), so entrypoints now mirror the broader capstone route-naming conventions.
- **Phase 1 (active):** Added a master dual-route package for `FullVertical` (`PrincipalBoundarySoundFullVerticalMasterRoutes`) with bundled/split-hook constructors and one-hop regular/dual branch projections, so regular and dual consequence-route witnesses are consumable from one theorem surface.
- **Phase 1 (active):** Extended `FullVertical` master-route projections with direct regular/dual full+vertical/app/proj wrappers (`principalBoundarySoundFullVerticalMasterRoutes_{regular,dual}_{full,vertical,vertical_app,vertical_proj}`), completing one-hop master-level access to vertical consequences.
- **Phase 1 (active):** Added regular/dual expr/field/no-unify full projections on `FullVertical` master routes (`principalBoundarySoundFullVerticalMasterRoutes_{regular,dual}_{expr,field,noUnifyExpr,noUnifyField}`), completing one-hop master-level access to principal-full consequences.
- **Phase 1 (active):** Added paired regular+dual extraction wrappers on `FullVertical` master routes (`..._{full,vertical,expr,field,noUnifyExpr,noUnifyField}_pair`), so both route consequences are consumable together from a single master witness.
- **Phase 1 (active):** Added explicit master-route decomposition/equivalence (`principalBoundarySoundFullVerticalMasterRoutes_iff_regular_and_dual`) with pair constructor/projection helpers (`..._of_pair`, `..._as_pair`), making regular+dual route packaging structurally explicit.
- **Phase 1 (active):** Added regular/dual branch decomposition wrappers on `FullVertical` master routes (`..._{regular,dual}_as_full_and_vertical`) plus paired decomposition extraction (`..._full_and_vertical_pair`), completing one-hop branch-level `full ∧ vertical` access.
- **Phase 1 (active):** Added direct success-entry convenience wrappers via `FullVerticalMasterRoutes` (`..._via_fullVerticalMasterRoutes` + bundled aliases) for expr/field/no-unify full surfaces and vertical app/proj consequences, enabling one-step consumption from successful runs.
- **Phase 1 (active):** Added packaged master-route capstone surface (`PrincipalBoundarySoundFullVerticalMasterCapstone`) with constructors from explicit master routes and successful runs (hook-seeded + bundled), bundling expr/field/no-unify full consequences with hook-free vertical app/proj guarantees under one witness.
- **Phase 1 (active):** Added explicit component decomposition for `PrincipalBoundarySoundFullVerticalMasterCapstone` (`..._iff_components` with constructor/projection helpers `..._of_components`, `..._as_components`), making the packaged capstone structurally transparent for downstream chaining.
- **Phase 1 (active):** Added bidirectional bridge/equivalence between `PrincipalBoundarySoundFullVerticalMasterCapstone` and `PrincipalBoundarySoundFullVerticalSuite` (`..._of_masterCapstone`, `..._of_fullVerticalSuite`, `..._iff_fullVerticalSuite`), aligning the master-route packaging with the existing full-suite surface.
- **Phase 1 (active):** Added explicit row-poly bundle entry constructors for master routes/capstone (`..._of_success_via_rowPolyBoundarySoundBundle`), so `FullVerticalMasterRoutes` and `FullVerticalMasterCapstone` can be entered directly from an existing `PrincipalRowPolyBoundarySoundBundle` witness.
- **Phase 1 (active):** Added no-unify-specialized packaged master surface (`PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone`) with constructors from master-capstone and successful runs (hook-seeded + bundled), isolating no-unify expr/field full consequences with vertical app/proj guarantees.
- **Phase 1 (active):** Added explicit component decomposition for `PrincipalBoundarySoundNoUnifyFullVerticalMasterCapstone` (`..._iff_components` with `..._of_components`, `..._as_components`), making the no-unify packaged surface structurally transparent.
- **Phase 1 (active):** Added a no-unify full+vertical suite surface (`PrincipalBoundarySoundNoUnifyFullVerticalSuite`) and proved bidirectional bridge/equivalence with the no-unify master capstone (`..._of_masterCapstone`, `..._of_fullVerticalSuite`, `..._iff_fullVerticalSuite`).
- **Phase 1 (active):** Extended `PrincipalBoundarySoundNoUnifyFullVerticalSuite` with direct success constructors (`..._of_success`, `..._of_success_from_bundle`), one-hop expr/field/vertical/app/proj projections, and explicit decomposition equivalence (`..._iff_components`), completing direct no-unify full-vertical suite consumption from successful runs.
- **Phase 1 (active):** Added route-complete no-unify suite entry wrappers from the existing full-vertical paths (`..._of_fullVerticalSuite` plus `..._of_success_via_{rowPolyBoundarySoundBundle,typingRunBundleSuite}` with bundled/dual/proved variants), so no-unify full-vertical suite construction now stays aligned with canonical row-poly and typing-route entry surfaces.
- **Phase 1 (active):** Added a no-unify full-vertical route-pair package (`PrincipalBoundarySoundNoUnifyFullVerticalRoutes`) with success/bundled/dual constructors and one-hop branch projections/decompositions, so typing-route and row-poly-route no-unify witnesses are consumable from one theorem surface.
- **Phase 1 (active):** Added a no-unify full-vertical master-route package (`PrincipalBoundarySoundNoUnifyFullVerticalMasterRoutes`) with regular/dual route-pair constructors, explicit decomposition equivalence, and one-hop regular/dual consequence projections, so both consequence routes are consumable from one no-unify theorem surface.
- **Phase 1 (active):** Extended no-unify master routes with naming-parity constructor aliases (`..._via_rowPolyBoundarySoundBundle`, `..._via_typingRunBundleSuite`, `..._via_dualConsequenceSlices`, bundled variants) and added capstone bridge projections from regular/dual master-route branches (`principalBoundarySoundNoUnifyFullVerticalMasterCapstone_of_noUnifyMasterRoutes_{regular,dual}`), linking route-pair and capstone surfaces explicitly.
- **Phase 1 (active):** Extended no-unify master routes with parity convenience/projection APIs matching the full-route layer (`..._{regular,dual}_via{TypingSuite,RowPolyBundle}`, paired extractions `..._{expr,field,vertical,components}_pair`, and branch decompositions `..._{regular,dual}_as_components`), closing one-hop consumption gaps on the no-unify master-route surface.
- **Phase 1 (active):** Added a unified no-unify master surface package (`PrincipalBoundarySoundNoUnifyFullVerticalMasterSurface`) carrying both no-unify master routes and no-unify master capstone, with constructors from routes/capstone/success (bundled and split hooks), one-hop projections, and explicit decomposition equivalence.
- **Phase 1 (active):** Extended that unified no-unify master surface with direct bridges from the general full master-capstone/full-vertical suite paths (under no-unify premises), plus direct one-hop expr/field/vertical app-proj projections from the unified surface.
- **Phase 1 (active):** Added bidirectional bridge/equivalence between unified no-unify master surface and no-unify full-vertical suite (`principalBoundarySoundNoUnifyFullVerticalMasterSurface_iff_fullVerticalSuite`) with direct lift/project wrappers, linking the new packaged top layer back to the existing no-unify suite surface.
- **Phase 1 (active):** Added success-entry naming parity and surface-equivalence contracts for unified no-unify master surface (`..._of_success_via_noUnifyMaster{Routes,Capstone}` with bundled variants, `..._iff_master{Routes,Capstone}`), making the top no-unify package directly interchangeable with its underlying route/capstone layers.
- **Phase 1 (active):** Added direct successful-run consequence wrappers via unified no-unify master surface (`principalBoundarySoundNoUnify{Expr,Field}Full_of_success_via_noUnifyMasterSurface`, `principalBoundarySoundNoUnify_vertical{App,Proj}_of_success_via_noUnifyMasterSurface`, plus bundled aliases), enabling one-hop consumption of the top no-unify package.
- **Phase 1 (active):** Extended unified no-unify master surface with paired regular/dual route consequence wrappers and explicit consequence-level decomposition contracts (`..._routes_pair`, `..._{expr,field,vertical}_pair`, `..._iff_consequences`, `..._of_consequences`, `..._as_consequences`), so both route-level and direct consequence-level consumption are one-hop.
- **Phase 1 (active):** Added route-named success wrapper parity on unified no-unify master surface (`..._of_success_via_{rowPolyBoundarySoundBundle,typingRunBundleSuite,dualConsequenceSlices,fullVerticalMasterRoutes}` with bundled variants), so all canonical route names now map directly to the same top no-unify package entry surface.
- **Phase 1 (active):** Added explicit lifts from general full-vertical route/master-route surfaces into no-unify layers under no-unify premises (`principalBoundarySoundNoUnifyFullVerticalRoutes_of_fullVerticalRoutes`, `...MasterRoutes_of_fullVerticalMasterRoutes`, `...MasterSurface_of_fullVerticalMasterRoutes`), linking general and no-unify packaged tracks directly.
- **Phase 1 (active):** Added unified general full-master capstone surface (`PrincipalBoundarySoundFullVerticalMasterSurface`) with constructors from routes/capstone/success, route/capstone/consequence equivalence APIs, direct successful-run wrappers (`principalBoundarySound{,NoUnify}{Expr,Field}Full_of_success_via_fullVerticalMasterSurface`, `principalBoundarySound_vertical{App,Proj}_of_success_via_fullVerticalMasterSurface`), and a direct lift into the no-unify top layer (`principalBoundarySoundNoUnifyFullVerticalMasterSurface_of_fullVerticalMasterSurface`) under no-unify premises.
- **Phase 1 (active):** Added a combined top-layer pair package (`PrincipalBoundarySoundFullNoUnifyMasterSurfacePair`) with success/bundled constructors, surface-equivalence decomposition, and one-hop full/no-unify/vertical projections, so one successful run can export both general and no-unify master-surface consequences from the same theorem witness.
- **Phase 1 (active):** Extended the pair route with consequence-equivalence decomposition (`principalBoundarySoundFullNoUnifyMasterSurfacePair_iff_consequences` with constructor/projection helpers) and direct successful-run wrappers (`principalBoundarySound{,NoUnify}{Expr,Field}Full_of_success_via_fullNoUnifyMasterSurfacePair`, `principalBoundarySound_vertical{App,Proj}_of_success_via_fullNoUnifyMasterSurfacePair`, plus bundled variants), keeping the shared full/no-unify route one-hop at call sites.
- **Phase 2 (next):** Kea-specific effect typing and handler theorems.
- **Phase 2 (active):** Added `Kea/Properties/HandlerEffectRemoval.lean` with a first handler-elimination core model (`EffectRow.handleRemove`) and capstone theorem surfaces (`handle_removes_effect`, `handle_preserves_other_effects`, row-tail/WF preservation, idempotence).
- **Phase 2 (active):** Latest MCP re-probe confirms overlap normalization closure (`[Trace] ∪ [Trace] = [Trace]`, prior duplicate-label regression shapes now infer normalized rows), so runtime behavior aligns with spec idempotent union on current handler probes.
- **Phase 2 (active):** Formal handler-composition proofs proceed on spec-normalized idempotent union via `EffectRow.handleComposeNormalized` (remove handled effect, then idempotent union with handler-body effects), and current MCP probes now confirm implementation-side overlap dedup for the tracked cases.
- **Phase 2 (active):** Added nested same-target handler consequences on the normalized model (`nested_same_target_outer_removal_noop_of_inner_absent`, `nested_same_target_remains_absent_of_outer_absent`) and row-tail preservation for composed handlers.
- **Phase 2 (active):** Added `Kea/Properties/HandlerAbsentEffectNoop.lean` with closed-row-aware no-op contracts (`handleComposeClosedAware`, `handle_absent_effect_noop`) to model absent-effect handler no-op behavior explicitly.
- **Phase 2 (active):** Added `Kea/Properties/HandlerClosedAwareContracts.lean` to lift absent-effect no-op semantics into clause-level APIs (`resultEffectsCoreClosedAware`, `resultEffectsClosedAware`, normalized/closed-case bridge theorems), then extended it with branch-classification + bundle surfaces (`resultEffectsCoreClosedAware_branch_classification`, `ClosedAwareCoreBundle`, `closedAwareCoreBundle_of_classification`) and typing-facing consequences (`resultEffectsClosedAware_preserves_row_tail`, `wellTypedSlice_implies_handled_removed_closedAware`) for direct downstream composition.
- **Phase 2 (active):** `HandlerClosedAwareContracts` now provides a shared Phase-2 entry API (`handleComposeClosedAware_removes_target_of_handler_absent`, `handleComposeClosedAware_preserves_row_tail`, `ClosedAwareResultBundle`, `closedAwareResultBundle_of_wellTyped`, `wellTypedSlice_implies_handled_removed_legacy_via_closedAware`) so downstream capstones can consume one closed-aware contract surface.
- **Phase 2 (active):** Added `Kea/Properties/ResumeLinearity.lean` as a no-`sorry` scaffold for `resume_at_most_once` reasoning (`ResumeUse`, saturating composition, exclusivity-preserving lemmas, and named `resume_at_most_once` contract surface).
- **Phase 2 (active):** `ResumeLinearity` now includes exact composition characterization (`resume_combine_atMostOnce_iff`) and exclusivity corollaries (`resume_combine_atMostOnce_implies_one_side_zero`, `resume_combine_one_one_not_atMostOnce`) for branch-level linearity reasoning.
- **Phase 2 (active):** MCP re-probes confirm runtime `E0012` enforcement aligns with the resume summary model: zero-resume clauses typecheck; sequential and both-branch double-resume cases are rejected.
- **Phase 2 (active):** Added `Kea/Properties/HandlerTypingContracts.lean` to integrate effect-removal and resume-linearity tracks through a clause-level contract surface (`wellTypedSlice`) with bridge theorems for handled-effect removal, branch exclusivity, and loop legality.
- **Phase 2 (active):** Refined `HandlerTypingContracts` from abstract summaries to concrete contract premises (`thenEffects`, `clauseCoverageComplete`) with explicit result-effect assembly (`resultEffectsCore`/`applyThenEffects`/`resultEffects`), non-reintroduction guarantees, and resume-provenance extraction from linearity assumptions.
- **Phase 2 (active):** Added `Kea/Properties/EffectOperationTyping.lean` to model effect declarations and operation-call typing (`EffectDecl`, `operationCallTyping`, `performOperationEffects`) with capstones `operationCallTyping_adds_declared_effect` and `capability_direct_call_sound`.
- **Phase 2 (active):** MCP re-probes for cross-handled capability calls now align with `EffectOperationTyping`: handling `Trace` from `-[Log, Trace]>` leaves `-[Log]`, and handling `Log` leaves `-[Trace]` (diagnostics clean).
- **Phase 2 (active):** `EffectOperationTyping` now includes WF transport (`performOperationEffects_preserves_wellFormed`), linking operation-call row updates to the Phase-1/2 well-formedness track.
- **Phase 2 (active):** MCP operation-call probes align with the declaration/update model: `call_log` infers `() -[Log]> ()`, and explicit too-weak annotations (e.g. `-[Trace]` body `Log.log`) are rejected with `E0001`.
- **Phase 2 (active):** `EffectOperationTyping` now includes named operation-call bundles (`OperationCallBundle`, `operationCallBundle_of_typing`) so declaration witness, effect-addition, and row-tail stability are available from one theorem surface.
- **Phase 2 (active):** Added `Kea/Properties/TailResumptiveClassification.lean` to classify clause resume shapes (`TailResumptiveClass`, `classifyClause`) with capstones `tail_resumptive_classification` and `tail_resumptive_direct_call_sound`.
- **Phase 2 (active):** `TailResumptiveClassification` now includes named bundle packaging (`TailResumptiveBundle`, `tail_resumptive_bundle_of_wellTyped`) with a one-hop non-invalid projection (`tail_resumptive_bundle_notInvalid`).
- **Phase 2 (active):** `TailResumptiveClassification` now includes closed-aware direct-call equivalence (`directCallEquivalentClosedAware`, `tail_resumptive_direct_call_sound_closedAware`) to align tail-resumptive fast-path contracts with the shared closed-aware handler surface.
- **Phase 2 (active):** `TailResumptiveClassification` now packages closed-aware fast-path reasoning in a named bundle (`TailResumptiveClosedAwareBundle`, `tail_resumptive_closedAware_bundle_of_wellTyped`) with one-hop eligible projection.
- **Phase 2 (active):** MCP probe alignment now covers the tail-resumptive slice: `run_no_then` and identity-`then` `run_then` both infer `() -> ()` with clean diagnostics, matching the direct-call contract surface.
- **Phase 2 (active):** Added `Kea/Properties/TailCapabilityComposition.lean` to compose operation-call capability preservation with tail-resumptive equivalence (`tail_resumptive_eligible_capability_direct_call_sound`, well-typed wrapper included).
- **Phase 2 (active):** `TailCapabilityComposition` now includes a general well-typed lift (`resultEffects_preserves_core_label_true`, `wellTyped_capability_direct_call_sound`) so capability preservation composes through full clause result effects (including `then`-union), with the tail-resumptive theorem retained as a corollary surface.
- **Phase 2 (active):** `TailCapabilityComposition` now also has named bundle packaging (`TailCapabilityBundle`, `tailCapabilityBundle_of_wellTyped`) with one-hop projections for full-result capability preservation under well-typed boundaries.
- **Phase 2 (active):** `TailCapabilityComposition` now also exposes closed-aware capability surfaces (`wellTyped_capability_direct_call_sound_closedAware`, `TailCapabilityClosedAwareBundle`, `tailCapabilityClosedAwareBundle_of_wellTyped`) so capability-preservation reasoning aligns with the shared closed-aware entry API.
- **Phase 2 (active):** `TailCapabilityComposition` now includes closed-aware tail-resumptive fast-path corollaries (`tail_resumptive_eligible_capability_direct_call_sound_closedAware`, `tail_resumptive_wellTyped_capability_direct_call_sound_closedAware`) and routes closed-aware `notInvalid` through `TailResumptiveClosedAwareBundle`.
- **Phase 2 (active):** Added `Kea/Properties/NestedHandlerCompositionContracts.lean` with explicit nested same-target theorem surfaces (`nested_handlers_compose`, row-tail/other-label preservation, and `NestedHandlerBundle` packaging).
- **Phase 2 (active):** Extended `NestedHandlerCompositionContracts` with closed-aware nested capstones (`nestedComposeClosedAware`, `nested_handlers_compose_closedAware`, `nested_handlers_compose_closedAware_row_tail`, `NestedHandlerClosedAwareBundle`) aligned to the shared closed-aware entry API.
- **Phase 2 (active):** MCP probe for a valid nested same-target shape (`nested_same` with inner handle bound then handled again) infers `() -> ()` with clean diagnostics, aligning with the nested composition contract boundary.
- **Phase 2 (active):** After phantom-IO fix (commits `746a4cb`, `9812380`) and MCP restart, handled-absent closed-row probes now align with no-op semantics: mismatched handlers preserve body effects (`probe_log : () -[Log]> ()`, `probe_trace : () -[Trace]> ()`) with clean diagnostics.
- **Phase 2 (active):** Added `Kea/Properties/FailResultContracts.lean`, specializing handler contracts to Fail-as-zero-resume and Result-lowering (`resultLowering`, `FailResultContract`, `failResultContract_sound`, `failResultContract_loopLegal`) to start the Fail/Result equivalence track.
- **Phase 2 (active):** `FailResultContracts` now also exports a closed-aware clause-output capstone (`failResultContract_sound_closedAware`) alongside the legacy `resultEffects` contract.
- **Phase 2 (active):** Extended `FailResultContracts` with explicit lowering/equivalence slices (`lowerFailEffects`, `lowerFailFunctionType`, `failResultFunctionEquivalent`) plus preservation/removal lemmas to bridge from contract-level Fail handling into function-type `Result` lowering.
- **Phase 2 (active):** Added `Kea/Properties/FailResultEquivalence.lean` with explicit `fail_result_equivalence` theorem/bundle surfaces (including catch-premise adapters), so the Fail/Result equivalence target now has a named capstone API.
- **Phase 2 (active):** Added `Kea/Properties/EffectPolymorphismSoundness.lean` with reusable soundness contracts for Fail lowering over polymorphic effect rows (`rowTailStable`, `labelsPreservedExcept`, `effectPolyFailLowering_sound`, no-op-if-absent), proving Fail removal while preserving non-Fail labels and row tails.
- **Phase 2 (active):** `EffectPolymorphismSoundness` now includes concrete handler-schema bridges (`EffectPolyHandlerSchema`, `effectPolyHandlerSchema_sound`, `effectPolyHandlerSchema_noop_if_fail_absent`) linking `wellTypedSlice` + Fail-zero-resume premises to polymorphic function-type lowering guarantees.
- **Phase 2 (active):** Divergence on Fail-absent `catch` is now closed (runtime now rejects with `E0012`: `expression cannot fail; catch is unnecessary`), so no-op-if-absent theorem claims are aligned as vacuous runtime cases rather than pending implementation fix.
- **Phase 2 (active):** Added explicit catch-admissibility contracts (`catchAdmissible`, `catchUnnecessary`) and precondition-gated effect-polymorphism wrappers (`effectPolyFailLowering_sound_of_catchAdmissible`, `catchUnnecessary_implies_no_admissible_*`), making the `E0012` fail-absent runtime behavior first-class in the formal theorem surface.
- **Phase 2 (active):** Added runtime-aligned admissible contract/schema wrappers (`AdmissibleEffectPolyFailLoweringContract`, `AdmissibleEffectPolyHandlerSchema`) and capstone entrypoints (`admissibleEffectPolyFailLowering_sound`, `admissibleEffectPolyHandlerSchema_sound`) so downstream proofs can consume only `catch`-admissible (`Fail`-present) cases.
- **Phase 2 (active):** Added premise-to-capstone adapters in `EffectPolymorphismSoundness` (`mkAdmissibleEffectPoly*`, `*_sound_of_premises`) to eliminate manual structure assembly and expose direct theorem entrypoints from handler typing assumptions.
- **Phase 2 (active):** Added one-hop admissible projection helpers for both contract and schema surfaces (`*_rowTailStable`, `*_preserves_nonFail`, `*_failRemoved*`) so downstream chaining can consume each guarantee independently from a single admissible assumption.
- **Phase 2 (active):** Added named admissible bundle contracts (`AdmissibleEffectPolyLoweringBundle`, `AdmissibleEffectPolyHandlerBundle`) with constructor/projection helpers, giving stable one-name theorem outputs for full capstone consequences.
- **Phase 2 (active):** `EffectPolymorphismSoundness` now includes structural decomposition APIs for those type-valued admissible bundles (`admissibleEffectPoly{Lowering,Handler}Bundle_{as_components,of_components,iff_components}`), with `Nonempty`-framed `iff_components` contracts to keep decomposition in `Prop` while preserving one-hop component reconstruction/projection.
- **Phase 2 (active):** `EffectPolymorphismSoundness` now also includes raw-premise bundle entry/decomposition wrappers (`admissibleEffectPolyFailLowering_bundle_of_premises`, `admissibleEffectPolyFailLowering_bundle_as_components_of_premises`, `admissibleEffectPolyHandler_bundle_of_premises`, `admissibleEffectPolyHandler_bundle_as_components_of_premises`) so premise-level call sites can obtain named bundles and full component witnesses directly.
- **Phase 2 (active):** `EffectPolymorphismSoundness` now also includes direct fail-present route wrappers at the same bundle/soundness layers (`admissibleEffectPoly{FailLowering,HandlerSchema}_sound_of_fail_present`, `admissibleEffectPoly{FailLowering,Handler}_bundle_of_fail_present`, `admissibleEffectPoly{FailLowering,Handler}_bundle_as_components_of_fail_present`), so runtime-admissible (`Fail`-present) entrypoints can reach full bundle/component witnesses without manually deriving admissibility.
- **Phase 2 (active):** Added admissibility partition theorems (`catchAdmissible_xor_unnecessary`) and admissible-branch extractors on contract/schema wrappers, making the runtime “admissible vs E0012-unnecessary” split explicit in theorem assumptions.
- **Phase 2 (active):** Added `Kea/Properties/CatchTypingBridge.lean`, a judgment-shaped bridge (`CatchTypingJudgment`) from typing-style catch premises into admissible effect-polymorphism capstones (`catchTypingJudgment_sound`, row-tail/non-Fail projections, admissibility branch).
- **Phase 2 (active):** `CatchTypingBridge` now includes judgment-level named bundles/projections (`CatchTypingBundle`, `catchTypingJudgment_bundle_*`) for one-name consumption of clause-removal and lowered-effect guarantees.
- **Phase 2 (active):** `CatchTypingBridge` now also includes structural decomposition APIs for its type-valued judgment bundle (`catchTypingJudgment_bundle_{as_components,of_components,iff_components}`), with `Nonempty`-framed decomposition to keep the contract in `Prop` while preserving one-hop bundle reconstruction/projection.
- **Phase 2 (active):** `CatchTypingBridge` now also exposes a raw-premise full decomposition entrypoint (`catchTypingJudgment_bundle_as_components_of_premises`), so clause-level assumptions can produce the complete bundle component witness in one theorem step.
- **Phase 2 (active):** `CatchTypingBridge` now also exposes fail-present bundle entry/decomposition wrappers (`catchTypingJudgment_bundle_of_fail_present`, `catchTypingJudgment_bundle_as_components_of_fail_present`), so runtime-admissible (`Fail`-present) routes can enter the full judgment bundle surface directly.
- **Phase 2 (active):** `CatchTypingBridge` now also includes fail-present classifier/projection wrappers (`catchTypingJudgment_classify_of_fail_present`, `catchTypingJudgment_bundle_{clauseFailRemoved,rowTailStable,preserves_nonFail,failRemoved}_of_fail_present`), completing direct fail-present access across classify and bundle-facet APIs.
- **Phase 2 (active):** `CatchTypingBridge` now also includes the remaining premise-level bundle-facet wrappers (`catchTypingJudgment_bundle_{preserves_nonFail,failRemoved}_of_premises`), making all four bundle facets directly available on both premise and fail-present routes.
- **Phase 2 (active):** `CatchTypingBridge` now also includes fail-present wrappers for non-bundle theorem surfaces (`catchTypingJudgment_sound_of_fail_present`, `catchTypingJudgment_rowTailStable_of_fail_present`, `catchTypingJudgment_preserves_nonFail_of_fail_present`), completing fail-present parity across both bundled and non-bundled catch APIs.
- **Phase 2 (active):** Added direct premise adapters in `CatchTypingBridge` (`mkCatchTypingJudgment`, `catchTypingJudgment_sound_of_premises`, noncomputable `catchTypingJudgment_bundle_of_premises`) for judgment-free entry into the bridge surface.
- **Phase 2 (active):** `CatchTypingBridge` now includes one-hop `of_premises` projections for row-tail/non-Fail preservation and bundle facets, so raw-premise call sites can consume specific guarantees without intermediate destructuring.
- **Phase 2 (active):** `CatchTypingBridge` now includes combined/classified premise surfaces (`CatchTypingCapstoneOutcome`, `catchTypingJudgment_capstone_of_premises`, `catchTypingJudgment_classify_of_premises`) plus Fail-presence/absence entry wrappers, aligning generic catch APIs with the higher-order runtime-admissibility pattern.
- **Phase 2 (active):** Higher-order typed-Fail catch regression is now closed on latest MCP probes: `catch` over `fn() -[Log, Fail String]> Int` is accepted with residual `Log`, while fail-absent paths still correctly reject with `E0012`.
- **Phase 2 (active):** Added `Kea/Properties/HigherOrderCatchContracts.lean` to specialize higher-order catch theorem surfaces (`higherOrderCatchType`, `HigherOrderCatchTypingJudgment`, soundness/admissibility theorems) and align formal APIs with the now-fixed higher-order MCP behavior.
- **Phase 2 (active):** Fail/catch bridge layers now consume the shared closed-aware entry API for clause-level handled-effect removal (`FailResultContracts.failResultContract_sound`, `EffectPolymorphismSoundness.effectPolyHandlerSchema_sound` now route through `wellTypedSlice_implies_handled_removed_legacy_via_closedAware`).
- **Phase 2 (active):** Catch layers now expose direct closed-aware clause-removal adapters (`CatchTypingBridge.catchTypingJudgment_clauseFailRemoved_via_closedAware`, `HigherOrderCatchContracts.higherOrderCatchTypingJudgment_clauseFailRemoved_via_closedAware`) so higher-order and first-order catch capstones consume the same entry contract explicitly.
- **Phase 2 (active):** Catch layers now additionally expose closed-aware clause row-tail adapters (`catchTypingJudgment_clauseRowTailStable_closedAware`, `higherOrderCatchTypingJudgment_clauseRowTailStable_closedAware`) to align clause-output shape reasoning across first-order and higher-order catch paths.
- **Phase 2 (active):** `HigherOrderCatchContracts` now includes direct raw-premise adapters (`higherOrderCatchTypingJudgment_sound_of_premises`, `higherOrderCatchTypingJudgment_admissibility_branch_of_premises`) for judgment-free entry into higher-order theorem surfaces.
- **Phase 2 (active):** `HigherOrderCatchContracts` now also includes named bundle contracts/projections (`HigherOrderCatchBundle`, `higherOrderCatchTypingJudgment_bundle*`) for stable one-name consumption of higher-order capstone consequences.
- **Phase 2 (active):** `HigherOrderCatchContracts` now also includes structural decomposition APIs for its type-valued bundle (`higherOrderCatchBundle_{as_components,of_components,iff_components}`), again using a `Nonempty`-framed decomposition contract so higher-order bundle components are reconstructible/projectable in one hop.
- **Phase 2 (active):** `HigherOrderCatchContracts` now includes a matching raw-premise full decomposition entrypoint (`higherOrderCatchTypingJudgment_bundle_as_components_of_premises`), so higher-order premise call sites can extract full clause/lowered-effect component witnesses directly.
- **Phase 2 (active):** `HigherOrderCatchContracts` now also includes fail-present bundle entry/decomposition wrappers (`higherOrderCatchTypingJudgment_bundle_of_fail_present`, `higherOrderCatchTypingJudgment_bundle_as_components_of_fail_present`), so higher-order runtime-admissible routes map directly to full bundle/component witnesses.
- **Phase 2 (active):** `HigherOrderCatchContracts` now also includes fail-present classifier/projection wrappers (`higherOrderCatchTypingJudgment_classify_of_fail_present`, `higherOrderCatchTypingJudgment_bundle_{clauseFailRemoved,rowTailStable,preserves_nonFail,failRemoved}_of_fail_present`), closing fail-present access parity between capstone, classify, and bundle-facet surfaces.
- **Phase 2 (active):** `HigherOrderCatchContracts` now also includes fail-present wrappers on bridge-routed theorem paths (`higherOrderCatchTypingJudgment_{capstone,classify}_of_fail_present_via_{catchTypingBridge,bridgeLaws}`), extending runtime-admissible parity to both generic-bridge route families.
- **Phase 2 (active):** `HigherOrderCatchContracts` now also includes fail-present wrappers for non-bundle core theorem surfaces (`higherOrderCatchTypingJudgment_sound_of_fail_present`, `higherOrderCatchTypingJudgment_admissibility_branch_of_fail_present`), completing direct fail-present parity across core soundness/admissibility outcomes.
- **Phase 2 (active):** `HigherOrderCatchContracts` now includes one-hop bundle `of_premises` projections (`higherOrderCatchTypingJudgment_bundle_*_of_premises`) so raw-premise higher-order call sites can extract clause-removal/row-tail/non-Fail guarantees directly.
- **Phase 2 (active):** `HigherOrderCatchContracts` now includes a combined raw-premise capstone (`higherOrderCatchTypingJudgment_capstone_of_premises`) that packages clause Fail-removal, lowered-row guarantees, and admissibility-vs-unnecessary branch facts in one theorem surface.
- **Phase 2 (active):** Added higher-order practical entry wrappers (`higherOrderCatchTypingJudgment_capstone_of_fail_present`, `higherOrderCatchUnnecessary_of_fail_absent`) so call sites can start from direct Fail-label presence/absence evidence.
- **Phase 2 (active):** Added a higher-order single-entry classifier (`higherOrderCatchTypingJudgment_classify_of_premises`) over `HigherOrderCatchCapstoneOutcome`, returning either full capstone consequences or the runtime-aligned `catchUnnecessary` branch without requiring an explicit admissibility premise.
- **Phase 2 (active):** Added explicit higher-order<->generic catch capstone bridges (`higherOrderCatchCapstoneOutcome_{of,to}_catchTypingCapstoneOutcome`, `..._iff_...`) and route wrappers (`higherOrderCatchTypingJudgment_{capstone,classify}_of_premises_via_catchTypingBridge`) so specialization and generic bridge layers are now theorem-linked rather than parallel.
- **Phase 2 (active):** Added classifier-level transport/equivalence between higher-order and generic catch layers (`higherOrderCatchClassification_of_catchTypingClassification`, `catchTypingClassification_of_higherOrderCatchClassification`, `higherOrderCatchClassification_iff_catchTypingClassification`) under clause-effect identification, completing bidirectional bridge coverage for both capstones and classified outcomes.
- **Phase 2 (active):** Added packaged higher-order catch bridge laws (`HigherOrderCatchBridgeLaws`, `higherOrderCatchBridgeLaws_of_clauseEffects`) with one-hop capstone/classifier transport helpers (`higherOrderCatchBridgeLaws_*`), so downstream proofs can depend on one named interoperability contract rather than stitching multiple bridge lemmas.
- **Phase 2 (active):** Added premise-level route wrappers through that packaged bridge-law surface (`higherOrderCatchTypingJudgment_{capstone,classify}_of_premises_via_bridgeLaws`), so higher-order premise consumers can stay on one interoperability API while reusing generic catch capstone/classifier proofs.
- **Phase 2 (active):** Added `Kea/Properties/CatchInteroperabilitySuite.lean` and imported it in `Kea.lean`; it packages generic+higher-order catch interoperability at classifier/capstone levels (`CatchClassifierInteropSuite`, `CatchCapstoneInteropSuite`, premise constructors, capstone->classifier lift, and one-hop projections), giving a single entry surface for cross-layer catch reasoning.
- **Phase 2 (active):** Extended `CatchInteroperabilitySuite` with practical constructors/projections (`..._of_fail_present`, `..._of_genericClassification`, `..._of_higherClassification`, `catchCapstoneInteropSuite_{generic,higher}`), so runtime-style Fail-presence and either-side classifier outcomes can be lifted directly into the shared interop suite.
- **Phase 2 (active):** Extended `CatchInteroperabilitySuite` with structural decomposition/projection APIs (`catch{Classifier,Capstone}InteropSuite_iff_components`, `..._of_components`, `..._as_components`, `..._laws`) so downstream consumers can switch between bundled and explicit component forms without manual record destructuring.
- **Phase 2 (active):** `CatchInteroperabilitySuite` now also includes raw-premise/fail-present decomposition wrappers (`catchClassifierInteropSuite_as_components_of_premises`, `catchCapstoneInteropSuite_as_components_of_premises`, `catchCapstoneInteropSuite_as_components_of_fail_present`, `catchClassifierInteropSuite_as_components_of_fail_present`), giving direct one-step access to explicit component witnesses from standard entry routes.
- **Phase 2 (active):** `CatchInteroperabilitySuite` now also includes decomposition wrappers for its classifier-constructor routes (`catchClassifierInteropSuite_as_components_of_{genericClassification,higherClassification,capstoneInteropSuite}`), so all major classifier entry constructors map directly to explicit component tuples in one hop.
- **Phase 2 (active):** `CatchInteroperabilitySuite` now also exposes direct constructor-route projections for premise/fail-present paths (`catch{Capstone,Classifier}InteropSuite_{generic,higher,laws}_of_{premises,fail_present}`), so interop consumers can target specific classifier/capstone facets in one theorem step without intermediate suite values.
- **Phase 2 (active):** `CatchInteroperabilitySuite` now also exposes direct classifier-constructor projections (`catchClassifierInteropSuite_{generic,higher,laws}_of_{genericClassification,higherClassification,capstoneInteropSuite}`), giving one-step facet access across all classifier constructor families.
- **Phase 2 (active):** Added `Kea/Properties/EffectHandlerContractSuite.lean` and imported it in `Kea.lean`; it packages closed-aware handler guarantees, closed-aware capability preservation, and catch classifier interoperability into one aggregate surface (`EffectHandlerSuite`) with premise constructors (`..._of_premises`, `..._of_fail_present`) and one-hop projections for handled-removal/capability/generic-classifier/higher-classifier outcomes.
- **Phase 2 (active):** Extended `EffectHandlerContractSuite` with structural decomposition/constructor helpers (`effectHandlerSuite_iff_components`, `..._of_components`, `..._as_components`) and additional one-hop projections (`effectHandlerSuite_closedAwareRowTailStable`, `effectHandlerSuite_legacyHandledRemoved`, `effectHandlerSuite_tailNotInvalid`) for direct consumption of row-tail/legacy/tail-classification guarantees from the aggregate suite.
- **Phase 2 (active):** Extended `EffectHandlerContractSuite` with a strict capstone-grade aggregate (`EffectHandlerCapstoneSuite`) plus component decomposition, premise/fail-present constructors, capstone->classifier downgrade (`effectHandlerSuite_of_capstoneSuite`), and capstone one-hop projections (`effectHandlerCapstoneSuite_{genericCatchCapstone,higherCatchCapstone,catchLaws}`), so downstream users can choose classifier-level or capstone-level catch interoperability from one cross-module API family.
- **Phase 2 (active):** Added a coherent dual-grade package in `EffectHandlerContractSuite` (`EffectHandlerCatchPairSuite`) that bundles capstone+classifier aggregates with an explicit coherence equation, plus capstone/premise/fail-present constructors and one-hop projections across generic/higher classifier and capstone outcomes (`effectHandlerCatchPairSuite_*`), so one witness exports both permissive and strict catch consequences together.
- **Phase 2 (active):** Added a master nested-composition aggregate in `EffectHandlerContractSuite` (`EffectHandlerCompositionSuite`) that combines the coherent catch pair with nested closed-aware same-target composition (`NestedHandlerClosedAwareBundle`) for an outer handler row, including component decomposition, premise/fail-present constructors, and one-hop projections for nested handled-removal/row-tail plus classifier/capstone catch outcomes (`effectHandlerCompositionSuite_*`).
- **Phase 2 (active):** Extended `EffectHandlerCompositionSuite` with direct clause-level projection wrappers (`effectHandlerCompositionSuite_{closedAwareHandledRemoved,closedAwareCapability,closedAwareRowTailStable,legacyHandledRemoved,tailNotInvalid,classifierFromCapstone}`), so master-suite consumers can access clause guarantees and catch-pair coherence without nested record unpacking.
- **Phase 2 (active):** Added direct capstone decomposition parity for the master composition layer (`effectHandlerCompositionSuite_iff_capstone_and_nested`, `..._of_capstone_and_nested`, `..._as_capstone_and_nested`), so callers with capstone evidence can construct/consume composition suites without threading the intermediate catch-pair bundle explicitly.
- **Phase 2 (active):** Added nested-vs-clause coherence lemmas on `EffectHandlerCompositionSuite` (`effectHandlerCompositionSuite_nestedRowTail_eq_closedAwareRowTail` and handled-removal coherence wrappers), explicitly tying nested same-target closed-aware outputs to clause closed-aware outputs on shared row-tail/handled-absence invariants.
- **Phase 2 (active):** Added named nested/clause coherence packaging on top of `EffectHandlerCompositionSuite` (`EffectHandlerNestedClauseCoherenceBundle`, `effectHandlerCompositionSuite_nestedClauseCoherenceBundle`, and one-hop bundle projections), so downstream users can consume handled-absence + row-tail coherence from one theorem surface.
- **Phase 2 (active):** Added a master composition+coherence package (`EffectHandlerCompositionCoherenceSuite`) with canonical constructors (`..._of_composition`, `..._of_premises`, `..._of_fail_present`), equivalence (`..._iff_composition`), and one-hop projections, so callers can consume full composition consequences and derived nested/clause coherence from one named theorem surface.
- **Phase 2 (active):** `EffectHandlerCompositionCoherenceSuite` now also exposes direct one-hop catch/capability/tail projections (`..._{genericCatchClassifier,higherCatchClassifier,genericCatchCapstone,higherCatchCapstone,closedAwareCapability,tailNotInvalid}`), so coherence-package consumers do not need to drop back to raw composition witnesses.
- **Phase 2 (active):** `NestedHandlerCompositionContracts` now includes an explicit closed-aware-to-normalized bridge theorem (`nestedComposeClosedAware_eq_nestedCompose_of_present_or_open`) for the dual present/open branch case, making normalization-agreement assumptions on nested handler composition citable directly.
- **Phase 2 (active):** `EffectHandlerContractSuite` now surfaces that nested bridge directly on master composition APIs (`effectHandlerCompositionSuite_nestedClosedAware_eq_nestedCompose_of_present_or_open` and `effectHandlerCompositionCoherenceSuite_nestedClosedAware_eq_nestedCompose_of_present_or_open`), so downstream consumers can stay on suite-level theorem surfaces.
- **Phase 2 (active):** Added open-row corollaries for nested closed-aware/normalized agreement (`nestedComposeClosedAware_eq_nestedCompose_of_open_row`, plus suite-level wrappers `effectHandlerComposition{,Coherence}Suite_nestedClosedAware_eq_nestedCompose_of_open_expr_row`), so common open-row cases avoid manual dual-stage branch premises.
- **Phase 2 (active):** `EffectHandlerCompositionCoherenceSuite` now has explicit component decomposition APIs (`..._iff_components`, `..._of_components`, `..._as_components`) in addition to `..._iff_composition`, keeping the package structurally transparent for downstream proof routing.
- **Phase 2 (active):** Added direct premise-level open-row bridge entrypoints on the coherence package (`effectHandlerCompositionCoherenceSuite_nestedClosedAware_eq_nestedCompose_of_open_expr_row_of_{premises,fail_present}`), so nested closed-aware/normalized agreement can be discharged from raw phase-2 premises in one step.
- **Phase 2 (active):** Added matching composition-suite open-base-row entrypoints (`effectHandlerCompositionSuite_nestedClosedAware_eq_nestedCompose_of_open_base_row_of_{premises,fail_present}`), so both composition and coherence package layers now expose one-step base-row-open bridge routes.
- **Phase 2 (active):** Added named open-row bridge packaging (`EffectHandlerNestedOpenRowBridgeBundle`) with constructors from composition/coherence/premise routes and one-hop projection, so nested closed-aware/normalized open-row agreement can be consumed from one stable theorem surface.
- **Phase 2 (active):** `EffectHandlerNestedOpenRowBridgeBundle` now also has direct `open_expr_row` premise constructors (`..._of_open_expr_row_{premises,fail_present}`), completing entrypoint parity between `open_base_row` and `open_expr_row` routes.
- **Phase 2 (active):** Added open-row consequence wrappers showing normalized nested composition also preserves handled-label absence (`effectHandlerComposition{,Coherence}Suite_nestedComposeHandledRemoved_of_open_expr_row`), lifting bridge equality into a direct safety consequence.
- **Phase 2 (active):** Added strengthened open-row consequence packaging (`EffectHandlerNestedOpenRowConsequenceBundle`) carrying both bridge equality and normalized handled-removal, with constructors from composition/coherence/premise routes and one-hop projections.
- **Phase 2 (active):** `EffectHandlerNestedOpenRowConsequenceBundle` now includes direct `open_expr_row` premise constructors (`..._of_open_expr_row_{premises,fail_present}`), completing constructor parity across open-row entry routes for the strengthened consequence surface.
- **Phase 2 (active):** Added bridge/consequence interoperability wrappers (`effectHandlerNestedOpenRowConsequenceBundle_of_bridge_and_normalizedHandledRemoved`, `effectHandlerNestedOpenRowBridgeBundle_of_consequenceBundle`) so open-row APIs can move between equality-only and strengthened consequence bundles without manual reconstruction.
- **Phase 2 (active):** `Kea/Typing.lean` now has explicit component aliases and structural decomposition APIs (`...Components`, `..._iff_components`, `..._of_components`, `..._as_components`, `..._as_components_of_components`) for boundary-sound run-route and typing-route bundles: `PrincipalBoundarySound{Expr,Field,NoUnifyExpr,NoUnifyField}RunBundleRoutes` and `PrincipalBoundarySound{Expr,Field,NoUnifyExpr,NoUnifyField}TypingRunBundleRoutes`.
- **Phase 2 (active):** `Kea/Typing.lean` now has matching component/decomposition parity for dual-master no-unify cross-route consequence+capstone packages: `PrincipalNoUnify{Expr,Field}RunBundleConsequencesBothMasterConsequenceRoutes` and `PrincipalNoUnify{Expr,Field}AllHooksCapstonesBothMasterConsequenceRoutes`.
- **Phase 2 (active):** Completed the remaining dual-master no-unify route-layer parity in `Kea/Typing.lean` with `...Components` and `..._{iff_components,of_components,as_components,as_components_of_components}` for `PrincipalNoUnify{Expr,Field}AllHooksRunBundlesBothMasterConsequenceRoutes`, `PrincipalNoUnify{Expr,Field}HookIrrelevanceBothMasterConsequenceRoutes`, and `PrincipalNoUnify{Expr,Field}AllHooksRouteSurfaceBothMasterConsequenceRoutes`; a `structure ...Routes` scan now reports zero missing route aliases.
- **Phase 2 (active):** Added the same alias/decomposition families for the base no-unify all-hooks surfaces in `Kea/Typing.lean` (`PrincipalNoUnify{Expr,Field}AllHooksRouteSurface`), so both base surfaces and dual-master wrappers now share uniform `...Components`/`..._{iff_components,of_components,as_components,as_components_of_components}` contracts.
- **Phase 2 (active):** Added full component/decomposition contracts for `PrincipalNoUnify{Expr,Field}RunBundleConsequences` in `Kea/Typing.lean` (`...Components` plus `..._{iff_components,of_components,as_components,as_components_of_components}`), aligning consequence bundles with the already-aliased no-unify all-hooks surfaces and cross-route wrappers.
- **Phase 2 (active):** Added the same full decomposition layer for boundary+sound counterparts `Principal{Expr,Field}RunBundleConsequences` in `Kea/Typing.lean` (`...Components` plus `..._{iff_components,of_components,as_components,as_components_of_components}`), so run-bundle consequence APIs are now uniform across no-unify and general boundary+sound paths.
- **Phase 2 (active):** Added matching alias/decomposition contracts for direct boundary+sound full bundles in `Kea/Typing.lean`: `PrincipalBoundarySound{Expr,Field,NoUnifyExpr,NoUnifyField}Full` now each expose `...Components` and `..._{iff_components,of_components,as_components,as_components_of_components}`.
- **Phase 2 (active):** Added alias/decomposition contracts for dual-bundle principal consequence packages `Principal{,Field}TypingDualConsequence` in `Kea/Typing.lean` (`...Components` and `..._{iff_components,of_components,as_components,as_components_of_components}`), aligning these bridge-level bundles with the same component-route API style.

The formal workspace lives at [`formal/`](formal/).

## Scope

### Phase 1: Core HM + Row Migration

Migrate and align these Lean modules with `kea-types` and `kea-infer`:

- `Kea/Ty.lean`
- `Kea/Substitution.lean`
- `Kea/FreeVars.lean`
- `Kea/OccursCheck.lean`
- `Kea/LacksConstraints.lean`
- `Kea/Unify.lean`
- `Kea/Generalize.lean`
- `Kea/Traits.lean`
- `Kea/Typing.lean`

### Phase 2: Kea Effect/Handler Formalization

Add Kea-native theorems for:

- Handler effect removal
- Resume linearity (at-most-once)
- Fail as zero-resume
- Fail/Result equivalence
- Effect polymorphism soundness

## Workflow Contract

Use MCP-first verification, mirroring the Rill protocol:

1. Predict (Lean conjecture + explicit preconditions)
2. Probe (`kea-mcp`: `type_check`, `diagnose`, `get_type`)
3. Classify (agreement / precondition gap / divergence)
4. Act (prove, revise, or log divergence)
5. Traceability (theorem + MCP evidence link)

All session evidence goes to [`formal/mcp-log.md`](formal/mcp-log.md).

## Build

```bash
cd formal && lake build
```

Lean runs independently of Rust checks.
