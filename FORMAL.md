# Kea Type System Formalization

Lean 4 formalization of Kea's type-and-effect system.

This work starts by cannibalizing the existing Rill formal corpus and then extending it for Kea's effect-row and handler semantics.

## Current Status

- **Phase 1 (active):** Core migration from Rill `formal/` into `kea/formal/`, with effect-row surface aligned to Kea (`Ty.functionEff` + `EffectRow`) and current Lean build green.
- **Phase 1 (active):** Core migration now includes explicit WF judgments and substitution-preservation lemmas for the effect-row-extended core surface.
- **Phase 1 (active):** Unification-side WF contracts are now staged (`Kea/WellFormed`, `Kea/Properties/WfSubstitution`, `Kea/Properties/WfRename`, `Kea/Properties/WfGeneralize`, `Kea/Properties/WfUnify`), including branch-shaped row-update lemmas for `unifyRows`.
- **Phase 1 (active):** Combined row-branch contracts now include extension + WF range + compat/WF swap packaging via `Kea/Properties/WfUnifyExtends` (`unifyRows_contract_full_wf`).
- **Phase 1 (active):** `WfUnifyExtends` now has branch-complete wrappers (no-update, single-bind, open-open fresh) for direct full-contract discharge at common `unifyRows` success shapes.
- **Phase 1 (active):** `WfUnifyExtends` now includes `bindTypeVar` combined contracts (`bindTypeVar_ok_extendsAndWfRange`, `bindTypeVar_ok_contract_full_wf`) so type-var bind success paths share the same extension + WF range + acyclic compat/WF packaging surface.
- **Phase 1 (active):** `WfUnifyExtends` now includes a direct `unify` var-left bridge (`unify_var_left_eq_bindTypeVar`) and lifted full-contract wrappers (`unify_var_left_ok_*_contract_full_wf`), so WF contracts can be discharged directly from var-branch unifier successes.
- **Phase 1 (active):** `WfUnifyExtends` now includes one-hop projections for the var-left unifier bridge contracts (base + non-`subst` state variants), exposing extension, WF-range, and acyclic compat/WF facets directly.
- **Phase 1 (active):** `WfUnifyExtends` now also includes a safe var-right bridge under explicit non-var preconditions (`unify_var_right_*_of_non_var`), with both base and non-`subst` full-contract wrappers.
- **Phase 1 (active):** `WfUnifyExtends` now includes full-state `bindTypeVar` packaging (`bindTypeVar_ok_with_non_subst_fields_contract_full_wf`) so type-var bind contracts compose cleanly with non-`subst` state updates.
- **Phase 1 (active):** `WfUnifyExtends` now includes contract projections for `bindTypeVar` full contracts (extension-only and WF-range-only, including non-`subst` state variants) to simplify downstream theorem consumption.
- **Phase 1 (active):** `WfUnifyExtends` now also projects the acyclic compat/WF agreement component out of `bindTypeVar` full contracts (base + non-`subst` state variants), completing one-hop access to all three contract facets.
- **Phase 1 (active):** `WfUnify` now includes `bindTypeVar` WF transport wrappers over non-`subst` state edits (`bindTypeVar_ok_with_lacks_preserves_substWellFormedRange`, `bindTypeVar_ok_with_non_subst_fields_preserves_substWellFormedRange`) for direct reuse in branch/state proofs.
- **Phase 1 (active):** `WfSubstitution` now includes WF-empty corollaries for well-founded row/effect-row substitution (`applySubstRowWF_empty_preserves_wf`, `applySubstEffectRowWF_empty_preserves_wf`) to complete the empty-substitution WF baseline across effect-row forms.
- **Phase 1 (active):** `WfSubstitution` now includes `TyList`/`RowFields` WF-preservation and empty-substitution lemmas (`applySubstTyList_preserves_wf_of_no_domain_vars`, `applySubstRowFields_preserves_wf_of_no_domain_vars`, `applySubstTyList_empty_preserves_wf`, `applySubstRowFields_empty_preserves_wf`) to close container-level WF gaps.
- **Phase 1 (active):** `WfSubstitution` now includes explicit `Ty.functionEff` component-wise WF wrappers for both fuel and WF substitution (`applySubst_functionEff_preserves_wf_of_component_no_domain_vars`, `applySubstWF_functionEff_preserves_wf_of_component_no_domain_vars`), alongside the existing compat wrapper.
- **Phase 1 (active):** Added explicit effect-row compat alias/surface (`applySubstEffectRowCompat`) and `WfSubstitution` lemmas (`applySubstEffectRowCompat_preserves_wf_of_no_domain_vars`, `applySubstEffectRowCompat_empty_preserves_wf`) so effect-row call sites can stay on compat APIs end-to-end.
- **Phase 1 (active):** Added compat aliases for `TyList`/`RowFields` (`applySubstTyListCompat`, `applySubstRowFieldsCompat`) with matching `WfSubstitution` preservation/empty lemmas, completing container-level compat WF surfaces.
- **Phase 1 (active):** `WfGeneralize` now includes a component-wise effect-row wrapper (`generalize_functionEff_preserves_wf_of_component_no_domain_vars`) for `Ty.functionEff` generalization under split no-domain assumptions.
- **Phase 1 (active):** `WfGeneralize` now includes `instantiate_functionEff_preserves_wf`, aligning effect-row `instantiate` WF coverage with the `functionEff` component-wise `generalize` wrapper.
- **Phase 1 (active):** `WfGeneralize` now includes `functionEff` convenience wrappers for `generalize`/`instantiate` entrypoints (`generalize_functionEff_empty_preserves_wf`, `instantiate_functionEff_mono_preserves_wf`, `instantiate_functionEff_preserves_wf_of_mapping_respects_ctx`) so common mono/non-mono cases can be discharged directly.
- **Phase 1 (active):** Added `Kea/Properties/WfEffectRowLadder.lean` and imported it in `Kea.lean`; it packages effect-row `functionEff` WF obligations into citable slices (`FunctionEffSubstWfSlice`, `FunctionEffGenInstWfSlice`) spanning substitution, generalize, and instantiate.
- **Phase 1 (active):** `WfEffectRowLadder` now includes direct specializations (`functionEff_subst_wf_slice_empty`, `functionEff_gen_inst_wf_slice_mono`) for immediate empty-substitution and monomorphic instantiate use.
- **Phase 1 (active):** `WfEffectRowLadder` now includes a unifier-success contract slice for `Ty.functionEff` (`FunctionEffBindTypeVarContractSlice`, `functionEff_bindTypeVar_contract_slice`) linking effect-row WF premises to `bindTypeVar` extension/WF/acyclic-agreement guarantees.
- **Phase 1 (active):** `WfEffectRowLadder` now includes projection helpers for the `FunctionEffBindTypeVarContractSlice` (extension-only, WF-range-only, and acyclic-agreement) so packaged assumptions can be consumed directly.
- **Phase 1 (active):** `WfEffectRowLadder` now also provides full-state `bindTypeVar` contract packaging/projections (`FunctionEffBindTypeVarFullStateContractSlice` and `functionEff_bindTypeVar_full_state_*`) for non-`subst` state updates.
- **Phase 1 (active):** Added explicit conversion lemmas between base and full-state `functionEff` bind-contract slices (`functionEff_bindTypeVar_full_state_slice_to_base`, `functionEff_bindTypeVar_base_slice_to_full_state`) so either surface can be used interchangeably.
- **Phase 1 (active):** Added capstone bundle theorem `functionEff_wf_ladder_bundle_of_bind_success` to export substitution, generalize/instantiate, and bind-contract slices from one `functionEff` entrypoint.
- **Phase 1 (active):** Added full-state capstone bundle theorem `functionEff_wf_ladder_bundle_of_bind_success_full_state`, lifting the one-shot `functionEff` WF ladder packaging to the non-`subst` state-update surface.
- **Phase 1 (active):** `WfEffectRowLadder` now includes one-hop projection helpers from both bundle theorems (base + full-state), including direct extraction of extension, WF-range, and compat/WF-acyclic guarantees from a single packaged assumption.
- **Phase 1 (active):** `WfEffectRowLadder` now exposes named bundle contracts (`FunctionEffWfLadderBundle`, `FunctionEffWfLadderBundleFullState`) with constructor/projection helpers, so downstream proofs can depend on stable one-name theorem surfaces rather than raw conjunction shapes.
- **Phase 1 (active):** Named bundle contracts now include direct extension/WF/acyclic projection lemmas (base + full-state), giving a complete one-hop API from a bundle assumption to each unifier contract facet.
- **Phase 1 (active):** `WfEffectRowLadder` now also supports var-left `unify` entrypoints (`functionEff_unify_var_left_*`) and corresponding one-shot bundle constructors, so effect-row WF contracts can start from successful `unify` var-branches as well as direct `bindTypeVar`.
- **Phase 1 (active):** Var-left `unify` entry wrappers in `WfEffectRowLadder` now discharge the constructor-mismatch BEq premise internally (`beqTy` reduction), keeping downstream theorem calls on semantic WF assumptions only.
- **Phase 1 (active):** `WfEffectRowLadder` now includes symmetric var-right `unify` entry wrappers/bundles (`functionEff_unify_var_right_*`, including full-state variants), backed by the new non-var right-branch bridge.
- **Phase 1 (active):** M2 compat-first bridge refactor is now complete in `Kea/Properties/UnifyExtends.lean` (`unifyRows_preconditioned_contract_compat_first`), with `unifyRows_extends_rowMap_preconditioned_wf_split` routed through the compat-first layer.
- **Phase 1 (active):** M4 weak-hook app-equality bridge target is now closed in `Kea/Typing.lean` via the contract theorem family (`app_unify_result_eq_of_unify_success_contract_succ` and specializations) built on `AppUnifyNoopDomain` + resolved-shape packaging.
- **Phase 1 (active):** Added the projection-side weak-hook refinement and bundle packaging in `Kea/Typing.lean` (`ProjUnifySoundHookWeak`, `projUnifySoundHookWeak_proved`, `UnifyHookPremisesWeak`, `unifyHookPremisesWeak_proved`) plus strong→weak adapters (`appUnifySoundHookWeak_of_appUnifySoundHook`, `projUnifySoundHookWeak_of_projUnifySoundHook`, `unifyHookPremisesWeak_of_unifyHookPremises`) to mirror and connect the app/projection weak-hook boundary surfaces.
- **Phase 1 (active):** Added explicit weak-boundary branch-step soundness surfaces (`inferExprUnify_app_step_sound_weak`, `inferExprUnify_proj_step_sound_weak`), strong-hook lifted weak-step corollaries (`inferExprUnify_app_step_sound_weak_of_strong`, `inferExprUnify_proj_step_sound_weak_of_strong`), and weak/strong-bundle entrypoints (`inferExprUnify_*_step_sound_weak_from_bundle`, `inferExprUnify_*_step_sound_weak_from_strong_bundle`) so weak-hook assumptions are consumable directly at app/proj one-step theorem call sites.
- **Phase 1 (active):** Added a canonical weak local-step bundle surface (`UnifyStepSoundWeak`) with constructors from weak/strong hook packages (`unifyStepSoundWeak_of_hookPremisesWeak`, `unifyStepSoundWeak_of_unifyHookPremises`) and direct step-bundle entrypoints (`inferExprUnify_*_step_sound_weak_from_stepBundle`) for stable downstream weak-boundary consumption.
- **Phase 1 (active):** Added direct proved/strong-package weak-step entrypoints (`inferExprUnify_*_step_sound_weak_proved`, `inferExprUnify_*_step_sound_weak_from_unifyHookPremises`) so call sites can consume weak step APIs without manual weak-bundle construction.
- **Phase 1 (active):** Added all-hooks no-unify naming-parity wrappers for fixed-run `preconditioned ↔ core` transport (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_allHooksSuite`, `principalPreconditionedCoreIff*_of_success_noUnify_via_allHooksSuite`) routed through the canonical all-hooks no-unify wrapper path.
- **Phase 1 (active):** Added master/all-hooks no-unify naming-parity wrappers for core/preconditioned/hook-irrelevance surfaces (`principalCore*`, `principalPreconditioned*_*`, `principalPreconditioned*hookIrrelevant*_of_success_noUnify_via_*Suite`) routed through canonical `principalNoUnify*` wrappers.
- **Phase 1 (active):** Added general-all-hooks/master capstone entry wrappers for arbitrary successful runs (`principalPreconditionedExpr/FieldAllHooksCapstone_of_success_via_generalAllHooksSuite`, `..._from_bundle`, `..._via_masterSuite`, `..._via_masterSuite_from_bundle`) so full core+any-hooks-preconditioned+`↔` boundary consequences are consumable through one theorem surface per success run.
- **Phase 1 (active):** Added bundled-baseline arbitrary-success convenience wrappers for general/master entrypoints (`principalCore*`, `principalPreconditioned*AnyHooks*`, `principalPreconditionedCoreIff*AnyHooks*_of_success_via_*Suite_from_bundle`) so callers can seed the whole non-no-unify principal surface with one `UnifyHookPremises` witness.
- **Phase 1 (active):** Completed bundled-baseline parity for bundled target-hook outputs on arbitrary-success general/master entrypoints (`principalPreconditioned*_*_of_success_via_*Suite_from_bundle`, including `preconditioned ↔ core` forms) so both any-hooks and bundled-target consumption now share the same single-seed API surface.
- **Phase 1 (active):** Added run-level arbitrary-success all-hooks bundle contracts (`PrincipalPreconditionedExpr/FieldAllHooksRunBundle`) with constructors from capstones/success (split and bundled seed hooks), plus suite entry wrappers (`..._of_success_via_generalAllHooksSuite(_from_bundle)`, `..._of_success_via_masterSuite(_from_bundle)`) so capstone + hook-irrelevance consequences are exported as one theorem output per successful run.
- **Phase 1 (active):** Added run-bundle projection helpers for core/preconditioned/preconditioned↔core/hook-irrelevance surfaces (`principalPreconditioned*AllHooksRunBundle_{core,preconditioned_anyHooks,preconditioned,preconditionedCoreIff_anyHooks,preconditionedCoreIff,hook_irrelevant}`) so run-bundle consumers can extract the principal boundary consequences directly without manual capstone-field threading.
- **Phase 1 (active):** Added combined run-bundle slice packaging (`PrincipalPreconditionedAllHooksRunBundleExpr/FieldSlice`, `PrincipalPreconditionedAllHooksRunBundleSlices`, proved + one-hop projections) so arbitrary-success run bundles are consumable through the same expression/field slice pattern as existing capstone/suite layers.
- **Phase 1 (active):** Extended `PrincipalPreconditionedAllHooksSuite` to carry run-bundle slices directly (`runBundles`) and added suite-level run-bundle projections (`principalPreconditionedAllHooksSuite_runBundle_expr/field`), making capstones, irrelevance, and run-bundle packaging available from one general-all-hooks suite witness.
- **Phase 1 (active):** Added parameterized arbitrary-success run-bundle convenience wrappers on the general-all-hooks layer (`principalGeneralAllHooksRunBundleExpr/Field_of_success`) and rerouted both general/master run-bundle entry wrappers through that layer, keeping arbitrary-success run-bundle access on one canonical path.
- **Phase 1 (active):** Added master-suite run-bundle one-hop projections (`principalBoundaryMasterSuite_allHooks_runBundle_expr/field`) so top-level master consumers can extract arbitrary-success all-hooks run bundles without dropping to nested suite fields.
- **Phase 1 (active):** Extended no-unify-to-general all-hooks packaging with run-bundle slices and projections (`PrincipalNoUnifyToGeneralAllHooks*RunBundle*`, suite field `runBundles`, suite/master one-hop run-bundle projections), and updated no-unify-all-hooks ↔ no-unify-to-general compatibility construction to populate the new run-bundle field.
- **Phase 1 (active):** Extended no-unify all-hooks packaging with run-bundle slices (`PrincipalBoundaryNoUnifyAllHooks*RunBundle*`), integrated them into `PrincipalBoundaryNoUnifyAllHooksSuite` (`runBundles` + suite projections), added master one-hop no-unify run-bundle projections, and updated no-unify-to-general ↔ no-unify-all-hooks compatibility construction to preserve the expanded suite shape.
- **Phase 1 (active):** Added explicit run-bundle compatibility theorems between no-unify and no-unify-to-general suite layers (both directions, plus canonical proved variants), making the cross-suite relation first-class at the run-bundle slice level.
- **Phase 1 (active):** Added direct no-unify run-bundle convenience wrappers across general/master/all-hooks entrypoints (`principalPreconditioned*AllHooksRunBundle_of_success_noUnify_via_*`) so successful no-unify runs can target the run-bundle API without manual suite/capstone reconstruction.
- **Phase 1 (active):** Added a top-level master run-bundle aggregate (`PrincipalBoundaryMasterRunBundleSuite`, `principalBoundaryMasterRunBundleSuite_of_master`, `..._proved`) plus no-unify-as-general run-bundle projections (`principalBoundaryMasterSuite_noUnifyAllHooks_runBundle_*_as_general`) so run-bundle entry surfaces across all-hooks/no-unify/no-unify-to-general are packaged behind one master-derived theorem API.
- **Phase 1 (active):** Added one-hop projection/coherence helpers for `PrincipalBoundaryMasterRunBundleSuite` (`..._allHooks_*`, `..._noUnifyAllHooks_*`, `..._noUnifyToGeneral_*`, `..._noUnify_*_as_general`) so downstream consumers can use the master run-bundle aggregate without manual record-field destructuring.
- **Phase 1 (active):** Added direct convenience wrappers on the proved master run-bundle suite (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterRunBundleSuite*`, including bundled-seed and no-unify variants) so callers can consume run-bundle surfaces without manually threading suite witnesses.
- **Phase 1 (active):** Added naming-parity no-unify run-bundle wrappers on the master-run-bundle-suite path (`principalNoUnifyRunBundle*_*_via_masterRunBundleSuite`) and routed the long-form no-unify wrappers through them, keeping no-unify run-bundle entry naming consistent across master surfaces.
- **Phase 1 (active):** Added no-unify consequence wrappers on the master-run-bundle-suite path for core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance (`principalNoUnifyCore*`, `principalNoUnifyPreconditioned*_*`, `principalNoUnifyPreconditionedCoreIff*_*`, `principalNoUnifyPreconditioned*hookIrrelevant*_*_via_masterRunBundleSuite`) by projecting through the no-unify run-bundle aliases.
- **Phase 1 (active):** Added matching long-form no-unify-to-general naming-parity wrappers on the master-run-bundle-suite path (`principalCore*`, `principalPreconditioned*_*`, `principalPreconditionedCoreIff*_*`, `principalPreconditioned*hookIrrelevant*_*_of_success_noUnify_via_masterRunBundleSuite`) so this surface now mirrors master/all-hooks no-unify naming conventions.
- **Phase 1 (active):** Added packaged per-run no-unify consequence bundles on the master-run-bundle-suite path (`PrincipalNoUnifyExpr/FieldRunBundleConsequences`) with constructors from successful no-unify runs, bundling core, preconditioned (any-hooks + bundled), preconditioned↔core (any-hooks + bundled), and hook-irrelevance into one theorem output.
- **Phase 1 (active):** Lifted the master-run-bundle no-unify consequence bundles to slice-level packaging (`PrincipalNoUnifyExpr/FieldRunBundleConsequenceSlice`, combined `PrincipalNoUnifyRunBundleConsequenceSlices`, proved + one-hop projections) so expression/field no-unify consequence bundles are consumable through one reusable theorem surface.
- **Phase 1 (active):** Added a top-level master run-bundle consequence suite (`PrincipalBoundaryMasterRunBundleConsequenceSuite`, constructors from master/master-run-bundle suites, proved theorem, and no-unify expr/field one-hop consequence projections) so run-bundle surfaces and no-unify consequence slices are now packaged behind one aggregate API.
- **Phase 1 (active):** Added master-suite projections into the consequence-suite layer (`principalBoundaryMasterSuite_runBundleConsequenceSuite`, `principalBoundaryMasterSuite_noUnifyRunBundleConsequences_{expr,field}`) so top-level master consumers can access no-unify consequence bundles directly through one-hop APIs.
- **Phase 1 (active):** Added run-bundle projection helpers from the master run-bundle consequence suite (`principalBoundaryMasterRunBundleConsequenceSuite_{allHooks,noUnifyAllHooks,noUnifyToGeneral}_{expr,field}`), so consumers can access the inherited run-bundle surfaces directly from the consequence-suite aggregate.
- **Phase 1 (active):** Routed the master-suite no-unify consequence wrappers (core, preconditioned, preconditioned↔core, hook-irrelevance for expr+field) through `principalBoundaryMasterSuite_noUnifyRunBundleConsequences_{expr,field}` and consequence-suite no-unify-to-general run-bundle projections, keeping top-level master no-unify consumption on the canonical consequence path.
- **Phase 1 (active):** Added top-level master run-bundle projection wrappers via the consequence-suite aggregate (`principalBoundaryMasterSuite_{allHooks,noUnifyAllHooks,noUnifyToGeneral}AllHooks_runBundle_{expr,field}_via_consequenceSuite`) and routed master no-unify run-bundle convenience wrappers through those names for consistent consequence-path entrypoints.
- **Phase 1 (active):** Added bundled-hook no-unify `_from_bundle` wrappers on both master paths (`..._of_success_noUnify_via_masterRunBundleConsequenceSuite_from_bundle`, `..._of_success_noUnify_via_masterSuite_from_bundle` for preconditioned and preconditioned↔core expr+field) to complete no-unify bundled-hook naming parity with the existing arbitrary-success wrapper families.
- **Phase 1 (active):** Added `principalNoUnify*..._from_bundle` alias wrappers on both master paths (`..._via_masterRunBundleConsequenceSuite_from_bundle`, `..._via_masterSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), completing bundled-hook parity across both long-form and `principalNoUnify*` naming families.
- **Phase 1 (active):** Added matching all-hooks no-unify bundled-hook `_from_bundle` wrappers for both long-form and `principalNoUnify*` naming families (`..._of_success_noUnify_via_allHooksSuite_from_bundle`, `..._via_allHooksSuite_from_bundle` for preconditioned and preconditioned↔core expr+field), closing bundled-hook parity across all-hooks/master/master-consequence entry layers.
- **Phase 1 (active):** Added direct consequence-bundle-to-capstone projections (`principalNoUnifyExpr/FieldRunBundleConsequences_capstone`) and top-level master `..._via_consequenceSuite` capstone/irrelevance wrappers (`principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_{expr,field,irrelevance_*}_via_consequenceSuite`), extending the consequence-path API beyond run-bundle surfaces.
- **Phase 1 (active):** Added consequence-path no-unify-as-general aliases on top-level master projections (`principalBoundaryMasterSuite_noUnifyAllHooks_{expr,field,runBundle_*}_as_general_via_consequenceSuite`), restoring the old no-unify-as-general coherence shape on the new consequence-suite routing layer.
- **Phase 1 (active):** Added no-unify capstone convenience wrappers on both master paths (`principalPreconditioned*AllHooksCapstone_of_success_noUnify_via_masterRunBundleConsequenceSuite`, `principalPreconditioned*AllHooksCapstone_of_success_noUnify_via_masterSuite`), bringing capstone-level no-unify entrypoints into parity with run-bundle/consequence surfaces.
- **Phase 1 (active):** Added no-unify capstone aliases (`principalNoUnify*AllHooksCapstone_of_success_via_*Suite`) across all-hooks/master/master-consequence entry layers, completing capstone naming parity alongside existing run-bundle and consequence alias families.
- **Phase 1 (active):** Added bundled-hook no-unify capstone wrappers/aliases (`...AllHooksCapstone_of_success_noUnify_via_*Suite_from_bundle` and `principalNoUnify*AllHooksCapstone_of_success_via_*Suite_from_bundle`) across all-hooks/master/master-consequence layers, completing `_from_bundle` parity for capstone no-unify entry surfaces.
- **Phase 1 (active):** Added direct convenience wrappers over `principalBoundaryMasterRunBundleConsequenceSuite_proved` (`principalNoUnifyExpr/FieldRunBundleConsequences_of_success_via_masterRunBundleConsequenceSuite` plus core/any-hooks projections) so no-unify consequence-bundle consumption is one-step from the aggregate consequence suite.
- **Phase 1 (active):** Extended the master-run-bundle-consequence-suite convenience layer to full no-unify parity (`principalPreconditioned*_*`, `principalPreconditionedCoreIff*_*`, `principalPreconditioned*hookIrrelevant*_*_of_success_noUnify_via_masterRunBundleConsequenceSuite`), so bundled/any-hooks and `↔`/irrelevance surfaces are all one-step from the aggregate consequence suite.
- **Phase 1 (active):** Added matching run-bundle convenience wrappers over `principalBoundaryMasterRunBundleConsequenceSuite_proved` (`principalPreconditioned*AllHooksRunBundle_of_success_via_masterRunBundleConsequenceSuite*` and no-unify variants), so arbitrary-success and no-unify run-bundle access can also route through the same aggregate consequence-suite entrypoint.
- **Phase 1 (active):** Added full `principalNoUnify*` naming-parity aliases on the master-run-bundle-consequence-suite path (core, preconditioned, preconditioned↔core, hook-irrelevance for expr+field) by routing through the long-form no-unify-to-general wrappers.
- **Phase 1 (active):** Added canonical no-unify run-bundle convenience wrappers on the no-unify suite layers themselves (`principalBoundaryNoUnifyRunBundle*_*_via_allHooksSuite`, `principalNoUnifyToGeneralRunBundle*_*_of_success`) so higher-level wrappers can route through stable per-suite API names.
- **Phase 1 (active):** Added naming-parity no-unify run-bundle wrappers on all-hooks/master paths (`principalNoUnifyRunBundle*_*_via_allHooksSuite`, `principalNoUnifyRunBundle*_*_via_masterSuite`) and rerouted no-unify run-bundle convenience entrypoints through canonical per-suite APIs (`principalNoUnifyToGeneralRunBundle*_*_of_success`) to keep higher-level run-bundle access on one canonical route.
- **Phase 1 (active):** Routed master-suite no-unify consequence wrappers (core, preconditioned, preconditioned↔core, hook-irrelevance) through no-unify run-bundle projection helpers, so the master no-unify API now consumes the same run-bundle canonical layer used elsewhere.
- **Phase 1 (active):** M4 DataFrame-verb typing follow-up is explicitly scoped out for Kea (tracked as N/A in `formal/ROADMAP.md`); remaining M4 scope is principal-typing extension on the Kea core language.
- **Phase 1 (active):** Added a packaged preconditioned principal-typing slice in `Kea/Typing.lean` (`PrincipalTypingSlicePreconditioned`, `principalTypingSlicePreconditioned_of_success`) to export determinism + declarative uniqueness + `inferExpr` agreement from one successful `inferExprUnify` run.
- **Phase 1 (active):** Added a hook-free no-unify principal/equivalence surface in `Kea/Typing.lean` (`inferExprUnify_complete_no_unify_branches`, `inferFieldsUnify_complete_no_unify_branches`, `inferExprUnify_ok_iff_inferExpr_no_unify_branches`, `inferFieldsUnify_ok_iff_inferFields_no_unify_branches`) with combined packaging in `PrincipalTypingNoUnifySlices`.
- **Phase 1 (active):** Added a no-unify bridge back into the preconditioned principal bundle (`principalTypingSlicePreconditioned_of_success_no_unify`), making hook assumptions vacuous on the no-unify fragment while preserving the same bundle API.
- **Phase 1 (active):** Added bundled-hook API entrypoints (`UnifyHookPremises`, `principalTypingSlicePreconditioned_of_success_from_bundle`, `principalTypingSlicePreconditioned_of_success_no_unify_from_bundle`) so principal bundle consumers can pass one hook package instead of separate app/proj assumptions.
- **Phase 1 (active):** Added core declarative principality packaging for syntax-directed inference (`hasType_unique`, `inferExpr_principal`, `PrincipalTypingSliceCore`, `principalTypingSliceCore_of_infer`) to expose a hook-free principal baseline on the core typing judgment itself.
- **Phase 1 (active):** Added no-unify success bridges from `inferExprUnify`/`inferFieldsUnify` into core principal packages (`principalTypingSliceCore_of_unify_success_no_unify`, `principalFieldTypingSliceCore_of_unify_success_no_unify`) so successful hook-free unify runs map directly to principal declarative slices.
- **Phase 1 (active):** Added a core-principal-to-preconditioned bridge (`principalTypingSlicePreconditioned_of_success_of_core_principal`) and routed the no-unify preconditioned theorem through it, reducing duplicated proof obligations and making hook assumptions explicitly vacuous once core principality is established.
- **Phase 1 (active):** Added the converse preconditioned-to-core bridge (`principalTypingSliceCore_of_preconditioned_success`, plus bundle entrypoint) so successful preconditioned inference runs can project directly to the core principal package.
- **Phase 1 (active):** Added a packaged no-unify bridge bundle (`PrincipalNoUnifyBridgeBundle`, constructors from direct hooks and hook bundles) that exports both core and preconditioned principal consequences from one successful no-unify run.
- **Phase 1 (active):** Added full field-side preconditioned principality parity (`inferFieldsUnify_deterministic`, `inferFieldsUnify_row_unique_preconditioned`, `PrincipalFieldTypingSlicePreconditioned`) with direct/bundle/no-unify/core-bridge entrypoints, mirroring the expression principal theorem stack.
- **Phase 1 (active):** Added packaged no-unify field bridge exports (`PrincipalFieldNoUnifyBridgeBundle`, direct and hook-bundle constructors) so one successful no-unify `inferFieldsUnify` run yields both core and preconditioned field principal packages.
- **Phase 1 (active):** Added the converse preconditioned-to-core field bridge (`principalFieldTypingSliceCore_of_preconditioned_success`, plus bundle entrypoint), completing expression/field symmetry for principal bridge directions.
- **Phase 1 (active):** Added a combined no-unify bridge slice capstone (`PrincipalNoUnifyBridgeSlices`, `principalNoUnifyBridgeSlices_proved`) that packages both expression and field no-unify bridge APIs into one proved theorem surface.
- **Phase 1 (active):** Added successful-run equivalence bridges between preconditioned and core principal slices (expression + field, direct and hook-bundle variants), tightening the M4 boundary to explicit `↔` contracts at fixed successful runs.
- **Phase 1 (active):** Added combined successful-run preconditioned↔core capstone packaging (`PrincipalPreconditionedCoreIffSlices`, `principalPreconditionedCoreIffSlices_proved`) for expression+field principality under bundled hooks.
- **Phase 1 (active):** Added one-hop projection helpers from the combined capstones (`principalNoUnifyBridgeSlices_expr/field`, `principalPreconditionedCoreIffSlices_expr/field`) so downstream proofs can consume expression or field slices directly.
- **Phase 1 (active):** Added top-level principal boundary suite packaging (`PrincipalBoundaryBridgeSuite`, `principalBoundaryBridgeSuite_proved`) with one-hop projections for no-unify and preconditioned↔core branches across expressions and fields.
- **Phase 1 (active):** Added suite-based convenience entrypoints (`principalNoUnifyCoreExpr/Field_of_success_via_suite`, `principalNoUnifyPreconditionedExpr/Field_of_success_via_suite`) for direct extraction of core/preconditioned principality from successful no-unify runs.
- **Phase 1 (active):** Added suite-based successful-run conversion wrappers in both directions (`principalCore*/principalPreconditioned*_*_via_suite`) for expressions and fields, making preconditioned↔core transport one-step at call sites.
- **Phase 1 (active):** Added suite coherence lemmas (`principalBoundaryBridgeSuite_noUnify_*_coherent_*`) showing the no-unify bundle witnesses and preconditioned↔core equivalence witnesses inter-derive each other for expressions and fields.
- **Phase 1 (active):** Added no-unify principal capstone packaging (`PrincipalBoundaryNoUnifyExprCapstone`, `PrincipalBoundaryNoUnifyFieldCapstone`, `PrincipalBoundaryNoUnifyCapstoneSlices`) with suite-derived constructors and one-hop projections/coherence wrappers so one successful no-unify run exposes both witnesses and their successful-run equivalence surface.
- **Phase 1 (active):** Added one-hop projection helpers from the combined no-unify capstone slices (`principalBoundaryNoUnifyCapstoneSlices_expr_*`, `principalBoundaryNoUnifyCapstoneSlices_field_*`) for direct extraction of core/preconditioned/`↔` witnesses at expression and field call sites.
- **Phase 1 (active):** Added unbundled-hook and hook-bundle capstone entrypoints (`principalBoundaryNoUnifyExpr/FieldCapstone_of_success`, `principalBoundaryNoUnifyExpr/FieldCapstone_of_success_from_hook_bundle`) so no-unify capstone construction works uniformly with either hook-passing style.
- **Phase 1 (active):** Added fixed-run hook-transport/irrelevance theorems for preconditioned principality (`principalTypingSlicePreconditioned_transport_hooks_of_success`, `principalTypingSlicePreconditioned_hook_irrelevant_of_success`, field analogues), making hook-witness independence explicit once inference success is fixed.
- **Phase 1 (active):** Added combined hook-irrelevance slice packaging (`PrincipalPreconditionedHookIrrelevanceSlices`, `principalPreconditionedHookIrrelevanceSlices_proved`) with expression/field one-hop projections for direct fixed-run hook-independence consumption.
- **Phase 1 (active):** Added top-level principal vacuity suite packaging (`PrincipalBoundaryVacuitySuite`, `principalBoundaryVacuitySuite_proved`) with one-hop projections for both no-unify capstones and fixed-run hook-irrelevance branches.
- **Phase 1 (active):** Added no-unify all-hooks capstone packaging (`PrincipalBoundaryNoUnifyExpr/FieldAllHooksCapstone`, `PrincipalBoundaryNoUnifyAllHooksCapstoneSlices`) so the no-unify boundary exposes hook-free core + per-hook preconditioned/`↔` consequences from one successful run.
- **Phase 1 (active):** Added no-unify all-hooks irrelevance packaging (`PrincipalBoundaryNoUnifyAllHooksIrrelevanceSlices`) derived directly from all-hooks capstones, with expression/field one-hop projections for hook-independence on successful no-unify runs.
- **Phase 1 (active):** Added top-level no-unify all-hooks suite packaging (`PrincipalBoundaryNoUnifyAllHooksSuite`, `principalBoundaryNoUnifyAllHooksSuite_proved`) with one-hop projections for both all-hooks capstones and derived irrelevance branches.
- **Phase 1 (active):** Added compatibility bridges from all-hooks back to hook-specific no-unify capstones (`principalBoundaryNoUnifyExpr/FieldCapstone_of_allHooks`) and derived the legacy no-unify capstone slices from the proved all-hooks suite (`principalBoundaryNoUnifyCapstoneSlices_of_allHooksSuite`).
- **Phase 1 (active):** Added a top-level principal boundary master suite (`PrincipalBoundaryMasterSuite`, `principalBoundaryMasterSuite_proved`) aggregating bridge, vacuity, general all-hooks, and no-unify all-hooks surfaces with one-hop projections for preconditioned↔core, hook-irrelevance, general all-hooks capstones, and both all-hooks/hook-specific no-unify capstones.
- **Phase 1 (active):** Added all-hooks-suite convenience wrappers for no-unify runs (`principalNoUnifyCore*` / `principalNoUnifyPreconditioned*_*_via_allHooksSuite`, including any-hooks forms) to expose core/preconditioned consequences without manual all-hooks capstone destructuring.
- **Phase 1 (active):** Added general successful-run all-hooks capstone packaging (`PrincipalPreconditionedExpr/FieldAllHooksCapstone`, `PrincipalPreconditionedAllHooksCapstoneSlices`) so arbitrary successful `inferExprUnify`/`inferFieldsUnify` runs can export core + any-hooks preconditioned consequences from one hook witness pair.
- **Phase 1 (active):** Added a top-level general all-hooks suite (`PrincipalPreconditionedAllHooksSuite`, `principalPreconditionedAllHooksSuite_proved`) with capstone-derived irrelevance (`principalPreconditionedHookIrrelevanceSlices_of_allHooksCapstones`) and one-hop projections for both capstone and irrelevance branches.
- **Phase 1 (active):** Added general-all-hooks-suite convenience wrappers (`principalCore*` / `principalPreconditioned*_*_via_generalAllHooksSuite`, including any-hooks forms) for arbitrary successful runs, removing manual capstone destructuring at call sites.
- **Phase 1 (active):** Added master-suite convenience wrappers (`principalCore*` / `principalPreconditioned*_*_via_masterSuite`, including any-hooks forms) so arbitrary successful-run consequences can be consumed directly from `PrincipalBoundaryMasterSuite`.
- **Phase 1 (active):** Added master-suite no-unify convenience wrappers (`principalNoUnifyCore*` / `principalNoUnifyPreconditioned*_*_via_masterSuite`, including any-hooks forms) so no-unify consequences are also consumable directly from the same master surface.
- **Phase 1 (active):** Added no-unify-to-general all-hooks bridge projections (`principalPreconditionedExpr/FieldAllHooksCapstone_of_noUnifyAllHooks`, `principalBoundaryNoUnifyAllHooksSuite_capstone_*_as_general`, `principalBoundaryMasterSuite_noUnifyAllHooks_*_as_general`) so every successful no-unify all-hooks witness is explicitly consumable on the general successful-run all-hooks API.
- **Phase 1 (active):** Added success-level no-unify-to-general convenience wrappers (`principalPreconditionedExpr/FieldAllHooksCapstone_of_success_noUnify`, `principalCore*` / `principalPreconditioned*AnyHooks*_of_success_noUnify_via_generalAllHooks`) so successful no-unify runs can project directly into the general all-hooks core/preconditioned consequences without first building no-unify suite witnesses.
- **Phase 1 (active):** Added no-unify-to-general parity wrappers for bundled hooks and hook-irrelevance (`principalPreconditionedExpr/Field_of_success_noUnify_via_generalAllHooks`, `principalPreconditionedExpr/Field_hookIrrelevant_of_success_noUnify_via_generalAllHooks`) to keep expression/field and any-hooks/bundled/irrelevance APIs aligned on the same success path.
- **Phase 1 (active):** Added a packaged no-unify-to-general all-hooks suite (`PrincipalNoUnifyToGeneralAllHooksSuite`, proved capstone/irrelevance slices, and one-hop expr/field projections) so this bridge now has a single theorem surface parallel to the other M4 suite layers.
- **Phase 1 (active):** Extended `PrincipalBoundaryMasterSuite` with the no-unify-to-general all-hooks suite and master-level projections (`principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_*`), then routed existing `*_noUnifyAllHooks_*_as_general` adapters through that canonical field.
- **Phase 1 (active):** Added missing hook-irrelevance convenience wrappers across suite entrypoints (`principalPreconditioned*hookIrrelevant*_via_generalAllHooksSuite`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_masterSuite`, `principalNoUnifyPreconditioned*hookIrrelevant*_via_allHooksSuite`) so any-hooks/bundled/irrelevance parity now holds on general and no-unify paths.
- **Phase 1 (active):** Routed master-suite no-unify core/preconditioned convenience wrappers (`principalNoUnifyCore*` / `principalNoUnifyPreconditioned*_*_via_masterSuite`) through the canonical `principalBoundaryMasterSuite_noUnifyToGeneralAllHooks_*` projections, consolidating no-unify-as-general consumption on one path.
- **Phase 1 (active):** Routed all-hooks-suite no-unify convenience wrappers (including hook-irrelevance variants) through `PrincipalNoUnifyToGeneralAllHooksSuite_proved`, so both master and all-hooks entrypoints now consume the same canonical no-unify-to-general bridge surface.
- **Phase 1 (active):** Added bidirectional compatibility between no-unify-all-hooks and no-unify-to-general suites (`principalNoUnifyToGeneralAllHooksSuite_of_noUnifyAllHooksSuite`, `principalBoundaryNoUnifyAllHooksSuite_of_noUnifyToGeneralAllHooksSuite`, plus proved derived forms), and now construct `PrincipalBoundaryMasterSuite.noUnifyToGeneralAllHooks` via the no-unify-all-hooks suite path.
- **Phase 1 (active):** Added parameterized no-unify-to-general convenience wrappers (`principalNoUnifyToGeneralCore*`, `principalNoUnifyToGeneralPreconditioned*_*`) and routed master/all-hooks no-unify convenience entrypoints through them, consolidating expression/field + any-hooks/bundled/irrelevance access behind one reusable suite API.
- **Phase 1 (active):** Added no-unify-to-general `preconditioned ↔ core` convenience wrappers (`principalNoUnifyToGeneralPreconditionedCoreIff*`) and exposed them through both master/all-hooks entrypoints (`principalNoUnifyPreconditionedCoreIff*_of_success_via_*Suite`) for complete no-unify API parity.
- **Phase 1 (active):** Added arbitrary-success `preconditioned ↔ core` convenience wrappers for the general all-hooks and master paths (`principalPreconditionedCoreIff*_of_success_via_generalAllHooksSuite`, `principalPreconditionedCoreIff*_of_success_via_masterSuite`), completing wrapper parity across no-unify and non-no-unify surfaces.
- **Phase 1 (active):** Added `any-hooks` no-unify `preconditioned ↔ core` wrappers (`principalNoUnifyToGeneralPreconditionedCoreIff*AnyHooks*`) and corresponding master/all-hooks entrypoints (`principalNoUnifyPreconditionedCoreIff*AnyHooks*_of_success_via_*Suite`), with bundled variants now routed through these canonical any-hooks forms.
- **Phase 1 (active):** Added matching `any-hooks` arbitrary-success `preconditioned ↔ core` wrappers for general/master paths (`principalPreconditionedCoreIff*AnyHooks*_of_success_via_generalAllHooksSuite`, `principalPreconditionedCoreIff*AnyHooks*_of_success_via_masterSuite`) and routed bundled variants through them.
- **Phase 1 (active):** Added a parameterized arbitrary-success convenience layer (`principalGeneralAllHooks*`) over `PrincipalPreconditionedAllHooksSuite` and routed both `via_generalAllHooksSuite` and `via_masterSuite` wrapper families through it, consolidating non-no-unify consumption on one canonical API.
- **Phase 1 (active):** Added direct no-unify-to-general `preconditioned ↔ core` wrappers on the proved general-all-hooks success path (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_generalAllHooks`, `principalPreconditionedCoreIff*_of_success_noUnify_via_generalAllHooks`) for expression/field parity without suite destructuring.
- **Phase 1 (active):** Added master no-unify-to-general naming-parity wrappers for fixed-run `preconditioned ↔ core` transport (`principalPreconditionedCoreIff*AnyHooks*_of_success_noUnify_via_masterSuite`, `principalPreconditionedCoreIff*_of_success_noUnify_via_masterSuite`) routed through canonical `principalNoUnifyPreconditionedCoreIff*_*_via_masterSuite` paths.
- **Phase 2 (next):** Kea-specific effect typing and handler theorems.
- **Phase 2 (active):** Added `Kea/Properties/HandlerEffectRemoval.lean` with a first handler-elimination core model (`EffectRow.handleRemove`) and capstone theorem surfaces (`handle_removes_effect`, `handle_preserves_other_effects`, row-tail/WF preservation, idempotence).
- **Phase 2 (active):** Latest MCP re-probe confirms overlap normalization closure (`[Trace] ∪ [Trace] = [Trace]`, prior duplicate-label regression shapes now infer normalized rows), so runtime behavior aligns with spec idempotent union on current handler probes.
- **Phase 2 (active):** Formal handler-composition proofs proceed on spec-normalized idempotent union via `EffectRow.handleComposeNormalized` (remove handled effect, then idempotent union with handler-body effects), and current MCP probes now confirm implementation-side overlap dedup for the tracked cases.
- **Phase 2 (active):** Added nested same-target handler consequences on the normalized model (`nested_same_target_outer_removal_noop_of_inner_absent`, `nested_same_target_remains_absent_of_outer_absent`) and row-tail preservation for composed handlers.
- **Phase 2 (active):** Added `Kea/Properties/HandlerAbsentEffectNoop.lean` with closed-row-aware no-op contracts (`handleComposeClosedAware`, `handle_absent_effect_noop`) to model absent-effect handler no-op behavior explicitly.
- **Phase 2 (active):** Added `Kea/Properties/HandlerClosedAwareContracts.lean` to lift absent-effect no-op semantics into clause-level APIs (`resultEffectsCoreClosedAware`, `resultEffectsClosedAware`, normalized/closed-case bridge theorems), then extended it with branch-classification + bundle surfaces (`resultEffectsCoreClosedAware_branch_classification`, `ClosedAwareCoreBundle`, `closedAwareCoreBundle_of_classification`) and typing-facing consequences (`resultEffectsClosedAware_preserves_row_tail`, `wellTypedSlice_implies_handled_removed_closedAware`) for direct downstream composition.
- **Phase 2 (active):** `HandlerClosedAwareContracts` now provides a shared Phase-2 entry API (`handleComposeClosedAware_removes_target_of_handler_absent`, `handleComposeClosedAware_preserves_row_tail`, `ClosedAwareResultBundle`, `closedAwareResultBundle_of_wellTyped`, `wellTypedSlice_implies_handled_removed_legacy_via_closedAware`) so downstream capstones can consume one closed-aware contract surface.
- **Phase 2 (active):** Added `Kea/Properties/ResumeLinearity.lean` as a no-`sorry` scaffold for `resume_at_most_once` reasoning (`ResumeUse`, saturating composition, exclusivity-preserving lemmas, and named `resume_at_most_once` contract surface).
- **Phase 2 (active):** `ResumeLinearity` now includes exact composition characterization (`resume_combine_atMostOnce_iff`) and exclusivity corollaries (`resume_combine_atMostOnce_implies_one_side_zero`, `resume_combine_one_one_not_atMostOnce`) for branch-level linearity reasoning.
- **Phase 2 (active):** MCP re-probes confirm runtime `E0012` enforcement aligns with the resume summary model: zero-resume clauses typecheck; sequential and both-branch double-resume cases are rejected.
- **Phase 2 (active):** Added `Kea/Properties/HandlerTypingContracts.lean` to integrate effect-removal and resume-linearity tracks through a clause-level contract surface (`wellTypedSlice`) with bridge theorems for handled-effect removal, branch exclusivity, and loop legality.
- **Phase 2 (active):** Refined `HandlerTypingContracts` from abstract summaries to concrete contract premises (`thenEffects`, `clauseCoverageComplete`) with explicit result-effect assembly (`resultEffectsCore`/`applyThenEffects`/`resultEffects`), non-reintroduction guarantees, and resume-provenance extraction from linearity assumptions.
- **Phase 2 (active):** Added `Kea/Properties/EffectOperationTyping.lean` to model effect declarations and operation-call typing (`EffectDecl`, `operationCallTyping`, `performOperationEffects`) with capstones `operationCallTyping_adds_declared_effect` and `capability_direct_call_sound`.
- **Phase 2 (active):** MCP re-probes for cross-handled capability calls now align with `EffectOperationTyping`: handling `Trace` from `-[Log, Trace]>` leaves `-[Log]`, and handling `Log` leaves `-[Trace]` (diagnostics clean).
- **Phase 2 (active):** `EffectOperationTyping` now includes WF transport (`performOperationEffects_preserves_wellFormed`), linking operation-call row updates to the Phase-1/2 well-formedness track.
- **Phase 2 (active):** MCP operation-call probes align with the declaration/update model: `call_log` infers `() -[Log]> ()`, and explicit too-weak annotations (e.g. `-[Trace]` body `Log.log`) are rejected with `E0001`.
- **Phase 2 (active):** `EffectOperationTyping` now includes named operation-call bundles (`OperationCallBundle`, `operationCallBundle_of_typing`) so declaration witness, effect-addition, and row-tail stability are available from one theorem surface.
- **Phase 2 (active):** Added `Kea/Properties/TailResumptiveClassification.lean` to classify clause resume shapes (`TailResumptiveClass`, `classifyClause`) with capstones `tail_resumptive_classification` and `tail_resumptive_direct_call_sound`.
- **Phase 2 (active):** `TailResumptiveClassification` now includes named bundle packaging (`TailResumptiveBundle`, `tail_resumptive_bundle_of_wellTyped`) with a one-hop non-invalid projection (`tail_resumptive_bundle_notInvalid`).
- **Phase 2 (active):** `TailResumptiveClassification` now includes closed-aware direct-call equivalence (`directCallEquivalentClosedAware`, `tail_resumptive_direct_call_sound_closedAware`) to align tail-resumptive fast-path contracts with the shared closed-aware handler surface.
- **Phase 2 (active):** `TailResumptiveClassification` now packages closed-aware fast-path reasoning in a named bundle (`TailResumptiveClosedAwareBundle`, `tail_resumptive_closedAware_bundle_of_wellTyped`) with one-hop eligible projection.
- **Phase 2 (active):** MCP probe alignment now covers the tail-resumptive slice: `run_no_then` and identity-`then` `run_then` both infer `() -> ()` with clean diagnostics, matching the direct-call contract surface.
- **Phase 2 (active):** Added `Kea/Properties/TailCapabilityComposition.lean` to compose operation-call capability preservation with tail-resumptive equivalence (`tail_resumptive_eligible_capability_direct_call_sound`, well-typed wrapper included).
- **Phase 2 (active):** `TailCapabilityComposition` now includes a general well-typed lift (`resultEffects_preserves_core_label_true`, `wellTyped_capability_direct_call_sound`) so capability preservation composes through full clause result effects (including `then`-union), with the tail-resumptive theorem retained as a corollary surface.
- **Phase 2 (active):** `TailCapabilityComposition` now also has named bundle packaging (`TailCapabilityBundle`, `tailCapabilityBundle_of_wellTyped`) with one-hop projections for full-result capability preservation under well-typed boundaries.
- **Phase 2 (active):** `TailCapabilityComposition` now also exposes closed-aware capability surfaces (`wellTyped_capability_direct_call_sound_closedAware`, `TailCapabilityClosedAwareBundle`, `tailCapabilityClosedAwareBundle_of_wellTyped`) so capability-preservation reasoning aligns with the shared closed-aware entry API.
- **Phase 2 (active):** `TailCapabilityComposition` now includes closed-aware tail-resumptive fast-path corollaries (`tail_resumptive_eligible_capability_direct_call_sound_closedAware`, `tail_resumptive_wellTyped_capability_direct_call_sound_closedAware`) and routes closed-aware `notInvalid` through `TailResumptiveClosedAwareBundle`.
- **Phase 2 (active):** Added `Kea/Properties/NestedHandlerCompositionContracts.lean` with explicit nested same-target theorem surfaces (`nested_handlers_compose`, row-tail/other-label preservation, and `NestedHandlerBundle` packaging).
- **Phase 2 (active):** Extended `NestedHandlerCompositionContracts` with closed-aware nested capstones (`nestedComposeClosedAware`, `nested_handlers_compose_closedAware`, `nested_handlers_compose_closedAware_row_tail`, `NestedHandlerClosedAwareBundle`) aligned to the shared closed-aware entry API.
- **Phase 2 (active):** MCP probe for a valid nested same-target shape (`nested_same` with inner handle bound then handled again) infers `() -> ()` with clean diagnostics, aligning with the nested composition contract boundary.
- **Phase 2 (active):** After phantom-IO fix (commits `746a4cb`, `9812380`) and MCP restart, handled-absent closed-row probes now align with no-op semantics: mismatched handlers preserve body effects (`probe_log : () -[Log]> ()`, `probe_trace : () -[Trace]> ()`) with clean diagnostics.
- **Phase 2 (active):** Added `Kea/Properties/FailResultContracts.lean`, specializing handler contracts to Fail-as-zero-resume and Result-lowering (`resultLowering`, `FailResultContract`, `failResultContract_sound`, `failResultContract_loopLegal`) to start the Fail/Result equivalence track.
- **Phase 2 (active):** `FailResultContracts` now also exports a closed-aware clause-output capstone (`failResultContract_sound_closedAware`) alongside the legacy `resultEffects` contract.
- **Phase 2 (active):** Extended `FailResultContracts` with explicit lowering/equivalence slices (`lowerFailEffects`, `lowerFailFunctionType`, `failResultFunctionEquivalent`) plus preservation/removal lemmas to bridge from contract-level Fail handling into function-type `Result` lowering.
- **Phase 2 (active):** Added `Kea/Properties/FailResultEquivalence.lean` with explicit `fail_result_equivalence` theorem/bundle surfaces (including catch-premise adapters), so the Fail/Result equivalence target now has a named capstone API.
- **Phase 2 (active):** Added `Kea/Properties/EffectPolymorphismSoundness.lean` with reusable soundness contracts for Fail lowering over polymorphic effect rows (`rowTailStable`, `labelsPreservedExcept`, `effectPolyFailLowering_sound`, no-op-if-absent), proving Fail removal while preserving non-Fail labels and row tails.
- **Phase 2 (active):** `EffectPolymorphismSoundness` now includes concrete handler-schema bridges (`EffectPolyHandlerSchema`, `effectPolyHandlerSchema_sound`, `effectPolyHandlerSchema_noop_if_fail_absent`) linking `wellTypedSlice` + Fail-zero-resume premises to polymorphic function-type lowering guarantees.
- **Phase 2 (active):** Divergence on Fail-absent `catch` is now closed (runtime now rejects with `E0012`: `expression cannot fail; catch is unnecessary`), so no-op-if-absent theorem claims are aligned as vacuous runtime cases rather than pending implementation fix.
- **Phase 2 (active):** Added explicit catch-admissibility contracts (`catchAdmissible`, `catchUnnecessary`) and precondition-gated effect-polymorphism wrappers (`effectPolyFailLowering_sound_of_catchAdmissible`, `catchUnnecessary_implies_no_admissible_*`), making the `E0012` fail-absent runtime behavior first-class in the formal theorem surface.
- **Phase 2 (active):** Added runtime-aligned admissible contract/schema wrappers (`AdmissibleEffectPolyFailLoweringContract`, `AdmissibleEffectPolyHandlerSchema`) and capstone entrypoints (`admissibleEffectPolyFailLowering_sound`, `admissibleEffectPolyHandlerSchema_sound`) so downstream proofs can consume only `catch`-admissible (`Fail`-present) cases.
- **Phase 2 (active):** Added premise-to-capstone adapters in `EffectPolymorphismSoundness` (`mkAdmissibleEffectPoly*`, `*_sound_of_premises`) to eliminate manual structure assembly and expose direct theorem entrypoints from handler typing assumptions.
- **Phase 2 (active):** Added one-hop admissible projection helpers for both contract and schema surfaces (`*_rowTailStable`, `*_preserves_nonFail`, `*_failRemoved*`) so downstream chaining can consume each guarantee independently from a single admissible assumption.
- **Phase 2 (active):** Added named admissible bundle contracts (`AdmissibleEffectPolyLoweringBundle`, `AdmissibleEffectPolyHandlerBundle`) with constructor/projection helpers, giving stable one-name theorem outputs for full capstone consequences.
- **Phase 2 (active):** Added admissibility partition theorems (`catchAdmissible_xor_unnecessary`) and admissible-branch extractors on contract/schema wrappers, making the runtime “admissible vs E0012-unnecessary” split explicit in theorem assumptions.
- **Phase 2 (active):** Added `Kea/Properties/CatchTypingBridge.lean`, a judgment-shaped bridge (`CatchTypingJudgment`) from typing-style catch premises into admissible effect-polymorphism capstones (`catchTypingJudgment_sound`, row-tail/non-Fail projections, admissibility branch).
- **Phase 2 (active):** `CatchTypingBridge` now includes judgment-level named bundles/projections (`CatchTypingBundle`, `catchTypingJudgment_bundle_*`) for one-name consumption of clause-removal and lowered-effect guarantees.
- **Phase 2 (active):** Added direct premise adapters in `CatchTypingBridge` (`mkCatchTypingJudgment`, `catchTypingJudgment_sound_of_premises`, noncomputable `catchTypingJudgment_bundle_of_premises`) for judgment-free entry into the bridge surface.
- **Phase 2 (active):** `CatchTypingBridge` now includes one-hop `of_premises` projections for row-tail/non-Fail preservation and bundle facets, so raw-premise call sites can consume specific guarantees without intermediate destructuring.
- **Phase 2 (active):** `CatchTypingBridge` now includes combined/classified premise surfaces (`CatchTypingCapstoneOutcome`, `catchTypingJudgment_capstone_of_premises`, `catchTypingJudgment_classify_of_premises`) plus Fail-presence/absence entry wrappers, aligning generic catch APIs with the higher-order runtime-admissibility pattern.
- **Phase 2 (active):** Higher-order typed-Fail catch regression is now closed on latest MCP probes: `catch` over `fn() -[Log, Fail String]> Int` is accepted with residual `Log`, while fail-absent paths still correctly reject with `E0012`.
- **Phase 2 (active):** Added `Kea/Properties/HigherOrderCatchContracts.lean` to specialize higher-order catch theorem surfaces (`higherOrderCatchType`, `HigherOrderCatchTypingJudgment`, soundness/admissibility theorems) and align formal APIs with the now-fixed higher-order MCP behavior.
- **Phase 2 (active):** Fail/catch bridge layers now consume the shared closed-aware entry API for clause-level handled-effect removal (`FailResultContracts.failResultContract_sound`, `EffectPolymorphismSoundness.effectPolyHandlerSchema_sound` now route through `wellTypedSlice_implies_handled_removed_legacy_via_closedAware`).
- **Phase 2 (active):** Catch layers now expose direct closed-aware clause-removal adapters (`CatchTypingBridge.catchTypingJudgment_clauseFailRemoved_via_closedAware`, `HigherOrderCatchContracts.higherOrderCatchTypingJudgment_clauseFailRemoved_via_closedAware`) so higher-order and first-order catch capstones consume the same entry contract explicitly.
- **Phase 2 (active):** Catch layers now additionally expose closed-aware clause row-tail adapters (`catchTypingJudgment_clauseRowTailStable_closedAware`, `higherOrderCatchTypingJudgment_clauseRowTailStable_closedAware`) to align clause-output shape reasoning across first-order and higher-order catch paths.
- **Phase 2 (active):** `HigherOrderCatchContracts` now includes direct raw-premise adapters (`higherOrderCatchTypingJudgment_sound_of_premises`, `higherOrderCatchTypingJudgment_admissibility_branch_of_premises`) for judgment-free entry into higher-order theorem surfaces.
- **Phase 2 (active):** `HigherOrderCatchContracts` now also includes named bundle contracts/projections (`HigherOrderCatchBundle`, `higherOrderCatchTypingJudgment_bundle*`) for stable one-name consumption of higher-order capstone consequences.
- **Phase 2 (active):** `HigherOrderCatchContracts` now includes one-hop bundle `of_premises` projections (`higherOrderCatchTypingJudgment_bundle_*_of_premises`) so raw-premise higher-order call sites can extract clause-removal/row-tail/non-Fail guarantees directly.
- **Phase 2 (active):** `HigherOrderCatchContracts` now includes a combined raw-premise capstone (`higherOrderCatchTypingJudgment_capstone_of_premises`) that packages clause Fail-removal, lowered-row guarantees, and admissibility-vs-unnecessary branch facts in one theorem surface.
- **Phase 2 (active):** Added higher-order practical entry wrappers (`higherOrderCatchTypingJudgment_capstone_of_fail_present`, `higherOrderCatchUnnecessary_of_fail_absent`) so call sites can start from direct Fail-label presence/absence evidence.
- **Phase 2 (active):** Added a higher-order single-entry classifier (`higherOrderCatchTypingJudgment_classify_of_premises`) over `HigherOrderCatchCapstoneOutcome`, returning either full capstone consequences or the runtime-aligned `catchUnnecessary` branch without requiring an explicit admissibility premise.

The formal workspace lives at [`formal/`](formal/).

## Scope

### Phase 1: Core HM + Row Migration

Migrate and align these Lean modules with `kea-types` and `kea-infer`:

- `Kea/Ty.lean`
- `Kea/Substitution.lean`
- `Kea/FreeVars.lean`
- `Kea/OccursCheck.lean`
- `Kea/LacksConstraints.lean`
- `Kea/Unify.lean`
- `Kea/Generalize.lean`
- `Kea/Traits.lean`
- `Kea/Typing.lean`

### Phase 2: Kea Effect/Handler Formalization

Add Kea-native theorems for:

- Handler effect removal
- Resume linearity (at-most-once)
- Fail as zero-resume
- Fail/Result equivalence
- Effect polymorphism soundness

## Workflow Contract

Use MCP-first verification, mirroring the Rill protocol:

1. Predict (Lean conjecture + explicit preconditions)
2. Probe (`kea-mcp`: `type_check`, `diagnose`, `get_type`)
3. Classify (agreement / precondition gap / divergence)
4. Act (prove, revise, or log divergence)
5. Traceability (theorem + MCP evidence link)

All session evidence goes to [`formal/mcp-log.md`](formal/mcp-log.md).

## Build

```bash
cd formal && lake build
```

Lean runs independently of Rust checks.
